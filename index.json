{
  "index.html": {
    "href": "index.html",
    "title": "Orleansæ˜¯ä¸€ä¸ªè·¨å¹³å°æ¡†æ¶ï¼Œç”¨äºæ„å»ºå¥å£®ï¼Œå¯æ‰©å±•çš„åˆ†å¸ƒå¼åº”ç”¨ç¨‹åº | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæ˜¯ä¸€ä¸ªè·¨å¹³å°æ¡†æ¶ï¼Œç”¨äºæ„å»ºå¥å£®ï¼Œå¯æ‰©å±•çš„åˆ†å¸ƒå¼åº”ç”¨ç¨‹åº Orleanså»ºç«‹åœ¨.NETå¼€å‘äººå‘˜ç”Ÿäº§åŠ›çš„åŸºç¡€ä¸Šï¼Œå¹¶å°†å…¶å¸¦å…¥äº†åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„ä¸–ç•Œï¼Œä¾‹å¦‚äº‘æœåŠ¡ã€‚ Orleanså¯ä»å•ä¸ªæœ¬åœ°æœåŠ¡å™¨æ‰©å±•åˆ°äº‘ä¸­å…¨å±€åˆ†å¸ƒçš„é«˜å¯ç”¨æ€§åº”ç”¨ç¨‹åºã€‚ Orleansé‡‡ç”¨äº†å¯¹è±¡ï¼Œæ¥å£ï¼Œasync/awaitå’Œtry/catchç­‰ç†Ÿæ‚‰çš„æ¦‚å¿µï¼Œå¹¶å°†å…¶æ‰©å±•åˆ°å¤šæœåŠ¡å™¨ç¯å¢ƒã€‚è¿™æ ·ï¼Œå®ƒå¯ä»¥å¸®åŠ©å…·æœ‰å•æœåŠ¡å™¨åº”ç”¨ç¨‹åºç»éªŒçš„å¼€å‘äººå‘˜è¿‡æ¸¡åˆ°æ„å»ºå¼¹æ€§ï¼Œå¯æ‰©å±•çš„äº‘æœåŠ¡å’Œå…¶ä»–åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºã€‚å› æ­¤ï¼ŒOrleansé€šå¸¸è¢«ç§°ä¸ºâ€œåˆ†å¸ƒå¼.NETâ€ã€‚ å®ƒæ˜¯ç”± Microsoft Research åˆ›å»ºçš„ï¼Œå¹¶ä»‹ç»äº† Virtual Actor Model ä½œä¸ºä¸€ç§æ–°æ–¹æ³•æ¥æ„å»ºé¢å‘äº‘æ—¶ä»£çš„æ–°ä¸€ä»£åˆ†å¸ƒå¼ç³»ç»Ÿã€‚ Orleansçš„æ ¸å¿ƒè´¡çŒ®æ˜¯å®ƒçš„ç¼–ç¨‹æ¨¡å‹ï¼Œå®ƒåœ¨ä¸é™åˆ¶åŠŸèƒ½ï¼Œä»¥åŠå¯¹å¼€å‘äººå‘˜æ–½åŠ ç¹é‡çº¦æŸçš„æƒ…å†µä¸‹ï¼Œé™ä½äº†é«˜å¹¶å‘åˆ†å¸ƒå¼ç³»ç»Ÿå›ºæœ‰çš„å¤æ‚æ€§ã€‚ æ–‡æ¡£ä½äº æ­¤å¤„ ã€‚ æ–‡æ¡£è¯´æ˜ Orleansä¸­æ–‡æ–‡æ¡£ï¼Œæ˜¯é€šè¿‡æœºå™¨ç¿»è¯‘ï¼ŒåŠ ä¸Šäººå·¥æ ¡å¯¹è€Œæˆï¼Œå› ä¸ºä¸ªäººç²¾åŠ›æœ‰é™ï¼Œæ ¡å¯¹å·¥ä½œç›®å‰åªåšäº†ä¸€éƒ¨åˆ†ï¼Œä½†ä¼šç»§ç»­åˆ©ç”¨é—²æš‡æ—¶é—´åšä¸‹å»ï¼Œä¹Ÿæ¬¢è¿å„ä½è¯»è€…ç§¯æå‚ä¸è¿›æ¥ã€‚ ä¸­æ–‡æ–‡æ¡£ç›®å‰ä½äºä¸ªäººä»“åº“ sheng-jie/orleans docsåˆ†æ”¯çš„zh-cnç›®å½•ä¸‹ ï¼Œå…¶ä¸­1.5ä¸‹çš„æ–‡ä»¶å¤¹æœªç¿»è¯‘ã€‚ ä¸€äº›ä¸“ä¸šæœ¯è¯­å› æ— åˆé€‚ç¿»è¯‘äºˆä»¥ä¿ç•™ï¼Œä¾‹å¦‚ï¼šOrleansï¼ŒSiloï¼ŒGrainï¼ŒActor ç­‰ç­‰ã€‚ è®¡åˆ’æ˜¯åœ¨ç»´æŠ¤ä¸€æ®µæ—¶é—´åï¼Œæ–‡æ¡£ç¿»è¯‘é€šé¡ºåå†æPRåˆå¹¶åˆ°Orlanså®˜æ–¹ä»“åº“ä¸‹ã€‚ [doc] Multiple language support ã€‚ å¦‚æœ‰å…´è¶£åŠ å…¥Orleansä¸­å›½ç¤¾åŒºäº¤æµç¾¤ï¼Œå¯ä»¥æ‰«ç åŠ æˆ‘å¾®ä¿¡ï¼Œæˆ‘é‚€è¯·æ‚¨è¿›ç¾¤ã€‚ è´¡çŒ®æŒ‡å¼• æ„Ÿè°¢æ‚¨çš„å‚ä¸ï¼Œä¸»è¦æœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å‚ä¸åˆ°æ–‡æ¡£æ”¹è¿›ä¸­ï¼š ç‚¹å‡»æ–‡æ¡£ç½‘é¡µå³ä¸Šæ–¹[Improve this Doc]é“¾æ¥ï¼Œå³å¯æ‰“å¼€GitHubä¸­å¯¹åº”å½“å‰æ–‡æ¡£çš„åŸç”ŸMarkdowné¡µé¢ï¼Œå†ç‚¹å‡»é¡µé¢ä¸Šçš„[ğŸ–]é“…ç¬”å›¾æ ‡ï¼Œå³å¯è¿›è¡Œåœ¨çº¿ä¿®æ”¹ï¼Œä¿®æ”¹å®Œæ¯•ï¼Œæäº¤åˆ›å»ºPRå³å¯ã€‚ Forkä»“åº“ sheng-jie/orleans å¹¶Cloneåˆ°æœ¬åœ°ç›®å½•ï¼Œç­¾å‡ºdocsåˆ†æ”¯ï¼ˆ checkout docs ï¼‰ï¼Œè¿›å…¥ zh-cn ç›®å½•ï¼Œå³å¯ä¿®æ”¹ï¼Œä¿®æ”¹å®Œæ¯•åï¼Œåˆ›å»ºPRå³å¯ã€‚"
  },
  "1.5/Tutorials/My-First-Orleans-Application.html": {
    "href": "1.5/Tutorials/My-First-Orleans-Application.html",
    "title": "My First Orleans Application | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "My First Orleans Application In this tutorial, we will walk through the steps to get the simplest possible Orleans application up and running, the all-too-familiar \"Hello World!\". We're using VS 2017, but it works equally well with VS 2012, VS 2013 and VS 2015. Before we start, there are three Orleans concepts that you will run into in this tutorial: that of a grain, a communication interface, and a silo. Grains Grains form the core of the Orleans programming model - they are distributed virtual actors. Grains are .NET classes that derive from a particular base class. It is easy to think about actors as objects that get dynamically instantiated on different servers and can invoke each other. They are distributed because interactions with grains may happen across process and computer boundaries, virtual because a particular grain may not be loaded in memory when another component sends it a message. If not present, the grain will be activated on-demand. Communication interfaces Communication interfaces describe how to communicate with grains. They are .NET interfaces extending a particular base interface. Silos Silos are containers of grains, potentially millions of grains in a single silo. Typically, you will run one silo per machine, but it sometimes make sense to run more than one on a single machine, when testing, for example. Getting Started Before getting started, make sure the Microsoft Orleans Tools for Visual Studio is installed. The plugin can be downloaded from: https://marketplace.visualstudio.com/items?itemName=sbykov.MicrosoftOrleansToolsforVisualStudio After starting Visual Studio, go to create a new project. Under \"Visual C#,\" you should see the following: Choose the \"Orleans Dev/Test Host\" project type, create a directory for the solution, and create the project: At this point go ahead and compile your project to download the packages. The project is just a console application populated with code that helps you host a silo in an environment that is \"developer friendly,\" i.e. where everything runs in a single process. The main code does three things: it creates a silo, initializes the Orleans client runtime, and waits for user input before terminating: static void Main(string[] args) { // First, configure and start a local silo var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"TestSilo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Silo started.\"); // Then configure and connect a client. var clientConfig = ClientConfiguration.LocalhostSilo(); var client = new ClientBuilder().UseConfiguration(clientConfig).Build(); client.Connect().Wait(); Console.WriteLine(\"Client connected.\"); // // This is the place for your test code. // Console.WriteLine(\"\\nPress Enter to terminate...\"); Console.ReadLine(); // Shut down client.Close(); silo.ShutdownOrleansSilo(); } Adding Some Grains At this point, we have everything we need except some actual Orleans-based code. Next we will create two more projects, one to hold the communication interface, and one to hold our grain. Separating the two is a best practice since the interface project is shared between the client and server-side, while the grains are implementation code and should be private to the server side. In addition to the Dev/Test host, there are two more Orleans projects, and we should create one of each in our solution: Once you have them in your solution, make sure to add a reference to the grain interface project from each of the other projects: the host, which will contain our client code, and the grain collection project. Add a reference for the grain collection project to the host project, so that it is automatically (re-)built and copied when starting the debugger. Open the IGrain1.cs file and add a method SayHello() to it. We should have something like this: public interface IGrain1 : IGrainWithIntegerKey { Task<string> SayHello(); } One of the important things is choosing a Key type for your grains, in this example we are using the Integer Key type. There are also Guids, strings and various compound keys that may meet your needs. Additionally, Orleans relies on TPL tasks in the interface method's return type -- an essential means to achieving scalability in the lightweight Orleans programming model is to use asynchronous I/O everywhere, and Orleans forces you to do so. Use Task or Task<T> as the return type of all methods of communication interfaces. Next, we turn our attention to the grain implementation, which is found in Grain1.cs . The first thing to do is make sure that the interface it implements is the right one: it should be MyGrainInterfaces1.IGrain1 , unless you renamed the project and/or the interface in the previous step. Then, we ask VS to generate the method stub for the one interface method we defined earlier: public Task<string> SayHello() { throw new NotImplementedException(); } We're finally ready to add the much-anticipated \"Hello World!\" code. Just return the string as the contents of a Task: public Task<string> SayHello() { return Task.FromResult(\"Hello World!\"); } OK, we're nearly done. All we need is a bit of client code. This will go in the Program.cs file in the Host project. In place of the comment following the call to GrainClient.Initialize() , add these two lines: var friend = client.GetGrain<MyGrainInterfaces1.IGrain1>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello().Result); That's it! Hit F5, let the silo initialization code take its time. This will take a few seconds, maybe as much as ten, and there will be a lot of log messages printed. At the very end, you should see the printout of the greeting. These are the essential steps to create and run Orleans-based code: define communication interfaces, implement them using grain classes, and write some client code to communicate with the grains in order to test them. In a realistic production environment, the grain code would be deployed in a silo hosted by Windows Azure or Windows Server and the client would most likely be a Web site or service using Orleans for the backend logic. However, that is just about making different configuration choices - the code in the simplified environment is the same as in the production environment. Next Next we'll see how we can run a minimal Orleans application. Minimal Orleans Application"
  },
  "1.5/Tutorials/A-Service-is-a-Collection-of-Communicating-Actors.html": {
    "href": "1.5/Tutorials/A-Service-is-a-Collection-of-Communicating-Actors.html",
    "title": "A Service is a Collection of Communicating Actors | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "A Service is a Collection of Communicating Actors The previous tutorials all relied on interacting with a single actor from the client. In most real-world situations this is not what would be expected as actors are intended to be more or less as light-weight as objects and treated as such. Thus, you would no more find an application with just one actor type and one actor instance than you would expect to find a .NET application with one instance of one class. In this tutorial, we're going to construct multiple actors from a couple of classes with different communication interfaces. Not everything will be explained while putting together the application, we will go back and elaborate on a few things after we have it working. Employees and Managers This example will use the relationship of employees and managers to demonstrate the concept of multiple actors - it's one we all understand and relate to. Start by creating a new solution with a silo host, a communications interface project and a grain implementation project as described in previous tutorials. Don't forget to add the necessary project-to-project references and make sure to add a build dependency on the implementation project so that it is built when the host project is built. Change the first interface to IEmployee and add an interface called IManager . Add a couple of methods to describe relationships and employment level: public interface IEmployee : IGrainWithGuidKey { Task<int> GetLevel(); Task Promote(int newLevel); Task<IManager> GetManager(); Task SetManager(IManager manager); } and public interface IManager : IGrainWithGuidKey { Task<IEmployee> AsEmployee(); Task<List<IEmployee>> GetDirectReports(); Task AddDirectReport(IEmployee employee); } Note that this looks a bit different to normal .NET interfaces: usually, you have a property with a setter and a getter, but when defining grain interfaces, you need to avoid using properties altogether, only methods are supported. This is because .NET property setters and getters aren't meant to do I/O. It is often possible to use traditional object-oriented design methodology with Orleans, but sometimes there are reasons for not doing so. In this case, we're choosing to not rely on inheritance when defining the Manager class, even though a Manager is clearly also an Employee . The reason for this will be explained when we discuss Orleans' support for Declarative Persistence . With these two interfaces as our starting point, the implementation classes are straightforward to implement, as the interfaces are simple. Here's what it looks like: public class Employee : Grain, IEmployee { public Task<int> GetLevel() { return Task.FromResult(_level); } public Task Promote(int newLevel) { _level = newLevel; return TaskDone.Done; } public Task<IManager> GetManager() { return Task.FromResult(_manager); } public Task SetManager(IManager manager) { _manager = manager; return TaskDone.Done; } private int _level; private IManager _manager; } and public class Manager : Grain, IManager { public override Task OnActivateAsync() { _me = this.GrainFactory.GetGrain<IEmployee>(this.GetPrimaryKey()); return base.OnActivateAsync(); } public Task<List<IEmployee>> GetDirectReports() { return Task.FromResult(_reports); } public Task AddDirectReport(IEmployee employee) { _reports.Add(employee); employee.SetManager(this); return TaskDone.Done; } public Task<IEmployee> AsEmployee() { return Task.FromResult(_me); } private IEmployee _me; private List<IEmployee> _reports = new List<IEmployee>(); } A manager is expressed as an employee through composition: the manager grain has a reference to a grain representing its \"employeeness.\" The role of OnActivateAsync() will be explained later on; for now, you may consider it to be a constructor. In the client (Program.cs) , we can add a few lines to create a couple of employees and their manager: // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); var grainFactory = GrainClient.GrainFactory; var e0 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e1 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e2 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e3 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var e4 = grainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var m0 = grainFactory.GetGrain<IManager>(Guid.NewGuid()); var m1 = grainFactory.GetGrain<IManager>(Guid.NewGuid()); var m0e = m0.AsEmployee().Result; var m1e = m1.AsEmployee().Result; m0e.Promote(10); m1e.Promote(11); m0.AddDirectReport(e0).Wait(); m0.AddDirectReport(e1).Wait(); m0.AddDirectReport(e2).Wait(); m1.AddDirectReport(m0e).Wait(); m1.AddDirectReport(e3).Wait(); m1.AddDirectReport(e4).Wait(); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); In the code we have seen so far, it is noteworthy that you can send grain references (interfaces) in messages. Thus, when a direct report is added to a manager, the manager can communicate directly with the employee without calling GetGrain() . This ability is essential in making the programming model a smooth transition from .NET. Let's add the ability for employees to send messages to each other: public interface IEmployee : IGrainWithGuidKey { ... Task Greeting(IEmployee from, string message); ... } then: public class Employee : Grain, Interfaces.IEmployee { public Task Greeting(IEmployee from, string message) { Console.WriteLine(\"{0} said: {1}\", from.GetPrimaryKey().ToString(), message); return TaskDone.Done; } and public class Manager : Grain, IManager { public Task AddDirectReport(IEmployee employee) { _reports.Add(employee); employee.SetManager(this); employee.Greeting(_me, \"Welcome to my team!\"); return TaskDone.Done; } Executing it, you should see something like this: ![](../Images/Multiple Actors1.PNG) The use of a GUID to represent the name of a person leaves something for you to fix, as an exercise. If you want to do this exercise, please keep the rule for always using asynchronous code inside grains. The Result of a Task will block execution if the task hasnâ€™t completed. This should be avoided in Orleans grains; tasks should always be awaited before Result is read. TaskDone.Done , used in the code above, is a convenience object defined by Orleans to allow code to succinctly return an already completed Task . Asynchrony Bites Us! In the image above, you may notice that the last message comes out after the request to press Enter -- why is that? All the client requests to add a direct report dutifully wait for the addition to finish, i.e. they are fully synchronous. The problem lies elsewhere -- in the implementation of AddDirectReport() , which doesn't wait for the greeting to be acknowledged. Such concurrency is often innocuous and sometimes beneficial, as long as we don't consider the risk of exceptions, which we always must. A correct version of the method would look like this: public async Task AddDirectReport(IEmployee employee) { _reports.Add(employee); await employee.SetManager(this); await employee.Greeting(_me, \"Welcome to my team!\"); } The Life of an Actor Orleans actors are virtual, meaning that even though an actor logically exists, it may not be present in memory at a given point in time. In fact, Orleans takes this concept to an extreme by claiming that all actors exist at all time (past and present) and are never created or destroyed. An actor may be inactive, such as before the first time anyone refers to it or after the last use, but is never not existing. While counter-intuitive and, frankly, strange to most of us with a object-oriented background, this notion actually removes a source of complexity from the system. An actor is either active (present in memory) or inactive, and that status can not be observed by a client. Actor activation is on-demand, just like virtual memory is mapped on demand to physical memory. Thus, the .NET object that holds the actor state is logically just a copy of the actor in memory while it is in the active state. Implementations of Orleans grains should refrain from having constructors, even parameter-less ones, with any logic. That is simply the wrong way of thinking about them: grains are never created or destroyed, just moved from the inactive to the active state or vice versa. Therefore, the implementation should catch the activation event (a call to OnActivateAsync() ) and perform any initialization steps necessary there. It is guaranteed to be called before any method on the grain instance is called. In the Manager grain above, it was used to establish the reference to the Employee grain. There is also an OnDeactivateAsync() method, used more infrequently. Next Next up is a look at Concurrency in Orleans."
  },
  "1.5/Tutorials/Failure-Handling.html": {
    "href": "1.5/Tutorials/Failure-Handling.html",
    "title": "Handling Failures | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Handling Failures Note: All of the containing guidance in this document is provided to serve as examples and food for thought. You should not think of them as prescriptive solutions to your problems, since failure handling is a rather application specific subject, and these patterns and others are only useful if applied with a good knowledge of the concrete case being worked on. The hardest thing in programming a distributed system is handling failures. The actor model and the way it works makes it much easier to deal with different kinds of failures but still as the developer you are responsible to deal with the failure possibilities and handle them in an appropriate way. Types of failures When you are coding your grains, all calls are asynchronous and potentially can go over the network. Each grain call can possibly fail due to one of the following reasons. The grain was activated on a silo which is unavailable at the moment due to a network partition crash or some other reason. If the silo has not been declared dead yet, your request might time out. The grain method call can throw an exception signaling that it failed and can not continue its job. An activation of the grain doesn't exist and cannot be created because the OnActivateAsync method throws an exception or is dead-locked. Network failures don't let you to communicate with the grain before timeout. And potentially other reasons Detection of failures Getting a reference to a grain always succeeds and is a local operation. However, method calls can fail, and when they do, you get an exception. You can catch the exception at any level you need and they are propagated even across silos. Recovering from failures Part of the recovery job is automatic in Orleans and if a grain is not accessible anymore, Orleans will reactivate it in the next method call. The thing you need to handle and make sure is correct in the context of your application is the state. A grain's state can be partially updated or the operation might be something which should be done across multiple grains and is carried on partially. After you see a grain operation fail you can do one or more of the following. Simply retry your action, especially if it doesn't involve any state changes which might be half done. This is by far the most typical case. Try to fix/reset the partially changed state by calling a method which resets the state to the last known correct state or just reads it from storage by calling ReadStateAsync . Reset the state of all related activations as well to ensure a clean state for all of them. Perform multi-grain state manipulations using a Process Manager or database transaction to make sure it's either done completely or nothing is changed to avoid the state being partially updated. Depending on your application, the retry logic might follow a simple or complex pattern, and you might have to do other stuff like notifying external systems and other things, but generally you either have to retry your action, restart the grain/grains involved or stop responding until something which is not available becomes available. If you have a grain responsible for database saves and the database is not available, you simply have to fail any request until the database comes back online. If your operation can simply be retried at the user's will like failure of saving a comment in a comment grain, you can retry when the user presses the retry button (until a certain number of times in order to not saturate the network). Specific details of how to do it are application specific but the possible strategies are the same. Strategy parameters and choosing a good strategy As described in the section above, choosing a strategy is application and context dependent and strategies usually have parameters which again have to be decided at the application level. For example you might want to retry a request maximum 5 times per minute and can deal with it being done eventually but for some other action you might not be able to continue if something is not working. If your Login grain fails , you cannot process any other requests from the user as an example. There is a guide in the Azure documentation about good patterns and practices for the cloud which applies to Orleans as well in most cases. A fairly complex example Since in Orleans grains are activated and deactivated automatically and you don't handle their life-cycle, you usually only deal with making sure that actor state is correct and actions are being started and finished correctly in relation to each other. Knowing the dependencies between grains and actions they perform is a big step toward understanding how to handle failure in any complex system. If you need to store relations between grains, you can simply do it and it is a widely followed practice too. As an example let's say we have a GameManager grain which starts and stops Game grains and adds Player grains to the games. If my GameManager grain fails to do its action regarding starting a game, the related game belonging to it should fail to do its Start() as well and the manager can do this for the game by doing orchestration. Managing memory in Orleans is automatic and the system deals with it, you only need to make sure that the game starts and only if manager can do its Start() as well. You can achieve this by either calling the related methods in a sequential manner or doing them in parallel and reset the state of all involved grains if any of them fail. If one of the games receives a call, it will be reactivated automatically, so if you need the manager to manage the game grains, then all calls to the game which are related to management should go through the GameManager . If you need orchestration between actors, Orleans doesn't solve it automagically for you and you need to do your orchestration but the fact that you are not dealing with creating/destroying actors means you don't need to worry about resource management. You don't need to answer any of these questions: Where should I create my supervision tree which actors should I register to be addressable by name? Is actor X alive so I can send it a message? ... So the game start example can be summarized like this: GameManager asks the Game grain to start Game grain adds the Player grains to itself Game asks Player grains to add game to themselves Game sets its state to be started. GameManager adds the game to its list of games. Now if, say, a player fails to add the game to itself, you don't need to kill all players and the game and start from scratch. You simply reset the state of other players which added the game to themselves, and reset the state of the Game and GameManager , if required, and redo your work or declare a failure. If you can deal with adding the game to the player later on, you can continue and retry doing that again in a reminder or at some other game call like Finish() method of the game. Next, we'll see how we can call our grains from an MVC web application. Front Ends for Orleans Services"
  },
  "1.5/Tutorials/Minimal-Orleans-Application.html": {
    "href": "1.5/Tutorials/Minimal-Orleans-Application.html",
    "title": "Minimal Orleans Application | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Minimal Orleans Application This tutorial provides step by step instructions for creating a basic functioning Orleans application. It is designed to be self-contained and minimalistic, with the following traits. It does not need the SDK or Extension to be installed, and relies on Nuget packages only. Has been tested in both Visual Studio 2013 and 2015 using Orleans 1.2.0. Has no reliance on SQL or Azure Keep in mind that this is only a tutorial and lacks appropriate error handling and other goodies that would be useful for a production environment. However, it should help the readers get a real hands-on with regards to different facets of Orleans and allow them to focus their continued learning on the parts most relevant to them. You can find the final source code in Samples\\Tutorial.Minimal folder ( see latest version online ). Project Setup For this tutorial weâ€™re going to need to create 3 projects. A Library that contains the interfaces (Communication interfaces), a library that contains the implementation (called Grains), and a simple console application that will Host our Silo. For further understanding of this terminology please see the document Getting Started with Orleans . The Solution will eventually look like this. (Missing files will be added in the sections below) Within Visual Studio Create a blank solution called OrleansTest Create a New Console Application called Host Create a New class library called GrainInterfaces Create a New class library called GrainCollection We just use the default project types in c#. Delete the Extras Delete Class1.cs from GrainCollection Delete Class1.cs from GrainInterfaces Add the following References GrainCollection references GrainInterfaces Host references GrainInterfaces Host references GrainCollection Adding Orleans Orleans is available via Nuget. The primary goodness is in Microsoft.Orleans.Core but we will be including packages that provide additional functionality. Specifically, we will be using Template packages, which provide autocode generation for our grains and interfaces, and the Runtime which is used for hosting. With Nuget Add Microsoft.Orleans.OrleansCodeGenerator.Build to GrainInterfaces Add Microsoft.Orleans.OrleansCodeGenerator.Build to GrainCollection Add Microsoft.Orleans.OrleansRuntime to Host Creating our Grain Interface In GrainInterfaces create an interface IHello.cs public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string msg); } Creating our Implementation In GrainCollection create a class HelloGrain.cs class HelloGrain : Orleans.Grain, IHello { public Task<string> SayHello(string msg) { return Task.FromResult(string.Format(\"You said {0}, I say: Hello!\", msg)); } } Host The host requires the most amount of attention to get Orleans up and running. Throughout future tutorials, much of this will change, or go away (Orleans comes with a nice precanned SiloHost and the extension provides a template that simplifies this). However this small implementation should demonstrate the basics of getting started. Host â€“ App.Config Change App.config to enable the recommended server garbage collection <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> Host â€“ OrleansConfiguration.xml Within the Host project, add an XML file named OrleansConfiguration.xml. This will be used for cluster configuration. Make sure to set the Copy to Output directory file property to Copy if newer : <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"localhost\" Port=\"11111\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> It is possible to configure this within the code, but it is fairly difficult to do so. Host â€“ Program.cs Program.cs is our lengthiest code block. We attempt to accomplish a number of objectives here Initialize Orleans in its own AppDomain Run a trivial task (DoSomeClientWork) Wait for the user to press enter Shutdown gracefully The Orleans samples come with a very nice class called HostWrapper, which abstracts some of the boiler plate within this example and is worth exploring for a more robust implementation. We're going to do this by hand in this tutorial. using Orleans.Runtime.Host; using Orleans; using System.Net; using System; class Program { static SiloHost siloHost; static void Main(string[] args) { // Orleans should run in its own AppDomain, we set it up like this AppDomain hostDomain = AppDomain.CreateDomain(\"OrleansHost\", null, new AppDomainSetup() { AppDomainInitializer = InitSilo }); DoSomeClientWork(); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); // We do a clean shutdown in the other AppDomain hostDomain.DoCallBack(ShutdownSilo); } static void DoSomeClientWork() { // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); var result = friend.SayHello(\"Goodbye\").Result; Console.WriteLine(result); } static void InitSilo(string[] args) { siloHost = new SiloHost(System.Net.Dns.GetHostName()); // The Cluster config is quirky and weird to configure in code, so we're going to use a config file siloHost.ConfigFileName = \"OrleansConfiguration.xml\"; siloHost.InitializeOrleansSilo(); var startedok = siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", siloHost.Name, siloHost.Type)); } static void ShutdownSilo() { if (siloHost != null) { siloHost.Dispose(); GC.SuppressFinalize(siloHost); siloHost = null; } } } Running the application At this point we should be able to run the Host project. A console should appear with a large amount of logging text, and at the end it should look like this Within the appropriate bin directory (Debug/Release) there will be a number of log files showing this information as well. The amount and method of logging is configurable. Troubleshooting System.SystemException: 'Failed to start Orleans silo 'YOUR-HOST-NAME' as a Secondary node': Problem: The silo is trying to start but does not find a the specified file to get the configuration. Solution: Set the property \"Copy to Output Directory\" to \"Copy if newer\", to set it, right click on the configuration file, then click on properties. ``` Further Reading List of Orleans Packages Orleans Configuration Guide Orleans Best Practices Running in a Stand Alone Silo Azure Web Sample"
  },
  "1.5/Tutorials/Custom-Storage-Providers.html": {
    "href": "1.5/Tutorials/Custom-Storage-Providers.html",
    "title": "Custom Storage Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Custom Storage Providers Writing a Custom Storage Provider In the tutorial on declarative actor storage, we looked at allowing grains to store their state in an Azure table using one of the built-in storage providers. While Azure is a great place to squirrel away your data, there are many alternatives. In fact, there are so many that there was no way to support them all. Instead, Orleans is designed to let you easily add support for your own form of storage by writing a storage provider. In this tutorial, we'll walk through how to write a simple file-based storage provider. A file system is not necessarily the best place to store data for grains, since it's so local, but it's an easy example to help us illustrate the principles. Getting Started An Orleans storage provider is simply a class that implements IStorageProvider . It should be built into an assembly that is placed in the Orleans binaries folder. To move it there on build will require adding a bit of post-build event code. We'll start by creating the project -- it should be a regular .NET class library. Once the project is created, let's also rename the file Class1.cs to FileStorageProvider.cs . That should also prompt VS to rename the class we find inside. Next, we must add references to Microsoft.Orleans.Core NuGet package . Assuming, of course, that your project is called StorageProviders , make your silo host project reference it, so that StorageProviders.dll gets copied to the silo folder. Our storage provider should implement the interface Orleans.Storage.IStorageProvider . With a little bit of massaging of the code, it should look something like this: using System; using System.Threading.Tasks; using System.Collections.Generic; using Orleans; using Orleans.Storage; using Orleans.Runtime; using Newtonsoft.Json; using Orleans.Serialization; namespace StorageProviders { public class FileStorageProvider : IStorageProvider { private JsonSerializerSettings _jsonSettings; public Logger Log { get; set; } public string Name { get; set; } public Task Init(string name, Orleans.Providers.IProviderRuntime providerRuntime, Orleans.Providers.IProviderConfiguration config) { throw new NotImplementedException(); } public Task Close() { throw new NotImplementedException(); } public Task ReadStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } public Task WriteStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } public Task ClearStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { throw new NotImplementedException(); } } } The first thing we have to figure out is what data we need to provide through configuration. The name is a required property, but we will also need the path to the root directory for our file store. That is, in fact, the only piece of information we need, so we'll add a RootDirectory string property and edit the configuration file as in the previous section. In doing so, it's critical to pay attention to the namespace and class name of the provider. Add this to the <StorageProviders> element in the OrleansConfiguration.xml configuration file of your silo host project where you will be testing the provider: <Provider Type=\"StorageProviders.FileStorageProvider\" Name=\"FileStore\" RootDirectory=\".\\Storage\"/> Edit the Grain1.cs file to use this storage provider instead of the Azure provider, then set a breakpoint in the Init() method of the storage provider implementation class and start the silo. If you have followed the instructions, you should hit the breakpoint during silo initialization. There's no reason to go on debugging, since you will throw an exception right away. Initializing the Provider There are four major functions to implement in the provider -- Close() is the only one we won't need to do anything with. As you may have guessed, the starting point is the call to Init() , which provides us with the configuration data and a chance to get things set up properly. In our case, we'll want to set the properties and create the root directory if it doesn't already exist: public Task Init(string name, Orleans.Providers.IProviderRuntime providerRuntime, Orleans.Providers.IProviderConfiguration config) { _jsonSettings = SerializationManager.UpdateSerializerSettings(SerializationManager.GetDefaultJsonSerializerSettings(), config); this.Name = name; if (string.IsNullOrWhiteSpace(config.Properties[\"RootDirectory\"])) throw new ArgumentException(\"RootDirectory property not set\"); var directory = new System.IO.DirectoryInfo(config.Properties[\"RootDirectory\"]); if (!directory.Exists) directory.Create(); this.RootDirectory = directory.FullName; return TaskDone.Done; } Run the program again. This time, you will still crash, but in ReadStateAsync() . After running the code, you should find a Storage directory under the bin\\Debug directory of the silo host project. Make sure you have set the project up to build on F5, or you may not see the edits take effect. Reading State To store data in the file system (or anywhere, really), we have to devise a convention that generates a unique name for each grain. This is easiest done by combining the state type name with the grain id, which combines the grain type and GUID creating a globally unique key. Thus, ReadStateAsync() (which, by the way, should be declared as an async method), starts like this: var collectionName = grainState.GetType().Name; var key = grainRef.ToKeyString(); var fName = key + \".\" + collectionName; var path = System.IO.Path.Combine(RootDirectory, fName); var fileInfo = new System.IO.FileInfo(path); if (!fileInfo.Exists) return; We also need to decide how the data will be stored. To make it easy to inspect the data outside of the application, we're going to use JSON. A more space-conscious design may use a binary serialization format, instead, it's entirely a choice of the provider designer's. using (var stream = fileInfo.OpenText()) { var storedData = await stream.ReadToEndAsync(); grainState.State = JsonConvert.DeserializeObject(storedData, grainState.State.GetType(), _jsonSettings); } Writing State The format decisions have already been made, so coding up the WriteStateAsync method should be straight-forward: serialize as JSON, construct the file name, then write to the file: public async Task WriteStateAsync(string grainType, GrainReference grainRef, IGrainState grainState) { var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings); var collectionName = grainState.GetType().Name; var key = grainRef.ToKeyString(); var fName = key + \".\" + collectionName; var path = System.IO.Path.Combine(RootDirectory, fName); var fileInfo = new System.IO.FileInfo(path); using (var stream = new System.IO.StreamWriter( fileInfo.Open(System.IO.FileMode.Create, System.IO.FileAccess.Write))) { await stream.WriteAsync(storedData); } } Putting it Together There's really just one thing left to do, and that is to test the thing. Run the application and let it get to the end, where the greetings are shown, and then terminate it. Under the bin\\Debug\\Storage directory of your silo host project, you should find a file called 0.Grain1State , and it should contain something very recognizable: ![](../Images/Storage Provider 1.PNG) Run the application again, and you should see the same behaviour as before, that is, the last greeting of the first session is remembered. Clearing State The easiest method to write is the one that deletes grain state, which we didn't see any use of in the previous tutorial. In fact, we don't need it for our Hello World application, so we'll just leave its implementation as an exercise. It should do the obvious, i.e. delete the file. Next We'll look at how you can unit test grains: Unit Testing Grains"
  },
  "1.5/Tutorials/Front-Ends-for-Orleans-Services.html": {
    "href": "1.5/Tutorials/Front-Ends-for-Orleans-Services.html",
    "title": "Front Ends for Orleans Services | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Front Ends for Orleans Services Exposing silo gateway ports as public endpoints of an Orleans cluster is not recommended. Instead, Orleans is intended to be fronted by your own API. Creating an HTTP API, or web application is a common scenario. Let's extend the Employee/Manager scenario from the Declarative-Persistence walk-through to see what steps are required to publish grain data over HTTP. Creating the ASP.NET application First, you should add a new ASP.NET Web Application to your solution. Then, select the Web API template, although you could use MVC or Web Forms. Initializing Orleans Next, add a reference to the Orleans.dll file in the project references. As with the Orleans host we created earlier, we need to initialize Orleans. This is best done in the Global.asax.cs file like this: namespace WebApplication1 { public class WebApiApplication : System.Web.HttpApplication { protected void Application_Start() { ... var config = ClientConfiguration.LocalhostSilo(); // Attempt to connect a few times to overcome transient failures and to give the silo enough // time to start up when starting at the same time as the client (useful when deploying or during development). const int initializeAttemptsBeforeFailing = 5; int attempt = 0; while (true) { try { GrainClient.Initialize(config); break; } catch (SiloUnavailableException e) { attempt++; if (attempt >= initializeAttemptsBeforeFailing) { throw; } Thread.Sleep(TimeSpan.FromSeconds(2)); } } ... Now when the ASP.NET application starts, it will initialize the Orleans Client. Creating the Controller Now lets add a controller to the project, to receive HTTP requests, and call the grain code. Right click on the \"Controllers\" folder, and add a new \"Web API 2 Controller - Empty\". Next, call the controller EmployeeController . This will create a new empty controller called EmployeeController . We can add a Get method to the controller, which we'll use to return the level of an Employee. public class EmployeeController : ApiController { public Task<int> Get(Guid id) { var employee = GrainClient.GrainFactory.GetGrain<IEmployee>(id); return employee.GetLevel(); } } Note that the controller is asynchronous, and we can just pass back the Task which the grain returns. Running the Application Now let's test the application. Build the project. Set the ASP.NET application and the silo host project as the startup projects, and run them. If you navigate to the API URL (the number may be different on your project)... http://localhost:6858/api/employee/42783519-d64e-44c9-9c29-399e3afaa625 ...you should see the result returned from the grain: 42 That's the basics in place, the rest of the API can be completed by adding the rest of the HTTP verbs. Next We'll look at how you can deploy Orleans in the Azure Cloud Cloud Deployment"
  },
  "1.5/Tutorials/Declarative-Persistence.html": {
    "href": "1.5/Tutorials/Declarative-Persistence.html",
    "title": "Declarative Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Declarative Persistence In the second tutorial, we saw how grain state survived the client being shut down, which opens up for a lot of cache-like scenarios, where Orleans is relied upon as a kind of 'cache with behavior,' an object-oriented cache, if you will. That is already very valuable and goes a long way toward achieving server-side scalability with a simple, familiar, programming model and the built-in single-threaded execution guarantees. However, it is sometimes the case that some of the state you are accumulating belongs in some form of permanent storage, so that it can survive a silo shutdown, or a grain migrating from one silo to another for load-balancing or a complete restart/shutdown of the service. What we have seen so far will not support such situations. Fortunately, Orleans offers a simple declarative model for identifying the state that needs to be stored in a permanent location, while leaving the decision when to save and restore state under programmatic control. You are not required to use the declarative persistence mechanism and can still access storage directly from your grain code, but itâ€™s a nice way to save you some boilerplate code and build applications that are portable across various storage services. Getting Started We'll continue to build on our employee-and-manager sample. The first thing we need to do is make the identities of our workers and managers a little more predictable. In the sample, they were assigned GUIDs using Guid.NewGuid() , which is convenient, but doesn't let us find them in a subsequent run. Therefore, we'll create a set of GUIDs first, then use them as the worker identities. The modified Main program looks like this: static void Main(string[] args) { ... var ids = new string[] { \"42783519-d64e-44c9-9c29-399e3afaa625\", \"d694a4e0-1bc3-4c3f-a1ad-ba95103622bc\", \"9a72b0c6-33df-49db-ac05-14316edd332d\", \"6526a751-b9ac-4881-9bfb-836ecce2ca9f\", \"ae4b106f-3c96-464a-b48d-3583ed584b17\", \"b715c40f-d8d2-424d-9618-76afbc0a2a0a\", \"5ad92744-a0b1-487b-a9e7-e6b91e9a9826\", \"e23a55af-217c-4d76-8221-c2b447bf04c8\", \"2eef0ac5-540f-4421-b9a9-79d89400f7ab\" }; var e0 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[0])); var e1 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[1])); var e2 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[2])); var e3 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[3])); var e4 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.Parse(ids[4])); var m0 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.Parse(ids[5])); var m1 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.Parse(ids[6])); ... } Next, we'll do some silo configuration, in order to configure the storage provider that will give us access to persistent storage. The silo host project includes a file OrleansHostWrapper.cs which is where we find the following section: var config = ClusterConfiguration.LocalhostPrimarySilo(); config.AddMemoryStorageProvider(); // Add this line to use the Azure storage emulator // config.AddAzureTableStorageProvider(\"AzureStore\", \"UseDevelopmentStorage=true\"); // Add this line to use an Azure storage account // config.AddAzureBlobStorageProvider(\"AzureStore\", \"[insert data connection string]\"); siloHost = new SiloHost(siloName, config); If this is hosted in Azure Cloud Services, then one can use: config.AddAzureBlobStorageProvider(\"AzureStore\"); and it will pick up the same connection string used in config.Globals.DataConnectionString . The MemoryStorage provider is fairly uninteresting, since it doesn't actually provide any permanent storage; it's intended for debugging persistent grains while having no access to a persistent store. In our case, that makes it hard to demonstrate persistence, so we will rely on a real storage provider. Depending on whether you have already set up (and want to use) an Azure storage account, or would like to rely on the Azure storage emulator, you should add one of the other two lines, but not both. You can use either the AddAzureTableStorageProvider() function or the AddAzureBlobStorageProvider() function depending on how you want to store information. In the case of the former, you have to start the Azure storage emulator after installing the latest version of the Azure SDK. In the case of the latter, you will have to create a Azure storage account and enter the name and keys in the configuration file. With one of those enabled, we're ready to tackle the grain code. Note: The built-in storage provider classes Orleans.Storage.AzureBlobStorage and Orleans.Storage.AzureTableStorage are in the OrleansAzureUtils.dll assembly, make sure this assembly is referenced in your silo worker role project with CopyLocal='True' . Declaring State Identifying that a grain should use persistent state takes three steps: declaring a class for the state, changing the grain base class, and identifying the storage provider. The first step, declaring a state class in the grain implementations project, simply means identifying the information of an actor that should be persisted and creating what looks like a record of the persistent data -- each state component is represented by a property with a getter and a setter. For employees, we want to persist all the state: public class EmployeeState { public int Level { get; set; } public IManager Manager { get; set; } } and for managers, we must store the direct reports, but the _me reference may continue to be created during activation. public class ManagerState { public List<IEmployee> Reports { get; set; } } Then, we change the grain class declaration to identify the state interface (e.g., from Orleans.Grain to Orleans.Grain<EmployeeState> ) and remove the variables that we want persisted. Make sure to remove level , and manager from the Employee class and _reports from the Manager class. In addition, we must update the other functions to reflect these removals. We also add an attribute to identify the storage provider: [StorageProvider(ProviderName = \"AzureStore\")] public class Employee : Orleans.Grain<EmployeeState>, Interfaces.IEmployee and [StorageProvider(ProviderName=\"AzureStore\")] public class Manager : Orleans.Grain<ManagerState>, IManager At risk of stating the obvious, the name of the storage provider attribute should match the name in the configuration file. This indirection is what allows you to delay choices around where to store grain state until deployment. Given these declarative changes, the grain should no longer rely on a private fields to keep compensation level and manager. Instead, the grain base class gives us access to the state via a State property that is available to the grain. For example: public Task SetManager(IManager manager) { State.Manager = manager; return TaskDone.Done; } Controlling Checkpoints The question that remains is when the persistent state gets saved to the storage provider. One choice that the Orleans designers could have made would be to have the runtime save state after every method invocation, but that turns out to be undesirable because it is far too conservative -- not all invocations will actually modify the state on all invocations, and some will never modify it. Rather than employing a complex system to evaluate state differentials after each method, Orleans asks the grain developer to add the necessary logic to determine whether state needs to be saved or not. Saving the state using the storage provider is easily accomplished by calling base.WriteStateAsync() . Thus, the final version of the Promote() and SetManager() methods looks like this: public Task Promote(int newLevel) { State.Level = newLevel; return base.WriteStateAsync(); } public Task SetManager(IManager manager) { State.Manager = manager; return base.WriteStateAsync(); } In the Manager class, there's only one method that need to be modified to write out data, AddDirectReport() . It should look like this: public async Task AddDirectReport(IEmployee employee) { if (State.Reports == null) { State.Reports = new List<IEmployee>(); } State.Reports.Add(employee); await employee.SetManager(this); var data = new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }; await employee.Greeting(data); Console.WriteLine(\"{0} said: {1}\", data.From.ToString(), data.Message); await base.WriteStateAsync(); } Let's try this out! Set a breakpoint in Employee.Promote() . When we run the client code the first time and hit the breakpoint, the level field should be 0 and the newLevel parameter either 10 or 11 : ![](../Images/Persistence 2.PNG) Let the application finish (reach the 'Hit Enter...' prompt) and exit. Run it again, and compare what happens when you look at state this second time around: ![](../Images/Persistence 3.PNG) Just Making Sure... It's worth checking what Azure thinks about the data. Using a storage explorer such as Azure Storage Explorer (ASE) or the one built in to Server Explorer in Visual Studio 2013, open the storage account (or developer storage of the emulator) and find the 'OrleansGrainState' table. It should look something like this (you have to hit 'Query' in ASE): ![](../Images/Persistence 4.PNG) If everything is working correctly, the grain keys should appear in the PartitionKey column, and the qualified class name of the grains should appear in the RowKey column. Mixing Things A grain may contain a combination of persisted and transient state. Any transient state should be represented by private fields in the grain class. A common use for mixing the two is to cache some computed version of the persisted state in private fields while it is present in memory. For example, a stack of elements may be externally represented as a List<T> , but internally, as a Stack<T> . In the case of our Manager class, the _me field is simply a cached value, something we don't even need to keep as a field in the first place, it can be created any time we need it, but since it's going to be a commonly used value, it's worth keeping it around in a transient field. Automatic loading of state If a grain type has state, at activation time the state will be loaded from storage and then OnActivateAsync is called so you can be sure that the state is loaded when initializing your grain. This is the only case that Orleans calls ReadStateAsync automatically. If you want to write the state or read it in some other place, you should do it on your own. Normally you should not need to call ReadStateAsync yourself unless you are doing something specific regarding handling corrupted state or something else. Handling failures using persistence Generally speaking reading and writing a grain's state is a good mechanism to handle failures as well as serving its original intent. There is a possibility that your grain call fails in the middle of a method due to different reasons and you end up with a state which is half changed. In this case reading from storage can return your state to the last correct state. Alternatively, having gotten into such a state, the grain can request to get immediately deactivated by calling DeactivateOnIdle(), so that its a next request to it would trigger reactivation of the grain, which would reread the persistent state and reconstruct its in-memory copy. Deactivation is the cleanest way of resetting a grain to its last know good state, but if you want to avoid the cost of the reactivation process, you can reset its state and rerun any initialization logic (for example, by calling OnActivateAsync ) instead of deactivating the grain. Next Next, we'll see how we can call our grains from an MVC web application. Handling Failure"
  },
  "1.5/Tutorials/Running-in-a-Stand-alone-Silo.html": {
    "href": "1.5/Tutorials/Running-in-a-Stand-alone-Silo.html",
    "title": "Running in a Stand-Alone Silo | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Running in a Stand-Alone Silo In the first tutorial , we got a very simple \"Hello World!\" Orleans application running in the simplest possible environment, a dev/test host where everything is running in one process, which makes starting and stopping it really easy. For most of your initial development of grain-based applications and services, that environment will be ideal. However, one thing that is hard to test in such an environment is what happens when the client and server do not get started and stopped at the same time. Often, state is maintained on the server across client sessions, something that is hard to model using the single-process setup. Therefore, what we're going to do now is modify the solution we finished up with in the first tutorial and make it just a bit more like a production environment, running the server and client code in different processes. Getting Started The first thing we need to do is get the grain code running in a silo that is in a separate process and prevent it from being started by the code in Program.cs . To do the latter, remove the code that starts the silo in its own app domain, as well as the code that shuts it down at the end. One consequence of not running the silo from the same process is that the client code has to wait for the silo to be ready to accept incoming requests. Rather than adding some clever backoff-retry code, here we simply expect you to wait for the silo to start, then hit 'Enter' in the client console window when the silo is advertising its readiness. This is the result: static void Main(string[] args) { Console.WriteLine(\"Waiting for Orleans Silo to start. Press Enter to proceed...\"); Console.ReadLine(); // Orleans comes with a rich XML and programmatic configuration. Here we're just going to set up with basic programmatic config var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); } Now you should add reference to Microsoft.Orleans.Server NuGet package to your collection project and then in its project properties in Debug tab set the bin/Debug/OrleansHost.exe or bin/Release/OrleansHost.exe file as startup program for your collections class library. Try to not mix NuGet package versions, make sure all Orlean packages (client, graininterface and grain projects) are aligned in the solution. You also need to add a OrleansConfiguration.xml file, you can create it using the instruction in Minimal Orleans Application tutorial . Then, in this file, make sure that the ProxyingGateway element inside its Defaults section matches this value: <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> Don't forget to set the file's \"Copy to Output Directory\" property to \"Copy if newer\". OrleansHost.exe is a ready-made host executable intended for running Orleans silo code. It is also useful for development purposes. If you set both the grain collection project and the the host project as startup projects, you will see two windows come up: ![](../Images/Standalone 1.PNG) This allows us to debug the grains in their own process, while keeping the client code in its own process. If you let the client make its request, then terminate it using 'Enter' when asked, you should see only the client process windows disappear. The debugging session won't end, because the grains are still being debugged in the OrleansHost.exe process. To start the client again, you will have to use the right-button context menu in the Solution Explorer to get it started. Keeping Things Around To demonstrate keeping state around across client sessions, let's modify the SayHello() method to take a string argument. Then, we will have our grain save each string it is sent and return the last one. Only at the first greeting will we see something we didn't send to the grain from the client. First, change the interface definition of SayHello public interface IGrain1 : IGrainWithIntegerKey { Task<string> SayHello(string greeting); } Then change the Implementation private string text = \"Hello World!\"; public Task<string> SayHello(string greeting) { var oldText = text; text = greeting; return Task.FromResult(oldText); } We also change the client to send a greeting several times in Program.cs: var hello = GrainClient.GrainFactory.GetGrain<IGrain1>(0); Console.WriteLine(hello.SayHello(\"First\").Result); Console.WriteLine(hello.SayHello(\"Second\").Result); Console.WriteLine(hello.SayHello(\"Third\").Result); Console.WriteLine(hello.SayHello(\"Fourth\").Result); What we would expect to see here is four greetings, the first of which is \"Hello World!\". Let's check it out: ![](../Images/Standalone 2.PNG) Terminate the client (make sure it's just the client, we need the grain host to stay up) and restart it using the context menu. There's no reason to wait for the silo now, since it's already running. Here's what we get: ![](../Images/Standalone 3.PNG) Still four greetings, but instead of \"Hello World!\" the first greeting is the last one from our previous client session. In other words, the grain in the silo kept some state around for us. Next So far, we've only seen one single grain type and a single instance of that type. It has served to keep things simple for the purpose of explaining how the environment works, but it is not typical of Orleans code. In the next tutorial, we will see something more realistic. Actor Identity"
  },
  "1.5/Tutorials/On-Premise-Deployment.html": {
    "href": "1.5/Tutorials/On-Premise-Deployment.html",
    "title": "On-Premise Deployment | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "On-Premise Deployment Overview While using Orleans to implement cloud-based services is a core scenario, there is nothing that intrinsically ties it to the cloud as the sole platform. Orleans can just as well be deployed to the internal, on-premise, equipment of your organization's. In this tutorial, we describe the steps to take. Orleans based services are xcopy-deployable. All you need to do to deploy an Orleans based service to a set of machines is copy the following set of file to the target machines and start the OrleansHost.exe host process: Contents of the build folder of your host project (it can use Microsoft.Orleans.Host NuGet package or use your own console application running the Silo). OrleansConfiguration.xml file with configuration for the deployment to replace the default placeholder (If you use file based config). Binaries with grain interfaces and grain implementation classes of the service along with any external dependencies to Application<service name> subdirectory of the folder on the target with binaries of the host which should contain Orleans DLLs as well. This simple task may be accomplished in many different ways and with different tools, but the Orleans GitHub repo includes a set of PowerShell scripts ( https://github.com/dotnet/orleans/tree/master/misc/scripts/RemoteDeployment ) that provide a way to deploy an Orleans based service to a cluster of machines and remote start the hosting processes on them. There are also scripts for removing a service, monitoring its performance, starting and stopping it, and collecting logs. These are the scripts we found useful for ourselves while building and testing Orleans. Prerequisites The following table lists the prerequisites for deploying and running Orleans on a remote machine: .Net Framework 4.5 Orleans runs under the .Net Framework 4.5, which can be installed from this link: ( https://www.microsoft.com/en-us/download/details.aspx?id=30653 ) Powershell 2.0 with WinRM Windows 7 and Windows Server 2008 R2 should have these installed by default. For earlier versions of Windows, select the appropriate download from this article: ( https://support.microsoft.com/en-us/help/968929/windows-management-framework-windows-powershell-2.0,-winrm-2.0,-and-bits-4.0 ). To confirm you are running the required version of PowerShell, start a PowerShell window and type Get-Host â€“ the resulting output needs to say \"Version: 2.0\" WinRM Configuration Both the source and target machines must be configured for remote operations: Open a PowerShell window as an Administrator and run the command below on the target machine (enter 'y' at the prompts): winrm quickconfig Increase PowerShell job memory Set the memory limit on remotely invoked jobs to 4Gb: Set-Item wsman:localhost\\Shell\\MaxMemoryPerShellMB 4096 To change it on a remote machine, use the following steps: Connect-WSMan -ComputerName <string> Set-Item wsman:<computerName>\\Shell\\MaxMemoryPerShellMB Disconnect-WSMan â€“ComputerName <string> PowerShell Execution Policy set to run remote scripts Open a PowerShell window as an Administrator and run the command below on the target machine (enter 'y' at the prompt): Set-ExecutionPolicy RemoteSigned This will set the machine to require signing for remote scripts only. Note that the user running the scripts must be a member of the Administrators Group on the remote machines. Deployment Steps In this tutorial , we will deploy the HelloWorld sample to a set of servers. The Orleans repo includes a RemoteDeployment folder ( https://github.com/dotnet/orleans/tree/master/misc/scripts/RemoteDeployment ) where everything we need can be found. Start by building the Hello World sample , commenting out (or removing) the silo initialization and shutdown code: static void Main(string[] args) { //AppDomain hostDomain = // AppDomain.CreateDomain(\"OrleansHost\", null, new AppDomainSetup //{ // AppDomainInitializer = InitSilo, // AppDomainInitializerArguments = args, //}); Orleans.GrainClient.Initialize(\"ClientConfiguration.xml\"); var friend = GrainClient.GrainFactory.GetGrain<HelloWorldInterfaces.IHello>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello(\"Good morning!\").Result); Console.WriteLine(\"Orleans Silo is running.\\nPress Enter to terminate...\"); Console.ReadLine(); //hostDomain.DoCallBack(ShutdownSilo); } Also, start a new PowerShell window as Administrator and move to the RemoteDeployment folder. The basic steps to deploy Orleans code are: Setup a deployment manifest (Deployment.xml) . Adjust the Orleans server-side configuration (OrleansConfiguration.xml) to suit the environment. Run the PowerShell deployment scripts to deploy Orleans into your remote environment. Orleans Deployment Manifest The Orleans Deployment scripts use a manifest (XML) file to specify details of the deployment, including source and destination locations and local or remote machines to be deployed to. By making small changes to an existing deployment manifest xml file (typically by listing the different host machines), the same PowerShell scripts can deploy and run that Orleans system on a set of remote machines with equal ease as deploying and running that system on the local machine. The default file name for the manifest is Deployment.xml , and if you just modify this file, which is found in the RemoteDeployment folder, it will not be necessary to specify a different name. There are times, such as during testing, it may be advantageous to maintain multiple deployment files that specify a different set of silos. These other files may be specified explicitly to the deployment tools as specified in the respective sections below. A deployment manifest contains many different items, which collectively allow deployment of the Orleans runtime and applications onto a variety of local and remote configurations: Source location for the Orleans system runtime Located in the Path attribute of the <Deployment><Packages><Package> element where the Type attribute is set to \"System\". <Package Name=\"Orleans Runtime\" Type=\"System\" Path=\"..\\Binaries\\OrleansServer\" /> Source location for additional Orleans applications If you have any additional Orleans applications / grains to be included in this Orleans system, they are also located in the <Deployment><Packages><Package> nodes. The Type attribute must be set to \"Application\". <Package Name=\"HelloWorld\" Type=\"Application\" Path=\"..\\Binaries\\Applications\\HelloWorldGrains\" /> Source location for the server configuration file to be used by the Orleans host process Located in the Path attribute of the <Deployment><RuntimeConfiguration> element. The file name must be \"OrleansConfiguration.xml\" â€“ if necessary, just change the path. <RuntimeConfiguration Path=\".\\OrleansConfiguration.xml\" /> Target location to install the Orleans server-side binaries on each machine Located in the <Deployment><TargetLocation> element. This must be an absolute local file system path (i.e. no \"..\" locations) that is valid on all the target hosts. <TargetLocation Path=\"C:\\Orleans\" /> The set of silos (host machines and optional silo names) this Orleans system should to be deployed to. Located in the <Deployment><Nodes><Node> elements. Typically: \"Primary\" on localhost , or multiple machines with one silo each. The HostName attribute specifies the machine name. The NodeName attribute specifies the name of the silo. Generally, this is arbitrary, with the exception that if multiple silos will run on any one machine, then silo names must be unique. <Nodes> <Node HostName=\"MACHINE1\" NodeName=\"Primary\" /> <Node HostName=\"MACHINE2\" NodeName=\"Node2\" /> <Node HostName=\"MACHINE3\" NodeName=\"Node3\" /> <Nodes /> Deployment Group ID This is a GUID which distinguishes one Orleans runtime system from another, even if both Orleans systems are running on the same machines. Located in the <Deployment> element. <Deployment Name=\"Deployment1\" DeploymentGroup=\"F219832A-1EE1-45DA-B35D-0BB3060C9FDA\" xmlns=\"urn:xcg-deployment\"> Orleans Silo Configuration Refer to Server Configuration for information on silo configuration. Orleans Powershell Scripts The following sections detail the PowerShell scripts provided with Orleans to aid with deployment and monitoring. (Use the /? option to get the latest usage info directly from the scripts.) Script Name Parameters Description DeployOrleansSilos.ps1 [$deploymentConfigFile] Copies the Orleans files to machines specified in the deploymentConfigFile (default is Deployment.xml). UndeployOrleansSilos.ps1 [$deploymentConfigFile] Stops and removes Orleans from the deployment servers deploymentConfigFile (default is Deployment.xml). MonitorOrleansSilos.ps1 [$deploymentConfigFile] [$networkInstance] [$samplesToLog] [$headerInterval] [$repeatHeaderInFile] Monitors CPU, Memory, Network Send, and Network Receive performance counters, and logs the data to files both as an aggregate of all data, and in separate files for each server. See usage text for details about the parameters. ShowOrleansSilos.ps1 [$deploymentConfigFile] Does a quick survey of the deployment silos and reports if Orleans is running on them. GatherOrleansSiloLogs.ps1 [$deploymentConfigFile] [$outputPath] Retrieve all log files from deployment silos and stores them in the specified output folder. UtilityFunctions.ps1 none Provides ancillary functionality to the other scripts. Deploying Orleans using Powershell Script Start a separate PowerShell command window as an administrator. Execute the DeployOrleansSilos.ps1 script, providing the location of the deployment configuration file (\"deployment.xml\" is the default and will be used if you donâ€™t supply a value). .\\DeployOrleansSilos.ps1 .\\Deployment.xml The deployment will execute the following steps: Stop any running instances of Orleans that are running on the deployment machines. Copy the Orleans files and any application files that are listed in the deployment manifest. When the copy is completed, start the silos. This will pause after starting the first silo so that it is available for the other silos to register with. Pause to allow the start-up to complete. Report the progress of the deployment. When the deployment is complete, Orleans is ready for clients to connect to it. Confirming Orleans Status To determine if Orleans is running on the servers in the deployment manifest, run the ShowOrleansSilos.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. .\\ShowOrleansSilos.ps1 .\\Deployment.xml If everything works well, you should see something like this: PS C:\\Orleans\\misc\\scripts\\RemoteDeployment> .\\ShowOrleansSilos.ps1 .\\Deployment.xml OrleansHost running on host001: Process 1: 1340 OrleansHost running on host002: Process 1: 4320 2 processes running Running the Client We've edited the Hello World program not to start a silo in-process, but in order to run the client, the client configuration file DevTestClientConfiguratio.xml needs to be edited according to the Client Configuration section. The setup needs to conform to how the server was set up, specifically whether or not Azure Storage is used to keep track of the deployment configuration. In the author's setup, Azure is not involved, so the client configuration looks like this: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"host001\" Port=\"30000\"/> <Gateway Address=\"host002\" Port=\"30000\"/> <Statistics MetricsTableWriteInterval=\"30s\" PerfCounterWriteInterval=\"30s\" LogWriteInterval=\"300s\" WriteLogStatisticsToTable=\"true\"/> </ClientConfiguration> which corresponds to a server configuration that looks like this (relevant excerpts only): <Globals> <SeedNode Address=\"host001\" Port=\"11111\" /> <Liveness LivenessType =\"MembershipTableGrain\" /> ... </Globals> <Defaults> <Networking Address=\"\" Port=\"11111\" /> <ProxyingGateway Address=\"\" Port=\"30000\" /> ... </Defaults> Running the client in VS, I see this: ![](../Images/onpremise 1.PNG) Monitoring Orleans Once Orleans is deployed, you can start an optional script that will monitor the Orleans deployment using standard performance counters. Run a dedicated PowerShell command prompt as an administrator, and execute the .\\MonitorOrleans.ps1 script to start monitor performance counters for an Orleans Deployment. The following parameters configure the monitoring to suit individual circumstances: Parameter Default Description DeploymentConfigFile Deployment.xml The deployment manifest used to install Orleans. NetworkInstance corp The name of the network for the network performance counters. SamplesToLog 480 The number of samples to record in the current run. Use Ctrl-C to stop the script sooner. The default of 480, which taken in one minute intervals should continue for eight hours. HeaderInterval 10 The number of samples to write before repeating the header. RepeatHeaderInFile If this switch is present, the header will be repeated in the log file at the interval specified by the previous parameter. The script will store the data in the following types listed below. The files will be written to a folder called PerformanceData under the directory where the monitoring script is run from. File Type FileNameBase Description Machine Specific â€œPerfData-â€ + machine name + Date/Time stamp. Contains only the data for a single machine. If there are four machines in the deployment, then there will be four of these files. Combined â€œConsolidatedPerfData-â€ + Date/Time stamp. Contains all of the data for all machines consolidated into a single file. Gathering Orleans Log Files To retrieve all log files from deployment silos and store them in the specified output folder, run the GatherOrleansSiloLogs.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. You may also specify an output folder where the collected log files will be stored otherwise a .\\logs subdirectory will be used by default. .\\GatherOrleansSiloLogs.ps1 .\\Deployment.xml .\\GatherOrleansSiloLogs.ps1 .\\Deployment.xml .\\MyLogs Removing Orleans When it is time to remove an Orleans deployment, use the UndeployOrleansSilos.ps1 script. If you have used a deployment manifest file named something other than the default, specify it on the command line. .\\UnDeployOrleansSilos.ps1 .\\Deployment.xml Next We'll write our own storage provider, to save grain state to alternative to file instead of Microsoft Azure: Custom Storage Providers"
  },
  "1.5/Documentation/Samples-Overview/Azure-Web-Sample.html": {
    "href": "1.5/Documentation/Samples-Overview/Azure-Web-Sample.html",
    "title": "Azure Web Sample | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Azure Web Sample Important note : Worker and web role instances are not automatically removed or disabled, even when they go unused for a long time. To avoid a nasty surprise when your Azure bill comes, make sure to delete the instances after you have finished testing the application! This sample is essentially the same as the Hello World sample, except that it hosts the grains in an Azure Worker Role instead of in the client process itself. While the communication interface and grain implementation are identical, three projects replace the client: OrleansAzureSample , which is the Azure configuration project. OrleansAzureSilos , the Worker Role integration logic that hosts the Orleans silo in the cloud. WebRole , which provides a simple HTML UI for the Orleans backend. Run AzureWebSample Locally The sample is configured to run inside of the Azure Compute Emulator on your desktop by default, so make sure that OrleansAzureSample is set as the Startup Project in this solution and just press F5 to build and run the sample locally. You do not need to start Visual Studio with administrative privileges to run this sample in the emulator - it is designed to use both IIS Express and Express Emulator , so make sure these options are selected in OrleansAzureSample->Properties->Web. You may also need to select the \"Use IIS Express for web sites and projects\" in Tools->Options->Projects and Solutions->Web Projects. Run AzureWebSample in Azure Cloud To get the sample running in the Azure cloud, open the ServiceConfiguration.Cloud.cscfg file in the OrleansAzureSample project. Edit the connection strings, replacing MYACCOUNTNAME and MYACCOUNTKEY with data you get from the Azure portal, logged in to your account. It may be useful to set up a new storage account within your subscription just for samples testing. All four connection strings will look exactly the same. In the file ServiceDefinition.csdef , the configuration sets up all instances as ExtraSmall to avoid any unpleasant surprises. If you want something else, modify the settings as you see fit. Then, build the solution with Visual Studio and right-click on the OrleansAzureSample project, selecting 'Publish.' Visual Studio will take you through the process of publishing your project to Azure, which will take a few minutes. If things work out, you should see something like this: ![](AzureSample 3.png) This means that the site and its backend are ready. Start a web browser and navigate to the link that VS displayed (or just click on it). You will be greeted by this screen: ![](AzureSample 1.png) Click on \"Ask Orleans it's details\" and wait for the response. The first time you interact with the site, it may take a few seconds, since the whole system need to warm up. After that first message, it should go quickly. ![](AzureSample 2.png)"
  },
  "1.5/Documentation/Samples-Overview/index.html": {
    "href": "1.5/Documentation/Samples-Overview/index.html",
    "title": "Samples Overview | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Samples Overview What do I need? To productively use the Orleans samples, please follow the Prerequisites section for the supported versions of the .NET framework, Visual Studio and Azure SDK. An Azure subscription will help with some of the samples, but is not required. For the Azure-based samples, you will need to install the SDK. The samples themselves can be downloaded from GitHub . Hello World This is the Orleans version of an old classic. It demonstrates that while there is no such thing as \"trivial\" when you are dealing with distributed computing, Orleans makes it pretty straight-forward. Azure Web Sample An Azure-hosted version of Hello World. Adventure Before there was graphical user interfaces, before the era of game consoles and massive-multiplayer games, there were VT100 terminals and there was Colossal Cave Adventure . Possibly lame by today's standards, back then it was a magical world of monsters, chirping birds, and things you could pick up. It's the inspiration for this sample. Presence Service This sample shows the principles behind a typical (though much simplified) presence service, such as you would find in online games and other social applications. Tic Tac Toe This is a simple online version of the classic board game. Chirper A simple social network pub/sub system, with chirp messages being sent from publishers to followers. Twitter Sentiment This sample uses Orleans to aggregate and analyze twitter data for a simple sentiment dashboard. Twitter Sentiment relies on a Node.js project for some of its functionality, as well as Twitter developer credentials. To use this sample, you will need to: Get the Node.js Tools for Visual Studio Get a Twitter account Sign up as a Twitter Developer. GPS Tracker A combination of Orleans and SignalR is used to simulate GPS devices tracked as they move around San Francisco, updating their locations as they change. Storage Providers This sample contains sample code for two Orleans storage providers: one that stores data in a regular file system, one that connects to MongoDB."
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html",
    "title": "Server Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Server Configuration There are two key aspects of silo configuration: Connectivity: siloâ€™s endpoints for other silos and clients Cluster membership and reliability: how silos discover each other in a deployment and detect node failures. Depending on the environment you want to run Orleans in some of these parameters may or may not be important. For example, for a single silo development environment one usually doesnâ€™t need reliability, and all the endpoints can be localhost. The following sections detail the configuration setting for the four mentioned key aspects. Then in the scenarios section you can find the recommended combinations of the settings for the most typical deployment scenarios. Connectivity The connectivity settings define two TCP/IP endpoints: one for inter-silo communication and one for client connections, also referred to as client gateway or simply gateway. Inter-silo Endpoint <Networking Address=\" \" Port=\"11111\" /> Address: IP address or host name to use. If left empty, silo will pick the first available IPv4 address. Orleans supports IPv6 as well as IPv4. Port: TCP port to use. If left empty, silo will pick a random available port. If there is only one silo running on the machine, it is advisable to specify a port for consistency and for easy configuration of the firewall. For running multiple silos on the same machine, you can either provide each of the silos with different configuration files or leave the Port attribute empty for a random port assignment. For machines that have more than one IP address assigned to them, if you need to choose an address from a specific subnet or an IPv6 address, you can do that by adding a Subnet and PreferredFamily attributes respectively (refer to the XSD schema for exact syntax of those attributes). For local development environment, you can simply use localhost as the host name: <Networking Address=\"localhost\" Port=\"11111\" /> Client Gateway Endpoint The setting for client gateway endpoint is identical to the inter-silo endpoint except for the XML element name: <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> You have to specify a port number different from the one used for the inter-silo endpoint. It is possible to configure clients to connect to the inter-silo endpoint instead of the gateway, but that requires opening a listening socket on the client (thus requires enabling incoming connections on the client machine firewall), and in general is not advisable other than for a very limited set of scenarios. Cluster Membership and Reliability Usually, a service built on Orleans is deployed on a cluster of nodes, either on dedicated hardware or in Azure. For development and basic testing, Orleans can be deployed in a single node configuration. When deployed to a cluster of nodes, Orleans internally implements a set of protocols to discover and maintain membership of Orleans silos in the cluster, including detection of node failures and automatic reconfiguration. For reliable management of cluster membership, Orleans uses Azure Table, SQL Server or Apache ZooKeeper for synchronization of nodes. The reliable membership setup requires configuring the 'SystemStore' element settings in the silo configuration file: <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"...\" DataConnectionString=\"...\"/> or <SystemStore SystemStoreType=\"SqlServer\" DeploymentId=\"...\" DataConnectionString=\"...\"/> or <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"...\" DataConnectionString=\"...\"/> DeploymentId is a unique string that defines a particular deployment. When deploying an Orleans based service to Azure it makes most sense to use the Azure deployment ID of the worker role. For development or if itâ€™s not possible to use Azure Table, silos can be configured to use the membership grain instead. Such a configuration is unreliable as it will not survive a failure of the primary silo that hosts the membership grain. â€œMembershipTableGrainâ€ is the default value of LivenessType. <Liveness LivenessType =\"MembershipTableGrain\" /> Primary Silo In a reliable deployment, one that is configured with membership using Azure Table, SQL Server or ZooKeeper, all silos are created equal, with no notion of primary or secondary silos. That is the configuration that is recommended for production that will survive a failure of any individual node or a combination of nodes. For example, Azure periodically rolls out OS patches and that causes all of the role instances to reboot eventually. For development or a non-reliable deployment when MembershipTableGrain is used, one of the silos has to be designated as Primary and has to start and initialize before other, Secondary, silos that wait for Primary to initialize before joining the cluster. In case of a failure of the Primary node, the whole deployment stops working properly and has to be restarted. Primary is designated in the configuration file with the following setting within the Globals section. <SeedNode Address=\"<host name or IP address of the primary node>\" Port=\"11111\" /> Here is an example how to configure and launch Orleans silo hosted inside worker-role. This is a reference only example and SHOULD NOT be used AS-IS - you may need to fine-tune client parameters for your specific environment. var dataConnection = \"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\"; var config = new ClusterConfiguration { Globals = { DeploymentId = RoleEnvironment.DeploymentId, ResponseTimeout = TimeSpan.FromSeconds(30), DataConnectionString = dataConnection, LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable, ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable, }, Defaults = { PropagateActivityId = true, // Tracing DefaultTraceLevel = Severity.Info, TraceToConsole = false, TraceFilePattern = @\"Silo_{0}-{1}.log\", //TraceFilePattern = \"false\", // Set it to false or none to disable file tracing, effectively it sets config.Defaults.TraceFileName = null; TraceLevelOverrides = { Tuple.Create(\"ComponentName\", Severity.Warning), } } }; // Register bootstrap provider class config.Globals.RegisterBootstrapProvider<AutoStartBootstrapProvider>(\"MyAutoStartBootstrapProvider\"); // Add Storage Providers config.Globals.RegisterStorageProvider<MemoryStorage>(\"MemoryStore\"); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"PubSubStore\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, //{ \"UseJsonFormat\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"AzureTable\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<AzureTableStorage>(\"DataStorage\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"DataConnectionString\", dataConnection } }); config.Globals.RegisterStorageProvider<BlobStorageProvider>(\"BlobStorage\", new Dictionary<string, string> { { \"DeleteStateOnClear\", \"true\" }, { \"ContainerName\", \"grainstate\" }, { \"DataConnectionString\", dataConnection } }); // Add Stream Providers config.Globals.RegisterStreamProvider<AzureQueueStreamProvider>(\"AzureQueueStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" }, { \"DeploymentId\", \"orleans-streams\" }, { \"NumQueues\", \"4\" }, { \"GetQueueMessagesTimerPeriod\", \"100ms\" }, { \"DataConnectionString\", dataConnection } }); try { _orleansAzureSilo = new AzureSilo(); var ok = _orleansAzureSilo.Start(config, config.Globals.DeploymentId, config.Globals.DataConnectionString); _orleansAzureSilo.Run(); // Call will block until silo is shutdown } catch (Exception exc) { //Log \"Error when starting Silo\" }"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.html",
    "title": "Typical Configurations | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Typical Configurations Below are examples of typical configurations that can be used for development and production deployments. Local Development For local development, where there is only one silo running locally on the programmerâ€™s machine, the configuration is already included in the Orleans Dev/Test Host project template of Microsoft Orleans Tools for Visual Studio . The local silo that can be started by running a project created with the Orleans Dev/Test Host template is configured as follows in DevTestServerConfiguration.xml. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"localhost\" Port=\"11111\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Silo configuration via code is as follows. var config = ClusterConfiguration.LocalhostPrimarySilo(11111, 30000); To connect to the local silo, the client needs to be configured to localhost and can only connect from the same machine. The Orleans client that can be started by running a project created with the Orleans Dev/Test Host template is configured as follows in DevTestClientConfiguration.xml <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"localhost\" Port=\"30000\"/> </ClientConfiguration> Client configuration via code is as follows. var config = ClientConfiguration.LocalhostSilo(30000); Reliable Production Deployment Using Azure For a reliable production deployment using Azure, you need to use the Azure Table option for cluster membership. This configuration is typical of deployments to either on-premise servers or Azure virtual machine instances. The format of the DataConnection string is \"DefaultEndpointsProtocol=https;AccountName= ;AccountKey= \" <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"<your deployment ID>\" DataConnectionString=\"<<see comment above>>\" /> <Liveness LivenessType =\"AzureTable\" /> </Globals> <Defaults> <Networking Address=\"\" Port=\"11111\" /> <ProxyingGateway Address=\"\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Clients need to be configured to use Azure Table for discovering the gateways, the addresses of the Orleans servers are not statically known to the clients. <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"target deployment ID\" DataConnectionString=\"<<see comment above>>\" /> </ClientConfiguration> Reliable Production Deployment Using ZooKeeper For a reliable production deployment using ZooKeeper, you need to use the ZooKeeper option for cluster membership. This configuration is typical of deployments to on-premise servers. The format of the DataConnection string is documented in the ZooKeeper Programmer's Guide . A minimum of 5 ZooKeeper servers is recommended . <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"<your deployment ID>\" DataConnectionString=\"<<see comment above>>\"/> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"11111\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Clients need to be configured to use ZooKeeper for discovering the gateways, the addresses of the Orleans servers are not statically known to the clients. ï»¿<?xml version=\"1.0\" encoding=\"utf-8\" ?> <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"target deployment ID\" DataConnectionString=\"<<see comment above>>\"/> </ClientConfiguration> Reliable Production Deployment Using SQL Server For a reliable production deployment using SQL server, a SQL server connection string needs to be supplied. Silo configuration via code is as follows, and includes logging configuration. var connectionString = @\"Data Source=MSSQLDBServer;Initial Catalog=Orleans;Integrated Security=True; Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; var config = new ClusterConfiguration{ Globals = { DataConnectionString = connectionString, DeploymentId = \"<your deployment ID>\", LivenessType = GlobalConfiguration.LivenessProviderType.SqlServer, LivenessEnabled = true, ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.SqlServer }, Defaults = { Port = 11111, ProxyGatewayEndpoint = new IPEndPoint(address, 30000), PropagateActivityId = true }}; var siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); Clients need to be configured to use SQL server for discovering the gateways, as with Azure and Zookeeper, the addresses of the Orleans servers are not statically known to the clients. var connectionString = @\"Data Source=MSSQLDBServer;Initial Catalog=Orleans;Integrated Security=True; Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; var config = new ClientConfiguration{ GatewayProvider = ClientConfiguration.GatewayProviderType.SqlServer, AdoInvariant = \"System.Data.SqlClient\", DataConnectionString = connectionString, DeploymentId = \"<your deployment ID>\", PropagateActivityId = true }; var client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); Unreliable Deployment on a Cluster of Dedicated Servers For testing on a cluster of dedicated servers when reliability isnâ€™t a concern you can leverage MembershipTableGrain and avoid dependency on Azure Table. You just need to designate one of the nodes as a Primary. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SeedNode Address=\"<primary node>\" Port=\"11111\" /> <Liveness LivenessType =\"MembershipTableGrain\" /> </Globals> <Defaults> <Networking Address=\" \" Port=\"11111\" /> <ProxyingGateway Address=\" \" Port=\"30000\" /> </Defaults> </OrleansConfiguration> For the client: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"node-1\" Port=\"30000\"/> <Gateway Address=\"node-2\" Port=\"30000\"/> <Gateway Address=\"node-3\" Port=\"30000\"/> </ClientConfiguration> Azure Worker Role Deployment When Orleans is deployed into an Azure Worker role, as opposed to VM instances, most of the server-side configuration is actually done in files other than the OrleansConfiguration, which looks something like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Liveness LivenessType=\"AzureTable\" /> </Globals> <Defaults> <Tracing DefaultTraceLevel=\"Info\" TraceToConsole=\"true\" TraceToFile=\"{0}-{1}.log\" /> </Defaults> </OrleansConfiguration> Some information is kept in the service configuration file, in which the worker role section looks like this: <Role name=\"OrleansAzureSilos\"> <Instances count=\"2\" /> <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"<<see earlier comment>>\" /> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"<<see earlier comment>>\" /> </ConfigurationSettings> </Role> The data connection string and the diagnostics connection string do not have to be the same. Some configuration information is kept in the service definition file. The worker role has to be configured there, too: <WorkerRole name=\"OrleansAzureSilos\" vmsize=\"Large\"> <Imports> <Import moduleName=\"Diagnostics\" /> </Imports> <ConfigurationSettings> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <LocalResources> <LocalStorage name=\"LocalStoreDirectory\" cleanOnRoleRecycle=\"false\" /> </LocalResources> <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> </WorkerRole> That's it for the worker role hosting the Orleans runtime. However, when deploying to Azure, there is typically a front end of some sort, either a web site or a web service, since making the Orleans ports public is not a good idea. Therefore, the client configuration is configuration of the web or worker role (or web site) that sits in front of Orleans. Important Note As of November 2017, there is a limitation in Azure Cloud Services which prevents firewall configuration of InternalEndpoint s if there is only 1 role in the Cloud Service. If you are connecting to your cloud service via a Virtual Network, you will have to scale your Cloud Services to two instances in order for the firewall rules to be created Assuming that the frontend is a web role, a simple ClientConfiguration file should be used: <ClientConfiguration xmlns=\"urn:orleans\"> <Tracing DefaultTraceLevel=\"Info\" TraceToConsole=\"true\" TraceToFile=\"{0}-{1}.log\" WriteTraces=\"false\"/> </ClientConfiguration> The web role needs the same connection string information as the worker role, in the service configuration file: <Role name=\"WebRole\"> <Instances count=\"2\" /> <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"<<see earlier comment>>\" /> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"<<see earlier comment>>\" /> </ConfigurationSettings> </Role> and in the service definition file: <WebRole name=\"WebRole\" vmsize=\"Large\"> <Imports> <Import moduleName=\"Diagnostics\" /> </Imports> <ConfigurationSettings> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <!-- There is additional web role data that has nothing to do with Orleans --> </WebRole>"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html",
    "title": "SQL Tables | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . SQL System Storage Any reliable production-style Orleans deployment requires using persistent storage to keep system state, specifically Orleans cluster status and the data used for the reminders functionality. In addition to out of the box support for Azure storage Orleans also provides an option to store this information in SQL server. In order to use SQL server for the system store, one needs to adjust server-side and client-side configurations. The server configuration should look like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType =\"SqlServer\" DeploymentId=\"OrleansTest\" DataConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" AdoInvariant=\"System.Data.SqlClient\" /> </Globals> </OrleansConfiguration> The client configuration should look like this: <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType =\"SqlServer\" DeploymentId=\"OrleansTest\" DataConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" AdoInvariant=\"System.Data.SqlClient\" /> </ClientConfiguration> Where the DataConnectionString is set to any valid SQL Server connection string. In order to use SQL Server as the store for system data, thereâ€™s now a script file CreateOrleansTables_*.sql (where asterisk denotes database vendor) in the Binaries\\OrleansServer folder which establishes the necessary database objects. Make sure that all servers that will be hosting Orleans silos can reach the database and has access rights to it! Weâ€™ve tripped up a few times on this seemingly trivial concern during our testing. Note that in Orleans 2.0.0 those SQL scripts have been split into per-feature pieces to match the finer grain provider model: Clustering , Persistence , Reminders , and Statistics . SQL Metrics and Statistics tables System tables can currently only be stored in Azure table or SQL server. For Metrics and Statistics tables however, we provide a generic support to host it in any persistent storage. This is provided via the notion of a StatisticsProvider . Any application can write an arbitrary provider to store statistics and metrics data in a persistent store of their choice. Orleans provides an implemention of one such provider: SQL Table Statistics Provider. In order to use SQL server for statistics and metrics tables, one needs to adjust server-side and client-side configurations. The server configuration should look like this: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StatisticsProviders> <Provider Type=\"Orleans.Providers.SqlServer.SqlStatisticsPublisher\" Name=\"MySQLStatsProvider\" ConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" /> </StatisticsProviders> </Globals> <Defaults> <Statistics ProviderType=\"MySQLStatsProvider\" WriteLogStatisticsToTable=\"true\"/> </Defaults> </OrleansConfiguration> The client configuration should look like this: <ClientConfiguration xmlns=\"urn:orleans\"> <StatisticsProviders> <Provider Type=\"Orleans.Providers.SqlServer.SqlStatisticsPublisher\" Name=\"SQL\" ConnectionString=\"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\" /> </StatisticsProviders> <Statistics ProviderType=\"MySQLStatsProvider\" WriteLogStatisticsToTable=\"true\"/> </ClientConfiguration>"
  },
  "Tutorials/Declarative-Persistence.zh.html": {
    "href": "Tutorials/Declarative-Persistence.zh.html",
    "title": "Declarative Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å£°æ˜æ€§æŒä¹…åŒ– åœ¨ç¬¬äºŒä¸ªæ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†grain stateæ˜¯å¦‚ä½•åœ¨å®¢æˆ·ç«¯è¢«å…³é—­çš„æƒ…å†µä¸‹å¹¸å­˜ä¸‹æ¥çš„ï¼Œè¿™ä¸ºè®¸å¤šç±»ä¼¼ç¼“å­˜çš„åœºæ™¯æ‰“å¼€äº†å¤§é—¨ï¼Œåœ¨è¿™ç§åœºæ™¯ä¸­ï¼ŒOrleansè¢«è§†ä¸ºä¸€ç§â€œå¸¦æœ‰è¡Œä¸ºçš„ç¼“å­˜â€ï¼Œä¸€ç§é¢å‘å¯¹è±¡çš„ç¼“å­˜ï¼Œå¦‚æœä½ æ„¿æ„çš„è¯ã€‚è¿™å·²ç»æ˜¯éå¸¸æœ‰ä»·å€¼çš„äº†ï¼Œå¹¶ä¸”é€šè¿‡ä¸€ä¸ªç®€å•ã€ç†Ÿæ‚‰çš„ç¼–ç¨‹æ¨¡å‹å’Œå†…ç½®çš„å•çº¿ç¨‹æ‰§è¡Œä¿è¯æ¥å®ç°æœåŠ¡å™¨ç«¯çš„å¯ä¼¸ç¼©æ€§ã€‚ ä½†æ˜¯ï¼Œæœ‰æ—¶ï¼Œæ‚¨æ­£åœ¨ç´¯ç§¯çš„æŸäº›çŠ¶æ€å±äºæŸç§å½¢å¼çš„æ°¸ä¹…å­˜å‚¨ï¼Œå› æ­¤å®ƒå¯ä»¥åœ¨siloså…³é—­æˆ–ä»ä¸€ä¸ªsilosè¿ç§»åˆ°å¦ä¸€ä¸ªsilosä»¥å®ç°è´Ÿè½½å¹³è¡¡æˆ–æœåŠ¡å®Œå…¨é‡æ–°å¯åŠ¨/å…³æœºåç»§ç»­å­˜åœ¨ã€‚æˆ‘ä»¬è¿„ä»Šæ‰€çœ‹åˆ°çš„æƒ…å†µå°†ä¸æ”¯æŒè¿™ç§æƒ…å†µã€‚ å¹¸è¿çš„æ˜¯ï¼ŒOrleansæä¾›äº†ä¸€ä¸ªç®€å•çš„å£°æ˜æ€§æ¨¡å‹ï¼Œç”¨äºæ ‡è¯†éœ€è¦å­˜å‚¨åœ¨æ°¸ä¹…ä½ç½®çš„çŠ¶æ€ï¼ŒåŒæ—¶å°†ä½•æ—¶ä¿å­˜å’Œæ¢å¤çŠ¶æ€çš„å†³å®šæƒäº¤ç»™ç¼–ç¨‹æ§åˆ¶ã€‚æ‚¨ä¸éœ€è¦ä½¿ç”¨å£°æ˜æ€§æŒä¹…åŒ–æœºåˆ¶ï¼Œå¹¶ä¸”ä»ç„¶å¯ä»¥ç›´æ¥ä»grainä»£ç è®¿é—®å­˜å‚¨ï¼Œä½†è¿™æ˜¯ä¸€ç§å¾ˆå¥½çš„æ–¹æ³•ï¼Œå¯ä»¥ä¸ºæ‚¨èŠ‚çœä¸€äº›æ ·æ¿ä»£ç ï¼Œå¹¶æ„å»ºå¯è·¨å„ç§å­˜å‚¨æœåŠ¡ç§»æ¤çš„åº”ç”¨ç¨‹åºã€‚ å…¥é—¨ æˆ‘ä»¬å°†ç»§ç»­ä»¥æˆ‘ä»¬çš„å‘˜å·¥å’Œç»ç†æ ·æœ¬ä¸ºåŸºç¡€ã€‚ æˆ‘ä»¬éœ€è¦åšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯è®©æˆ‘ä»¬çš„å‘˜å·¥å’Œç®¡ç†è€…çš„èº«ä»½æ›´åŠ å¯é¢„æµ‹ã€‚åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œä½¿ç”¨ Guid.NewGuid() ï¼Œè¿™å¾ˆæ–¹ä¾¿ï¼Œä½†ä¸å…è®¸æˆ‘ä»¬åœ¨åç»­è¿è¡Œä¸­æ‰¾åˆ°å®ƒä»¬ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆåˆ›å»ºä¸€ç»„guidï¼Œç„¶åå°†å®ƒä»¬ç”¨ä½œå·¥ä½œè€…æ ‡è¯†ã€‚ ä¿®æ”¹åçš„å®¢æˆ·ç«¯ç¨‹åºå¦‚ä¸‹æ‰€ç¤ºï¼š private static async Task DoClientWork(IClusterClient client) { ... var ids = new string[] { \"42783519-d64e-44c9-9c29-399e3afaa625\", \"d694a4e0-1bc3-4c3f-a1ad-ba95103622bc\", \"9a72b0c6-33df-49db-ac05-14316edd332d\", \"6526a751-b9ac-4881-9bfb-836ecce2ca9f\", \"ae4b106f-3c96-464a-b48d-3583ed584b17\", \"b715c40f-d8d2-424d-9618-76afbc0a2a0a\", \"5ad92744-a0b1-487b-a9e7-e6b91e9a9826\", \"e23a55af-217c-4d76-8221-c2b447bf04c8\", \"2eef0ac5-540f-4421-b9a9-79d89400f7ab\" }; var e0 = client.GetGrain<IEmployee>(Guid.Parse(ids[0])); var e1 = client.GetGrain<IEmployee>(Guid.Parse(ids[1])); var e2 = client.GetGrain<IEmployee>(Guid.Parse(ids[2])); var e3 = client.GetGrain<IEmployee>(Guid.Parse(ids[3])); var e4 = client.GetGrain<IEmployee>(Guid.Parse(ids[4])); var m0 = client.GetGrain<IManager>(Guid.Parse(ids[5])); var m1 = client.GetGrain<IManager>(Guid.Parse(ids[6])); ... } æ³¨æ„ï¼šå¦‚æœæ‚¨ä»Orleans1.5è¿‡æ¸¡ï¼Œæ‚¨ä¼šæ³¨æ„åˆ°å®¢æˆ·ç«¯ä¸å†æ˜¯é™æ€çš„ã€‚è¯·å‚è€ƒ ä»Orleansè¿ç§»åˆ°0.5 ç¬¬é¡µã€‚ ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†è¿›è¡Œä¸€äº›silosé…ç½®ï¼Œä»¥ä¾¿é…ç½®å°†å…è®¸æˆ‘ä»¬è®¿é—®æŒä¹…å­˜å‚¨çš„å­˜å‚¨æä¾›ç¨‹åºã€‚SiloHosté¡¹ç›®åŒ…æ‹¬ä¸€ä¸ªæ–‡ä»¶ ç¨‹åº.cs æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ä»¥ä¸‹éƒ¨åˆ†ï¼š var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; å¦‚æœè¿™æ˜¯æ‰˜ç®¡åœ¨Azureäº‘æœåŠ¡ä¸­ï¼Œåˆ™å¯ä»¥åœ¨è°ƒç”¨ä¹‹å‰ä½¿ç”¨ä»¥ä¸‹ä»»ä¸€é€‰é¡¹ å»ºé€ è€…ã€‚å»ºé€ è€…() è¦ä½¿ç”¨Azureæ¥ä¿æŒgrainsçŠ¶æ€ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š // Stores grains as composition of fields builder.AddAzureTableGrainStorage(option => option.ConnectionString = your_connection_string); // Stores grains as blobs builder.AddAzureBlobGrainStorage(option => option.ConnectionString = your_connection_string); è¿™ä¸ª è®°å¿†åº“ providerç›¸å½“æ— è¶£ï¼Œå› ä¸ºå®ƒå®é™…ä¸Šä¸æä¾›ä»»ä½•æ°¸ä¹…å­˜å‚¨ï¼›å®ƒçš„ç›®çš„æ˜¯è°ƒè¯•æŒä¹…åŒ–grainsï¼Œè€Œä¸èƒ½è®¿é—®æŒä¹…åŒ–å­˜å‚¨ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™ä½¿å¾—å¾ˆéš¾è¯æ˜æŒä¹…åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä¾èµ–äºä¸€ä¸ªçœŸæ­£çš„å­˜å‚¨æä¾›è€…ã€‚ æ ¹æ®æ‚¨æ˜¯å¦å·²ç»è®¾ç½®(å¹¶å¸Œæœ›ä½¿ç”¨)Azureå­˜å‚¨å¸æˆ·ï¼Œè¿˜æ˜¯å¸Œæœ›ä¾èµ–Azureå­˜å‚¨ä»¿çœŸç¨‹åºï¼Œæ‚¨åº”è¯¥æ·»åŠ å…¶ä»–ä¸¤è¡Œä¸­çš„ä¸€è¡Œï¼Œä½†ä¸èƒ½åŒæ—¶æ·»åŠ è¿™ä¸¤è¡Œã€‚æ‚¨å¯ä»¥ä½¿ç”¨ AddAzureTableStorageæä¾›ç¨‹åº() å‡½æ•°æˆ– AddAzureBlobStorageProvider() å‡½æ•°å–å†³äºæ‚¨å¸Œæœ›å¦‚ä½•å­˜å‚¨ä¿¡æ¯ã€‚ å¯¹äºå‰è€…ï¼Œæ‚¨å¿…é¡»åœ¨å®‰è£…æœ€æ–°ç‰ˆæœ¬çš„azuresdkä¹‹åå¯åŠ¨Azureå­˜å‚¨ä»¿çœŸå™¨ã€‚å¯¹äºåè€…ï¼Œæ‚¨å¿…é¡»åˆ›å»ºä¸€ä¸ªAzureå­˜å‚¨å¸æˆ·ï¼Œå¹¶åœ¨é…ç½®æ–‡ä»¶ä¸­è¾“å…¥åç§°å’Œå¯†é’¥ã€‚ å¯ç”¨å…¶ä¸­ä¸€ä¸ªï¼Œæˆ‘ä»¬å°±å¯ä»¥å¤„ç†grainä»£ç äº†ã€‚ æ³¨æ„ï¼šåœ¨Orleans 2.0ä¸­ï¼Œè®¸å¤šåŠŸèƒ½è¢«æ‹†åˆ†æˆæ›´å°çš„åŒ…ï¼Œä»¥å…è®¸æ›´ç»†Grainçš„é…ç½®å’Œéƒ¨ç½²ã€‚è¿™åŒ…æ‹¬Azureå­˜å‚¨æä¾›ç¨‹åºã€‚è¯·å®‰è£… OrleansæŒä¹…åŒ– å¦‚æœè¦å°†Azureç”¨ä½œå­˜å‚¨æä¾›ç¨‹åºï¼Œè¯·æ‰“åŒ…ã€‚æ‚¨å¯ä»¥é€šè¿‡ å¯»æ‰¾Orleansã€‚åšæŒ . ç”³æŠ¥å›½ ç¡®å®šgrainsåº”ä½¿ç”¨æŒä¹…çŠ¶æ€éœ€è¦ä¸‰ä¸ªæ­¥éª¤ï¼š ä¸ºå·å£°æ˜ä¸€ä¸ªç±»ï¼Œ æ”¹å˜GrainsåŸºç±»ï¼Œä»¥åŠ æ­£åœ¨æ ‡è¯†å­˜å‚¨æä¾›ç¨‹åºã€‚ ç¬¬ä¸€æ­¥ï¼Œåœ¨grainå®ç°é¡¹ç›®ä¸­å£°æ˜ä¸€ä¸ªstateç±»ï¼Œåªæ„å‘³ç€æ ‡è¯†åº”è¯¥æŒä¹…åŒ–çš„å‚ä¸è€…çš„ä¿¡æ¯ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªçœ‹èµ·æ¥åƒæŒä¹…æ•°æ®è®°å½•çš„å†…å®¹â€”â€”æ¯ä¸ªçŠ¶æ€ç»„ä»¶éƒ½ç”±ä¸€ä¸ªå¸¦æœ‰getterå’Œsetterçš„å±æ€§è¡¨ç¤ºã€‚ å¯¹äºå‘˜å·¥ï¼Œæˆ‘ä»¬å¸Œæœ›ä¿æŒæ‰€æœ‰çŠ¶æ€ï¼š public class EmployeeState { public int Level { get; set; } public IManager Manager { get; set; } } å¯¹äºç»ç†æ¥è¯´ï¼Œæˆ‘ä»¬å¿…é¡»å­˜å‚¨ç›´æ¥ä¸‹å±ï¼Œä½†æ˜¯ _æˆ‘ åœ¨æ¿€æ´»æœŸé—´å¯èƒ½ä¼šç»§ç»­åˆ›å»ºå¼•ç”¨ã€‚ public class ManagerState { public List<IEmployee> Reports { get; set; } } ç„¶åï¼Œæˆ‘ä»¬æ›´æ”¹grainç±»å£°æ˜ä»¥æ ‡è¯†çŠ¶æ€æ¥å£(ä¾‹å¦‚ï¼Œä» Orleansã€‚Grains åˆ° Orleansã€‚Grains<EmployeeState> )å¹¶åˆ é™¤æˆ‘ä»¬æƒ³è¦æŒä¹…åŒ–çš„å˜é‡ã€‚ç¡®ä¿ç§»é™¤ æ°´å¹³ ï¼Œå’Œ ç»ç† ä» é›‡å‘˜ ç±»å’Œ _æŠ¥å‘Š ä» ç»ç† ç­çº§ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»æ›´æ–°è¿™äº›åŠŸèƒ½ã€‚ æˆ‘ä»¬è¿˜æ·»åŠ äº†ä¸€ä¸ªå±æ€§æ¥æ ‡è¯†å­˜å‚¨æä¾›ç¨‹åºï¼š [StorageProvider(ProviderName = \"AzureStore\")] public class Employee : Orleans.Grain<EmployeeState>, Interfaces.IEmployee å’Œ [StorageProvider(ProviderName=\"AzureStore\")] public class Manager : Orleans.Grain<ManagerState>, IManager åœ¨å£°æ˜æ˜¾è€Œæ˜“è§çš„é£é™©ä¸‹ï¼Œå­˜å‚¨æä¾›ç¨‹åºå±æ€§çš„åç§°åº”è¯¥ä¸é…ç½®silosæ—¶ä½¿ç”¨çš„åç§°ç›¸åŒ¹é…ã€‚è¿™ç§é—´æ¥æ€§ä½¿æ‚¨èƒ½å¤Ÿåœ¨éƒ¨ç½²ä¹‹å‰å»¶è¿Ÿå…³äºåœ¨å“ªé‡Œå­˜å‚¨GrainçŠ¶æ€çš„é€‰æ‹©ã€‚ è€ƒè™‘åˆ°è¿™äº›å£°æ˜æ€§çš„æ›´æ”¹ï¼Œgrainä¸åº”è¯¥å†ä¾èµ–ç§æœ‰å­—æ®µæ¥ä¿æŒè¡¥å¿çº§åˆ«å’Œç®¡ç†å™¨ã€‚ç›¸åï¼ŒgrainåŸºç±»è®©æˆ‘ä»¬é€šè¿‡ State å¯ç”¨äºGrainsçš„å±æ€§ã€‚ ä¾‹å¦‚ï¼š public Task SetManager(IManager manager) { State.Manager = manager; return TaskDone.Done; } æ§åˆ¶æ£€æŸ¥ç‚¹ å‰©ä¸‹çš„é—®é¢˜æ˜¯æŒä¹…çŠ¶æ€ä½•æ—¶ä¿å­˜åˆ°å­˜å‚¨æä¾›ç¨‹åºã€‚ Orleansè®¾è®¡äººå‘˜å¯ä»¥åšå‡ºçš„ä¸€ä¸ªé€‰æ‹©æ˜¯åœ¨æ¯æ¬¡æ–¹æ³•è°ƒç”¨åéƒ½è®¾ç½®è¿è¡Œæ—¶ä¿å­˜çŠ¶æ€ï¼Œä½†ç»“æœè¯æ˜è¿™æ˜¯ä¸å¯å–çš„ï¼Œå› ä¸ºå®ƒè¿‡äºä¿å®ˆâ€”â€”å¹¶éæ‰€æœ‰è°ƒç”¨éƒ½ä¼šä¿®æ”¹æ‰€æœ‰è°ƒç”¨çš„çŠ¶æ€ï¼Œè€Œä¸”æœ‰äº›è°ƒç”¨æ°¸è¿œä¸ä¼šä¿®æ”¹å®ƒã€‚Orleansæ²¡æœ‰åœ¨æ¯ä¸ªæ–¹æ³•ä¹‹åä½¿ç”¨å¤æ‚çš„ç³»ç»Ÿæ¥è¯„ä¼°çŠ¶æ€å·®å¼‚ï¼Œè€Œæ˜¯è¦æ±‚grainå¼€å‘äººå‘˜æ·»åŠ å¿…è¦çš„é€»è¾‘æ¥ç¡®å®šæ˜¯å¦éœ€è¦ä¿å­˜çŠ¶æ€ã€‚ ä½¿ç”¨å­˜å‚¨æä¾›ç¨‹åºä¿å­˜çŠ¶æ€å¾ˆå®¹æ˜“é€šè¿‡è°ƒç”¨ base.WriteStateAsync() . å› æ­¤ï¼Œæœ€ç»ˆç‰ˆæœ¬çš„ æå‡() å’Œ è®¾ç½®ç®¡ç†å™¨() æ–¹æ³•å¦‚ä¸‹ï¼š public Task Promote(int newLevel) { State.Level = newLevel; return base.WriteStateAsync(); } public Task SetManager(IManager manager) { State.Manager = manager; return base.WriteStateAsync(); } åœ¨ ç»ç† ç±»ï¼Œåªæœ‰ä¸€ä¸ªæ–¹æ³•éœ€è¦ä¿®æ”¹æ‰èƒ½å†™å‡ºæ•°æ®ï¼Œ AddDirectReport() . åº”è¯¥æ˜¯è¿™æ ·çš„ï¼š public async Task AddDirectReport(IEmployee employee) { if (State.Reports == null) { State.Reports = new List<IEmployee>(); } State.Reports.Add(employee); await employee.SetManager(this); var data = new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }; await employee.Greeting(data); Console.WriteLine(\"{0} said: {1}\", data.From.ToString(), data.Message); await base.WriteStateAsync(); } è®©æˆ‘ä»¬è¯•è¯•è¿™ä¸ªï¼ åœ¨ä¸­è®¾ç½®æ–­ç‚¹ å‘˜å·¥ã€‚æ™‹å‡() . å½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡è¿è¡Œå®¢æˆ·ç«¯ä»£ç å¹¶åˆ°è¾¾æ–­ç‚¹æ—¶ï¼Œlevelå­—æ®µåº”è¯¥æ˜¯ 0 ä»¥åŠnewLevelå‚æ•° 10 æˆ– 11 : ![](../Images/Persistence 2.PNG) è®©åº”ç”¨ç¨‹åºå®Œæˆ(åˆ°è¾¾â€œç‚¹å‡»å›è½¦â€¦â€æç¤ºç¬¦)å¹¶é€€å‡ºã€‚å†æ¬¡è¿è¡Œå®ƒï¼Œå¹¶æ¯”è¾ƒç¬¬äºŒæ¬¡æŸ¥çœ‹çŠ¶æ€æ—¶å‘ç”Ÿçš„æƒ…å†µï¼š ![](../Images/Persistence 3.PNG) åªæ˜¯ç¡®ä¿ã€‚ã€‚ã€‚ å€¼å¾—æ£€æŸ¥ä¸€ä¸‹Azureå¯¹æ•°æ®çš„çœ‹æ³•ã€‚ä½¿ç”¨å­˜å‚¨èµ„æºç®¡ç†å™¨(å¦‚Azureå­˜å‚¨èµ„æºç®¡ç†å™¨(ASE)æˆ–Visual Studio 2013ä¸­å†…ç½®çš„æœåŠ¡å™¨èµ„æºç®¡ç†å™¨)ï¼Œæ‰“å¼€å­˜å‚¨å¸æˆ·(æˆ–æ¨¡æ‹Ÿå™¨çš„å¼€å‘äººå‘˜å­˜å‚¨)å¹¶æ‰¾åˆ°â€œOrleansGrainStateâ€è¡¨ã€‚å®ƒåº”è¯¥æ˜¯è¿™æ ·çš„(ä½ å¿…é¡»åœ¨ASEä¸­ç‚¹å‡»'Query'ï¼š ![](../Images/Persistence 4.PNG) å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œåˆ™çº¹ç†é”®åº”è¯¥å‡ºç°åœ¨ åˆ†åŒºé”® åˆ—ä¸­ï¼Œå¹¶ä¸”grainsçš„é™å®šç±»ååº”å‡ºç°åœ¨ è¡Œé”® åˆ—ã€‚ æ··åˆçš„ä¸œè¥¿ grainså¯èƒ½åŒ…å«æŒä¹…çŠ¶æ€å’Œç¬æ€çŠ¶æ€çš„ç»„åˆã€‚ä»»ä½•ç¬æ€éƒ½åº”è¯¥ç”¨grainç±»ä¸­çš„ç§æœ‰å­—æ®µæ¥è¡¨ç¤ºã€‚æ··åˆä½¿ç”¨è¿™ä¸¤è€…çš„ä¸€ä¸ªå¸¸è§ç”¨é€”æ˜¯ï¼Œå½“æŒä¹…åŒ–çŠ¶æ€å­˜åœ¨äºå†…å­˜ä¸­æ—¶ï¼Œå°†å®ƒçš„æŸäº›è®¡ç®—ç‰ˆæœ¬ç¼“å­˜åˆ°ç§æœ‰å­—æ®µä¸­ã€‚ä¾‹å¦‚ï¼Œä¸€å †å…ƒç´ å¯ä»¥å¤–éƒ¨è¡¨ç¤ºä¸º åˆ—è¡¨<T> ï¼Œä½†åœ¨å†…éƒ¨ï¼Œä½œä¸º å †æ ˆ<T> . å¦‚æœæˆ‘ä»¬ ç»ç† åŒå­¦ä»¬ _æˆ‘ fieldåªæ˜¯ä¸€ä¸ªç¼“å­˜çš„å€¼ï¼Œä¸€å¼€å§‹æˆ‘ä»¬ç”šè‡³ä¸éœ€è¦å°†å…¶ä½œä¸ºå­—æ®µä¿å­˜ï¼Œå®ƒå¯ä»¥åœ¨ä»»ä½•éœ€è¦å®ƒçš„æ—¶å€™åˆ›å»ºï¼Œä½†æ˜¯ç”±äºå®ƒå°†æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å€¼ï¼Œæ‰€ä»¥å€¼å¾—å°†å®ƒä¿å­˜åœ¨ä¸€ä¸ªä¸´æ—¶å­—æ®µä¸­ã€‚ çŠ¶æ€è‡ªåŠ¨åŠ è½½ å¦‚æœGrainsç±»å‹å…·æœ‰çŠ¶æ€ï¼Œåˆ™åœ¨æ¿€æ´»æ—¶è¯¥çŠ¶æ€å°†ä»å­˜å‚¨ä¸­åŠ è½½ï¼Œç„¶å éæ¿€æ´»å¼‚æ­¥ è°ƒç”¨ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥ç¡®ä¿åœ¨åˆå§‹åŒ–Grainsæ—¶åŠ è½½äº†çŠ¶æ€ã€‚è¿™æ˜¯Orleanså”¯ä¸€è°ƒç”¨æ¥çš„æ¡ˆå­ è¯»çŠ¶æ€å¼‚æ­¥ è‡ªåŠ¨åœ°ã€‚å¦‚æœä½ æƒ³å†™å·æˆ–åœ¨å…¶ä»–åœ°æ–¹è¯»ï¼Œä½ åº”è¯¥è‡ªå·±å†™ã€‚é€šå¸¸ä½ ä¸éœ€è¦è°ƒç”¨ è¯»çŠ¶æ€å¼‚æ­¥ ä½ è‡ªå·±ï¼Œé™¤éä½ æ­£åœ¨åšä¸€äº›å…³äºå¤„ç†æŸåçŠ¶æ€æˆ–å…¶ä»–äº‹æƒ…çš„å…·ä½“äº‹æƒ…ã€‚ ä½¿ç”¨æŒä¹…åŒ–å¤„ç†æ•…éšœ ä¸€èˆ¬æ¥è¯´ï¼Œè¯»å†™Grainsçš„çŠ¶æ€æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æœºåˆ¶æ¥å¤„ç†å¤±è´¥å’ŒæœåŠ¡äºå®ƒçš„åˆè¡·ã€‚ç”±äºä¸åŒçš„åŸå› ï¼Œgrainè°ƒç”¨å¯èƒ½ä¼šåœ¨æ–¹æ³•çš„ä¸­é—´å¤±è´¥ï¼Œæœ€ç»ˆå¯¼è‡´çŠ¶æ€æ›´æ”¹ä¸€åŠã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä»å­˜å‚¨å™¨ä¸­è¯»å–å¯ä»¥å°†çŠ¶æ€è¿”å›åˆ°ä¸Šä¸€ä¸ªæ­£ç¡®çš„çŠ¶æ€ã€‚æˆ–è€…ï¼Œè¿›å…¥è¿™ç§çŠ¶æ€åï¼Œgrainå¯ä»¥é€šè¿‡è°ƒç”¨DeactivateOnIdle()è¯·æ±‚ç«‹å³åœç”¨ï¼Œè¿™æ ·å®ƒçš„ä¸‹ä¸€ä¸ªè¯·æ±‚å°†è§¦å‘grainçš„é‡æ–°æ¿€æ´»ï¼Œè¿™å°†é‡æ–°è¯»å–æŒä¹…çŠ¶æ€å¹¶é‡å»ºå…¶åœ¨å†…å­˜ä¸­çš„å‰¯æœ¬ã€‚åœç”¨æ˜¯å°†grainsé‡ç½®ä¸ºå…¶æœ€åå·²çŸ¥è‰¯å¥½çŠ¶æ€çš„æœ€å¹²å‡€çš„æ–¹æ³•ï¼Œä½†æ˜¯å¦‚æœè¦é¿å…é‡æ–°æ¿€æ´»è¿‡ç¨‹çš„æˆæœ¬ï¼Œå¯ä»¥é‡ç½®å…¶çŠ¶æ€å¹¶é‡æ–°è¿è¡Œä»»ä½•åˆå§‹åŒ–é€»è¾‘(ä¾‹å¦‚ï¼Œé€šè¿‡è°ƒç”¨ éæ¿€æ´»å¼‚æ­¥ )è€Œä¸æ˜¯ä½¿Grainså¤±æ´»ã€‚ ä¸‹ä¸€ä¸ª æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†äº†è§£å¦‚ä½•ä»mvcwebåº”ç”¨ç¨‹åºè°ƒç”¨grainsã€‚ å¤„ç†å¤±è´¥"
  },
  "Tutorials/Custom-Grain-Storage.zh.html": {
    "href": "Tutorials/Custom-Grain-Storage.zh.html",
    "title": "Custom Grain Storage | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è‡ªå®šä¹‰Grainså­˜å‚¨ ç¼–å†™è‡ªå®šä¹‰Grainså­˜å‚¨ åœ¨æœ‰å…³å£°æ˜æ€§å‚ä¸è€…å­˜å‚¨çš„æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†å…è®¸Grainsä½¿ç”¨å†…ç½®å­˜å‚¨æä¾›ç¨‹åºä¹‹ä¸€å°†å…¶çŠ¶æ€å­˜å‚¨åœ¨Azureè¡¨ä¸­ã€‚å°½ç®¡Azureæ˜¯æ¾æ•£æ•°æ®çš„å¥½åœ°æ–¹ï¼Œä½†è¿˜æœ‰è®¸å¤šæ›¿ä»£æ–¹æ³•ã€‚å®é™…ä¸Šï¼Œæœ‰å¤ªå¤šçš„äººæ— æ³•æ”¯æŒæ‰€æœ‰äººã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼ŒOrleansæ—¨åœ¨è®©æ‚¨é€šè¿‡ç¼–å†™Grainså­˜å‚¨æ¥è½»æ¾æ·»åŠ å¯¹æ‚¨è‡ªå·±çš„å­˜å‚¨å½¢å¼çš„æ”¯æŒã€‚ åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†é€æ­¥ä»‹ç»å¦‚ä½•ç¼–å†™åŸºäºæ–‡ä»¶çš„ç®€å•Grainså­˜å‚¨ã€‚æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯å­˜å‚¨GrainsçŠ¶æ€çš„æœ€ä½³ä½ç½®ï¼Œå› ä¸ºå®ƒæ˜¯æœ¬åœ°çš„ï¼Œæ–‡ä»¶é”å¯èƒ½å­˜åœ¨é—®é¢˜ï¼Œå¹¶ä¸”æœ€åæ›´æ–°æ—¥æœŸä¸è¶³ä»¥é˜²æ­¢ä¸ä¸€è‡´ã€‚ä½†è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬è¯´æ˜ Grainså‚¨å­˜ ã€‚ å…¥é—¨ OrleansGrainsä»“åº“æ˜¯å®ç° IGrainå­˜å‚¨ åŒ…å«åœ¨å…¶ä¸­ Microsoft.Orleans.Core NuGetç¨‹åºåŒ… ã€‚ æˆ‘ä»¬ä¹Ÿä» ILifecycleParticipant <ISiloLifecycle> è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿè®¢é˜…å­¤å²›ç”Ÿå‘½å‘¨æœŸä¸­çš„ç‰¹å®šäº‹ä»¶ã€‚ æˆ‘ä»¬é¦–å…ˆåˆ›å»ºä¸€ä¸ªåä¸º FileGrainStorage ã€‚ using Orleans; using System; using Orleans.Storage; using Orleans.Runtime; using System.Threading.Tasks; namespace GrainStorage { public class FileGrainStorage : IGrainStorage, ILifecycleParticipant<ISiloLifecycle> { private readonly string _storageName; private readonly FileGrainStorageOptions _options; private readonly ClusterOptions _clusterOptions; private readonly IGrainFactory _grainFactory; private readonly ITypeResolver _typeResolver; private JsonSerializerSettings _jsonSettings; public FileGrainStorage(string storageName, FileGrainStorageOptions options, IOptions<ClusterOptions> clusterOptions, IGrainFactory grainFactory, ITypeResolver typeResolver) { _storageName = storageName; _options = options; _clusterOptions = clusterOptions.Value; _grainFactory = grainFactory; _typeResolver = typeResolver; } public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } } } åœ¨å¼€å§‹å®æ–½ä¹‹å‰ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªåŒ…å«æ ¹ç›®å½•çš„é€‰é¡¹ç±»ï¼ŒGrainsçŠ¶æ€æ–‡ä»¶å°†å­˜å‚¨åœ¨è¯¥ç›®å½•ä¸‹ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªé€‰é¡¹æ–‡ä»¶ FileGrainStorageOptions ï¼š public class FileGrainStorageOptions { public string RootDirectory { get; set; } } åˆ›å»ºä¸€ä¸ªåŒ…å«ä¸¤ä¸ªå­—æ®µçš„æ„é€ å‡½æ•°ï¼Œ storageName æŒ‡å®šä½¿ç”¨æ­¤å­˜å‚¨åº”è¯¥å†™å…¥å“ªäº›çº¹ç† [StorageProvider(ProviderName =â€œæ–‡ä»¶â€)] å’Œ ç›®å½• è¿™å°†æ˜¯ä¿å­˜grainsçŠ¶æ€çš„ç›®å½•ã€‚ IGrainå·¥å‚ ï¼Œ ITypeResolver å°†åœ¨ä¸‹ä¸€éƒ¨åˆ†ä¸­ä½¿ç”¨ï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä¸­åˆå§‹åŒ–å­˜å‚¨ã€‚ æˆ‘ä»¬ä¹Ÿæœ‰ä¸¤ä¸ªé€‰æ‹©ï¼Œæˆ‘ä»¬è‡ªå·± FileGrainStorageOptions å’Œ é›†ç¾¤é€‰é¡¹ ã€‚å®ç°å­˜å‚¨åŠŸèƒ½å°†éœ€è¦è¿™äº›ã€‚ æˆ‘ä»¬è¿˜éœ€è¦ JsonSerializerSettings å› ä¸ºæˆ‘ä»¬æ­£åœ¨ä»¥Jsonæ ¼å¼è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ Jsonæ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼Œç”±å¼€å‘äººå‘˜å†³å®šå“ªç§ä¸²è¡ŒåŒ–/ååºåˆ—åŒ–åè®®é€‚åˆè¯¥åº”ç”¨ç¨‹åºã€‚å¦ä¸€ç§å¸¸è§æ ¼å¼æ˜¯äºŒè¿›åˆ¶æ ¼å¼ã€‚ åˆå§‹åŒ–å­˜å‚¨ è¦åˆå§‹åŒ–å­˜å‚¨ï¼Œæˆ‘ä»¬æ³¨å†Œä¸€ä¸ª åœ¨é‡Œé¢ åŠŸèƒ½ä¸Š åº”ç”¨æœåŠ¡ ç”Ÿå‘½å‘¨æœŸã€‚ public void Participate(ISiloLifecycle lifecycle) { lifecycle.Subscribe(OptionFormattingUtilities.Name<FileGrainStorage>(_storageName), ServiceLifecycleStage.ApplicationServices, Init); } çš„ åœ¨é‡Œé¢ åŠŸèƒ½ç”¨äºè®¾ç½® _jsonSettings å°†ç”¨äºé…ç½® Json åºåˆ—åŒ–å™¨ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬åˆ›å»ºæ–‡ä»¶å¤¹æ¥å­˜å‚¨grainsçŠ¶æ€(å¦‚æœå°šä¸å­˜åœ¨)ã€‚ private Task Init(CancellationToken ct) { // Settings could be made configurable from Options. _jsonSettings = OrleansJsonSerializer.UpdateSerializerSettings(OrleansJsonSerializer.GetDefaultSerializerSettings(_typeResolver, _grainFactory), false, false, null); var directory = new System.IO.DirectoryInfo(_rootDirectory); if (!directory.Exists) directory.Create(); return Task.CompletedTask; } æˆ‘ä»¬è¿˜æä¾›äº†ä¸€ä¸ªé€šç”¨å‡½æ•°æ¥æ„é€ æ–‡ä»¶åï¼Œä»¥ç¡®ä¿æ¯ä¸ªæœåŠ¡ï¼ŒGrainIDå’ŒGrainç±»å‹çš„å”¯ä¸€æ€§ã€‚ private string GetKeyString(string grainType, GrainReference grainReference) { return $\"{_clusterOptions.ServiceId}.{grainReference.ToKeyString()}.{grainType}\"; } é˜…è¯»çŠ¶æ€ è¦è¯»å–grainsçŠ¶æ€ï¼Œæˆ‘ä»¬ä½¿ç”¨å…ˆå‰å®šä¹‰çš„å‡½æ•°è·å–æ–‡ä»¶åï¼Œå¹¶å°†å…¶ç»„åˆåˆ°æ¥è‡ªé€‰é¡¹çš„æ ¹ç›®å½•ä¸­ã€‚ public async Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (!fileInfo.Exists) { grainState.State = Activator.CreateInstance(grainState.State.GetType()); return; } using (var stream = fileInfo.OpenText()) { var storedData = await stream.ReadToEndAsync(); grainState.State = JsonConvert.DeserializeObject(storedData, _jsonSettings); } grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } æˆ‘ä»¬ä½¿ç”¨ fileInfo.LastWriteTimeUtc ä½œä¸ºETagï¼Œå…¶ä»–åŠŸèƒ½å°†ä½¿ç”¨è¯¥ETagè¿›è¡Œä¸ä¸€è‡´æ£€æŸ¥ä»¥é˜²æ­¢æ•°æ®ä¸¢å¤±ã€‚ è¯·æ³¨æ„ï¼Œå¯¹äºååºåˆ—åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨ _jsonSettings è¿™æ˜¯åœ¨ åœ¨é‡Œé¢ åŠŸèƒ½ã€‚è¿™å¯¹äºèƒ½å¤Ÿæ­£ç¡®åœ°åºåˆ—åŒ–/ååºåˆ—åŒ–çŠ¶æ€å¾ˆé‡è¦ã€‚ å†™ä½œçŠ¶æ€ å†™å…¥çŠ¶æ€ç±»ä¼¼äºè¯»å–çŠ¶æ€ã€‚ public async Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings); var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists && fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (WriteState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } using (var stream = new StreamWriter(fileInfo.Open(FileMode.Create, FileAccess.Write))) { await stream.WriteAsync(storedData); } fileInfo.Refresh(); grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } ä¸é˜…è¯»ç±»ä¼¼ï¼Œæˆ‘ä»¬ä½¿ç”¨ _jsonSettings å†™çŠ¶æ€ã€‚å½“å‰çš„ETagç”¨äºæ£€æŸ¥æ–‡ä»¶çš„UTCä¸­çš„æœ€åæ›´æ–°æ—¶é—´ã€‚å¦‚æœæ—¥æœŸä¸åŒï¼Œåˆ™æ„å‘³ç€åŒä¸€ç²’Grainsçš„å¦ä¸€æ¬¡æ¿€æ´»ä¼šåŒæ—¶æ›´æ”¹çŠ¶æ€ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°† InconsistentStateException è¿™å°†å¯¼è‡´å½“å‰æ¿€æ´»è¢«æ€æ­»ï¼Œä»¥é˜²æ­¢è¦†ç›–å…ˆå‰ç”±å…¶ä»–æ¿€æ´»grainsä¿å­˜çš„çŠ¶æ€ã€‚ æ¸…ç®—å›½ å¦‚æœæ–‡ä»¶å­˜åœ¨ï¼Œåˆ™æ¸…é™¤çŠ¶æ€å°†åˆ é™¤è¯¥æ–‡ä»¶ã€‚ public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists) { if (fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (ClearState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } grainState.ETag = null; grainState.State = Activator.CreateInstance(grainState.State.GetType()); fileInfo.Delete(); } return Task.CompletedTask; } å‡ºäºåŒæ ·çš„åŸå›  å†™çŠ¶æ€ ï¼Œæˆ‘ä»¬åœ¨ç»§ç»­åˆ é™¤æ–‡ä»¶å¹¶é‡ç½®ETagä¹‹å‰æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸ä¸€è‡´ï¼Œå¹¶æ£€æŸ¥å½“å‰ETagæ˜¯å¦ä¸ä¸Šæ¬¡å†™å…¥æ—¶é—´UTCç›¸åŒã€‚ æŠŠå®ƒæ”¾åœ¨ä¸€èµ· ä¹‹åï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå·¥å‚ï¼Œè¯¥å·¥å‚å°†ä½¿æˆ‘ä»¬å¯ä»¥å°†é€‰é¡¹è®¾ç½®çš„èŒƒå›´é™å®šåœ¨æä¾›ç¨‹åºåç§°ä¸Šï¼ŒåŒæ—¶åˆ›å»ºä¸€ä¸ªå®ä¾‹ã€‚ FileGrainStorage ç®€åŒ–å‘æœåŠ¡é›†åˆçš„æ³¨å†Œã€‚ public static class FileGrainStorageFactory { internal static IGrainStorage Create(IServiceProvider services, string name) { IOptionsSnapshot<FileGrainStorageOptions> optionsSnapshot = services.GetRequiredService<IOptionsSnapshot<FileGrainStorageOptions>>(); return ActivatorUtilities.CreateInstance<FileGrainStorage>(services, name, optionsSnapshot.Get(name), services.GetProviderClusterOptions(name)); } } æœ€åï¼Œè¦æ³¨å†ŒGrainså‚¨å­˜åº“ï¼Œæˆ‘ä»¬åœ¨ ISiloHostBuilder åœ¨å†…éƒ¨ä½¿ç”¨ä»¥ä¸‹æ–¹å¼å°†Grainså­˜å‚¨æ³¨å†Œä¸ºå‘½åæœåŠ¡ .AddSingletonNamedService(...) ï¼Œç”±æä¾›çš„æ‰©å±• Orleans ã€‚ public static class FileSiloBuilderExtensions { public static ISiloHostBuilder AddFileGrainStorage(this ISiloHostBuilder builder, string providerName, Action<FileGrainStorageOptions> options) { return builder.ConfigureServices(services => services.AddFileGrainStorage(providerName, options)); } public static IServiceCollection AddFileGrainStorage(this IServiceCollection services, string providerName, Action<FileGrainStorageOptions> options) { services.AddOptions<FileGrainStorageOptions>(providerName).Configure(options); return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); } } æˆ‘ä»¬çš„ FileGrainStorage å®ç°ä¸¤ä¸ªæ¥å£ï¼Œ IGrainå­˜å‚¨ å’Œ ILifecycleParticipant <ISiloLifecycle> å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºæ¯ä¸ªæ¥å£æ³¨å†Œä¸¤ä¸ªå‘½åæœåŠ¡ï¼š return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨æ‰©å±•åæ·»åŠ æ–‡ä»¶å­˜å‚¨ã€‚ ISiloHostBuilder ï¼š var silo = new SiloHostBuilder() .UseLocalhostClustering() .AddFileGrainStorage(\"File\", opts => { opts.RootDirectory = \"C:/TestFiles\"; }) .Build(); ç°åœ¨ï¼Œæˆ‘ä»¬å°†å¯ä»¥ä¸ä¾›åº”å•†ä¸€èµ·è£…é¥°Grains [StorageProvider(ProviderName =â€œæ–‡ä»¶â€)] å®ƒå°†ä»¥è°·Grainæ€å­˜å‚¨åœ¨é€‰é¡¹ä¸­è®¾ç½®çš„æ ¹ç›®å½•ä¸­ã€‚"
  },
  "Documentation/implementation/testing.html": {
    "href": "Documentation/implementation/testing.html",
    "title": "å•å…ƒæµ‹è¯• | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å•å…ƒæµ‹è¯• æœ¬æ•™ç¨‹æ˜¾ç¤ºå¦‚ä½•å¯¹Grainsè¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œä»¥ç¡®ä¿å®ƒä»¬çš„è¡Œä¸ºæ­£ç¡®ã€‚å¯¹Grainsè¿›è¡Œå•å…ƒæµ‹è¯•çš„ä¸»è¦æ–¹æ³•æœ‰ä¸¤ç§ï¼Œé€‰æ‹©çš„æ–¹æ³•å°†å–å†³äºè¦æµ‹è¯•çš„åŠŸèƒ½ç±»å‹ã€‚çš„ å¾®è½¯Orleansæµ‹è¯•ä¸»æœº NuGetåŒ…å¯ç”¨äºä¸ºGrainsåˆ›å»ºæµ‹è¯•silosï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡æ‹Ÿæ¡†æ¶ï¼Œä¾‹å¦‚ èµ·è®¢é‡ æ¨¡æ‹Ÿæ‚¨ä¸ä¹‹äº¤äº’çš„Orleansè¿è¡Œæ—¶çš„å„ä¸ªéƒ¨åˆ†ã€‚ ä½¿ç”¨TestCluster çš„ å¾®è½¯Orleansæµ‹è¯•ä¸»æœº NuGetè½¯ä»¶åŒ…åŒ…å« æµ‹è¯•é›†ç¾¤ å¯ä»¥ç”¨æ¥åˆ›å»ºä¸€ä¸ªå†…å­˜é›†ç¾¤ï¼Œé»˜è®¤æƒ…å†µä¸‹å®ƒç”±ä¸¤ä¸ªsilosç»„æˆï¼Œå¯ä»¥ç”¨æ¥æµ‹è¯•Grainsã€‚ using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } ç”±äºå¯åŠ¨å†…å­˜é›†ç¾¤çš„å¼€é”€ï¼Œæ‚¨å¯èƒ½å¸Œæœ›åˆ›å»ºä¸€ä¸ª æµ‹è¯•é›†ç¾¤ å¹¶åœ¨å¤šä¸ªæµ‹è¯•æ¡ˆä¾‹ä¸­é‡å¤ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨xUnitçš„ç±»æˆ–é›†åˆå¤¹å…·æ¥å®Œæˆæ­¤æ“ä½œ(è¯·å‚è§ https://xunit.github.io/docs/shared-context.html æ›´å¤šç»†èŠ‚)ã€‚ ä¸ºäº†åˆ†äº«ä¸€ä¸ª æµ‹è¯•é›†ç¾¤ åœ¨å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ä¹‹é—´ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ªå¤¹å…·ç±»å‹ï¼š public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } æ¥ä¸‹æ¥åˆ›å»ºä¸€ä¸ªé›†åˆå¤¹å…·ï¼š [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } æ‚¨ç°åœ¨å¯ä»¥é‡å¤ä½¿ç”¨ æµ‹è¯•é›†ç¾¤ åœ¨æ‚¨çš„æµ‹è¯•ç”¨ä¾‹ä¸­ï¼š using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHell(); Assert.Equal(\"Hello, World\", greeting); } } } xUnitå°†è°ƒç”¨ å¤„ç† çš„æ–¹æ³• é›†ç¾¤å›ºå®š å½“æ‰€æœ‰æµ‹è¯•éƒ½å·²å®Œæˆå¹¶ä¸”åœ¨å†…å­˜ä¸­ç¾¤é›†å­¤å²›å°†åœæ­¢æ—¶ï¼Œè¯·é”®å…¥ã€‚ æµ‹è¯•é›†ç¾¤ ä¹Ÿæœ‰ä¸€ä¸ªæ¥å—çš„æ„é€ å‡½æ•° TestClusterOptions å¯ç”¨äºé…ç½®é›†ç¾¤ä¸­çš„å­¤å²›ã€‚ å¦‚æœæ‚¨åœ¨silosä¸­ä½¿ç”¨ä¾èµ–æ³¨å…¥æ¥ä½¿æœåŠ¡å¯ç”¨äºGrainsï¼Œåˆ™ä¹Ÿå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼ï¼š public class ClusterFixture : IDisposable { public ClusterFixture() { var builder = new TestClusterBuilder(); builder.AddSiloBuilderConfigurator<TestSiloConfigurations>(); this.Cluster = builder.Build(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } public class TestSiloConfigurations : ISiloBuilderConfigurator { public void Configure(ISiloHostBuilder hostBuilder) { hostBuilder.ConfigureServices(services => { services.AddSingleton<T, Impl>(...); }); } } ä½¿ç”¨å˜²å¼„ Orleansè¿˜ä½¿æ¨¡æ‹Ÿç³»ç»Ÿçš„è®¸å¤šéƒ¨åˆ†æˆä¸ºå¯èƒ½ï¼Œå¹¶ä¸”åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œè¿™æ˜¯å¯¹grainsè¿›è¡Œå•å…ƒæµ‹è¯•çš„æœ€ç®€å•æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•ç¡®å®æœ‰å±€é™æ€§(ä¾‹å¦‚ï¼Œå›´ç»•è°ƒåº¦é‡å…¥å’Œåºåˆ—åŒ–)ï¼Œå¹¶ä¸”å¯èƒ½è¦æ±‚GrainåŒ…å«ä»…ç”±å•å…ƒæµ‹è¯•ä½¿ç”¨çš„ä»£ç ã€‚çš„ OrleansTestKit æä¾›äº†ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œå¯ä»¥ç»•å¼€è®¸å¤šè¿™äº›é™åˆ¶ã€‚ ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹æˆ‘ä»¬æ­£åœ¨æµ‹è¯•çš„Grainsä¸å…¶ä»–Grainsç›¸äº’ä½œç”¨ã€‚ä¸ºäº†èƒ½å¤Ÿæ¨¡æ‹Ÿå…¶ä»–Grainsï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ¨¡æ‹Ÿ grainå·¥å‚ è¢«æµ‹Grainsçš„æˆå‘˜ã€‚é»˜è®¤ grainå·¥å‚ æ˜¯æ­£å¸¸çš„ å—ä¿æŠ¤çš„ å±æ€§ï¼Œä½†å¤§å¤šæ•°æ¨¡æ‹Ÿæ¡†æ¶è¦æ±‚å°†å±æ€§è®¾ç½®ä¸º ä¸Šå¸‚ å’Œ è™šæ‹Ÿ æ‰èƒ½å˜²ç¬‘ä»–ä»¬ã€‚æ‰€ä»¥æˆ‘ä»¬è¦åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯ grainå·¥å‚ éƒ½ ä¸Šå¸‚ å’Œ è™šæ‹Ÿ å±æ€§ï¼š public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Orleansè¿è¡Œæ—¶ä¹‹å¤–åˆ›å»ºGrainsï¼Œå¹¶ä½¿ç”¨æ¨¡æ‹Ÿæ¥æ§åˆ¶ grainå·¥å‚ ï¼š using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); worker .Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())) .Returns(journal.Object); await worker.DoWork(data) journal.Verify(x => x.Record(data), Times.Once()); } } } åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºå—æµ‹Grains å·¥äººç²® ï¼Œä½¿ç”¨Moqè¡¨ç¤ºæˆ‘ä»¬å¯ä»¥è¦†ç›– grainå·¥å‚ ä»¥ä¾¿å®ƒè¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿ IJournalGrain ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯æˆ‘ä»¬çš„ å·¥äººç²® ä¸ IJournalGrain å¦‚æˆ‘ä»¬æ‰€æ–™ã€‚"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html",
    "title": "Client Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Client Configuration The key parameter that has to be configured for a client is the siloâ€™s client gateway endpoint(s) to connect to. There are two ways to do that: manually configure one or more gateway endpoints or point the client to the Azure Table used by silosâ€™ cluster membership. In the latter case the client automatically discovers what silos with client gateways enabled are available within the deployment, and adjusts its connections to the gateways as they join or leave the cluster. This option is reliable and recommended for production deployment. Fixed Gateway Configuration A fixed set of gateways is specified in the ClientConfiguration.xml with one or more Gateway nodes: <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"gateway1\" Port=\"30000\"/> <Gateway Address=\"gateway2\" Port=\"30000\"/> <Gateway Address=\"gateway3\" Port=\"30000\"/> </ClientConfiguration> One gateway is generally enough. Multiple gateway connections help increase throughput and reliability of the system. Gateway Configuration Based on Cluster Membership To configure the client to automatically find gateways from the silo cluster membership table, you need to specify the Azure Table or SQL Server connection string and the target deployment ID. <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"AzureTable\" DeploymentId=\"target deployment ID\" DataConnectionString=\"Azure storage connection string\"/> </ClientConfiguration> or <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"SqlServer\" DeploymentId=\"target deployment ID\" DataConnectionString=\"SQL connection string\"/> </ClientConfiguration> or <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"ZooKeeper\" DeploymentId=\"target deployment ID\" DataConnectionString=\"ZooKeeper connection string\"/> </ClientConfiguration> Local Silo For the local development/test configuration that uses a local silo, the client gateway should be configured to 'localhost.' <ClientConfiguration xmlns=\"urn:orleans\"> <Gateway Address=\"localhost\" Port=\"30000\"/> </ClientConfiguration> Web Role Client in Azure When the client is a web role running inside the same Azure deployment as the silo worker roles, all gateway address information is read from the OrleansSiloInstances table when OrleansAzureClient.Initialize() is called. The Azure storage connection string used to find the correct OrleansSiloInstances table is specified in the \"DataConnectionString\" setting defined in the service configuration for the deployment & role. <ServiceConfiguration ...> <Role name=\"WebRole\"> ... <ConfigurationSettings> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\" /> </ConfigurationSettings> </Role> ... </ServiceConfiguration> Both the silo worker roles and web client roles need to be use the same Azure storage account in order to successfully discover each other successfully. When using OrleansAzureClient.Initialize() and OrleansSiloInstances table for gateway address discovery, no additional gateway address info in required in the client config file. Typically the ClientConfiguration.xml file will only contain some minimal debug / tracing configuration settings, although even that is not required. <ClientConfiguration xmlns=\"urn:orleans\"> <Tracing DefaultTraceLevel=\"Info\" > <TraceLevelOverride LogPrefix=\"Application\" TraceLevel=\"Info\" /> </Tracing> </ClientConfiguration> Code-based client configuration. This is a reference only example and SHOULD NOT be used AS-IS - you may need to fine-tune client parameters for your specific environment. var dataConnection = \"DefaultEndpointsProtocol=https;AccountName=MYACCOUNTNAME;AccountKey=MYACCOUNTKEY\"; var config = new ClientConfiguration { // Some top level features GatewayProvider = ClientConfiguration.GatewayProviderType.AzureTable, ResponseTimeout = TimeSpan.FromSeconds(30), DeploymentId = RoleEnvironment.DeploymentId, DataConnectionString = dataConnection, PropagateActivityId = true, // Tracing DefaultTraceLevel = Severity.Info, TraceToConsole = false, TraceFilePattern = @\"Client_{0}-{1}.log\", //TraceFilePattern = \"false\", // Set it to false or none to disable file tracing, effectively it sets config.Defaults.TraceFileName = null; TraceLevelOverrides = { Tuple.Create(\"ComponentName\", Severity.Warning), } }; config.RegisterStreamProvider<AzureQueueStreamProvider>(\"AzureQueueStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" }, { \"DeploymentId\", \"orleans-streams\" }, // This will be a prefix name of your Queues - so be careful and use string that is valid for queue name { \"NumQueues\", \"4\" }, { \"GetQueueMessagesTimerPeriod\", \"100ms\" }, { \"DataConnectionString\", dataConnection } }); config.RegisterStreamProvider<SimpleMessageStreamProvider>(\"SimpleMessagingStreams\", new Dictionary<string, string> { { \"PubSubType\", \"ExplicitGrainBasedAndImplicit\" } }); IClusterClient client = null; while (true) { try { // Build a client and then connect it to the cluster. client = new ClientBuilder() .UseConfiguration(config) .ConfigureServices( services => { // Services can be provided to the client here. These services are made // available via dependency injection. // ConfigureServices can be called multiple times for a single // ClientBuilder instance. }) .Build(); // Connect the client to the cluster. Once connection succeeds, the client will // maintain the connection, automatically reconnecting as necessary. await client.Connect().ConfigureAwait(false); break; } catch (Exception exception) { // If the connection attempt fails, the client instance must be disposed. client?.Dispose(); // TODO: Log the exception. // TODO: Add a counter to break up an infinite cycle (circuit breaker pattern). await Task.Delay(TimeSpan.FromSeconds(5)); } } // Use the client. // Note that clients can be shared between threads and are typically long-lived. var user client.GetGrain<IUserGrain>(\"leeroy77jenkins@battle.net\"); Console.WriteLine(await user.GetProfile());"
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html",
    "title": "Configuring .NET Garbage Collection | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Configuring .NET Garbage Collection For good performance, it is important to configure .NET garbage collection for the silo process the right way. The best combination of settings we found is to set gcServer=true and gcConcurrent=true. These are easy to set via the application config file when a silo runs as a standalone process. You can use OrleansHost.exe.config included in the Microsoft.Orleans.OrleansHost NuGet package as an example. .NET Framework <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> .NET Core // .csproj <PropertyGroup> <ServerGarbageCollection>true</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> However, this is not as easy to do if a silo runs as part of an Azure Worker Role, which by default is configured to use workstation GC. This blog post shows how to set the same configuration for an Azure Worker Role - https://blogs.msdn.microsoft.com/cclayton/2014/06/05/server-garbage-collection-mode-in-microsoft-azure/ IMPORTANT NOTE Server garbage collection is available only on multiprocessor computers . Therefore, even if you configure the Garbage Collection either via Application Configuration file (app.config or web.config) or via the scripts on the referred blog post, if the silo is running on a (virtual) machine with a single core, you will not get the benefits of gcServer=true ."
  },
  "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/index.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Configuration-Guide/index.html",
    "title": "Orleans Configuration Guide | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Configuration Guide This Configuration Guide explains the key configuration parameters and how they should be used for most typical usage scenarios. Orleans Configuration xsd file is located here . Orleans can be used in a variety of configurations that fit different usage scenarios, such as local single node deployment for development and testing, cluster of servers, multi-instance Azure worker role, etc. All of the different target scenarios are achieved by specifying particular values in the Orleans configuration XML files. This guide provides instructions for the key configuration parameters that are necessary to make Orleans run in one of the target scenarios. There are also other configuration parameters that primarily help fine tune Orleans for better performance. They are documented in the XSD schema and in general are not required even for running the system in production. Orleans is a framework for building and running high scale services. A typical deployment of an Orleans application spans a cluster of servers. The instances of the Orleans runtime, called silos, running on each of the servers need to be configured to connect to each other. In addition to that, there is always a client component that connects to the Orleans deployment, most typically a web frontend, that needs to be configured to connect to the silos. The Server Configuration and Client Configuration sections of the guide cover those aspects, respectively. The section on Typical Configurations provides a summary of a few common configurations. Important : Make sure you properly configure .NET Garbage Collection as detailed in Configuring .NET Garbage Collection ."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Client-Error-Code-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Client-Error-Code-Monitoring.html",
    "title": "Client Error Code Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Client Error Code Monitoring Group Log Type Log Code Values Threshold Description Azure Problems Warning or Error 100800 - 100899 Any Error or Warning Transient problems reading or writing to Azure table store will be logged as Warning. Transient read errors will automatically be retried. A final Error log message means there is a real problem connecting to Azure table storage. Gateway connectivity problems Warning or Error 100901 - 100904, 100912, 100913, 100921, 100923, 100158, 100161, 100178, , 101313 Any Error or Warning Problems connecting to gateways. No active gateways in the Azure table. Connection to active gateway lost. Grain call timeouts Warning 100157 Multiple Warnings logged in short space of time Grain-call timeout problems are generally caused by temporary network connectivity issues or silo restart / reboot problems. System should recover after a short time (depending on Liveness config settings) at which point Timeouts should clear. Ideally, monitoring for just the bulk log code 600157 variety of these warnings should be sufficient. Network Socket Problems Warning or Error 101000 to 101999, 100307, 100015, 100016 Any Error or Warning Socket disconnects are logged as Warning messages. Problems opening sockets or during message transmission are logged as Errors. Bulk log message compaction Any 500000 or higher Message summary based on bulk message threshold settings If multiple logs of the same log code occur within a designated time interval (the default is >5 within 1 minute) then additional log messages with that log code are suppressed and output as a \"bulk\" entry with log code equal to the original log code + 500000. So for example, multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Silo-Error-Code-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Silo-Error-Code-Monitoring.html",
    "title": "Silo Error Code Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Silo Error Code Monitoring Group Log Type Log Code Values Threshold Description Azure Problems Warning or Error 100800 - 100899 Any Error or Warning Transient problems reading or writing to Azure table store will be logged as Warning. Transient read errors will automatically be retried. A final Error log message means there is a real problem connecting to Azure table storage. Membership Connectivity Problems Warning or Error 100600 - 100699 Any Error or Warning Warning logs are an early indication of network connectivity problems and/or silo restart / migration. Ping timeouts and silo-dead votes will show up as Warning messages. Silo detesting it was voted dead will show as Error message. Grain call timeouts Warning 100157 Multiple Warnings logged in short space of time Grain-call timeout problems are generally caused by temporary network connectivity issues or silo restart / reboot problems. The system should recover after a short time (depending on Liveness config settings) at which point Timeouts should clear. Ideally, monitoring for just the bulk log code 600157 variety of these warnings should be sufficient. Silo Restart / Migration Warning 100601 or 100602 Any Warning Warning printed when silo detects it was restarted on same machine {100602) or migrated to different machine (100601) Network Socket Problems Warning or Error 101000 to 101999, 100307,100015, 100016 Any Error or Warning Socket disconnects are logged as Warning messages. Problems opening sockets or during message transmission are logged as Errors. Bulk log message compaction Any 500000 or higher Message summary based on bulk message threshold settings If multiple logs of the same log code occur within a designated time interval (the default is >5 within 1 minute) then additional log messages with that log code are suppressed and output as a \"bulk\" entry with log code equal to the original log code + 500000. So for example, multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute. Grain problems Warning or Error 101534 Any Error or Warning Detection of â€œstuckâ€ requests for non-reentrant grains . The error code is reported every time a request takes longer than 5x request timeout time to execute."
  },
  "1.5/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html",
    "title": "Runtime Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Runtime Monitoring [[THIS IS IN NEED OF REVIEW]] There are five ways Orleans deployment can be monitored by an external operator by utilizing the data that Orleans writes automatically to Azure storage. The tables mentioned below are desribed in more detail here . OrleansSilosTable for cluster membership - this table lists all silos in the deployment (partition key DeploymentID, row key silo id). The operator can use this table to check cluster health, watch the current set of live silos, or learn why and when a certain silo went down. Orleans' cluster membership protocol uses this table internally and updates it with significant membership events (silos goes up and down). OrleansSiloMetrics table for coarse grain performance statistics - Orleans writes a small number (about 10) of coarse-grain performance stats into this table (partition key DeplomentID, row key silo id). The table is updated automatically every X seconds (configurable) for each silo. The metrics include silo CPU, memory usage, number of grain activations on this silo, number of messages in the send/receive queue, etc. This data can be used to compare silos, check that there are no significant outliers (for example, one silo runs at much higher CPU), or simply check that in general the metrics reported by silos are in the expected range. In addition, this data can be used to decide to add new silos if the system becomes overloaded or reduce the number of silos if the system is mostly idle. OrleansSiloStatistics table - this table includes a much larger number of performance statistics (hundreds of counters) which provide a much more detailed and in-depth view of the internal silo state. This table is currently not recommended for use by external operators. It is mainly for Orleans developers to help them troubleshoot complex production problems, if they occur. The Orleans team is building tools to analyze this data automatically and provide compact recommendations to operators based on it. Such tools can also be built by anyone independently. Watching error codes in MDS - Orleans automatically writes different error messages into logger. This logger can be configured to output its data to various destinations. For example, the Halo team redirects all logs in production to MDS. They have written custom alerts in MDS to watch for specific error codes and count their occurrences, and alert them when those reach a certain threshold. The list of important error codes to watch is specified here: Silo Error Code Monitoring Client Error Code Monitoring Windows performance counters - The Orleans runtime continually updates a number of them. CounterControl.exe helps register the counters, and needs to run with elevated privileges. Obviously, the performance counters can be monitored using any of the standard monitoring tools."
  },
  "1.5/Documentation/Deployment-and-Operations/Service-Fabric.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Service-Fabric.html",
    "title": "Service Fabric Hosting | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Service Fabric Hosting Overview Orleans can be hosted on Service Fabric. There are currently two points of integration with Service Fabric: Hosting : Silos can be hosted on Service Fabric inside of a Service Fabric Reliable Service. Silos should be hosted as unpartitioned, stateless services since Orleans manages distribution of grains itself using fine-grained, dynamic distribution. Other hosting options (partitioned, stateful) are currently untested and unsupported. Clustering (beta): Silos and clients can leverage Service Fabric's Service Discovery mechanisms to form clusters. This option requires Service Fabric Hosting, however Service Fabric Hosting does not require Service Fabric Clustering. A sample which demonstrates hosting and clustering is present at Samples/ServiceFabric . Hosting Hosting support is available in the Microsoft.Orleans.Hosting.ServiceFabric package. It allows an Orleans Silo to run as a Service Fabric ICommunicationListener . The Silo lifecycle follows the typical communication listener lifecycle: it is initialized via the ICommunicationListener.OpenAsync method and is gracefully terminated via the ICommunicationListener.CloseAsync method or abruptly terminated via the ICommunicationListener.Abort method. OrleansCommunicationListener provides the ICommunicationListener implementation. The recommended approach is to create the communication listener using OrleansServiceListener.CreateStateless(Action<StatelessServiceContext, ISiloHostBuilder> configure) in the Orleans.Hosting.ServiceFabric namespace. This ensures that the listener has the endpoint name required by Clustering (described below). Each time the communication listener is opened, the configure delegate passed to CreateStateless is invoked to configure the new Silo. Hosting can be used in conjunction with the Service Fabric Clustering provider, however other clustering providers can be used instead. Example: Configuring Service Fabric hosting. The following example demonstrates a Service Fabric StatelessService class which hosts an Orleans silo. The full sample can be found in the Samples/ServiceFabric directory of the Orleans repository. internal sealed class StatelessCalculatorService : StatelessService { public StatelessCalculatorService(StatelessServiceContext context) : base(context) { } protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners() { // Listeners can be opened and closed multiple times over the lifetime of a service // instance. A new Orleans silo will be both created and initialized each time the // listener is opened and will be shutdown when the listener is closed. var listener = OrleansServiceListener.CreateStateless( (serviceContext, builder) => { // Optional: use Service Fabric for cluster membership. builder.UseServiceFabricClustering(serviceContext); // Alternative: use Azure Storage for cluster membership. builder.UseAzureTableMembership(options => { /* Configure connection string*/ }); // Optional: configure logging. builder.ConfigureLogging(logging => logging.AddDebug()); var config = new ClusterConfiguration(); config.Globals.RegisterBootstrapProvider<BootstrapProvider>(\"poke_grains\"); config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.ReminderTableGrain; // Service Fabric manages port allocations, so update the configuration using // those ports. config.Defaults.ConfigureServiceFabricSiloEndpoints(serviceContext); // Tell Orleans to use this configuration. builder.UseConfiguration(config); // Add your application assemblies. builder.ConfigureApplicationParts(parts => { parts.AddApplicationPart(typeof(CalculatorGrain).Assembly).WithReferences(); // Alternative: add all loadable assemblies in the current base path // (see AppDomain.BaseDirectory). parts.AddFromApplicationBaseDirectory(); }); }); return new[] { listener }; } protected override async Task RunAsync(CancellationToken cancellationToken) { while (true) { cancellationToken.ThrowIfCancellationRequested(); await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken); } } } Clustering (beta) Note: it is currently recommended to use a storage-backed clustering provider such as SQL, ZooKeeper, Consul, or Azure Tables in production while this feature is in beta. Support to use Service Fabric's Service Discovery (Naming Service) mechanism for cluster membership is available in the Microsoft.Orleans.Clustering.ServiceFabric package. The implementation requires that the Service Fabric Hosting support is also used and that the Silo endpoint is named \"Orleans\" in the value returned from StatelessService.CreateServiceInstanceListeners() . The simplest way to ensure this is to use the OrleansServiceListener.CreateStateless(...) method as described in the previous section. Service Fabric Clustering is enabled with the ISiloHostBuilder.UseServiceFabricClustering(ServiceContext) extension method on the silo and the IClientBuilder.UseServiceFabricClustering(Uri) extension method on the client. The current recommendation is to use a storage-backed clustering provider for production services, such as SQL, ZooKeeper, Consul, or Azure Storage. These providers (particularly SQL and Azure Storage) are sufficiently well tested for production use."
  },
  "1.5/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html",
    "title": "Getting Started using Azure Web Apps | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Getting Started using Azure Web Apps If you would like to connect to an Azure Silo from an Azure Web App rather than a Web Role hosted within the same cloud service you can. For this to work securely you will need to assign both the Azure Web App and the Worker Role hosting the Silo to an Azure Virtual Network . First we'll setup the Azure Web App, you can follow this guide which will create the virtual network and assign it to the Azure Web App. Now we can assign the cloud service to the virtual network by modifying the ServiceConfiguration file. <NetworkConfiguration> <VirtualNetworkSite name=\"virtual-network-name\" /> <AddressAssignments> <InstanceAddress roleName=\"role-name\"> <Subnets> <Subnet name=\"subnet-name\" /> </Subnets> </InstanceAddress> </AddressAssignments> </NetworkConfiguration> Also make sure the Silo endpoints are configured. <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> Finally, you need to specify the same deployment id for Silos and the Web App Client. You can now use the GrainClient to make a connection from the Web App to the Silo. Potential Issues If the Web App is having difficulty connecting to the Silo: Make sure you have at least two roles , or two instances of one role in your Azure Cloud Service, or the InternalEndpoint firewall rules may not be generated. Check that both the Web App and the Silo are using the same DeploymentId . Make sure the network security group is set up to allow internal virtual network connections. If you haven't got one you can create and assign one easily using the following PowerShell : New-AzureNetworkSecurityGroup -Name \"Default\" -Location \"North Europe\" Get-AzureNetworkSecurityGroup -Name \"Default\" | Set-AzureNetworkSecurityGroupToSubnet -VirtualNetworkName \"virtual-network-name\" -SubnetName \"subnet-name\""
  },
  "1.5/Documentation/Deployment-and-Operations/Troubleshooting-Deployments.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Troubleshooting-Deployments.html",
    "title": "Troubleshooting Deployments | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Troubleshooting Deployments This page gives some general guidelines for troubleshooting any issues that occur while deploying to Azure Cloud Services. These are very common issues to watch out for. Be sure to check the logs for more information. Getting a SiloUnavailableException First check to make sure that you are actually starting the silos before attempting to initialize the client. Sometimes the silos take a long time to start so it can be beneficial to try to initialize the client multiple times. If it still throws an exception, then there might be another issue with the silos. Check the silo configuration and make sure that the silos are starting up properly. Common Connection String Issues Using the local connection string when deploying to Azure â€“ the website will fail to connect Using different connection strings for the silos and the front end (web and worker roles) â€“ the website will fail to initialize the client because it cannot connect to the silos The connection string configuration can be checked in the Azure Portal. The logs may not display properly if the connection strings are not set up correctly. Modifying the Configuration Files Improperly Make sure that the proper endpoints are configured in the ServiceDefinition.csdef file or else the deployment will not work. It will give errors saying that it cannot get the endpoint information. Missing Logs Make sure that the connection strings are set up properly. It is likely that the Web.config file in the web role or the app.config file in the worker role were modified improperly. Incorrect versions in these files can cause issues with the deployment. Be careful when dealing with updates. Version Issues Make sure that the same version of Orleans is used in every project in the solution. Not doing this can lead to the worker role recycling. Check the logs for more information. Visual Studio provides some silo startup error messages in the deployment history. Role Keeps Recycling Check that all the appropriate Orleans assemblies are in the solution and have Copy Local set to True. Check the logs to see if there is an unhandled exception while initializing. Make sure that the connection strings are correct. Check the Azure Cloud Services troubleshooting pages for more information. How to Check Logs Use the cloud explorer in Visual Studio to navigate to the appropriate storage table or blob in the storage account. The WADLogsTable is a good starting point for looking at the logs. You might only be logging errors. If you want informational logs as well, you will need to modify the configuration to set the logging severity level. Programmatic configuration: When creating a ClusterConfiguration object, set config.Defaults.DefaultTraceLevel = Severity.Info . When creating a ClientConfiguration object, set config.DefaultTraceLevel = Severity.Info . Declarative configuration: Add <Tracing DefaultTraceLevel=\"Info\" /> to the OrleansConfiguration.xml and/or the ClientConfiguration.xml files. In the diagnostics.wadcfgx file for the web and worker roles, make sure to set the scheduledTransferLogLevelFilter attribute in the Logs element to Information , as this is an additional layer of trace filtering that defines which traces are sent to the WADLogsTable in Azure Storage. You can find more information about this in the Configuration Guide . Compatibility with ASP.NET The razor view engine included in ASP.NET uses the same code generation assemblies as Orleans ( Microsoft.CodeAnalysis and Microsoft.CodeAnalysis.CSharp ). This can present a version compatibility problem at runtime. To resolve this, try upgrading Microsoft.CodeDom.Providers.DotNetCompilerPlatform (this is the NuGet package ASP.NET uses to include the above assemblies) to the latest version, and setting binding redirects like this: <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Extensibility.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Extensibility.html",
    "title": "Orleans Streams Extensibility | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Extensibility There are three ways developers can extend the currently implemented behaviour of Orleans Streaming: Utilize or extend Stream Provider Configuration. Write a Custom Queue Adapter. Writ a New Stream Provider We will describe those below. Please read the Orleans Streams Implementation before reading this section to have a high level view of the internal implementation. Stream Provider Configuration Currently implemented stream providers support a number of configuration options. Simple Message Stream Provider Configuration . SMS Stream Provider currently supports only a single configuration option: FireAndForgetDelivery : this option specifies if the messages sent by SMS stream producer are sent as fire and forget without the way to know if they were delivered or not. When FireAndForgetDelivery is set to false (messages are sent not as FireAndForget), the stream producer's call stream.OnNext() returns a Task that represents the processing status of the stream consumer. If this Task succeeds, the producer knows for sure that the message was delivered and processed successfully. If FireAndForgetDelivery is set to true, the returned Task only expresses that the Orleans runtime has accepted the message and queued it for further delivery. The default value for FireAndForgetDelivery is false. Persistent Stream Provider Configuration . All persistent stream providers support the following configuration options: GetQueueMessagesTimerPeriod - how much time the pulling agents wait after the last attempt to pull from the queue that did not return any items before the agent attempts to pull again. Default is 100 milliseconds. InitQueueTimeout - how much time the pulling agents waits for the adapter to initialize the connection with the queue. Default is 5 seconds. QueueBalancerType - the type of balancing algorithm to be used to balance queues to silos and agents. Default is ConsistentRingBalancer. Azure Queue Stream Provider Configuration . Azure Queue stream provider supports the following configuration options, in addition to what is supported by Persistent Stream Provider: DataConnectionString - the Azure Queue storage connection string. DeploymentId - the deployment id of this Orleans cluster (usually similar to Azure Deployment Id). CacheSize - the size of the persistent provider cache that is used to store stream message for further delivery. Default is 4096. It would be totally possible and a lot of times easy to provide additional configuration options. For example, in some scenarios developers might want more control over queue names used by the Queue Adapter. This is currently abstracted away with IStreamQueueMapper , but there is currently no way to configure which IStreamQueueMapper to use without writing a new code. We would be happy to provide such an option, if needed. So please consider adding more configuration options to existing stream providers before writing a completely new provider. Writing a Custom Queue Adapter If you want to use a different queueing technology, you need to write a queue adapter that abstracts away the access to that queue. Below we provide details on how this should be done. Please refer to AzureQueueAdapterFactory for an example. Start by defining a MyQueueFactory class that implements IQueueAdapterFactory . You need to: a. Initialize the factory: read the passed config values, potentially allocate some data structures if you need to, etc. b. Implement a method that returns your IQueueAdapter . c. Implement a method that returns IQueueAdapterCache . Theoretically, you can build your own IQueueAdapterCache , but you don't have to. It is a good idea just to allocate and return an Orleans SimpleQueueAdapterCache . d. Implement a method that returns IStreamQueueMapper . Again, it is theoretically possible to build your own IStreamQueueMapper , but you don't have to. It is a good idea just to allocate and return an Orleans HashRingBasedStreamQueueMapper . Implement MyQueueAdapter class that implements the IQueueAdapter interface, which is an interfaces that manages access to a sharded queue . IQueueAdapter manages access to a set of queues/queue partitions (those are the queues that were returned by IStreamQueueMapper ). It provides an ability to enqueue a message in a specified the queue and create an IQueueAdapterReceiver for a particular queue. Implement MyQueueAdapterReceiver class that implements the IQueueAdapterReceiver , which is an interfaces that manages access to one queue (one queue partition) . In addition to initialization and shutdown, it basically provides one method: retrieve up to maxCount messages from the queue. Declare public class MyQueueStreamProvider : PersistentStreamProvider<MyQueueFactory> . This is your new Stream Provider. Configuration : in order to load and use you new stream provider you need to configure it properly via silo config file. If you need to use it on the client, you need to add a similar config element to the client config file. It is also possible to configure the stream provider programmatically. Below is an example of silo configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StreamProviders> <Provider Type=\"My.App.MyQueueStreamProvider\" Name=\"MyStreamProvider\" GetQueueMessagesTimerPeriod=\"100ms\" AdditionalProperty=\"MyProperty\"/> </StreamProviders> </Globals> </OrleansConfiguration> Writing a Completely New Stream Provider It is also possible to write a completely new Stream Provider. In such a case there is very little integration that needs to be done from Orleans perspective. You just need to implement the IStreamProviderImpl interface, which is a thin interface that allows application code to get a handle to the stream. Beyond that, it is totally up to you how to implement it. Implementing a completely new Stream Provider might turn to be a rather complicated task, since you might need access to various internal runtime components, some of which may have internal access. We currently do not envision scenarios where one would need to implement a completely new Stream Provider and could not instead achieve his goals through the two options outlined above: either via extended configuration or by writing a Queue Adapter. However, if you think you have such a scenario, we would like to hear about it and work together on simplifying writing new Stream Providers."
  },
  "1.5/Documentation/Orleans-Streams/index.html": {
    "href": "1.5/Documentation/Orleans-Streams/index.html",
    "title": "Orleans Streams | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Orleans v.1.0.0 added support for streaming extensions to the programing model. Streaming extensions provide a set of abstractions and APIs that make thinking about and working with streams simpler and more robust. Streaming extensions allow developers to write reactive applications that operate on a sequence of events in a structured way. The extensibility model of stream providers makes the programming model compatible with and portable across a wide range of existing queuing technologies, such as Event Hubs , ServiceBus , Azure Queues , and Apache Kafka . There is no need to write special code or run dedicated processes to interact with such queues. Why should I care? If you already know all about Stream Processing and are familiar with technologies like Event Hubs , Kafka , Azure Stream Analytics , Apache Storm , Apache Spark Streaming , and Reactive Extensions (Rx) in .NET , you may be asking why should you care. Why do we need yet another Stream Processing System and how Actors are related to Streams? \"Why Orleans Streams?\" is meant to answer that question. Programming Model There is a number of principles behind Orleans Streams Programming Model. Following the philosophy of Orleans virtual actors , Orleans streams are virtual . That is, a stream always exists. It is not explicitly created or destroyed, and it can never fail. Streams are identified by stream IDs, which are just logical names comprised of GUIDs and strings. Orleans Streams allow to decouple generation of data from its processing both in time and space . That means that stream producer and stream consumer may be on different servers, in different times and will withstand failures. Orleans streams are lightweight and dynamic . Orleans Streaming Runtime is designed to handle a large number of streams that come and go at a high rate. Orleans stream bindings are dynamic . Orleans Streaming Runtime is designed to handle cases where grains connect to and disconnect from streams at a high rate. Orleans Streaming Runtime transparently manages the lifecycle of stream consumption . After an application subscribes to a stream, from then on it will receive the stream's events, even in presence of failures. Orleans streams work uniformly across grains and Orleans clients . Programming APIs Applications interact with streams via APIs that are very similar to the well known Reactive Extensions (Rx) in .NET , by using Orleans.Streams.IAsyncStream<T> that implements Orleans.Streams.IAsyncObserver<T> and Orleans.Streams.IAsyncObservable<T> interfaces. In a typical example below a device generates some data, which is sent as an HTTP request to the service running in the Cloud. Orleans client running in the front end server receives this HTTP call and publishes the data into a matching device stream: public async Task OnHttpCall(DeviceEvent deviceEvent) { // Post data directly into device's stream. IStreamProvider streamProvider = GrainClient.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<DeviceEventData> deviceStream = streamProvider.GetStream<DeviceEventData>(deviceEvent.DeviceId); await deviceStream.OnNextAsync(deviceEvent.Data); } In another example below a chat user (implemented as Orleans Grain) joins a chat room, gets a handle to a stream of chat messages generated by all others users in this room and subscribes to it. Notice that the chat user neither does not need to know about the chat room grain itself (there might not be such a grain in our system) nor about other user in that group that produce messages. Needless to say, to produce to the chat stream, users don't need to know who is currently subscribed to the stream. This demonstrates how chat users can be completely decoupled in time and space. public class ChatUser: Grain { public async Task JoinChat(string chatGroupName) { IStreamProvider streamProvider = base.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<string> chatStream = streamProvider.GetStream<string>(chatGroupName); await chatStream.SubscribeAsync((string chatEvent) => Console.Out.Write(chatEvent)); } } Quick Start Sample The Quick Start Sample is a good quick overview of the overall workflow of using streams in the application. After reading it you should read the Streams Programming APIs to get a deeper understanding of the concepts. Streams Programming APIs A Streams Programming APIs provides detailed description of the programming APIs. Stream Providers Streams can come via physical channels of various shapes and forms and can have different semantics. Orleans Streaming is designed to support this diversity via the concept of Stream Providers , which is an extensibility point in the system. Orleans currently has implementation of two stream providers: TCP based Simple Message Stream Provider and Azure Queue based Azure Queue Stream Provider . More details on Steam Providers can be found at Stream Providers . Stream Semantics Stream Subsription Semantics : Orleans Streams guarantee Sequential Consistency for Stream Subsription operations. Specificaly, when consumer subscribes to a stream, once the Task representing the subsription operation was successfuly resolved, the consumer will see all events that were generated after it has subscribed. In addition, Rewindable streams allow to subscribe from an arbitrary point in time in the past by using StreamSequenceToken (more details can be found here ). Individual Stream Events Delivery Guarantees : Individual event delivery guarantees depend on individual stream providers. Some provide only best-effort at-most-once delivery (such as Simple Message Streams), while others provide at-least-once delivery (such as Azure Queue Streams). It is even possible to build a stream provider that will guarantee exactly-once delivery (we don't have such a provider yet, but it is possible to build one with the extensability model ). Events Delivery Order : Event order also depends on a particular stream provider. In SMS streams, the producer explicitelly controls the order of events seen by the consumer by controlling the way it publishes them. Azure Queue streams do not guarantee FIFO order, since the underlaying Azure Queues do not guarantee order in failure cases. Applications can also control their own stream delivery ordering, by using StreamSequenceToken . Streams Implementation The Orleans Streams Implementation provides a high level overview of the internal implementation. Streams Extensibility The Orleans Streams Extensibility describes how to extend streams with new functionality. Code Samples More examples of how to use streaming APIs within a grain can be found here . We plan to create more samples in the future. More Material Orleans Virtual Meetup about Streams [Orleans Streaming Presentation from Virtual Meetup]( http://dotnet.github.io/orleans/Presentations/Orleans Streaming - Virtual meetup - 5-22-2015.pptx)"
  },
  "1.5/Documentation/Multi-Cluster/MultiClusterConfiguration.html": {
    "href": "1.5/Documentation/Multi-Cluster/MultiClusterConfiguration.html",
    "title": "Multi-Cluster Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Configuration The multi-cluster configuration determines which clusters are currently part of the multi-cluster. It does not change automatically, but is controlled by the operator. Thus, it is quite different from the membership mechanism used within a cluster, which automatically determines the set of silos that are part of the cluster. We use the following terminology for the clusters in a service: A cluster is active if it has at least one active silo, and inactive otherwise A cluster is joined if it is part of the current multi-cluster configuration, and non-joined otherwise Being active/inactive is independent from being joined/non-joined: all four combinations are possible. All the clusters for a particular service are connected by a gossip network . The gossip network propagates configuration and status information. Injecting a configuration An operator issues configuration changes by injecting them into the multi-cluster network. The configurations can be injected into any cluster, and spread from there to all active clusters. Each new configuration consists of a list of cluster ids that form the multi-cluster. It also has a UTC timestamp that is used to track its propagation through the gossip network. Initially, the multi-cluster configuration is null, which means the multi-cluster list is empty (contains no clusters). Thus, the operator must initially inject a multi-cluster configuration. Once injected, this configuration persists in all connected silos (while running) and in all specified gossip channels (if those channels are persistent). We pose some restrictions on the injection of new configurations that an operator must follow: Each new configuration may add a number of clusters, or remove a number of clusters (but not both at the same time). An operator should not issue a new configuration while a previous configuration change is still being processed. These restrictions ensure that protocols such as the single-instance-protocol can correctly maintain mutual exclusion of activations even under configuration changes. Via Management Grain Multi-cluster configurations can be injected on any node in any cluster, using the Orleans Management Grain. For example, to inject a multi-cluster configuration that consists of the three clusters { us1, eu1, us2 }, we can pass a string enumerable to the management grain: var clusterlist = \"us1,eu1,us2\".Split(','); var mgtGrain = GrainClient.GrainFactory.GetGrain<IManagementGrain>(0); mgtGrain.InjectMultiClusterConfiguration(clusterlist, \"my comment here\")); The first argument to InjectMultiClusterConfiguration is an enumerable of cluster ids, which is going to define the new multi-cluster configuration. The second argument is an (optional) comment string that can be used to tag configurations with arbitrary information, such as who injected them why. There is an optional third argument, a boolean called checkForLaggingSilosFirst , which defaults to true. It means that the system performs a best-effort check to see if there are any silos anywhere that have not caught up to the current configuration yet, and rejects the change if it finds such a silo. This helps to detect violations of the restriction that only one configuration change should be pending at a time (though it cannot guarantee it under all circumstances). Via Default Configuration In situations where the multi-cluster configuration is known in advance and the deployment is fresh every time (e.g. for testing), we may want to supply a default configuration. The global configuration supports an optional attribute DefaultMultiCluster which takes a comma-separated list of cluster ids: <MultiClusterNetwork ... DefaultMulticluster=\"us1,eu1,us2\" ...> After a silo is started with this setting, it checks to see if the current multi-cluster configuration is null, and if so, injects the given configuration with the current UTC timestamp. WARNING. Persistent multi-cluster gossip channels (e.g. based on AzureTable) retain the last injected configuration unless they are deleted explicitly. In that case, specifying a DefaultMulticluster has no effect when re-deploying a cluster because the configuration stored in the gossip channels is not null.> Via Gossip Channel An operator can also inject the configuration directly into the gossip channel. Changes in the channel are picked up and propagated automatically by the periodic background gossip, though possibly very slowly (using the management grain is much faster). A rough estimate on the propagation time is 30 seconds (or whatever gossip interval is specified in the global configuration) times the binary logarithm of the total number of silos in all clusters. But since the gossip pairs are selected randomly, it can be both much quicker or much slower. If using the Azure Table-Based Gossip Channel, operators can inject a new configuration simply by editing the configuration record in the OrleansGossipTable , e.g. using some tool for editing data in Azure tables. The configuration record has the following format: Name Type Value PartitionKey String the ServiceId GUID RowKey String \"CONFIG\" Clusters String comma-separated list of cluster IDs, e.g. \"us1,eu1,us2\" Comment String optional comment GossipTimestamp DateTime UTC timestamp for the configuration NOTE . When editing this record in storage, the GossipTimestamp must also be set to a newer value than it has currently (otherwise the change is ignored). The most convenient and recommended way to do this is to delete the GossipTimestamp field - our gossip channel implementation then automatically replaces it with a correct, current Timestamp (it uses the Azure Table Timestamp). Cluster Addition/Removal Procedures Adding or removing a cluster from the multi-cluster often needs to be coordinated within some larger context. We recommend to always follow the procedures described below when adding/removing clusters from the multi-cluster. Procedure for adding a cluster Start a new Orleans cluster and wait till all silos are up and running. Inject a configuration that contains the new cluster. Start routing user requests to the new cluster. Procedure for removing a cluster Stop routing new user requests to the cluster. Inject a configuration that no longer contains the cluster. Stop all silos of the cluster. Once a cluster has been removed in this way, it can be re-added by following the procedure for adding a new cluster. Activity on Non-Joined Clusters There can be brief, temporary periods of time where a cluster is both active and non-joined: A freshly started cluster may start executing code before it is in the multicluster configuration (between steps 1 and 2 of the procedure for adding a cluster) A cluster that is being decommissioned may still execute code before the silos are shut down (between steps 2 and 3 of the procedure for removing a cluster). During those intermediate situations, the following are possible: For global-single-instance grains: A grain may have a duplicate activation on a non-joined cluster. For versioned grains: activations on non-joined clusters do not receive notifications when the grain state changes."
  },
  "1.5/Documentation/Multi-Cluster/GossipChannels.html": {
    "href": "1.5/Documentation/Multi-Cluster/GossipChannels.html",
    "title": "Multi-Cluster Communication | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Communication The network must be configured in such a way that any Orleans silo can connect to any other Orleans silo via TCP/IP, regardless of where in the world it is located. Exactly how this is achieved is outside of the scope of Orleans, as it depends on how and where silos are deployed. For example, on Windows Azure, we can use VNETs to connect muliple deployments within a region, and gateways to connect VNETs across different regions. Cluster Id Each cluster has its own unique cluster id. The cluster id must be specified in the global configuration. Cluster ids may not be empty, nor may they contain commas. Also, if using Azure Table Storage, cluster ids may not contain the characters forbidden for row keys (/, , #, ?). We recommend using very short strings for the cluster ids, because cluster ids are transmitted frequently and may be stored in storage by some log-view providers. Cluster Gateways Each cluster automatically designates a subset of its active silos to serve as cluster gateways . Cluster gateways directly advertise their IP addresses to other clusters, and can thus serve as \"points of first contact\". By default, at most 10 silos (or whatever number is configured as MaxMultiClusterGateways ) are designated as cluster gateways. Communication between silos in different clusters does not always pass through a gateway. Once a silo has learned and cached the location of a grain activation (no matter in what cluster), it sends messages to that silo directly, even if the silo is not a cluster gateway. Gossip Gossip is a mechanism for clusters to share configuration and status information. As the name suggests, gossip is decentralized and bidirectional: each silo communicates directly with other silos, both in the same cluster and in other clusters, to exchange information in both directions. Content . Gossip contains some or all of the following information: The current time-stamped multi-cluster configuration . A dictionary that contains information about cluster gateways. The key is the silo address, and the value contains (1) a timestamp, (2) the cluster id, and (3) a status, which is either active or inactive. Fast & Slow Propagation . When a gateway changes its status, or when an operator injects a new configuration, this gossip information is immediately sent to all silos, clusters, and gossip channels. This happens fast, but is not reliable. Should the message be lost due to any reasons (e.g. races, broken sockets, silo failures), our periodic background gossip ensures that the information eventually spreads, albeit more slowly. All information is eventually propagated everywhere, and is highly resilient to occasional message loss and failures. All gossip data is timestamped, which ensures that newer information replaces older information regardless of the relative timing of messages. For example, newer multi-cluster configurations replace older ones, and newer information about a gateway replaces older information about that gateway. For more details on the representation of gossip data, see the MultiClusterData class. It has a Merge method that combines gossip data, resolving conflicts using timestamps. Gossip Channels When a silo is first started, or when it is restarted after a failure, it needs to have a way to bootstrap the gossip . This is the role of the gossip channel , which can be configured in the Silo Configuration . On startup, a silo fetches all the information from the gossip channels. After startup, a silo keeps gossiping periodically, every 30 seconds or whatever is configured as BackgroundGossipInterval . Each time it synchronizes its gossip information with a partner randomly selected from all cluster gateways and gossip channels. Notes: Though not strictly required, we recommend to always configure at least two gossip channels, in distinct regions, for better availability. Latency of communication with gossip channels is not critical. Multiple different services can use the same gossip channel without interference, as long as the ServiceId Guid (as specified by their respective configuration) is distinct. There is no strict requirement that all silos use the same gossip channels, as long as the channels are sufficient to let a silo initially connect with the \"gossiping community\" when it starts up. But if a gossip channel is not part of a silo's configuration, and that silo is a gateway, it does not push its status updates to the channel (fast propagation), so it may take longer before those reach the channel via periodic background gossip (slow propagation). Azure-Table-Based Gossip Channel We have already implemented a gossip channel based on Azure Tables. The configuration specifies standard connection strings used for Azure accounts. For example, a configuration could specify two gossip channels with separate Azure storage accounts usa and europe as follows: <MultiClusterNetwork ClusterId=\"...\"> <GossipChannel Type=\"AzureTable\" ConnectionString=\"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"/> <GossipChannel Type=\"AzureTable\" ConnectionString=\"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\"/> </MultiClusterNetwork> Multiple different services can use the same gossip channel without interference, as long as the ServiceId guid specified by their respective configuration is distinct. Other Gossip Channel Implementations We are working on other gossip channel providers, similar to how membership and reminders are packaged for many different storage back-ends."
  },
  "1.5/Documentation/Multi-Cluster/GlobalSingleInstance.html": {
    "href": "1.5/Documentation/Multi-Cluster/GlobalSingleInstance.html",
    "title": "Global-Single-Instance Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain Coordination Attributes Developers can indicate when and how clusters should coordinate their grain directories with respect to a particular grain class. The [GlobalSingleInstance] attribute means we want the same behavior as as when running Orleans in a single global cluster: that is, route all calls to a single activation of the grain. Conversely, the [OneInstancePerCluster] attribute indicates that each cluster can have its own independent activation. This is appropriate if communication between clusters is undesired. The attributes are placed on grain implementations. For example: using Orleans.MultiCluster; [GlobalSingleInstance] public class MyGlobalGrain : Orleans.Grain, IMyGrain { ... } [OneInstancePerCluster] public class MyLocalGrain : Orleans.Grain, IMyGrain { ... } If a grain class does not specify either one of those attributes, it defaults to [OneInstancePerCluster] , or [GlobalSingleInstance] if the configuration parameter UseGlobalSingleInstanceByDefault is set to true. Protocol for Global-Single-Instance Grains When a global-single-instance (GSI) grain is accessed, and no activation is known to exist, a special GSI activation protocol is executed before activating a new instance. Specifically, a request is sent to all other clusters in the current multi-cluster configuration to check if they already have an activation for this grain. If all responses are negative, a new activation is created in this cluster. Otherwise, the remote activation is used (and a reference to it is cached in the local directory). Protocol for One-Instance-Per-Cluster Grains There is no inter-cluster communication for One-Instance-Per-Cluster grains. They simply use the standard Orleans mechanism independently within each cluster. Inside the Orleans framework itself, the following grain classes are marked with the [OneInstancePerCluster] attribute: ManagementGrain , GrainBasedMembershipTable , and GrainBasedReminderTable . Doubtful Activations If the GSI protocol does not receive conclusive responses from all clusters after 3 retries (or whatever number is specified by the configuration parameter GlobalSingleInstanceNumberRetries ), it creates a new local \"doubtful\" activation optimistically, favoring availability over consistency. Doubtful activations may be duplicates (because some remote cluster that did not respond during the GSI protocol activation may nevertheless have an activation of this grain). Therefore, periodically every 30 seconds (or whatever interval is specified by the configuration parameter GlobalSingleInstanceRetryInterval ) the GSI protocol is run again for all doubtful activations. This ensures that once communication between clusters is restored, duplicate activations can be detected and removed."
  },
  "1.5/Documentation/Multi-Cluster/SiloConfiguration.html": {
    "href": "1.5/Documentation/Multi-Cluster/SiloConfiguration.html",
    "title": "Multi-Cluster Silo Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Silo Configuration To get a quick overview, we show all relevant configuration parameters (including optional ones) in XML syntax below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <MultiClusterNetwork ClusterId=\"clusterid\" DefaultMultiCluster=\"uswest,europewest,useast\" BackgroundGossipInterval=\"30s\" UseGlobalSingleInstanceByDefault=\"false\" GlobalSingleInstanceRetryInterval=\"30s\" GlobalSingleInstanceNumberRetries=\"3\" MaxMultiClusterGateways=\"10\"> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> </MultiClusterNetwork> <SystemStore ... ServiceId=\"some-guid\" .../> </Globals> </OrleansConfiguration> As usual, all configuration settings can also be read and written programmatically, via the respective members of the GlobalConfiguration class. The Service Id is an arbitrary Guid for identifying this service. It must be the same for all clusters and all silos. If not specified, the default Guid (containing all zeroes) is used. The MultiClusterNetwork section is optional - if not present, all multi-cluster support is disabled for this silo. The required parameters ClusterId and GossipChannel are explained in the section on Multi-Cluster Communication . The optional parameters MaxMultiClusterGateways and BackgroundGossipInterval are explained in the section on Multi-Cluster Communication . The optional parameter DefaultMultiCluster is explained in the section on Multi-Cluster Configuration . The optional parameters UseGlobalSingleInstanceByDefault , GlobalSingleInstanceRetryInterval and GlobalSingleInstanceNumberRetries are explained in the section on Global-Single-Instance Grains . Orleans Client Configuration No extra configuration is required for Orleans client. The same client may not connect to silos in different clusters (the silo refuses the connection in that situation)."
  },
  "1.5/Documentation/Multi-Cluster/Overview.html": {
    "href": "1.5/Documentation/Multi-Cluster/Overview.html",
    "title": "Multi-Cluster Support | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Multi-Cluster Support Orleans v.1.3.0 added support for federating several Orleans clusters into a loosely connected multi-cluster that acts like a single service. Multi-clusters facilitate geo-distribution of a service, that is, make it easier to run an Orleans application in multiple data-centers around the world. Also, a multi-cluster can be run within a single datacenter to get better failure and performance isolation. All mechanisms are designed with particular attention to (1) minimize communication between clusters, and (2) let each cluster run autonomously even if other clusters fail or become unreachable. Configuration and Operation Below we document how to configure and operate a multi-cluster. Communication . Clusters communicate via the same silo-to-silo connections that are used within a cluster. To exchange status and configuration information, Clusters use a gossip mechanism and gossip channel implementations. Silo Configuration . Silos need to be configured so they know which cluster they belong to (each cluster is identified by a unique string). Also, each silo needs to be configured with connection strings that allow them to connect to one or more gossip channels on startup. Multi-Cluster Configuration Injection . At runtime, the service operator can specify and/or change the multi-cluster configuration , which contains a list of cluster ids, to specify which clusters are part of the current multi-cluster. This is done by calling the management grain in any one of the clusters. Multi-Cluster Grains Below we document how to use multi-cluster functionality at the application level. Global-Single-Instance Grains . Developers can indicate when and how clusters should coordinate their grain directories with respect to a particular grain class. The [GlobalSingleInstance] attribute means we want the same behavior as as when running Orleans in a single global cluster: that is, route all calls to a single activation of the grain. Conversely, the [OneInstancePerCluster] attribute indicates that each cluster can have its own independent activation. This is appropriate if communication between clusters is undesired. Log-View Grains (not in v.1.3.0) . A special type of grain that uses a new API, similar to event sourcing, for synchronizing or persisting grain state. It can be used to automatically and efficiently synchronize the state of a grain between clusters and with storage. Because its synchronization algorithms are safe to use with reentrant grains, and are optimized to use batching and replication, it can perform better than standard grains when a grain is frequently accessed in multiple clusters, and/or when it is written to storage frequently. Support for log-view grains is not part of the master branch yet. We have a prerelease including samples and a bit of documentation in the geo-orleans branch . It is currently being evaluated in production by an early adopter."
  },
  "1.5/Documentation/Advanced-Concepts/Cancellation-Tokens.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Cancellation-Tokens.html",
    "title": "Grain cancellation tokens | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain cancellation tokens The Orleans runtime provides mechanism called grain cancellation token, that enables the developer to cancel an executing grain operation. Description GrainCancellationToken is a wrapper around standard .NET System.Threading.CancellationToken , which enables cooperative cancellation between threads, thread pool work items or Task objects, and can be passed as grain method argument. A GrainCancellationTokenSource is a object that provides a cancellation token through its Token property and sends a cancellation message by calling its Cancel method. Usage Instantiate a CancellationTokenSource object, which manages and sends cancellation notification to the individual cancellation tokens. var tcs = new GrainCancellationTokenSource(); Pass the token returned by the GrainCancellationTokenSource.Token property to each grain method that listens for cancellation. var waitTask = grain.LongIoWork(tcs.Token, TimeSpan.FromSeconds(10)); A cancellable grain operation needs to handle underlying CancellationToken property of GrainCancellationToken just like it would do in any other .NET code. public async Task LongIoWork(GrainCancellationToken tc, TimeSpan delay) { while(!tc.CancellationToken.IsCancellationRequested) { await IoOperation(tc.CancellationToken); } } Call the GrainCancellationTokenSource.Cancel method to initiate cancellation. await tcs.Cancel(); Call the Dispose method when you are finished with the GrainCancellationTokenSource object. tcs.Dispose(); Important Considerations: The GrainCancellationTokenSource.Cancel method returns Task , and in order to ensure cancellation the cancel call must be retried in case of transient communication failure. Callbacks registered in underlying System.Threading.CancellationToken are subjects to single threaded execution guarantees within the grain activation on which they were registered. Each GrainCancellationToken can be passed through multiple methods invocations."
  },
  "1.5/Documentation/Advanced-Concepts/Codegen.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Codegen.html",
    "title": "Code Generation | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Code Generation Efficient code generation is one of the pillars of the Orleans Runtime . The Orleans Runtime makes use of generated code in order to ensure proper serialization of types that are used across the cluster as well as for generating boilerplate which abstracts away the implementation details of method shipping, exception propagation, and other internal runtime concepts. There are two modes of OrleansCodeGenerator : Build-time Codegen - in this mode, codegen will run every time your project is compiled. A build task is injected into your project's build pipeline and the code is generated in the project's intermediate output directory. To activate this mode, add the package Microsoft.Orleans.OrleansCodeGenerator.Build to your Grain Interface project. If you edit your .csproj file, you will see that an extra build target was added. This mode allows a user to step-into the generated code while debugging since the file is physically on the disk. However, your build time will be slower than usual if you have big projects. This is the default mode selected when you create a Grain Interface project by using the Visual Studio templates. Runtime Codegen - This mode makes OrleansCodeGenerator to generate code when the Silo is starting. As such, no code is generated during the build. Users can therefore not step-into the generated code while debugging and it will increase silo initialization time. To enable this mode, if you were using the build-time codegen, remove the the Microsoft.Orleans.OrleansCodeGenerator.Build package and install Microsoft.Orleans.OrleansCodeGenerator in your Silo Host and Client projects. If the project was created via the Visual Studio templates then it will already be installed. Otherwise, just install Microsoft.Orleans.OrleansCodeGenerator on your silo & client projects. Both modes generate the same code with the exception that run-time code generation can only generate code for publicly accessible types."
  },
  "1.5/Documentation/Advanced-Concepts/Request-Context.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Request-Context.html",
    "title": "Request Context | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Request Context RequestContext is an Orleans feature that allows application metadata, such as a trace ID, to flow with requests. Application metadata may be added on the client; it will flow with Orleans requests to the receiving grain. The feature is implemented by a public static class, RequestContext, in the Orleans namespace. This class exposes two simple methods: void Set(string key, object value) is used to store a value in the request context. The value can be any Serializable type. Object Get(string key) is used to retrieve a value from the current request context. The backing storage for RequestContext is thread-static. When a thread (whether client-side or within Orleans) sends a request, the contents of the sending threadâ€™s RequestContext is included with the Orleans message for the request; when the grain code receives the request, that metadata is accessible from the local RequestContext. If the grain code does not modify the RequestContext, then any grain it makes a request of will receive the same metadata, and so on. Application metadata also is maintained when you schedule a future computation using StartNew or ContinueWith; in both cases, the continuation will execute with the same metadata as the scheduling code had at the moment the computation was scheduled (that is, the system makes a copy of the current metadata and passes that to the continuation, so changes after the call to StartNew or ContinueWith will not be seen by the continuation). Note that application metadata does not flow back with responses; that is, code that runs as a result of a response being received, either within a ContinueWith continuation or after a call to Wait or GetValue, will still run within the current context that was set by the original request. For example, to set a trace ID in the client to a new GUID, one would simply call: RequestContext.Set(\"TraceId\", new Guid()); Within grain code (or other code that runs within Orleans on a scheduler thread), the trace ID of the original client request could be used, for instance, when writing a log: Logger.Info(\"Currently processing external request {0}\", RequestContext.Get(\"TraceId\")); While any serializable object may be sent as application metadata, itâ€™s worth mentioning that large or complex objects may add noticeable overhead to message serialization time. For this reason, the use of simple types (strings, GUIDs, or numeric types) is recommended."
  },
  "1.5/Documentation/Advanced-Concepts/External-Tasks-and-Grains.html": {
    "href": "1.5/Documentation/Advanced-Concepts/External-Tasks-and-Grains.html",
    "title": "External Tasks and Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . External Tasks and Grains By design, any sub-Tasks spawned from grain code (for example, by using await or ContinueWith or Task.Factory.StartNew ) will be dispatched on the same per-activation TPL Task Scheduler as the parent task and therefore inherit the same single-threaded execution model as the rest of grain code. This is the main point behind single threaded execution of grain turn based concurency . In some cases grain code might need to â€œbreak outâ€ of the Orleans task scheduling model and â€œdo something specialâ€, such as explicitly pointing a Task to a different task scheduler or using the .NET Thread pool. An example of such cases is when grain code has to execute a synchronous remote blocking call (such as remote IO). Doing that in the grain context will block the grain as well as one of the Orleans threads and thus should never be made. Instead, the grain code can execute this piece of blocking code on the thread pool thread and join ( await ) the completion of that execution and proceed in the grain context. We expect that escaping from the Orleans scheduler will be a very advanced and seldom required usage scenario beyond the â€œnormalâ€ usage patterns. Task based APIs: 1) await , Task.Factory.StartNew , Task.ContinuewWith , Task.WhenAny , Task.WhenAll , Task.Delay all respect the current Task Scheduler. That means that using them in the default way, without passing a different TaskScheduler, will cause them to execute in the grain context. 2) Both Task.Run and the endMethod delegate of Task.Factory.FromAsync do NOT respect the current task Scheduler. They both use the TaskScheduler.Default scheduler, which is the .NET thread pool task Scheduler. Therefore, the code inside Task.Run and the endMethod will ALWAYS run on the .NET thread pool outside of the single-threaded execution model for Orleans grains, as detailed here . However, any code after the await Task.Run or await Task.Factory.FromAsync will run back under the scheduler at the point the task was created, which is the grain scheduler. 3) configureAwait(false) is an explicit API to escape the current task Scheduler. It will cause the code after an awaited Task to be executed on the TaskScheduler.Default scheduler, which is the .NET thread pool, and will thus break the single-threaded execution of the Orleans grain. You should in general never ever use configureAwait(false) directly in grain code. 4) Methods with signature async void should not be used with grains. They are intended for graphical user interface event handlers. Example: Below is sample code that demonstrates the usage of TaskScheduler.Current , Task.Run and a special custom scheduler to escape from Orlean grain context and how to get back to it. public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; await TaskDelay(10000); // Current task scheduler did not change, the code after await is still running in the same task scheduler. Assert.AreEqual(orleansTs, TaskScheduler.Current); Task t1 = Task.Run( () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(TaskScheduler.Default, TaskScheduler.Current); } ); await t1; // We are back to the Orleans task scheduler. // Since await was executed in Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); // Example of using ask.Factory.StartNew with a custom scheduler to escape from the Orleans scheduler Task t2 = Task.Factory.StartNew(() => { // This code runs on the MyCustomSchedulerThatIWroteMyself scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(MyCustomSchedulerThatIWroteMyself, TaskScheduler.Current); }, CancellationToken.None, TaskCreationOptions.None, scheduler: MyCustomSchedulerThatIWroteMyself); await t2; // We are back to Orleans task scheduler. Assert.AreEqual(orleansTS, TaskScheduler.Current); } Advanced Example - making a grain call from code that runs on a thread pool An even more advanced scenario is a piece of grain code that needs to â€œbreak outâ€ of the Orleans task scheduling model and run on a thread pool (or some other, non-Orleans context), but still needs to call another grain. If you try to make a grain call but are not within an Orleans context, you will get an exception that says you are \"trying to send a message on a silo not from within a grain and not from within a system target (RuntimeContext is not set to SchedulingContext)\". Below is code that demonstrates how a grain call can be made from a piece of code that runs inside a grain but not in the grain context. public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; Task<int> t1 = Task.Run(async () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); // You can do whatever you need to do here. Now let's say you need to make a grain call. Task<Task<int>> t2 = Task.Factory.StartNew(() => { // This code runs on the Orleans task scheduler since we specified the scheduler: orleansTs. Assert.AreEqual(orleansTS, TaskScheduler.Current); return GrainFactory.GetGrain<IFooGrain>(0).MakeGrainCall(); }, CancellationToken.None, TaskCreationOptions.None, scheduler: orleansTs); int res = await (await t2); // double await, unrelated to Orleans, just part of TPL APIs. // This code runs back on the thread pool scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); return res; } ); int result = await t1; // We are back to the Orleans task scheduler. // Since await was executed in the Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); } Dealing with libraries Some external libraries that your code is using might be using ConfigureAwait(false) internally. In fact, it is a good and correct practice in .NET to use ConfigureAwait(false) when implementing general purpose libraries . This is not a problem in Orleans. As long as the code in the grain that invokes the library method is awaiting the library call with a regular await , the grain code is correct. The result will be exactly as desired -- the library code will run continuations on the Default scheduler (which happens to be ThreadPoolTaskScheduler but it does not guarantee that the continuations will definitely run on a ThreadPool thread, as continuations are often inlined in the previous thread), while the grain code will run on the Orleans scheduler. Another frequently-asked question is whether there is a need to execute library calls with Task.Run -- that is, whether there is a need to explicitly offload the library code to ThreadPool (for grain code to do Task.Run(()=> myLibrary.FooAsync()) ). The answer is No. There is no need to offload any code to ThreadPool, except for the case of library code that is making a blocking synchronous calls. Usually, any well-written and correct .NET async library (methods that return Task and are named with an Async suffix) do not make blocking calls. Thus there is no need to offload anything to ThreadPool, unless you suspect the async library is buggy or if you are deliberately using a synchronous blocking library. Summary What are you trying to do? How to do it Run background work on .NET thread-pool threads. No grain code or grain calls allowed. Task.Run Grain interface call Method return types = Task or Task<T> Run worker task from grain code with Orleans turn-based concurrency guarantees. Task.Factory.StartNew Timeouts for executing work items Task.Delay + Task.WhenAny Use with async / await The normal .NET Task-Async programming model. Supported & recommended ConfigureAwait(false) Do not use inside grain code. Allowed only inside libraries. Calling async library await the library call"
  },
  "1.5/Documentation/Advanced-Concepts/Serialization.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Serialization.html",
    "title": "Serialization and Writing Custom Serializers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Serialization and Writing Custom Serializers Orleans has an advanced and extensible serialization framework. Orleans serializes data types passed in grain request and response messages as well as grain persistent state objects. As part of this framework, Orleans automatically generates serialization code for those data types. In addition to generating a more efficient serialization/deserialization for types that are already .NET-serializable, Orleans also tries to generate serializers for types used in grain interfaces that are not .NET-serializable. The framework also includes a set of efficient built-in serializers for frequently used types: lists, dictionaries, strings, primitives, arrays, etc. There are 2 important features of Orleans's serializer that set it apart from a lot of other third party serialization frameworks: dynamic types/arbitrary polymorphism and object identity. Dynamic types and arbitrary polymorphism - Orleans does not put any restrictions on the types that can be passed in grain calls and maintains the dynamic nature of the actual data type. That means, for example, that if the method in the grain interfaces is declared to accept IDictionary but at runtime the sender passes SortedDictionary , the receiver will indeed get SortedDictionary (although the \"static contract\"/grain interface did not specify this behaviour). Maintaining Object identity - if the same object is passed multiple types in the arguments of a grain call or is indirectly pointed more than once from the arguments, Orleans will serialize it only once. At the receiver side Orleans will restore all references correctly, so that two pointers to the same object still point to the same object after deserialization as well. Object identity is important to preserve in scenarios like the following. Imagine actor A is sending a dictionary with 100 entries to actor B, and 10 of the keys in the dictionary point to the same object, obj, on A's side. Without preserving object identity, B would receive a dictionary of 100 entries with those 10 keys pointing to 10 different clones of obj. With object identity preserved, the dictionary on B's side looks exactly like on A's side with those 10 keys pointing to a single object obj. The above two behaviours are provided by the standard .NET binary serializer and it was therefore important for us to support this standard and familiar behaviour in Orleans as well. Generated Serializers Orleans uses the following rules to decide which serializers to generate. The rules are: 1) Scan all types in all assemblies which reference the core Orleans library. 2) Out of those assemblies: generate serializers for types that are directly referenced in grain interfaces method signatures or state class signature or for any type that is marked with [Serializable] attribute. 3) In addition, a grain interface or implementation project can point to arbitrary types for serialization generation by adding a [KnownType] or [KnownAssembly] assembly level attributes to tell code generator to generate serializers for a specific types or all eligible types within an assembly. Serialization Providers Orleans supports integration with third-party serializers using a provider model. This requires an implementation of the IExternalSerializer type described in the custom serialization section of this document. Integrations for some common serializers are maintained alongside Orleans, for example: Protocol Buffers : Orleans.Serialization.ProtobufSerializer from the Microsoft.Orleans.OrleansGoogleUtils NuGet package. Bond : Orleans.Serialization.BondSerializer from the Microsoft.Orleans.Serialization.Bond NuGet package. Newtonsoft.Json AKA Json.NET : Orleans.Serialization.OrleansJsonSerializer from the core Orleans library. Custom implementation of IExternalSerializer is described in the Writing Custom Serializers section below. Configuration It is important to ensure that serialization configuration is identical on all clients and silos. If configurations are not consistent, serialization errors may occur. Serialization providers, which implement IExternalSerializer , can be specified using the SerializationProviders property of ClientConfiguration and GlobalConfiguration in code: var cfg = new ClientConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); var cfg = new GlobalConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); Alternatively, they can be specified in XML configuration under the <SerializationProviders /> property of <Messaging> : <Messaging> <SerializationProviders> <Provider type=\"GreatCompany.FantasticSerializer, GreatCompany.SerializerAssembly\"/> </SerializationProviders> </Messaging> In both cases, multiple providers can be configured. The collection is ordered, meaning that if a provider which can serialize types A and B is specified before a provider which can only serialize type B , then the latter provider will not be used. Writing Custom Serializers In addition to automatic serialization generation, application code can provide custom serialization for types it chooses. Orleans recommends using the automatic serialization generation for the majority of your application types and only write custom serializers in rare cases when you believe it is possible to get improved performance by hand-coding serializers. This note describes how to do so, and identifies some specific cases when it might be helpful. There are 3 ways in which applications can customize serialization: Add serialization methods to your type and mark them with appropriate attributes ( CopierMethod , SerializerMethod , DeserializerMethod ). This method is preferable for types that your application owns, that is, the types that you can add new methods to. Implement IExternalSerializer and register it during configuration time. This method is useful for integrating an external serialization library. Write a separate static class annotated with an [Serializer(typeof(YourType))] with the 3 serialization methods in it and the same attributes as above. This method is useful for types that the application does not own, for example, types defined in other libraries your application has no control over. Each of these methods are detailed in the sections below. Introduction Orleans serialization happens in three stages: objects are immediately deep copied to ensure isolation; before being put on the wire; objects are serialized to a message byte stream; and when delivered to the target activation, objects are recreated (deserialized) from the received byte stream. Data types that may be sent in messages -- that is, types that may be passed as method arguments or return values -- must have associated routines that perform these three steps. We refer to these routines collectively as the serializers for a data type. The copier for a type stands alone, while the serializer and deserializer are a pair that work together. You can provide just a custom copier, or just a custom serializer and a custom deserializer, or you can provide custom implementations of all three. Serializers are registered for each supported data type at silo start-up and whenever an assembly is loaded. Registration is necessary for custom serializer routines for a type to be used. Serializer selection is based on the dynamic type of the object to be copied or serialized. For this reason, there is no need to create serializers for abstract classes or interfaces, because they will never be used. When to Consider Writing a Custom Serializer It is rare that a hand-crafted serializer routine will perform meaningfully better than the generated versions. If you are tempted to do so, you should first consider the following options: If there are fields or properties within your data types that don't have to be serialized or copied, you can mark them with the NonSerialized attribute. This will cause the generated code to skip these fields when copying and serializing. Use Immutable<T> & [Immutable] where possible to avoid copying immutable data. The section on Optimizing Copying below for details. If you're avoiding using the standard generic collection types, don't. The Orleans runtime contains custom serializers for the generic collections that use the semantics of the collections to optimize copying, serializing, and deserializing. These collections also have special \"abbreviated\" representations in the serialized byte stream, resulting in even more performance advantages. For instance, a Dictionary<string, string> will be faster than a List<Tuple<string, string>> . The most common case where a custom serializer can provide a noticeable performance gain is when there is significant semantic information encoded in the data type that is not available by simply copying field values. For instance, arrays that are sparsely populated may often be more efficiently serialized by treating the array as a collection of index/value pairs, even if the application keeps the data as a fully realized array for speed of operation. A key thing to do before writing a custom serializer is to make sure that the generated serializer is really hurting your performance. Profiling will help a bit here, but even more valuable is running end-to-end stress tests of your application with varying serialization loads to gauge the system-level impact, rather than the micro-impact of serialization. For instance, building a test version that passes no parameters to or results from grain methods, simply using canned values at either end, will zoom in on the impact of serialization and copying on system performance. Method 1: Adding Serialization Methods to the Type All serializer routines should be implemented as static members of the class or struct they operate on. The names shown here are not required; registration is based on the presence of the respective attributes, not on method names. Note that serializer methods need not be public. Unless you implement all three serialization routines, you should mark your type with the Serializable attribute so that the missing methods will be generated for you. Copier Copier methods are flagged with the Orleans.CopierMethod attribute: [CopierMethod] static private object Copy(object input, ICopyContext context) { ... } Copiers are usually the simplest serializer routines to write. They take an object, guaranteed to be of the same type as the type the copier is defined in, and must return a semantically-equivalent copy of the object. If, as part of copying the object, a sub-object needs to be copied, the best way to do so is to use the SerializationManager's DeepCopyInner routine: var fooCopy = SerializationManager.DeepCopyInner(foo, context); It is important to use DeepCopyInner, instead of DeepCopy, in order to maintain the object identity context for the full copy operation. Maintaining Object Identity An important responsibility of a copy routine is to maintain object identity. The Orleans runtime provides a helper class for this. Before copying a sub-object \"by hand\" (i.e., not by calling DeepCopyInner), check to see if it has already been referenced as follows: var fooCopy = context.CheckObjectWhileCopying(foo); if (fooCopy == null) { // Actually make a copy of foo context.RecordObject(foo, fooCopy); } The last line, the call to RecordObject , is required so that possible future references to the same object as foo references will get found properly by CheckObjectWhileCopying . Note that this should only be done for class instances, not struct instances or .NET primitives (strings, Uris, enums). If you use DeepCopyInner to copy sub-objects, then object identity is handled for you. Serializer Serialization methods are flagged with the SerializerMethod attribute: [SerializerMethod] static private void Serialize(object input, ISerializationContext context, Type expected) { ... } As with copiers, the \"input\" object passed to a serializer is guaranteed to be an instance of the defining type. The \"expected\" type may be ignored; it is based on compile-time type information about the data item, and is used at a higher level to form the type prefix in the byte stream. To serialize sub-objects, use the SerializationManager 's SerializeInner routine: SerializationManager.SerializeInner(foo, context, typeof(FooType)); If there is no particular expected type for foo, then you can pass null for the expected type. The BinaryTokenStreamWriter class provides a wide variety of methods for writing data to the byte stream. An instance of the class can be obtained via the context.StreamWriter property. See the class for documentation. Deserializer Deserialization methods are flagged with the DeserializerMethod attribute: [DeserializerMethod] static private object Deserialize(Type expected, IDeserializationContext context) { ... } The \"expected\" type may be ignored; it is based on compile-time type information about the data item, and is used at a higher level to form the type prefix in the byte stream. The actual type of the object to be created will always be the type of the class in which the deserializer is defined. To deserialize sub-objects, use the SerializationManager 's DeserializeInner routine: var foo = SerializationManager.DeserializeInner(typeof(FooType), context); Or, alternatively, var foo = SerializationManager.DeserializeInner<FooType>(context); If there is no particular expected type for foo, use the non-generic DeserializeInner variant and pass null for the expected type. The BinaryTokenStreamReader class provides a wide variety of methods for reading data from the byte stream. An instance of the class can be obtained via the context.StreamReader property. See the class for documentation. Method 2: Writing a Serializer Provider In this method, you implement Orleans.Serialization.IExternalSerializer and add it to the SerializationProviders property on both ClientConfiguration on the client and GlobalConfiguration on the silos. Configuration is detailed in the Serialization Providers section above. Implementation of IExternalSerializer follows the pattern described for serialization methods from Method 1 above with the addition of an Initialize method and an IsSupportedType method which Orleans uses to determine if the serializer supports a given type. This is the interface definition: public interface IExternalSerializer { /// <summary> /// Initializes the external serializer. Called once when the serialization manager creates /// an instance of this type /// </summary> void Initialize(Logger logger); /// <summary> /// Informs the serialization manager whether this serializer supports the type for serialization. /// </summary> /// <param name=\"itemType\">The type of the item to be serialized</param> /// <returns>A value indicating whether the item can be serialized.</returns> bool IsSupportedType(Type itemType); /// <summary> /// Tries to create a copy of source. /// </summary> /// <param name=\"source\">The item to create a copy of</param> /// <param name=\"context\">The context in which the object is being copied.</param> /// <returns>The copy</returns> object DeepCopy(object source, ICopyContext context); /// <summary> /// Tries to serialize an item. /// </summary> /// <param name=\"item\">The instance of the object being serialized</param> /// <param name=\"context\">The context in which the object is being serialized.</param> /// <param name=\"expectedType\">The type that the deserializer will expect</param> void Serialize(object item, ISerializationContext context, Type expectedType); /// <summary> /// Tries to deserialize an item. /// </summary> /// <param name=\"context\">The context in which the object is being deserialized.</param> /// <param name=\"expectedType\">The type that should be deserialized</param> /// <returns>The deserialized object</returns> object Deserialize(Type expectedType, IDeserializationContext context); } Method 3: Writing a Serializer for Individual Types In this method you write a new class annotated with an attribute [SerializerAttribute(typeof(TargetType))] , where TargetType is the type which is being serialized, and implement the 3 serialization routines. The rules for how to write those routines are identical to method 1. Orleans uses the [SerializerAttribute(typeof(TargetType))] to determine that this class is a serializer for TargetType and this attribute can be specified multiple times on the same class if it's able to serialize multiple types. Below is an example for such a class: public class User { public User BestFriend { get; set; } public string NickName { get; set; } public int FavoriteNumber { get; set; } public DateTimeOffset BirthDate { get; set; } } [Orleans.CodeGeneration.SerializerAttribute(typeof(User))] internal class UserSerializer { [CopierMethod] public static object DeepCopier(object original, ICopyContext context) { var input = (User) original; var result = new User(); // Record 'result' as a copy of 'input'. Doing this immediately after construction allows for // data structures which have cyclic references or duplicate references. // For example, imagine that 'input.BestFriend' is set to 'input'. In that case, failing to record // the copy before trying to copy the 'BestFriend' field would result in infinite recursion. context.RecordCopy(original, result); // Deep-copy each of the fields. result.BestFriend = (User)context.SerializationManager.DeepCopy(input.BestFriend); result.NickName = input.NickName; // strings in .NET are immutable, so they can be shallow-copied. result.FavoriteNumber = input.FavoriteNumber; // ints are primitive value types, so they can be shallow-copied. result.BirthDate = (DateTimeOffset)context.SerializationManager.DeepCopy(input.BirthDate); return result; } [SerializerMethod] public static void Serializer(object untypedInput, ISerializationContext context, Type expected) { var input = (User) untypedInput; // Serialize each field. SerializationManager.SerializeInner(input.BestFriend, context); SerializationManager.SerializeInner(input.NickName, context); SerializationManager.SerializeInner(input.FavoriteNumber, context); SerializationManager.SerializeInner(input.BirthDate, context); } [DeserializerMethod] public static object Deserializer(Type expected, IDeserializationContext context) { var result = new User(); // Record 'result' immediately after constructing it. As with with the deep copier, this // allows for cyclic references and de-duplication. context.RecordObject(result); // Deserialize each field in the order that they were serialized. result.BestFriend = SerializationManager.DeserializeInner<User>(context); result.NickName = SerializationManager.DeserializeInner<string>(context); result.FavoriteNumber = SerializationManager.DeserializeInner<int>(context); result.BirthDate = SerializationManager.DeserializeInner<DateTimeOffset>(context); return result; } } Serializing Generic Types The TargetType parameter of [Serializer(typeof(TargetType))] can be an open-generic type, for example, MyGenericType<> . In that case, the serializer class must have the same generic parameters as the target type. Orleans will create a concrete version of the serializer at runtime for every concrete MyGenericType<T> type which is serialized, for example, one for each of MyGenericType<int> and MyGenericType<string> . Hints for Writing Serializers and Deserializers Often the simplest way to write a serializer/deserializer pair is to serialize by constructing a byte array and writing the array length to the stream, followed by the array itself, and then deserialize by reversing the process. If the array is fixed-length, you can omit it from the stream. This works well when you have a data type that you can represent compactly and that doesn't have sub-objects that might be duplicated (so you don't have to worry about object identity). Another approach, which is the approach the Orleans runtime takes for collections such as dictionaries, works well for classes with significant and complex internal structure: use instance methods to access the semantic content of the object, serialize that content, and deserialize by setting the semantic contents rather than the complex internal state. In this approach, inner objects are written using SerializeInner and read using DeserializeInner. In this case, it is common to write a custom copier, as well. If you write a custom serializer, and it winds up looking like a sequence of calls to SerializeInner for each field in the class, you don't need a custom serializer for that class. Fallback Serialization Orleans supports transmission of arbitrary types at runtime and therefore the in-built code generator cannot determine the entire set of types which will be transmitted ahead of time. Additionally, certain types cannot have serializers generated for them because they are inaccessible (for example, private ) or have fields which are inaccessible (for example, readonly ). Therefore, there is a need for just-in-time serialization of types which were unexpected or could not have serializers generated ahead-of-time. The serializer responsible for these types is called the fallback serializer . Orleans ships with two fallback serializers: Orleans.Serialization.BinaryFormatterSerializer which uses .NET's BinaryFormatter ; and Orleans.Serialization.ILBasedSerializer which emits CIL instructions at runtime to create serializers which leverage Orleans' serialization framework to serialize each field. This means that if an inaccessible type MyPrivateType contains a field MyType which has a custom serializer, that custom serializer will be used to serialize it. The fallback serializer can be configured using the FallbackSerializationProvider property on both ClientConfiguration on the client and GlobalConfiguration on the silos. var cfg = new ClientConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); var cfg = new GlobalConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); Alternatively, the fallback serialization provider can be specified in XML configuration: <Messaging> <FallbackSerializationProvider type=\"GreatCompany.FantasticFallbackSerializer, GreatCompany.SerializerAssembly\"/> </Messaging> .NET Core uses the ILBasedSerializer by default, whereas .NET 4.6 uses BinaryFormatterSerializer by default. Optimize Copying Using Immutable Types Orleans has a feature that can be used to avoid some of the overhead associated with serializing messages containing immutable types. This section describes the feature and its application, starting with context on where it is relevant. Serialization in Orleans When a grain method is invoked, the Orleans runtime makes a deep copy of the method arguments and forms the request out of the copies. This protects against the calling code modifying the argument objects before the data is passed to the called grain. If the called grain is on a different silo, then the copies are eventually serialized into a byte stream and sent over the network to the target silo, where they are deserialized back into objects. If the called grain is on the same silo, then the copies are handed directly to the called method. Return values are handled the same way: first copied, then possibly serialized and deserialized. Note that all 3 processes, copying, serializing, and deserializing, respect object identity. In other words, if you pass a list that has the same object in it twice, on the receiving side you'll get a list with the same object in it twice, rather than with two objects with the same values in them. Optimizing Copying In many cases, the deep copying is unnecessary. For instance, a possible scenario is a web front-end that receives a byte array from its client and passes that request, including the byte array, on to a grain for processing. The front-end process doesn't do anything with the array once it has passed it on to the grain; in particular, it doesn't reuse the array to receive a future request. Inside the grain, the byte array is parsed to fetch the input data, but not modified. The grain returns another byte array that it has created to get passed back to the web client; it discards the array as soon as it returns it. The web front-end passes the result byte array back to its client, without modification. In such a scenario, there is no need to copy either the request or response byte arrays. Unfortunately, the Orleans runtime can't figure this out by itself, since it can't tell whether or not the arrays are modified later on by the web front-end or by the grain. In the best of all possible worlds, we'd have some sort of .NET mechanism for indicating that a value is no longer modified; lacking that, we've added Orleans-specific mechanisms for this: the Immutable<T> wrapper class and the [Immutable] attribute. Using Immutable<T> The Orleans.Concurrency.Immutable<T> wrapper class is used to indicate that a value may be considered immutable; that is, the underlying value will not be modified, so no copying is required for safe sharing. Note that using Immutable<T> implies that neither the provider of the value nor the recipient of the value will modify it in the future; it is not a one-sided commitment, but rather a mutual dual-side commitment. Using Immutable<T> is simple: in your grain interface, instead of passing T , pass Immutable<T> . For instance, in the above described scenario, the grain method that was: Task<byte[]> ProcessRequest(byte[] request); Becomes: Task<Immutable<byte[]>> ProcessRequest(Immutable<byte[]> request); To create an Immutable<T> , simply use the constructor: Immutable<byte[]> immutable = new Immutable<byte[]>(buffer); To get the value inside the immutable, use the .Value property: byte[] buffer = immutable.Value; Using [Immutable] For user-defined types, the [Orleans.Concurrency.Immutable] attribute can be added to the type. This instructs Orleans' serializer to avoid copying instances of this type. The following code snippet demonstrates using [Immutable] to denote an immutable type. This type will not be copied during transmission. [Immutable] public class MyImmutableType { public MyImmutableType(int value) { this.MyValue = value; } public int MyValue { get; } } Immutability in Orleans For Orleans' purposes, immutability is a rather strict statement: the contents of the data item will not be modified in any way that could change the item's semantic meaning, or that would interfere with another thread simultaneously accessing the item. The safest way to ensure this is to simply not modify the item at all: bitwise immutability, rather than logical immutability. In some cases it is safe to relax this to logical immutability, but care must be taken to ensure that the mutating code is properly thread-safe; because dealing with multithreading is complex, and uncommon in an Orleans context, we strongly recommend against this approach and recommend sticking to bitwise immutability. Serialization Best Practices Serialization serves two primary purposes in Orleans: As a wire format for transmitting data between grains and clients at runtime. As a storage format for persisting long-lived data for later retrieval. The serializers generated by Orleans are suitable for the first purpose due to their flexibility, performance, and versatility. They are not as suitable for the second purpose, since they are not explicitly version-tolerant. It is recommended that users configure a version-tolerant serializer such as Protocol Buffers for persistent data. Protocol Buffers is supported via Orleans.Serialization.ProtobufSerializer from the Microsoft.Orleans.OrleansGoogleUtils NuGet package. The best-practices for the particular serializer of choice should be used in order to ensure version-tolerance. Third-party serializers can be configured using the SerializationProviders configuration property as described above."
  },
  "1.5/Documentation/Advanced-Concepts/Reentrant-Grains.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Reentrant-Grains.html",
    "title": "Reentrant Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Reentrant Grains By default, the Orleans scheduler requires an activation to completely finish processing one request before invoking the next request. An activation cannot receive a new request until all of the Task s created (directly or indirectly) in the processing of the current request have been resolved and all of their associated closures executed. Grain implementation classes may be marked with the [Reentrant] attribute to indicate that turns belonging to different requests may be freely interleaved. In other words, a reentrant activation may start executing another request while a previous request has not finished processing and has pending closures. Execution of turns of both requests are still limited to a single thread. So the activation is still executing one turn at a time, and each turn is executing on behalf of only one of the activationâ€™s requests. Reentrant grain code will never run multiple pieces of grain code in parallel (execution of grain code will always be single-threaded), but reentrant grains may see the execution of code for different requests interleaving. That is, the continuation turns from different requests may interleave. For example, with the below pseudo-code, when Foo and Bar are 2 methods of the same grain class: Task Foo() { await task1; // line 1 return Do2(); // line 2 } Task Bar() { await task2; // line 3 return Do2(); // line 4 } If this grain is marked [Reentrant] , the execution of Foo and Bar may interleave. For example, the following order of execution is possible: Line 1, line 3, line 2 and line 4. That is, the turns from different requests interleave. If the grain was not reentrant, the only possible executions would be: line 1, line 2, line 3, line 4 OR: line 3, line 4, line 1, line 2 (new request cannot start before the previous one finished). Reentrant grains should have slightly less overhead because of fewer activations, scheduling queues, smaller directory, and resources proportional to the number of activations. How small or large the â€œslightlyâ€ depends on what order of numbers we are talking about here, and on the potential overhead of handling interleaving requests (extra copies of state, etc.). The main tradeoff in choosing between reentrant and non-reentrant grains is the code complexity to make interleaving work correctly and the difficulty to reason about it. In a trivial case when the grains are stateless and the logic is simple, fewer (but not too few, so that all the hardware threads are used) reentrant grains should be in general slightly more efficient. If the code is more complex, then a larger number of non-reentrant grains, even if slightly less efficient overall, should save you a lot of grief of figuring out non-obvious interleaving issues. In the end answer will depend on the specifics of the application."
  },
  "1.5/Documentation/Advanced-Concepts/Interceptors.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Interceptors.html",
    "title": "Interceptors | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Interceptors Grain call filters provide a means for intercepting grain calls. Filters can execute code both before and after a grain call. Multiple filters can be installed simultaneously. Filters are asynchronous and can modify RequestContext , arguments, and the return value of the method being invoked. Filters can also inspect the MethodInfo of the method being invoked on the grain class and can be used to throw or handle exceptions. Some example usages of grain call filters are: Authorization: a filter can inspect the method being invoked and the arguments or some authorization information in the RequestContext to determine whether or not to allow the call to proceed. Logging/Telemetry: a filter can log information and capture timing data and other statistics about method invocation. Error Handling: a filter can intercept exceptions thrown by a method invocation and transform it into another exception or handle the exception as it passes through the filter. Grain call filters must implement the IGrainCallFilter interface, which has one method: public interface IGrainCallFilter { Task Invoke(IGrainCallContext context); } The IGrainCallContext argument passed to the Invoke method has the following shape: public interface IGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> of the method being invoked. /// </summary> MethodInfo Method { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } The IGrainCallFilter.Invoke() method must await or return the result of IGrainCallContext.Invoke() to execute the next configured filter and eventually the grain method itself. The IGrainCallContext.Result property can be modified after awaiting the Invoke() method. The IGrainCallContext.Method property returns the MethodInfo of the implementation class, not the interface. The MethodInfo of the interface method can be accessed using reflection. Grain call filters are called for all method calls to a grain and this includes calls to grain extensions (implementations of IGrainExtension ) which are installed in the grain. For example, grain extensions are used to implement Streams and Cancellation Tokens . Therefore, it should be expected that the value of IGrainCallContext.Method is not always a method in the grain class itself. Configuring Grain Call Filters Implementations of IGrainCallFilter can either be registered as silo-wide filters via Dependency Injection or they can be registered as grain-level filters via a grain implementing IGrainCallFilter directly. Silo-wide Grain Call Filters A delegate can be registered as a silo-wide grain call filters using Dependency Injection like so: services.AddGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.Method.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); Similarly, a class can be registered as a grain call filter using the AddGrainCallFilter helper method. Here is an example of a grain call filter which logs the results of every grain method: public class LoggingCallFilter : IGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.Method.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.Method.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } This filter can then be registered using the AddGrainCallFilter extension method: services.AddGrainCallFilter<LoggingCallFilter>(); Alternatively, the filter can be registered without the extension method: services.AddSingleton<IGrainCallFilter, LoggingCallFilter>(); Per-grain Grain Call Filters A grain class can register itself as a grain call filter and filter any calls made to it by implementing IGrainCallFilter like so: public class MyFilteredGrain : Grain, IMyFilteredGrain, IGrainCallFilter { public async Task Invoke(IGrainCallContext context) { await context.Invoke(); // Change the result of the call from 7 to 38. if (string.Equals(context.Method.Name, nameof(this.GetFavoriteNumber))) { context.Result = 38; } } public Task<int> GetFavoriteNumber() => Task.FromResult(7); } In the above example, all calls to the GetFavoriteNumber method will return 38 instead of 7 , because the return value has been altered by the filter. Another use case for filters is in access control, as in this example: [AttributeUsage(AttributeTargets.Method)] public class AdminOnlyAttribute : Attribute { } public class MyAccessControlledGrain : Grain, IMyFilteredGrain, IGrainCallFilter { public Task Invoke(IGrainCallContext context) { // Check access conditions. var isAdminMethod = context.Method.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool) RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {context.Method.Name}!\"); } return context.Invoke(); } [AdminOnly] public Task<int> SpecialAdminOnlyOperation() => Task.FromResult(7); } In the above example, the SpecialAdminOnlyOperation method can only be called if \"isAdmin\" is set to true in the RequestContext . In this way, grain call filters can be used for authorization. In this example, it is the responsibility of the caller to ensure that the \"isAdmin\" value is set correctly and that authentication is performed correctly. Note that the [AdminOnly] attribute is specified on the grain class method. This is because the IGrainCallContext.Method property returns the MethodInfo of the implementation, not the interface. The interface method can be accessed using reflection. Ordering of Grain Call Filters Grain call filters follow a defined ordering: IGrainCallFilter implementations configured in the dependency injection container, in the order in which they are registered. (Obsolete) Silo-wide InvokeInterceptor , configured via IProviderRuntime.SetInvokeInterceptor(...) . Grain-level filter, if the grain implements IGrainCallFilter . (Obsolete) Grain-level interceptor, if the grain implements IGrainInvokeInterceptor . Grain method implementation or grain extension method implementation. Each call to IGrainCallContext.Invoke() encapsulates the next defined filter so that each filter has a chance to execute code before and after the next filter in the chain and eventually the grain method itself. Client-side interceptors If a client side interceptor is defined, any grain call made from an Orleans client will invoke this interceptor before the call is dispatched remotely. The interceptor is invoked synchronously in the same thread where the call is made after call arguments are deep copied. Since the interceptor is invoked synchronously it should return promptly and do minimal work, to avoid blocking the calling thread or impacting throughput. The interceptor is allowed to mutate the call arguments and also mutate the Orleans.RequestContext . Any changes made by the interceptor to Orleans.RequestContext will be picked up as part of the call dispatch logic that occurs after the interceptor. If the interceptor logic throws an exception, the remote call will not be made and the client calling code will throw promptly. The interceptor can be set by setting GrainClient.ClientInvokeCallback , which is a property of type Action<InvokeMethodRequest, IGrain> . The first argument is the invocation request that includes various details about the invoked call, such as InterfaceId and MethodId, as well as deep-copied arguments. The second argument is the target grain reference to which this call is made. Currently, the main scenario that we know of that uses client side pre-call inteceptors is to add some extra information to Orleans.RequestContext , such as any special call context or token. Use Cases Exception Conversion When an exception which has been thrown from the server is getting deserialized on the client, you may sometimes get the following exception instead of the actual one: TypeLoadException: Could not find Whatever.dll. This happens if the assembly containing the exception is not available to the client. For example, say you are using Entity Framework in your grain implementations; then it is possible that an EntityException is thrown. The client on the other hand does not (and should not) reference EntityFramework.dll since it has no knowledge about the underlying data access layer. When the client tries to deserialize the EntityException , it will fail due to the missing DLL; as a consequence a TypeLoadException is thrown hiding the original EntityException . One may argue that this is pretty okay, since the client would never handle the EntityException ; otherwise it would have to reference EntityFramework.dll . But what if the client wants at least to log the exception? The problem is that the original error message is lost. One way to workaround this issue is to intercept server-side exceptions and replace them by plain exceptions of type Exception if the exception type is presumably unknown on the client side. However, there is one important thing we have to keep in mind: we only want to replace an exception if the caller is the grain client . We don't want to replace an exception if the caller is another grain (or the Orleans infrastructure which is making grain calls, too; e.g. on the GrainBasedReminderTable grain). On the server side this can be done with a silo-level interceptor: public class ExceptionConversionFilter : IGrainCallFilter { private static readonly HashSet<string> KnownExceptionTypeAssemblyNames = new HashSet<string> { typeof(string).Assembly.GetName().Name, \"System\", \"System.ComponentModel.Composition\", \"System.ComponentModel.DataAnnotations\", \"System.Configuration\", \"System.Core\", \"System.Data\", \"System.Data.DataSetExtensions\", \"System.Net.Http\", \"System.Numerics\", \"System.Runtime.Serialization\", \"System.Security\", \"System.Xml\", \"System.Xml.Linq\", \"MyCompany.Microservices.DataTransfer\", \"MyCompany.Microservices.Interfaces\", \"MyCompany.Microservices.ServiceLayer\" }; public async Task Invoke(IGrainCallContext context) { var isConversionEnabled = RequestContext.Get(\"IsExceptionConversionEnabled\") as bool? == true; if (!isConversionEnabled) { // If exception conversion is not enabled, execute the call without interference. await context.Invoke(); return; } RequestContext.Remove(\"IsExceptionConversionEnabled\"); try { await context.Invoke(); } catch (Exception exc) { var type = exc.GetType(); if (KnownExceptionTypeAssemblyNames.Contains(type.Assembly.GetName().Name)) { throw; } // Throw a base exception containing some exception details. throw new Exception( string.Format( \"Exception of non-public type '{0}' has been wrapped.\" + \" Original message: <<<<----{1}{2}{3}---->>>>\", type.FullName, Environment.NewLine, exc, Environment.NewLine)); } } } As mentioned earlier, this filter can then be registered using the AddGrainCallFilter extension method: services.AddGrainCallFilter<ExceptionConversionFilter>(); On the client side you have to set up a client-side interceptor: GrainClient.ClientInvokeCallback = (request, grain) => { RequestContext.Set(\"IsExceptionConversionEnabled\", true); }; This way the client tells the server that it wants to use exception conversion. Calling Grains from Interceptors It is possible to make grain calls from an interceptor through the injection of IGrainFactory into our interceptor class: private readonly IGrainFactory grainFactory; public CustomCallFilter(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Invoke(IGrainCallContext context) { // Hook calls to any grain other than ICustomFilterGrain implementations. // This avoids potential infinite recursion when calling OnReceivedCall() below. if (!(context.Grain is ICustomFilterGrain)) { var filterGrain = this.grainFactory.GetGrain<ICustomFilterGrain>(context.Grain.GetPrimaryKeyLong()); // Perform some grain call here. await filterGrain.OnReceivedCall(); } // Continue invoking the call on the target grain. await context.Invoke(); } Obsolete Interceptor Features The following sections describe functionality which has been superseded by the above features and may be removed in a future release. Silo-level Interceptors Silo-level interceptors are called for all grain calls within a silo. They can be installed using IProviderRuntime.SetInvokeInterceptor(interceptor) , typically from within a Bootstrap Provider 's Init method, like so: providerRuntime.SetInvokeInterceptor(async (method, request, grain, invoker) => { log.LogInfo($\"{grain.GetType()}.{method.Name}(...) called\"); // Invoke the request and return the result back to the caller. var result = await invoker.Invoke(grain, request); log.LogInfo($\"Grain method returned {result}\"); return result; }); Note how the interceptor wraps the call to the grain. This allows the user to inspect the return value of each method as well as handle any exceptions which are thrown. SetInvokeInterceptor takes a single parameter, a delegate of type InvokeInterceptor with the following signature: public delegate Task<object> InvokeInterceptor( MethodInfo targetMethod, InvokeMethodRequest request, IGrain target, IGrainMethodInvoker invoker); In this delegate: targetMethod is the MethodInfo of the method being called on the grain implementation, not the interface. request.Arguments is an object[] containing the arguments to the method, if any. target is the grain implementation instance being called. invoker is used to invoke the method itself. Grain-level Interceptors Grain-level interceptors intercept calls for individual grains only. Grain-level interceptors are enabled by implementing IGrainInvokeInterceptor in a grain class: public interface IGrainInvokeInterceptor { Task<object> Invoke( MethodInfo method, InvokeMethodRequest request, IGrainMethodInvoker invoker); } For example: public Task<object> Invoke( MethodInfo methodInfo, InvokeMethodRequest request, IGrainMethodInvoker invoker) { // Check access conditions. var isAdminMethod = methodInfo.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool)RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {methodInfo.Name}!\"); } return invoker.Invoke(this, request); } If a silo-level interceptor is also present, the grain-level interceptor is invoked inside of silo-level interceptors, during the call to invoker.Invoke(...) . Grain-level interceptors will also be invoked for grain extensions (implementations of IGrainExtension ), not only for method in the current class."
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Debugging.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Debugging.html",
    "title": "Debugging and Symbols | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Debugging An Orleans-based application can be easily debugged during development by attaching a debugger to the silo host process or to the client process . For fast development iterations, it is convenient to use a single process that combines a silos and a client, such as a console application project that gets created by the Orleans Dev/Test Host project template that is part of the Microsoft Orleans Tools extension for Visual Studio. Similarly, debugger can be attached to the Worker/Web Role instance process when running inside the Azure Compute Emulator. In production, it is rarely a good idea to stop a silo at a breakpoint because the frozen silo will soon get voted dead by the cluster membership protocol and will not be able to communicate with other silos in the cluster. Hence, in productions tracing is the primary 'debugging' mechanism. Source Link Starting with the 2.0.0-beta1 release we added Source Link support to our Symbols. It means that if a project consumes the Orleans NuGet packages, when debugging the application code, they can step into the Orleans source code. In Steve Gordon's blog post , you can see what steps are needed to configure it. Symbols Starting with 1.3.0 release, symbols for Orleans binaries are published to Microsoft symbol servers. Make sure you enable Microsoft Symbol Servers in Visual Studio in Tools/Options/Debugging/Symbols for debugging Orleans code. Prior to 1.3.0, symbols were published to https://nuget.smbsrc.net/ symbol server. Add it to the list of symbol servers in Visual Studio in Tools/Options/Debugging/Symbols. Make sure there is a trailing slash in the URL. Visual Studio 2015 has a bug with parsing it. Sources You can download zipped sources for specific releases of Orleans from the Releases page . However, due to the LF/CR differences between Windows and Unix (default for GitHub), debugger may complain about a mismatch of the sources and symbols. The workaround is to check out the corresponding version tag on a Windows machine to get sources with the matching LF/CR ending."
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html",
    "title": "Developing a Client | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . What Is Grain Client? The term \"Client\" or sometimes \"Grain Client\" is used for application code that interacts with grains but itself is not part of a grain logic. Client code runs outside of the cluster of Orleans servers called silos where grains are hosted. Hence, a client acts as a connector or conduit to the cluster and to all grains of the application. Usually, clients are used on the frontend web servers to connect to an Orleans cluster that serves as a middle tier with grains executing business logic. In a typical setup, a frontend web server: Receives a web request Performs necessary authentication and authorization validation Decides which grain(s) should process the request Uses Grain Client to make one or more method call to the grain(s) Handles successful completion or failures of the grain calls and any returned values Sends a response for the web request Initialization of Grain Client Before a grain client can be used for making calls to grains hosted in an Orleans cluster, it needs to be configured, initialized, and connected to the cluster. Configuration is provided via a ClientConfiguration object that contains a hierarchy of configuration properties for programmatically configuring a client. There is also a way to configure a client via a XML file, but that option will be deprecated in the future. More information is in the Client Configuration guide . Here we will simply use a helper method that creates a configuration object hardcoded for connecting to a local silo running as localhost . ClientConfiguration clientConfig = ClientConfiguration.LocalhostSilo(); Once we have a configuration object, we can build a client via the ClientBuilder class. IClusterClient client = new ClientBuilder().UseConfiguration(clientConfig).Build(); Lastly, we need to call Connect() method on the constructed client object to make it connect to the Orleans cluster. It's an asynchronous method that returns a Task . So we need to wait for its completion with an await or .Wait() . await client.Connect(); Making Calls to Grains Making calls to grain from a client is really no different from making such calls from within grain code . The same GetGrain<T>(key) method, where T is the target grain interface, is used in both cases to obtain grain references . The slight difference is in through what factory object we invoke GetGrain . In client code we do that through the connected client object. IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Task t = player.JoinGame(game) await t; A call to a grain method returns a Task or a Task<T> as required by the grain interface rules . The client can use the await keyword to asynchronously await the returned Task without blocking the thread, or in some cases the Wait() method to block the current thread of execution. The major difference between making calls to grains from client code and from within another grain is the single-threaded execution model of grains. Grains are constrained to be single-threaded by the Orleans runtime, while clients may be multi-threaded. Orleans does not provide any such guarantee on the client side, and so it is up to the client to manage its own concurrency using whatever synchronization constructs are appropriate for its environment â€“ locks, events, Tasks , etc. Receiving notifications There are situations in which a simple request-response pattern is not enough, and the client needs to receive asynchronous notifications. For example, a user might want to be notified when a new message has been published by someone that she is following. Observers is one such mechanism that enables exposing client side objects as grain-like targets to get invoked by grains. Calls to observers do not provide any indication of success or failure, as they are sent as one-way best effort message. So it is a responsibility of the application code to build a higher level reliability mechanism on top of observers where necessary. Another mechanism that can be used for delivering asynchronous messages to clients is Streams . Streams expose indications of success or failure of delivery of individual messages, and hence enable reliable communication back to the client. Example Here is an extended version of the example given above of a client application that connects to Orleans, finds the player account, subscribes for updates to the game session the player is part of with an observer, and prints out notifications until the program is manually terminated. namespace PlayerWatcher { class Program { /// <summary> /// Simulates a companion application that connects to the game /// that a particular player is currently part of, and subscribes /// to receive live notifications about its progress. /// </summary> static void Main(string[] args) { RunWatcher().Wait(); // Block main thread so that the process doesn't exit. // Updates arrive on thread pool threads. Console.ReadLine(); } static async Task RunWatcher() { try { // Connect to local silo var config = ClientConfiguration.LocalhostSilo(); var client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); // Hardcoded player ID Guid playerId = new Guid(\"{2349992C-860A-4EDA-9590-000000000006}\"); IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); IGameGrain game = null; while (game == null) { Console.WriteLine(\"Getting current game for player {0}...\", playerId); try { game = await player.GetCurrentGame(); if (game == null) // Wait until the player joins a game { await Task.Delay(5000); } } catch (Exception exc) { Console.WriteLine(\"Exception: \", exc.GetBaseException()); } } Console.WriteLine(\"Subscribing to updates for game {0}...\", game.GetPrimaryKey()); // Subscribe for updates var watcher = new GameObserver(); await game.SubscribeForGameUpdates( await client.CreateObjectReference<IGameObserver>(watcher)); Console.WriteLine(\"Subscribed successfully. Press <Enter> to stop.\"); } catch (Exception exc) { Console.WriteLine(\"Unexpected Error: {0}\", exc.GetBaseException()); } } } /// <summary> /// Observer class that implements the observer interface. Need to pass a grain reference to an instance of this class to subscribe for updates. /// </summary> class GameObserver : IGameObserver { // Receive updates public void UpdateGameScore(string score) { Console.WriteLine(\"New game score: {0}\", score); } } } } Next Running the Application"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Grain.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Developing-a-Grain.html",
    "title": "Developing a Grain | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Please read about Grains before reading this article. Setup Before you write code to implement a grain class, create a new Class Library project targeting .NET 4.6.1 or higher in Visual Studio and add the Microsoft.Orleans.OrleansCodeGenerator.Build NuGet package to it. PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build Grain Interfaces and Classes Grains interact with each other and get called from outside by invoking methods declared as part of the respective grain interfaces. A grain class implements one or more previously declared grain interfaces. All methods of a grain interface must return a Task (for void methods) or a Task<T> (for methods returning values of type T ). The following is an excerpt from the Presence Service sample: //an example of a Grain Interface public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } //an example of a Grain class implementing a Grain Interface public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGame() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGame(IGameGrain game) { currentGame = game; Console.WriteLine( \"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGame(IGameGrain game) { currentGame = null; Console.WriteLine( \"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } } Returning Values from Grain Methods A grain method that returns a value of type T is defined in a grain interface as returning a Task<T> . For grain methods not marked with the async keyword, when the return value is available, it is usually returned via the following statement: public Task<SomeType> GrainMethod1() { ... return Task.FromResult(<variable or constant with result>); } A grain method that returns no value, effectively a void method, is defined in a grain interface as returning a Task . The returned Task indicates asynchronous execution and completion of the method. For grain methods not marked with the async keyword, when a \"void\" method completes its execution, it needs to return the special value of Task.CompletedTask : public Task GrainMethod2() { ... return Task.CompletedTask; } A grain method marked as async returns the value directly: public async Task<SomeType> GrainMethod3() { ... return <variable or constant with result>; } A \"void\" grain methods marked as async that returns no value simply returns at the end of their execution: public async Task GrainMethod4() { ... return; } If a grain method receives the return value from another asynchronous method call, to a grain or not, and doesn't need to perform error handling of that call, it can simply return the Task it receives from that asynchronous call as its return value: public Task<SomeType> GrainMethod5() { ... Task<SomeType> task = CallToAnotherGrain(); return task; } Similarly, a \"void\" grain method can return a Task returned to it by another call instead of awaiting it. public Task GrainMethod6() { ... Task task = CallToAsyncAPI(); return task; } Grain Reference A Grain Reference is a proxy object that implements the same grain interface as the corresponding grain class. It encapsulates a logical identity (type and unique key) of the target grain. A grain reference is what is used for making calls to the target grain. Each grain reference is for a single grain (a single instance of the grain class), but one can create multiple independent references for the same grain. Since a grain reference represents a logical identity of the target grain, it is independent from the physical location of the grain, and stays valid even after a complete restart of the system. Developers can use grain references like any other .NET object. It can be passed to a method, used as a method return value, etc., and even saved to persistent storage. A grain reference can be obtained by passing the identity of a grain to the GrainFactory.GetGrain<T>(key) method, where T is the grain interface and key is the unique key of the grain within the type. The following are examples of how to obtain a grain reference of the IPlayerGrain interface defined above. From inside a grain class: //construct the grain reference of a specific player IPlayerGrain player = GrainFactory.GetGrain<IPlayerGrain>(playerId); From Orleans Client code. Prior to 1.5.0: IPlayerGrain player = GrainClient.GrainFactory.GetGrain<IPlayerGrain>(playerId); Since 1.5.0: IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Grain Method Invocation The Orleans programming model is based on the Asynchronous Programming with Async and Await . Using the grain reference from the previous example, here's how one performs a grain method invocation: //Invoking a grain method asynchronously Task joinGameTask = player.JoinGame(this); //The await keyword effectively makes the remainder of the method execute asynchronously at a later point (upon completion of the Task being awaited) without blocking the thread. await joinGameTask; //The next line will execute later, after joinGameTask is completed. players.Add(playerId); It is possible to join two or more Tasks ; the join operation creates a new Task that is resolved when all of its constituent Task s are completed. This is a useful pattern when a grain needs to start multiple computations and wait for all of them to complete before proceeding. For example, a front-end grain that generates a web page made of many parts might make multiple back-end calls, one for each part, and receive a Task for each result. The grain would then await the join of all of these Tasks ; when the join Task is resolved, the individual Task s have been completed, and all the data required to format the web page has been received. Example: List<Task> tasks = new List<Task>(); Message notification = CreateNewMessage(text); foreach (ISubscriber subscriber in subscribers) { tasks.Add(subscriber.Notify(notification)); } // WhenAll joins a collection of tasks, and returns a joined Task that will be resolved when all of the individual notification Tasks are resolved. Task joinedTask = Task.WhenAll(tasks); await joinedTask; // Execution of the rest of the method will continue asynchronously after joinedTask is resolve. Virtual methods A grain class can optionally override OnActivateAsync and OnDeactivateAsync virtual methods that get invoked by the Orleans runtime upon activation and deactivation of each grain of the class. This gives the grain code a chance to perform additional initialization and cleanup operations. An exception thrown by OnActivateAsync fails the activation process. While OnActivateAsync , if overridden, is always called as part of the grain activation process, OnDeactivateAsync is not guaranteed to get called in all situations, for example, in case of a server failure or other abnormal events. Because of that, applications should not rely on OnDeactivateAsync for performing critical operations, such as persistence of state changes, and only use it for best effort operations. Next Developing a Client"
  },
  "1.5/Documentation/Runtime-Implementation-Details/Runtime-Tables.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Runtime-Tables.html",
    "title": "Azure Runtime Tables | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Azure Runtime Tables Orleans maintains a number of internal tables for different runtime mechanisms. Here we list all the tables as they are organized if Azure is used as the system store, and provide more details on their internal structure. When SQL, ZooKeeper, Consul and other technologies are used for system store, organization and exact structure of the data may vary, but the general idea stays the same. Runtime tables: Orleans Silo Instances table Reminders table Silo Metrics table Clients Metrics table Silo Statistics table Clients Statistics table Orleans Silo Instances table Orleans Silo Instances table, also commonly referred to as Membership table, lists the set of silos that make an Orleans deployment. More details can be found in the description of the Cluster Management Protocol that maintains this table. All rows in this table consist of the following columns ( SiloInstanceTableEntry ): PartitionKey - deployment id. RowKey - Silo IP Address + \"-\" + Silo Port + \"-\" + Silo Generation number (epoch) DeploymentId - the deployment id of this Orleans service Address - IP address Port - silo to silo TCP port Generation - Generation number (epoch number) HostName - silo Hostname Status - status of this silo, as set by cluster management protocol. Any of the type Orleans.Runtime.SiloStatus ProxyPort - silo to clients TCP port Primary - whether this silo is primary or not. Deprecated. RoleName - If running in Azure - the name of this role. If running on premises, the name of the executing assembly. InstanceName - If running in Azure - the name of this role instance. If running on premises, the silo name that the silo host gave it. UpdateZone - Azure update zone, if running in Azure. FaultZone - Azure fault zone, if running in Azure. SuspectingSilos - the list of silos that suspect this silo. Managed by cluster management protocol. SuspectingTimes - the list of times when this silo was suspected. Managed by cluster management protocol. StartTime - the time when this silo was started. IAmAliveTime - the last time this silo reported that it is alive. Used for diagnostics and troubleshooting only. There is also a special row in this table, called membership version row, with the following columns: PartitionKey - deployment id. RowKey - \"VersionRow\" constant string DeploymentId MembershipVersion - the latest version of the current membership configuration. Naming: The silo instance row has 3 names: hostname, rolename and instance name. What is the difference? First, it is important to note that Orleans cluster protocol does not use any of these names for distinguishing between silos. Instead it uses IP:port:epoch as a unique identity of a silo instance. Therefore, setting of those 3 names has no impact on runtime correctness. It is in the table merely to help diagnostics and operational troubleshooting. Hostname is always set to the name of this host, as returned by Dns.GetHostName() . Role name is a logical name of the whole service and instance name is the name of this specific silo instance within this service. Role name and Instance name depend on the hosting - where the silo runs. Each silo host can set those differently. Azure host ( AzureSiloHost ) sets the role name to Azure role name ( myRoleInstance.Role.Name ) and instance name to Azure role Instance name ( myRoleInstance.Id ). On premises ( SiloHost ) the role name is the executing assembly name ( Assembly.GetExecutingAssembly().GetName().Name ) and the instance name is the name the host gave to that silo when it was started. Orleans Reminders table Orleans Reminders table durably stores all the reminders registered in the system. Each reminder has a separate row. All rows in this table consist of the following columns ( ReminderTableEntry ): PartitionKey - ServiceId + \"_\" + GrainRefConsistentHash RowKey - GrainReference + \"-\" ReminderName GrainReference - the grain reference of the grain that created this reminder. ReminderName - the name of this reminder ServiceId - the service id of the currently running Orleans service DeploymentId - the deployment id of the currently running Orleans service StartAt - the time when this reminder was supposed to tick in the first time Period - the time period for this reminder GrainRefConsistentHash - the consistent hash of the GrainReference Silo Metrics table Silo metrics table contains a small set of per-silo important key performance metrics (usually known as KPI - Key Performance Indicators ). Each silo has one row, periodically updated in-place by its silo ( SiloMetricsData ). PartitionKey - DeploymentId RowKey - silo name DeploymentId - the deployment id of this Orleans service Address - the silo address (ip:port:epoch) of this silo SiloName - the name of this silo (in Azure it is its Instance name) GatewayAddress - the gateway ip:port of tis silo HostName - the hostname of this silo CPU - current CPU utilization MemoryUsage - current memory usage ( GC.GetTotalMemory(false) ) Activations - number of activations on this silo RecentlyUsedActivations - number of activations on this silo that were used in the last 10 minutes (Note: this number may currently not be accurate if different age limits are used for different grain types). SendQueue - the current size of the send queue (number of messages waiting to be send). Only captures remote messages to other silos (not including messages to the clients). ReceiveQueue - the current size of the receive queue (number of messages that arrived to this silo and are waiting to be dispatched). Captures both remote and local messages from other silos as well as from the clients. RequestQueue SentMessages - total number of remote messages sent to other silos as well as to the clients. ReceivedMessages - total number of remote received messages, from other silos as well as from the clients. LoadShedding - whether this silo is currently overloaded and is in the load shedding mode. Clients - number of currently connected clients Clients Metrics table Silo metrics table containes a small set of per-Orleans-client important key performance metrics. Each client has one row, periodically updated in-place by its client. Client metrics are essentilay a subset of silo metrics ( ClientMetricsData ). PartitionKey - DeploymentId RowKey - Address DeploymentId - the deployment id of this Orleans service Address - the address (ip:port) of this client ClientId - the unique name of this client (pseudo client grain id) HostName - the hostname of this client CPU - current CPU utilization MemoryUsage - current memory usage ( GC.GetTotalMemory(false) ) SendQueue - the current size of the send queue (number of messages waiting to be send). Captures remote messages to other silos. ReceiveQueue - the current size of the receive queue (number of messages that arrived to this client and are waiting to be dispatched, including responses). SentMessages - total number of remote messages sent to silos. ReceivedMessages - total number of remote received messages from silos. ConnectedGatewayCount - number of gateways that this client is currently connected to. Silo Statistics table Silo Statistics table containes a large set of per-silo detailed statistic counters. Most of them are low level performance statistics, which are usualy used in troubleshooting scenarios. A set of examples and methodology of how those statistics can be used are described in our paper PAD: Performance Anomaly Detection in Multi-Server Distributed Systems and a proof of concept . Each statistic value is one row. This table is append only. Every silo periodicaly (usually every 5 minutes, configurable) appends all its latest statistic counter values. The number of counters per silo is currently about 200. So every 5 minutes every silo appends around 200 rows to this table. Each row is in the format ( StatsTableData ): PartitionKey - DeploymentId$ReverseTimestampToTheNearestHour - deploymentId and last hour RowKey - ReverseTimestampToTheNearestSecond$Name$counter - current second, silo name, monotonically growing sequence number DeploymentId - the deployment id of this Orleans service Time - the current time of the reporting on the reporting silo Address - the silo address (ip:port:epoch) of this silo Name - the name of this silo (in Azure it is its Instance name) HostName - the host name of this silo Statistic - the name of the statistic counter StatValue - the value of the statistic counter IsDelta - if this the statistic counter value is delta since last value reported or an absolute value The rationale behind the choice of partition key and row key is described here and here . Clients Statistics table Same as Silo Statistics table but for client."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Load-Balancing.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Load-Balancing.html",
    "title": "Load Balancing | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Load Balancing Load balancing, in a broad sense, is one of the pillars of the Orleans runtime . Orleans runtime tries to make everything balanced, since balancing allows to maximize resource usage and avoid hotspots, which leads to better performance, as well as helps with elasticity. Load balancing in Orleans applies in multiple places. Below is a non-exhaustive list of places where the runtime performs balancing: Default actor placement strategy is random - new activations are placed randomly across silos. That results in a balanced placement and prevents hotspots for most scenarios. A more advanced ActivationCountPlacement tries to equalize the number of activations on all silos, which results in a more even distribution of activations across silos. This is especially important for elasticity. Grain Directory service is built on top of a Distributed Hash Table, which inherently is balanced. The directory service maps grains to activations, each silo owns part of the global mapping table, and this table is globally partitioned in a balanced way across all silos. We use consistent hashing with virtual buckets for that. Clients connect to all gateways and spread their requests across them, in a balanced way. Reminder service is a distributed partitioned runtime service. The assignment of which silo is responsible to serve which reminder is balanced across all silos via consistent hashing, just like in grain directory. Performance critical components within a silo are partitioned, and the work across them is locally balanced . That way the silo runtime can fully utilize all available CPU cores and not create in-silo bottlenecks. This applies to all local resources: allocation of work to threads, sockets, dispatch responsibilities, queues, etc. StreamQueueBalance balances the responsibility of pulling events from persistence queues across silos in the cluster. Also notice that balancing, in a broad sense, does not necessarily mean loss of locality . One can be balanced and still maintain a good locality. For example, when balancing means sharding/partitioning, you can partition responsibility for a certain logical task, while still maintaining locality within each partition. That applies both for local and distributed balancing. Refer to this presentation on [Balancing Techniques in Orleans]( http://dotnet.github.io/orleans/Presentations/Balancing Techniques in Orleans.pptx) for more details."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Messaging-Delivery-Guarantees.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Messaging-Delivery-Guarantees.html",
    "title": "Messaging Delivery Guarantees | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Messaging Delivery Guarantees Orleans messaging delivery guarantees are at-most-once , by default. Optionally, if configured to do retries upon timeout, Orleans provides at-least-once delivÂ­ery instead. In more details: Every message in Orleans has automatic timeout (the exact timeout can be configured). If the reply does not arrive on time the return Task is broken with timeout exception. Orleans can be configured to do automatic retries upon timeout. By default we do NOT do automatic retries. Application code of course can also pick to do retries upon timeout. If the Orleans system is configured not to do automatic retries (default setting) and application is not resending â€“ Orleans provides at most once message delivery . A message will either be delivered once or not at all. It will never be delivered twice. In the system with retries (either by the runtime or by the application) the message may arrive multiple times. Orleans currently does nothing to durably store which messages already arrived and suppress the second delivery (we believe this would be pretty costly). So in the system with retries Orleans does NOT guarantee at most once delivery. If you keep retrying potentially indefinitely , the message will eventually arrive , thus providing at least once delivery guarantee. Notice that â€œwill eventually arriveâ€ is something that the runtime needs to guarantee. It does not come for free just by itself even if you keep retrying. Orleans provides eventually delivery since grains never go into any permanent failure state and a failed grain will for sure eventually be re-activated on another silo. So to summarize : in the system without retries Orleans guarantees at most once message delivery. In the system with infinite retries Orleans guarantee at least once (and does NOT guarantee at most once). Note : In the Orleans technical report we accidentally only mentioned the 2nd option with automatic retries and forgot to mention that by default with no retries, Orleans provides at most once delivery."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Relational-Storage.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Relational-Storage.html",
    "title": "Relational Storage | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Relational Storage Relational storage backend code in Orleans is built on generic ADO.NET functionality and is consequently database vendor agnostic. The Orleans data storage layout has been explained already in Runtime Tables . Setting up the connection strings are done as explained in Orleans Configuration Guide and SQL Tables . To make Orleans code function with a given relational database backend, the following is required: Appropriate ADO.NET library must be loaded to the process (multiple can exist in GAC or otherwise). This should be defined as usual, e.g. via DbProviderFactories element in application configuration. Configure the ADO.NET invariant via AdoInvariant attribute in the element defining the connection string, by default it is System.Data.SqlClient The database needs to exist and be compatible with the code. This is done by running a vendor specific database creation script. The scripts are found in the OrleansSqlUtils NuGet package and are published with every Orleans release. Currently there are two database scripts: SQL Server - CreateOrleansTables_SqlServer.sql . AdoInvariant is System.Data.SqlClient . MySQL - CreateOrleansTables_MySql.sql . AdoInvariant is MySql.Data.MySqlClient . If you need setup scripts for other ADO.NET supported databases, open an issue or please, stop by at Orleans Gitter . Goals of the design 1. Allow use of any backend that has a ADO.NET provider This should cover the broadest possible set of backends available for .NET, which is a factor in on-premises installations. Some providers are listed at ADO.NET Data Providers MSDN page , but for the sake of a remark, not all are listed, such as Teradata . 2. Maintain the potential to tune queries and database structure as appropriate, even while a deployment is running In many cases, the servers and databases are hosted by a third party in contractual relation with the client. It is not an unusual situation the hosting environment is virtualized and performance fluctuates due to unforeseen factors, such as noisy neighbors or faulty hardware. It may not be possible to alter and re-deploy either Orleans binaries (contractual reasons) or even application binaries, but usually it is possible to tweak the database deployment. Altering standard components , such as Orleans binaries, requires a lenghtier procedure as to what is afforded in a given situation. 3. Allow one to make use of vendor and version specific abilities Vendors have implemented different extensions and features within their products. It is sensible to make use of these features when they are available. These features are such as native UPSERT or PipelineDB in PostgreSQL, PolyBase or natively compiled tables and stored procedures in SQL Server â€“ and myriads of other features. 4. Make it possible to optimize hardware resources When designing an application, it is often possible to anticipate which data needs to be inserted faster than other data and which data could be more likely put into cold storage which is cheaper (e.g. splitting data between SSD and HDD). As for an example, further considerations are that the physical location of some data could be more expensive (e.g. SSD RAID viz HDD RAID), more secured or some other decision attribute used. Related to point 3. Some databases offer special partitioning schemes, such as SQL Server Partitioned Tables and Indexes . This principle applies also throughout the application life-cycle. Considering one of the principles of Orleans itself is a high-availability system, it should be possible to adjust storage system without interruption to Orleans deployment or that it should be possible to adjust the queries according to data and other application parameters. One example of changes is in Brian Harry's blog post When a table is small, it almost doesnâ€™t matter what the query plan is. When itâ€™s medium an OK query plan is fine. When it's huge (millions upon millions or billions of rows) a tiny, slight variation in query plan can kill you. So, we hint our sensitive queries heavily. This is true in general. 5. No assumptions on what tools, libraries or deployment processes are used in organizations Many organizations have familiarity with a certain set of database tools, examples being Dacpac or Red Gate . It may be so that deploying a database requires either a permission or a person, such as someone in a DBA role, to do it. Usually this means also having the target database layout and a rough sketch of the queries the application will produce to the database to be used estimate the load. There might be processes, perhaps influenced by industry standards, which mandate script based deployment. Having the queries and database structures in an external script makes this possible. 6. Use the minimum set needed of interface functionality to load the ADO.NET libraries and functionality This is both fast and has less surface to be exposed to ADO.NET library implementation discrepancies. 7. Make the design shardable When it makes sense, for instance in relational storage provider, make the design readily shardable. This means for instance no database dependent data (e.g. IDENTITY ) and basically it means the information that distinguishes row data should build on only data from the actual parameters. 8. Make the design easy to test Creating a new backend should be ideally as easy as translating one of the deployment scripts and adding a new connection string to tests assuming default parameters, check if a given database is installed and then run the tests against it. 9. Taking into account the previous points, make both porting scripts for new backends and modifying already deployed backend scripts as transparent as possible Realization of the goals Orleans framework does not have knowledge of deployment specific hardware (which may change during active deployment), the change of data during the deployment life-cycle and some vendor specific features are usable in only some situations. For this reason, the interface between relational database and Orleans should adhere a minimum set of abstractions and rules to meet the goals but to make it also robust against misuse and easy to test if needed. Runtime Tables , Cluster Management and the concrete membership protocol implementation . Also, the SQL Server implementation contains SQL Server edition specific tuning. The interface contract between the database and Orleans is defined as follows: The general idea is that data is read and written through Orleans specific queries. Orleans operates on column names and types when reading and on parameter names and types when writing. The implementations must preserve input and output names and types. Orleans uses these parameters to reads query results by name and type. Vendor and deployment specific tuning is allowed and contributions are encouraged as long as the interface contract is maintained. The implementation across vendor specific scripts should preserve the constraint names. This simplifies troubleshooting by virtue of uniform naming across concrete implementations. Version â€“ or ETag in application code â€“ for Orleans represents a unique version. The type of its actual implementation is not important as long as it represents a unique version. In the implementation Orleans code excepts a signed 32-bit integer. For the sake of being explicit and removing ambiguity, Orleans expects some queries to return either TRUE as > 0 value or FALSE as = 0 value. That is, affected rows or such does not matter. If an error is raised or an exception is thrown the query must ensure the entire transaction is rolled back and may either return FALSE or propagate the exception. Currently all but one query are single row inserts or updates (note, one could replace UPDATE queries with INSERT ones provided the associated SELECT queries would provide the last write) except for statistic inserts. Statistic insert, as defined by InsertOrleansStatisticsKey writes the statistics in batches of predefined maximum size using UNION ALL for all databases except for Oracle, for which a UNION ALL FROM DUAL construct is used. InsertOrleansStatisticsKey is the only query that defines a kind of a template parameters of which Orleans multiplies as many times as there are parameters with differing values. Database engines support in-database programming, this is is similar to an idea of loading an executable script and invoke it to execute database operations. In pseudocode it could be depicted as const int Param1 = 1; const DateTime Param2 = DateTime.UtcNow; const string queryFromOrleansQueryTableWithSomeKey = \"SELECT column1, column2 FROM <some Orleans table> where column1 = @param1 AND column2 = @param2;\"; TExpected queryResult = SpecificQuery12InOrleans<TExpected>(query, Param1, Param2); These principles are also included in the database scripts . Some ideas on applying customized scripts Alter scripts in OrleansQuery for grain persistence with IF ELSE so that some state is saved using the default INSERT while some grain state uses, for instance, memory optimized tables . The SELECT queries need to be altered accordingly. The idea in 1. can be used to take advantage of other deployment or vendor specific aspects. Such as splitting data between SSD or HDD , putting some data on encrypted tables, or perhaps inserting statistics data via SQL Server to Hadoop or even linked servers . The altered scripts can be tested running the Orleans test suite or straight in the database using, for instance, SQL Server Unit Test Project . Guidelines for adding new ADO.NET providers Add a new database setup script according to the Realization of the goals section above. Add the vendor ADO invariant name to AdoNetInvariants and ADO.NET provider specific data to DbConstantsStore . These are (potentially) used in some query operations. e.g. to select the correct statistics insert mode (i.e. the UNION ALL with or without FROM DUAL ). Orleans has comprehensive tests for all system stores: membership, reminders and statistics. Adding tests for the new database script is done by copy-pasting existing test classes and changing the ADO invariant name. Also, derive from RelationalStorageForTesting in order to define test functionality for the ADO invariant."
  },
  "Documentation/tutorials_and_samples/testing.html": {
    "href": "Documentation/tutorials_and_samples/testing.html",
    "title": "å•å…ƒæµ‹è¯• | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å•å…ƒæµ‹è¯• æœ¬æ•™ç¨‹æ˜¾ç¤ºå¦‚ä½•å¯¹Grainsè¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œä»¥ç¡®ä¿å®ƒä»¬çš„è¡Œä¸ºæ­£ç¡®ã€‚å¯¹Grainsè¿›è¡Œå•å…ƒæµ‹è¯•çš„ä¸»è¦æ–¹æ³•æœ‰ä¸¤ç§ï¼Œé€‰æ‹©çš„æ–¹æ³•å°†å–å†³äºè¦æµ‹è¯•çš„åŠŸèƒ½ç±»å‹ã€‚çš„ å¾®è½¯Orleansæµ‹è¯•ä¸»æœº NuGetåŒ…å¯ç”¨äºä¸ºGrainsåˆ›å»ºæµ‹è¯•silosï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡æ‹Ÿæ¡†æ¶ï¼Œä¾‹å¦‚ èµ·è®¢é‡ æ¨¡æ‹Ÿæ‚¨ä¸ä¹‹äº¤äº’çš„Orleansè¿è¡Œæ—¶çš„å„ä¸ªéƒ¨åˆ†ã€‚ ä½¿ç”¨TestCluster çš„ å¾®è½¯Orleansæµ‹è¯•ä¸»æœº NuGetè½¯ä»¶åŒ…åŒ…å« æµ‹è¯•é›†ç¾¤ å¯ä»¥ç”¨æ¥åˆ›å»ºä¸€ä¸ªå†…å­˜é›†ç¾¤ï¼Œé»˜è®¤æƒ…å†µä¸‹å®ƒç”±ä¸¤ä¸ªsilosç»„æˆï¼Œå¯ä»¥ç”¨æ¥æµ‹è¯•Grainsã€‚ using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } ç”±äºå¯åŠ¨å†…å­˜é›†ç¾¤çš„å¼€é”€ï¼Œæ‚¨å¯èƒ½å¸Œæœ›åˆ›å»ºä¸€ä¸ª æµ‹è¯•é›†ç¾¤ å¹¶åœ¨å¤šä¸ªæµ‹è¯•æ¡ˆä¾‹ä¸­é‡å¤ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨xUnitçš„ç±»æˆ–é›†åˆå¤¹å…·æ¥å®Œæˆæ­¤æ“ä½œ(è¯·å‚è§ https://xunit.github.io/docs/shared-context.html æ›´å¤šç»†èŠ‚)ã€‚ ä¸ºäº†åˆ†äº«ä¸€ä¸ª æµ‹è¯•é›†ç¾¤ åœ¨å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ä¹‹é—´ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ªå¤¹å…·ç±»å‹ï¼š public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } æ¥ä¸‹æ¥åˆ›å»ºä¸€ä¸ªé›†åˆå¤¹å…·ï¼š [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } æ‚¨ç°åœ¨å¯ä»¥é‡å¤ä½¿ç”¨ æµ‹è¯•é›†ç¾¤ åœ¨æ‚¨çš„æµ‹è¯•ç”¨ä¾‹ä¸­ï¼š using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); Assert.Equal(\"Hello, World\", greeting); } } } xUnitå°†è°ƒç”¨ å¤„ç† çš„æ–¹æ³• é›†ç¾¤å›ºå®š å½“æ‰€æœ‰æµ‹è¯•éƒ½å·²å®Œæˆå¹¶ä¸”åœ¨å†…å­˜ä¸­ç¾¤é›†å­¤å²›å°†åœæ­¢æ—¶ï¼Œè¯·é”®å…¥ã€‚ æµ‹è¯•é›†ç¾¤ ä¹Ÿæœ‰ä¸€ä¸ªæ¥å—çš„æ„é€ å‡½æ•° TestClusterOptions å¯ç”¨äºé…ç½®é›†ç¾¤ä¸­çš„å­¤å²›ã€‚ å¦‚æœæ‚¨åœ¨silosä¸­ä½¿ç”¨ä¾èµ–æ³¨å…¥æ¥ä½¿æœåŠ¡å¯ç”¨äºGrainsï¼Œåˆ™ä¹Ÿå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ¨¡å¼ï¼š public class ClusterFixture : IDisposable { public ClusterFixture() { var builder = new TestClusterBuilder(); builder.AddSiloBuilderConfigurator<TestSiloConfigurations>(); this.Cluster = builder.Build(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } public class TestSiloConfigurations : ISiloBuilderConfigurator { public void Configure(ISiloHostBuilder hostBuilder) { hostBuilder.ConfigureServices(services => { services.AddSingleton<T, Impl>(...); }); } } ä½¿ç”¨å˜²å¼„ Orleansè¿˜ä½¿æ¨¡æ‹Ÿç³»ç»Ÿçš„è®¸å¤šéƒ¨åˆ†æˆä¸ºå¯èƒ½ï¼Œå¹¶ä¸”åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œè¿™æ˜¯å¯¹grainsè¿›è¡Œå•å…ƒæµ‹è¯•çš„æœ€ç®€å•æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•ç¡®å®æœ‰å±€é™æ€§(ä¾‹å¦‚ï¼Œå›´ç»•è°ƒåº¦é‡å…¥å’Œåºåˆ—åŒ–)ï¼Œå¹¶ä¸”å¯èƒ½è¦æ±‚GrainåŒ…å«ä»…ç”±å•å…ƒæµ‹è¯•ä½¿ç”¨çš„ä»£ç ã€‚çš„ OrleansTestKit æä¾›äº†ä¸€ç§æ›¿ä»£æ–¹æ³•ï¼Œå¯ä»¥ç»•å¼€è®¸å¤šè¿™äº›é™åˆ¶ã€‚ ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸‹æˆ‘ä»¬æ­£åœ¨æµ‹è¯•çš„Grainsä¸å…¶ä»–Grainsç›¸äº’ä½œç”¨ã€‚ä¸ºäº†èƒ½å¤Ÿæ¨¡æ‹Ÿå…¶ä»–Grainsï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ¨¡æ‹Ÿ grainå·¥å‚ è¢«æµ‹Grainsçš„æˆå‘˜ã€‚é»˜è®¤ grainå·¥å‚ æ˜¯æ­£å¸¸çš„ å—ä¿æŠ¤çš„ å±æ€§ï¼Œä½†å¤§å¤šæ•°æ¨¡æ‹Ÿæ¡†æ¶è¦æ±‚å°†å±æ€§è®¾ç½®ä¸º ä¸Šå¸‚ å’Œ è™šæ‹Ÿ æ‰èƒ½å˜²ç¬‘ä»–ä»¬ã€‚æ‰€ä»¥æˆ‘ä»¬è¦åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯ grainå·¥å‚ éƒ½ ä¸Šå¸‚ å’Œ è™šæ‹Ÿ å±æ€§ï¼š public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Orleansè¿è¡Œæ—¶ä¹‹å¤–åˆ›å»ºGrainsï¼Œå¹¶ä½¿ç”¨æ¨¡æ‹Ÿæ¥æ§åˆ¶ grainå·¥å‚ ï¼š using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); worker .Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())) .Returns(journal.Object); await worker.DoWork(data) journal.Verify(x => x.Record(data), Times.Once()); } } } åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºå—æµ‹Grains å·¥äººç²® ï¼Œä½¿ç”¨Moqè¡¨ç¤ºæˆ‘ä»¬å¯ä»¥è¦†ç›– grainå·¥å‚ ä»¥ä¾¿å®ƒè¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿ IJournalGrain ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯æˆ‘ä»¬çš„ å·¥äººç²® ä¸ IJournalGrain å¦‚æˆ‘ä»¬æ‰€æ–™ã€‚"
  },
  "Documentation/tutorials_and_samples/MathGrains.html": {
    "href": "Documentation/tutorials_and_samples/MathGrains.html",
    "title": "MathGrains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "MathGrains å°†åŠŸèƒ½å°è£…åˆ°ä¸“ç”¨Grainä¸­çš„è®¡ç®—å™¨ã€‚"
  },
  "Documentation/tutorials_and_samples/Hello-World.html": {
    "href": "Documentation/tutorials_and_samples/Hello-World.html",
    "title": "Hello World | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä½ å¥½ï¼Œä¸–ç•Œ è¿è¡ŒHello Worldç¤ºä¾‹ è¿è¡Œæ­¤ç¤ºä¾‹çš„ä¸€ç§æ–¹æ³•æ˜¯ä»ä»¥ä¸‹ä½ç½®ä¸‹è½½HelloWorldçš„æœ¬åœ°å‰¯æœ¬ Samples / 2.0 / HelloWorld /æ–‡ä»¶å¤¹ ã€‚ æ‰“å¼€ä¸¤ä¸ªå‘½ä»¤æç¤ºç¬¦çª—å£ï¼Œç„¶ååœ¨æ¯ä¸ªçª—å£ä¸­å¯¼èˆªåˆ°HelloWorldæ–‡ä»¶å¤¹ã€‚ ç”Ÿæˆé¡¹ç›®ã€‚ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åœ¨ä¸€ä¸ªçª—å£ä¸­å¯åŠ¨silosï¼š dotnet run --project src\\SiloHost silosè¿è¡Œåï¼Œä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åœ¨å¦ä¸€ä¸ªçª—å£ä¸­å¯åŠ¨å®¢æˆ·ç«¯ï¼š dotnet run --project src\\OrleansClient silosçª—å£å’Œå®¢æˆ·ç«¯çª—å£å°†ç›¸äº’æ˜¾ç¤ºé—®å€™ã€‚ Orleansæ€ä¹ˆè¯´ åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œå®¢æˆ·ç«¯ä¸Grainsè¿æ¥ï¼Œå‘å…¶å‘é€é—®å€™å¹¶æ¥æ”¶å›é—®å€™ã€‚å®¢æˆ·ç„¶åæ‰“å°è¯¥é—®å€™ï¼Œä»…æ­¤è€Œå·²ã€‚ç†è®ºä¸Šå¾ˆç®€å•ï¼Œä½†æ˜¯ç”±äºæ¶‰åŠåˆ†å¸ƒï¼Œå› æ­¤è¿˜æœ‰æ›´å¤šå†…å®¹ã€‚ æ¶‰åŠå››ä¸ªé¡¹ç›®-ä¸€ä¸ªç”¨äºå£°æ˜Grainæ¥å£ï¼Œä¸€ä¸ªç”¨äºGrainå®ç°ï¼Œä¸€ä¸ªç”¨äºå®¢æˆ·ç«¯ï¼Œä¸€ä¸ªç”¨äºsilosä¸»æœºã€‚ IHello.csä¸­æœ‰ä¸€ä¸ªGrainsæ¥å£ï¼š public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } è¿™å¾ˆç®€å•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ‰€æœ‰å›å¤éƒ½å¿…é¡»è¡¨ç¤ºä¸ºä¸€ä¸ªä»»åŠ¡æˆ–ä¸€ä¸ªä»»åŠ¡ åœ¨é€šä¿¡æ¥å£ä¸­ã€‚åœ¨HelloGrain.csä¸­æ‰¾åˆ°çš„å®ç°ä¹Ÿå¾ˆç®€å•ï¼š public class HelloGrain : Orleans.Grain, HelloWorldInterfaces.IHello { Task<string> HelloWorldInterfaces.IHello.SayHello(string greeting) { return Task.FromResult($\"You said: '{greeting}', I say: Hello!\"); } } è¯¥ç±»ä»åŸºç±»ç»§æ‰¿ grain ï¼Œå¹¶å®ç°ä¹‹å‰å®šä¹‰çš„é€šä¿¡æ¥å£ã€‚ç”±äºæ²¡æœ‰ä»€ä¹ˆéœ€è¦ç­‰å¾…çš„Grainsï¼Œå› æ­¤ä¸ä¼šå£°æ˜è¯¥æ–¹æ³•asyncè€Œæ˜¯ä½¿ç”¨è¿”å›å€¼ Task.FromResult() ã€‚ ç¼–æ’Grainsä»£ç å¹¶åœ¨OrleansClienté¡¹ç›®ä¸­æ‰¾åˆ°çš„å®¢æˆ·ç«¯å¦‚ä¸‹æ‰€ç¤ºï¼š //configure the client with proper cluster options, logging and clustering client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); //connect the client to the cluster, in this case, which only contains one silo await client.Connect(); ... // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, my friend!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); SiloHosté¡¹ç›®ä¸­çš„silosä¸»æœº(ç”¨äºé…ç½®å’Œå¯åŠ¨silos)å¦‚ä¸‹æ‰€ç¤ºï¼š //define the cluster configuration var builder = new SiloHostBuilder() //configure the cluster with local host clustering .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureLogging(logging => logging.AddConsole()); //build the silo var host = builder.Build(); //start the silo await host.StartAsync();"
  },
  "Documentation/tutorials_and_samples/tutorial_1.html": {
    "href": "Documentation/tutorials_and_samples/tutorial_1.html",
    "title": "Tutorial One | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ•™ç¨‹ä¸€-åˆ›å»ºæœ€å°çš„Orleansåº”ç”¨ç¨‹åº æœ¬æ•™ç¨‹æä¾›æœ‰å…³åˆ›å»ºåŸºæœ¬è¿è¡Œçš„Orleansåº”ç”¨ç¨‹åºçš„é€æ­¥è¯´æ˜ã€‚å®ƒè¢«è®¾è®¡ä¸ºè‡ªåŒ…å«ä¸”æç®€çš„ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š å®ƒä»…ä¾èµ–NuGetè½¯ä»¶åŒ… å·²ä½¿ç”¨Orleans 2.2.0åœ¨Visual Studio 2017ä¸­è¿›è¡Œäº†æµ‹è¯• å®ƒä¸ä¾èµ–å¤–éƒ¨å­˜å‚¨ è¯·è®°ä½ï¼Œè¿™åªæ˜¯ä¸€ä¸ªæ•™ç¨‹ï¼Œç¼ºå°‘é€‚å½“çš„é”™è¯¯å¤„ç†å’Œå…¶ä»–å¯¹ç”Ÿäº§ç¯å¢ƒæœ‰ç”¨çš„ä¸œè¥¿ã€‚ä½†æ˜¯ï¼Œå®ƒåº”è¯¥å¸®åŠ©è¯»è€…çœŸæ­£äº†è§£Orleansçš„ç»“æ„ï¼Œå¹¶ä½¿ä»–ä»¬å°†ç»§ç»­å­¦ä¹ çš„é‡ç‚¹æ”¾åœ¨ä¸ä»–ä»¬æœ€ç›¸å…³çš„éƒ¨åˆ†ä¸Šã€‚ é¡¹ç›®è®¾ç½® åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†åˆ›å»º4ä¸ªé¡¹ç›®ï¼š ä¸€ä¸ªåŒ…å«Grainsæ¥å£çš„åº“ ä¸€ä¸ªåŒ…å«Grainsç±»çš„åº“ ä¸€ä¸ªæ§åˆ¶å°åº”ç”¨ç¨‹åºæ¥æ‰˜ç®¡æˆ‘ä»¬çš„silos ä¸€ä¸ªæ§åˆ¶å°åº”ç”¨ç¨‹åºæ¥æ‰˜ç®¡æˆ‘ä»¬çš„å®¢æˆ· éµå¾ªæœ¬æ•™ç¨‹ä¹‹åï¼Œå®Œæ•´çš„è§£å†³æ–¹æ¡ˆåº”å¦‚ä¸‹æ‰€ç¤ºï¼š åœ¨Visual Studioä¸­åˆ›å»ºç»“æ„ æ³¨æ„ï¼šæ‚¨å¯ä»¥åœ¨cï¼ƒä¸­ä¸ºè¿™äº›é¡¹ç›®ä¸­çš„æ¯ä¸ªé¡¹ç›®ä½¿ç”¨é»˜è®¤é¡¹ç›®ç±»å‹ã€‚æ‚¨å°†åœ¨ä¸‹é¢ä¸ºæ¯ä¸ªé¡¹ç›®æä¾›çš„ä»£ç æ›¿æ¢é»˜è®¤ä»£ç ã€‚æ‚¨å¯èƒ½è¿˜éœ€è¦æ·»åŠ  ä½¿ç”¨ é™ˆè¿°ã€‚ é¦–å…ˆåœ¨æ–°è§£å†³æ–¹æ¡ˆä¸­åˆ›å»ºä¸€ä¸ªæ§åˆ¶å°åº”ç”¨ç¨‹åº(.NET Core)é¡¹ç›®ã€‚è°ƒç”¨é¡¹ç›®éƒ¨åˆ† silos å¹¶å‘½åè§£å†³æ–¹æ¡ˆ Orleansä¸–ç•Œ ã€‚ æ·»åŠ å¦ä¸€ä¸ªæ§åˆ¶å°åº”ç”¨ç¨‹åº(.NET Core)é¡¹ç›®å¹¶å°†å…¶å‘½å å®¢æˆ· ã€‚ æ·»åŠ ä¸€ä¸ªç±»åº“(.NETæ ‡å‡†)å¹¶å‘½å grainsæ¥å£ ã€‚ æ·»åŠ å¦ä¸€ä¸ªç±»åº“(.NETæ ‡å‡†)å¹¶å‘½å Grains ã€‚ åˆ é™¤é»˜è®¤æºæ–‡ä»¶ ä»Grainsä¸­åˆ é™¤Class1.cs ä»GrainInterfacesåˆ é™¤Class1.cs æ·»åŠ å‚è€ƒ Grains å‚è€ƒèµ„æ–™ grainsæ¥å£ ã€‚ silos å‚è€ƒèµ„æ–™ grainsæ¥å£ å’Œ Grains ã€‚ å®¢æˆ· å‚è€ƒèµ„æ–™ grainsæ¥å£ ã€‚ æ·»åŠ OrleansNuGetè½¯ä»¶åŒ… åœ¨silosé¡¹ç›®ä¸­ï¼Œæ·»åŠ  å¾®è½¯OrleansæœåŠ¡å™¨ NuGetè½¯ä»¶åŒ…ã€‚ åœ¨å®¢æˆ·ç«¯é¡¹ç›®ä¸­ï¼Œæ·»åŠ  å¾®è½¯Orleanså®¢æˆ· NuGetè½¯ä»¶åŒ…ã€‚ åœ¨GrainInterfaceså’ŒGrainsé¡¹ç›®ä¸­ï¼Œæ·»åŠ  Microsoft.Orleans.Core.Abstractions å’Œ Microsoft.Orleans.CodeGenerator.MSBuild åŒ…ã€‚ åœ¨â€œGrainsâ€é¡¹ç›®ä¸­ï¼Œæ·»åŠ  Microsoft.Extensions.Logging.Abstractions ç”¨äºè®°å½•çš„è½¯ä»¶åŒ…ã€‚ åœ¨å®¢æˆ·å’Œsilosé¡¹ç›®ä¸­ï¼Œæ·»åŠ  Microsoft.Extensions.Logging.Console ï¼Œä»¥ä¾¿ä»–ä»¬å¯ä»¥åœ¨æ§åˆ¶å°çª—å£ä¸­æ‰“å°æ—¥å¿—ã€‚ å¾®è½¯OrleansæœåŠ¡å™¨ å’Œ å¾®è½¯Orleanså®¢æˆ· æ˜¯å…ƒè½¯ä»¶åŒ…ï¼Œå®ƒä»¬å¸¦æ¥äº†åœ¨siloså’Œå®¢æˆ·ç«¯æœ€å¯èƒ½éœ€è¦çš„ä¾èµ–å…³ç³»ã€‚ Microsoft.Orleans.Core.Abstractions åœ¨ä»»ä½•åœ°æ–¹éƒ½éœ€è¦ã€‚ä¸¤è€…éƒ½åŒ…å« å¾®è½¯OrleansæœåŠ¡å™¨ å’Œ å¾®è½¯Orleanså®¢æˆ· ã€‚ Microsoft.Orleans.CodeGenerator.MSBuild è‡ªåŠ¨ç”Ÿæˆè°ƒç”¨Grainsé€šè¿‡æœºå™¨è¾¹ç•Œæ‰€éœ€çš„ä»£ç ã€‚æ‰€ä»¥ä¸¤è€…éƒ½éœ€è¦ grainsæ¥å£ å’Œ Grains é¡¹ç›®ã€‚ å®šä¹‰grainsæ¥å£ åœ¨GrainInterfacesé¡¹ç›®ä¸­ï¼Œæ·»åŠ ä¸€ä¸ª IHello.cs ä»£ç æ–‡ä»¶ï¼Œå¹¶åœ¨å…¶ä¸­å®šä¹‰ä»¥ä¸‹IHelloæ¥å£ï¼š using System.Threading.Tasks; namespace OrleansBasics { public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } } å®šä¹‰Grainsç­‰çº§ åœ¨Grainsé¡¹ç›®ä¸­ï¼Œæ·»åŠ ä¸€ä¸ª HelloGrain.cs ä»£ç æ–‡ä»¶ï¼Œå¹¶åœ¨å…¶ä¸­å®šä¹‰ä»¥ä¸‹ç±»ï¼š using Microsoft.Extensions.Logging; using System.Threading.Tasks; namespace OrleansBasics { public class HelloGrain : Orleans.Grain, IHello { private readonly ILogger logger; public HelloGrain(ILogger<HelloGrain> logger) { this.logger = logger; } Task<string> IHello.SayHello(string greeting) { logger.LogInformation($\"\\n SayHello message received: greeting = '{greeting}'\"); return Task.FromResult($\"\\n Client said: '{greeting}', so HelloGrain says: Hello!\"); } } } åˆ›å»ºsilosâ€“ Program.cs åœ¨è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬æ·»åŠ ä»£ç ä»¥åˆå§‹åŒ–å°†æ‰˜ç®¡å’Œè¿è¡Œæˆ‘ä»¬çš„Grainsçš„æœåŠ¡å™¨-silosã€‚æˆ‘ä»¬å°†åœ¨æ­¤å¤„ä½¿ç”¨å¼€å‘ç¾¤é›†æä¾›ç¨‹åºï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åœ¨æœ¬åœ°è¿è¡Œæ‰€æœ‰å†…å®¹ï¼Œè€Œæ— éœ€ä¾èµ–å¤–éƒ¨å­˜å‚¨ç³»ç»Ÿã€‚æ‚¨å¯ä»¥åœ¨ æœ¬åœ°å¼€å‘é…ç½® Orleansæ–‡æ¡£çš„é¡µé¢ã€‚æˆ‘ä»¬å°†åœ¨å…¶ä¸­è¿è¡Œå¸¦æœ‰å•ä¸ªsilosçš„é›†ç¾¤ã€‚ å°†ä»¥ä¸‹ä»£ç æ·»åŠ åˆ°Siloé¡¹ç›®çš„Program.csä¸­ï¼š using System; using System.Threading.Tasks; using Microsoft.Extensions.Logging; using Orleans; using Orleans.Configuration; using Orleans.Hosting; namespace OrleansBasics { public class Program { public static int Main(string[] args) { return RunMainAsync().Result; } private static async Task<int> RunMainAsync() { try { var host = await StartSilo(); Console.WriteLine(\"\\n\\n Press Enter to terminate...\\n\\n\"); Console.ReadLine(); await host.StopAsync(); return 0; } catch (Exception ex) { Console.WriteLine(ex); return 1; } } private static async Task<ISiloHost> StartSilo() { // define the cluster configuration var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"OrleansBasics\"; }) .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences()) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } } åˆ›å»ºå®¢æˆ·ç«¯â€“ Program.cs æœ€åï¼Œæˆ‘ä»¬éœ€è¦é…ç½®ä¸€ä¸ªå®¢æˆ·ç«¯ä¸æˆ‘ä»¬çš„Grainsè¿›è¡Œé€šä¿¡ï¼Œå°†å…¶è¿æ¥åˆ°é›†ç¾¤(å…¶ä¸­æœ‰ä¸€ä¸ªsilos)ï¼Œç„¶åè°ƒç”¨Grainsã€‚è¯·æ³¨æ„ï¼Œç¾¤é›†é…ç½®å¿…é¡»ä¸æˆ‘ä»¬ç”¨äºsilosçš„é…ç½®åŒ¹é…ã€‚æœ‰å…³å®¢æˆ·ç«¯çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ é›†ç¾¤å’Œå®¢æˆ· Orleansæ–‡æ¡£ä¸­çš„éƒ¨åˆ†ã€‚ using Microsoft.Extensions.Logging; using Orleans; using Orleans.Configuration; using System; using System.Threading.Tasks; namespace OrleansBasics { public class Program { static int Main(string[] args) { return RunMainAsync().Result; } private static async Task<int> RunMainAsync() { try { using (var client = await ConnectClient()) { await DoClientWork(client); Console.ReadKey(); } return 0; } catch (Exception e) { Console.WriteLine($\"\\nException while trying to run client: {e.Message}\"); Console.WriteLine(\"Make sure the silo the client is trying to connect to is running.\"); Console.WriteLine(\"\\nPress any key to exit.\"); Console.ReadKey(); return 1; } } private static async Task<IClusterClient> ConnectClient() { IClusterClient client; client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"OrleansBasics\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); await client.Connect(); Console.WriteLine(\"Client successfully connected to silo host \\n\"); return client; } private static async Task DoClientWork(IClusterClient client) { // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, HelloGrain!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); } } } è¿è¡Œåº”ç”¨ç¨‹åº æ„å»ºè§£å†³æ–¹æ¡ˆå¹¶è¿è¡Œsilosã€‚åœ¨æ”¶åˆ°ç¡®è®¤ä¿¡æ¯åï¼Œè¡¨ç¤ºæ­£åœ¨è¿è¡Œsilos(â€œæŒ‰Enteré”®ä»¥ç»ˆæ­¢...â€)ï¼Œç„¶åè¿è¡Œå®¢æˆ·ç«¯ã€‚æˆåŠŸçœ‹èµ·æ¥åƒè¿™æ ·ï¼š è¿›ä¸€æ­¥é˜…è¯» OrleansåŒ…æ¸…å• Orleansé…ç½®æŒ‡å— Orleansæœ€ä½³å®è·µ"
  },
  "Documentation/tutorials_and_samples/index.html": {
    "href": "Documentation/tutorials_and_samples/index.html",
    "title": "Samples Overview | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è®²è§£ æ•™ç¨‹1ï¼šOrleansåŸºç¡€çŸ¥è¯† æ•™ç¨‹1æŒ‡å¯¼æ‚¨å®Œæˆåˆ›å»ºç»“æ„å¹¶è®¾ç½®ç¬¬ä¸€ä¸ªOrleansåº”ç”¨ç¨‹åºçš„åŒ…å’Œå‚è€ƒçš„æ­¥éª¤ã€‚ æ ·å“ ä½ éœ€è¦ä»€ä¹ˆ é™¤éå¦æœ‰è¯´æ˜ï¼Œå¦åˆ™æ ·å“å‡ä¸ºè‡ªå¤‡æ ·å“ã€‚å¯¹äºæŸäº›ç¤ºä¾‹ï¼Œæ‚¨å¯èƒ½éœ€è¦Azureè®¢é˜…ã€‚å¯¹äºåŸºäºAzureçš„ç¤ºä¾‹ï¼Œæ‚¨å°†éœ€è¦å®‰è£…SDKã€‚ å¯ä»¥ä»ä»¥ä¸‹ä½ç½®ä¸‹è½½æ ·æœ¬ çš„GitHub ã€‚ ä½ å¥½ï¼Œä¸–ç•Œ ç»å…¸çš„Hello Worldåº”ç”¨ç¨‹åºçš„Orleansç‰ˆæœ¬ã€‚è¿™è¡¨æ˜åœ¨å¤„ç†åˆ†å¸ƒå¼è®¡ç®—æ—¶ï¼Œè™½ç„¶æ²¡æœ‰â€œçç¢â€çš„äº‹æƒ…ï¼Œä½†Orleansä½¿å®ƒå˜å¾—ç›´æˆªäº†å½“ã€‚ MathGrains è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨Orleansæ ¸å¿ƒç»„ä»¶å°è£…åŠŸèƒ½çš„ç®€å•è®¡ç®—å™¨ã€‚ å†’é™© åœ¨æ²¡æœ‰å›¾å½¢ç”¨æˆ·æ¥å£ä¹‹å‰ï¼Œåœ¨æ¸¸æˆæœºå’Œå¤§å‹å¤šäººæ¸¸æˆæ—¶ä»£ä¹‹å‰ï¼Œæœ‰VT100ç»ˆç«¯ï¼Œå¹¶ä¸”æœ‰ å·¨å¤§çš„æ´ç©´å†’é™© ã€‚æŒ‰ç…§ä»Šå¤©çš„æ ‡å‡†ï¼Œè¿™å¯èƒ½æ˜¯laè„šçš„ï¼Œé‚£æ—¶å€™æ˜¯ä¸€ä¸ªç¥å¥‡çš„ä¸–ç•Œï¼Œé‡Œé¢æœ‰æ€ªç‰©ã€,å«çš„é¸Ÿä»¥åŠå¯ä»¥æ¡åˆ°çš„ä¸œè¥¿ã€‚è¿™æ˜¯æ­¤ç¤ºä¾‹çš„çµæ„Ÿã€‚"
  },
  "Documentation/deployment/multi-cluster_support/MultiClusterConfiguration.html": {
    "href": "Documentation/deployment/multi-cluster_support/MultiClusterConfiguration.html",
    "title": "Multi-Cluster Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤šç¾¤é›†é…ç½® å¤šç¾¤é›†é…ç½®ç¡®å®šå“ªäº›ç¾¤é›†å½“å‰æ˜¯å¤šç¾¤é›†çš„ä¸€éƒ¨åˆ†ã€‚å®ƒä¸ä¼šè‡ªåŠ¨æ›´æ”¹ï¼Œä½†ç”±æ“ä½œå‘˜æ§åˆ¶ã€‚å› æ­¤ï¼Œå®ƒä¸é›†ç¾¤ä¸­ä½¿ç”¨çš„æˆå‘˜æœºåˆ¶æœ‰å¾ˆå¤§ä¸åŒï¼Œåè€…è‡ªåŠ¨ç¡®å®šé›†ç¾¤ä¸­çš„ä¸€ç»„silosã€‚ æˆ‘ä»¬å¯¹æœåŠ¡ä¸­çš„é›†ç¾¤ä½¿ç”¨ä»¥ä¸‹æœ¯è¯­ï¼š é›†ç¾¤æ˜¯ ç§¯æçš„ å¦‚æœå®ƒè‡³å°‘æœ‰ä¸€ä¸ªæ´»åŠ¨silosï¼Œå¹¶ä¸” ä¸æ´»åŠ¨ å¦åˆ™ é›†ç¾¤æ˜¯ åŠ å…¥ å¦‚æœå®ƒæ˜¯å½“å‰å¤šç¾¤é›†é…ç½®çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸” æœªè¿æ¥ å¦åˆ™ æ´»åŠ¨/éæ´»åŠ¨ä¸è¿æ¥/éè¿æ¥æ˜¯ç‹¬ç«‹çš„ï¼šæ‰€æœ‰å››ç§ç»„åˆéƒ½æ˜¯å¯èƒ½çš„ã€‚ ç‰¹å®šæœåŠ¡çš„æ‰€æœ‰é›†ç¾¤éƒ½é€šè¿‡ å…«å¦ç½‘ æ˜¯çš„ã€‚å…«å¦ç½‘ä¼ æ’­é…ç½®å’ŒçŠ¶æ€ä¿¡æ¯ã€‚ æ³¨å…¥é…ç½® è¿è¥å•†é€šè¿‡å°†é…ç½®æ›´æ”¹æ³¨å…¥å¤šé›†ç¾¤ç½‘ç»œæ¥å‘å¸ƒé…ç½®æ›´æ”¹ã€‚é…ç½®å¯ä»¥æ³¨å…¥åˆ°ä»»ä½•é›†ç¾¤ä¸­ï¼Œå¹¶ä»é‚£é‡Œæ‰©å±•åˆ°æ‰€æœ‰æ´»åŠ¨é›†ç¾¤ã€‚æ¯ä¸ªæ–°é…ç½®éƒ½åŒ…å«ä¸€ä¸ªç»„æˆå¤šé›†ç¾¤çš„é›†ç¾¤idåˆ—è¡¨ã€‚å®ƒè¿˜æœ‰ä¸€ä¸ªUTCæ—¶é—´æˆ³ï¼Œç”¨äºè·Ÿè¸ªå®ƒåœ¨å…«å¦ç½‘ä¸­çš„ä¼ æ’­ã€‚ æœ€åˆï¼Œå¤šé›†ç¾¤é…ç½®ä¸ºç©ºï¼Œè¿™æ„å‘³ç€å¤šé›†ç¾¤åˆ—è¡¨ä¸ºç©º(ä¸åŒ…å«é›†ç¾¤)ã€‚å› æ­¤ï¼Œæ“ä½œå‘˜ å¿…é¡» æœ€åˆæ³¨å…¥å¤šç¾¤é›†é…ç½®ã€‚ä¸€æ—¦æ³¨å…¥ï¼Œæ­¤é…ç½®å°†åœ¨æ‰€æœ‰è¿æ¥çš„silos(è¿è¡Œæ—¶)å’Œæ‰€æœ‰æŒ‡å®šçš„å…«å¦é¢‘é“(å¦‚æœè¿™äº›é¢‘é“æ˜¯æŒä¹…çš„)ä¸­æŒç»­å­˜åœ¨ã€‚ æˆ‘ä»¬å¯¹æ³¨å…¥æ–°é…ç½®æå‡ºäº†ä¸€äº›é™åˆ¶ï¼Œæ“ä½œå‘˜å¿…é¡»éµå®ˆè¿™äº›é™åˆ¶ï¼š æ¯ä¸ªæ–°é…ç½®éƒ½å¯ä»¥æ·»åŠ å¤šä¸ªé›†ç¾¤ï¼Œæˆ–åˆ é™¤å¤šä¸ªé›†ç¾¤(ä½†ä¸èƒ½åŒæ—¶åˆ é™¤è¿™ä¸¤ä¸ªé›†ç¾¤)ã€‚ åœ¨ä»åœ¨å¤„ç†ä»¥å‰çš„é…ç½®æ›´æ”¹æ—¶ï¼Œæ“ä½œå‘˜ä¸åº”å‘å¸ƒæ–°é…ç½®ã€‚ è¿™äº›é™åˆ¶ç¡®ä¿è¯¸å¦‚å•å®ä¾‹åè®®ä¹‹ç±»çš„åè®®å¯ä»¥æ­£ç¡®åœ°ç»´æŠ¤æ¿€æ´»çš„äº’æ–¥ï¼Œå³ä½¿åœ¨é…ç½®æ›´æ”¹çš„æƒ…å†µä¸‹ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ ç»ç®¡ç²® ä½¿ç”¨Orleansç®¡ç†Grainï¼Œå¯ä»¥åœ¨ä»»ä½•é›†ç¾¤ä¸­çš„ä»»ä½•èŠ‚ç‚¹ä¸Šæ³¨å…¥å¤šé›†ç¾¤é…ç½®ã€‚ä¾‹å¦‚ï¼Œè¦æ³¨å…¥ç”±ä¸‰ä¸ªé›†ç¾¤{us1ã€eu1ã€us2}ç»„æˆçš„å¤šé›†ç¾¤é…ç½®ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç®¡ç†Grainä¼ é€’ä¸€ä¸ªå¯æšä¸¾çš„å­—ç¬¦ä¸²ï¼š var clusterlist = \"us1,eu1,us2\".Split(','); var mgtGrain = client.GetGrain<IManagementGrain>(0); mgtGrain.InjectMultiClusterConfiguration(clusterlist, \"my comment here\")); ç¬¬ä¸€ä¸ªè®ºç‚¹ æ³¨å…¥å¤šç¾¤é›†é…ç½® æ˜¯ç¾¤é›†IDçš„å¯æšä¸¾é¡¹ï¼Œå®ƒå°†å®šä¹‰æ–°çš„å¤šç¾¤é›†é…ç½®ã€‚ç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ª(å¯é€‰)æ³¨é‡Šå­—ç¬¦ä¸²ï¼Œå¯ç”¨äºç”¨ä»»æ„ä¿¡æ¯æ ‡è®°é…ç½®ï¼Œä¾‹å¦‚è°æ³¨å…¥äº†é…ç½®çš„åŸå› ã€‚ æœ‰ä¸€ä¸ªå¯é€‰çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œä¸€ä¸ªåä¸º ç¬¬ä¸€æ¬¡æ£€æŸ¥ ï¼Œé»˜è®¤ä¸ºtrueã€‚è¿™æ„å‘³ç€ç³»ç»Ÿå°†å°½æœ€å¤§åŠªåŠ›æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•siloså°šæœªèµ¶ä¸Šå½“å‰é…ç½®ï¼Œå¦‚æœå‘ç°æ­¤ç±»silosï¼Œåˆ™æ‹’ç»æ›´æ”¹ã€‚è¿™æœ‰åŠ©äºæ£€æµ‹è¿åé™åˆ¶çš„æƒ…å†µï¼Œå³ä¸€æ¬¡åªèƒ½æŒ‚èµ·ä¸€ä¸ªé…ç½®æ›´æ”¹(å°½ç®¡åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½ä¸èƒ½ä¿è¯)ã€‚ é€šè¿‡é»˜è®¤é…ç½® åœ¨é¢„å…ˆçŸ¥é“å¤šé›†ç¾¤é…ç½®å¹¶ä¸”æ¯æ¬¡éƒ¨ç½²éƒ½æ˜¯æ–°çš„(ä¾‹å¦‚ä¸ºäº†æµ‹è¯•)çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›æä¾›é»˜è®¤é…ç½®ã€‚å…¨å±€é…ç½®æ”¯æŒå¯é€‰å±æ€§ é»˜è®¤å¤šç¾¤é›† å®ƒé‡‡ç”¨ä»¥é€—å·åˆ†éš”çš„ç¾¤é›†IDåˆ—è¡¨ï¼š var silo = new SiloHostBuilder() [...] .Configure<MultiClusterOptions>(options => { [...] options.DefaultMultiCluster = new[] { \"us1\", \"eu1\", \"us2\" }; [...] }) [...] ä½¿ç”¨æ­¤è®¾ç½®å¯åŠ¨silosåï¼Œå®ƒå°†æ£€æŸ¥å½“å‰å¤šç¾¤é›†é…ç½®æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ™å°†ç»™å®šé…ç½®æ³¨å…¥å½“å‰UTCæ—¶é—´æˆ³ã€‚ è­¦å‘Šã€‚æŒä¹…çš„å¤šé›†ç¾¤å…«å¦é¢‘é“(ä¾‹å¦‚ï¼ŒåŸºäºazuretable)ä¿ç•™ä¸Šæ¬¡æ³¨å…¥çš„é…ç½®ï¼Œé™¤éå®ƒä»¬è¢«æ˜¾å¼åˆ é™¤ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒæŒ‡å®šDefaultMultiClusteråœ¨é‡æ–°éƒ¨ç½²ç¾¤é›†æ—¶ä¸èµ·ä½œç”¨ï¼Œå› ä¸ºå­˜å‚¨åœ¨å…«å¦é¢‘é“ä¸­çš„é…ç½®ä¸ä¸ºç©ºã€‚> é€šè¿‡å…«å¦é¢‘é“ æ“ä½œå‘˜è¿˜å¯ä»¥å°†é…ç½®ç›´æ¥æ³¨å…¥å…«å¦é¢‘é“ã€‚é¢‘é“ä¸­çš„å˜åŒ–ä¼šè¢«å‘¨æœŸæ€§çš„èƒŒæ™¯å…«å¦è‡ªåŠ¨æ‹¾å–å’Œä¼ æ’­ï¼Œå°½ç®¡å¯èƒ½éå¸¸ç¼“æ…¢(ä½¿ç”¨ç®¡ç†Grainè¦å¿«å¾—å¤š)ã€‚å¯¹ä¼ æ’­æ—¶é—´çš„ç²—ç•¥ä¼°è®¡æ˜¯30ç§’(æˆ–å…¨å±€é…ç½®ä¸­æŒ‡å®šçš„ä»»ä½•å…«å¦é—´éš”)ä¹˜ä»¥æ‰€æœ‰é›†ç¾¤ä¸­silosæ€»æ•°çš„äºŒè¿›åˆ¶å¯¹æ•°ã€‚ä½†æ˜¯ï¼Œç”±äºå…«å¦å¯¹æ˜¯éšæœºé€‰æ‹©çš„ï¼Œæ‰€ä»¥å®ƒå¯ä»¥å¿«å¾—å¤šï¼Œä¹Ÿå¯ä»¥æ…¢å¾—å¤šã€‚ å¦‚æœä½¿ç”¨åŸºäºazureè¡¨çš„å…«å¦é¢‘é“ï¼Œè¿è¥å•†åªéœ€åœ¨ Orleanså¯è¡Œ ï¼Œä¾‹å¦‚ï¼Œä½¿ç”¨æŸäº›å·¥å…·ç¼–è¾‘azureè¡¨ä¸­çš„æ•°æ®ã€‚é…ç½®è®°å½•çš„æ ¼å¼å¦‚ä¸‹ï¼š å§“å ç±»å‹ ä»·å€¼ åˆ†åŒºé”® å­—ç¬¦ä¸² æœåŠ¡ID è¡Œé”® å­—ç¬¦ä¸² â€œé…ç½®â€ é›†ç¾¤ å­—ç¬¦ä¸² ç¾¤é›†IDçš„é€—å·åˆ†éš”åˆ—è¡¨ï¼Œä¾‹å¦‚â€œus1ã€eu1ã€us2â€ è¯„è®º å­—ç¬¦ä¸² å¯é€‰æ³¨é‡Š æ£‰çº±å°èŠ± æ—¥æœŸæ—¶é—´ é…ç½®çš„UTCæ—¶é—´æˆ³ æ³¨æ„ æ˜¯å•Šã€‚åœ¨å­˜å‚¨å™¨ä¸­ç¼–è¾‘æ­¤è®°å½•æ—¶ï¼Œgossipttimestampä¹Ÿå¿…é¡»è®¾ç½®ä¸ºæ¯”å½“å‰æ›´æ–°çš„å€¼(å¦åˆ™å°†å¿½ç•¥æ›´æ”¹)ã€‚æœ€æ–¹ä¾¿å’Œæ¨èçš„æ–¹æ³•æ˜¯ åˆ é™¤gossipttimestampå­—æ®µ -ç„¶åï¼Œæˆ‘ä»¬çš„gossipé€šé“å®ç°ä¼šè‡ªåŠ¨å°†å…¶æ›¿æ¢ä¸ºæ­£ç¡®çš„å½“å‰æ—¶é—´æˆ³(å®ƒä½¿ç”¨azureè¡¨æ—¶é—´æˆ³)ã€‚ ç¾¤é›†æ·»åŠ /åˆ é™¤è¿‡ç¨‹ ä»å¤šé›†ç¾¤ä¸­æ·»åŠ æˆ–åˆ é™¤é›†ç¾¤é€šå¸¸éœ€è¦åœ¨ä¸€äº›æ›´å¤§çš„ä¸Šä¸‹æ–‡ä¸­è¿›è¡Œåè°ƒã€‚æˆ‘ä»¬å»ºè®®åœ¨ä»å¤šç¾¤é›†æ·»åŠ /åˆ é™¤ç¾¤é›†æ—¶å§‹ç»ˆéµå¾ªä»¥ä¸‹æ­¥éª¤ã€‚ æ·»åŠ ç¾¤é›†çš„è¿‡ç¨‹ å¯åŠ¨ä¸€ä¸ªæ–°Orleansé›†ç¾¤ï¼Œç­‰å¾…æ‰€æœ‰siloséƒ½å¯åŠ¨å¹¶è¿è¡Œã€‚ æ’å…¥åŒ…å«æ–°ç¾¤é›†çš„é…ç½®ã€‚ å¼€å§‹å°†ç”¨æˆ·è¯·æ±‚è·¯ç”±åˆ°æ–°ç¾¤é›†ã€‚ åˆ é™¤ç¾¤é›†çš„è¿‡ç¨‹ åœæ­¢å°†æ–°ç”¨æˆ·è¯·æ±‚è·¯ç”±åˆ°ç¾¤é›†ã€‚ æ’å…¥ä¸å†åŒ…å«ç¾¤é›†çš„é…ç½®ã€‚ åœæ­¢ç¾¤é›†çš„æ‰€æœ‰silosã€‚ ä»¥è¿™ç§æ–¹å¼åˆ é™¤ç¾¤é›†åï¼Œå¯ä»¥æŒ‰ç…§æ·»åŠ æ–°ç¾¤é›†çš„è¿‡ç¨‹é‡æ–°æ·»åŠ å®ƒã€‚ éè¿æ¥ç¾¤é›†ä¸Šçš„æ´»åŠ¨ åœ¨ç¾¤é›†å¤„äºæ´»åŠ¨çŠ¶æ€å’Œæœªè¿æ¥çŠ¶æ€æ—¶ï¼Œå¯èƒ½ä¼šæœ‰çŸ­æš‚çš„ä¸´æ—¶æ—¶é—´æ®µï¼š æ–°å¯åŠ¨çš„é›†ç¾¤å¯èƒ½åœ¨è¿›å…¥å¤šé›†ç¾¤é…ç½®ä¹‹å‰(åœ¨æ·»åŠ é›†ç¾¤çš„è¿‡ç¨‹çš„æ­¥éª¤1å’Œæ­¥éª¤2ä¹‹é—´)å¼€å§‹æ‰§è¡Œä»£ç ã€‚ æ­£åœ¨åœç”¨çš„ç¾¤é›†åœ¨å…³é—­silosä¹‹å‰(åœ¨åˆ é™¤ç¾¤é›†çš„è¿‡ç¨‹çš„æ­¥éª¤2å’Œæ­¥éª¤3ä¹‹é—´)ä»å¯ä»¥æ‰§è¡Œä»£ç ã€‚ åœ¨è¿™äº›ä¸­é—´æƒ…å†µä¸‹ï¼Œå¯èƒ½å‡ºç°ä»¥ä¸‹æƒ…å†µï¼š å¯¹äºå…¨å±€å•å®ä¾‹grainsï¼šgrainså¯èƒ½åœ¨æœªè¿æ¥çš„é›†ç¾¤ä¸Šå…·æœ‰é‡å¤æ¿€æ´»ã€‚ å¯¹äºå·²ç‰ˆæœ¬åŒ–çš„grainsï¼šå½“grainsçŠ¶æ€æ›´æ”¹æ—¶ï¼Œæœªè¿æ¥ç¾¤é›†ä¸Šçš„æ¿€æ´»ä¸ä¼šæ”¶åˆ°é€šçŸ¥ã€‚"
  },
  "Documentation/deployment/multi-cluster_support/GossipChannels.html": {
    "href": "Documentation/deployment/multi-cluster_support/GossipChannels.html",
    "title": "Multi-Cluster Communication | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤šé›†ç¾¤é€šä¿¡ ç½‘ç»œçš„é…ç½®å¿…é¡»ä½¿ä»»ä½•Orleanssiloséƒ½å¯ä»¥é€šè¿‡TCP/IPè¿æ¥åˆ°ä»»ä½•å…¶ä»–Orleanssilosï¼Œè€Œä¸ç®¡å®ƒä½äºä¸–ç•Œçš„å“ªä¸ªä½ç½®ã€‚å…·ä½“å¦‚ä½•å®ç°è¿™ä¸€ç‚¹ä¸åœ¨Orleansçš„èŒƒå›´å†…ï¼Œå› ä¸ºè¿™å–å†³äºsilosçš„éƒ¨ç½²æ–¹å¼å’Œåœ°ç‚¹ã€‚ ä¾‹å¦‚ï¼Œåœ¨windows azureä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨vnetsè¿æ¥ä¸€ä¸ªåŒºåŸŸå†…çš„å¤šä¸ªéƒ¨ç½²ï¼Œå¹¶ä½¿ç”¨ç½‘å…³è¿æ¥ä¸åŒåŒºåŸŸçš„vnetsã€‚ ç¾¤é›†ID æ¯ä¸ªç¾¤é›†éƒ½æœ‰è‡ªå·±å”¯ä¸€çš„ç¾¤é›†IDã€‚å¿…é¡»åœ¨å…¨å±€é…ç½®ä¸­æŒ‡å®šç¾¤é›†IDã€‚ ç¾¤é›†IDä¸èƒ½ä¸ºç©ºï¼Œä¹Ÿä¸èƒ½åŒ…å«é€—å·ã€‚æ­¤å¤–ï¼Œå¦‚æœä½¿ç”¨azureè¡¨å­˜å‚¨ï¼Œåˆ™ç¾¤é›†IDä¸èƒ½åŒ…å«è¡Œé”®(/ï¼Œ\\ï¼Œï¼Œï¼Ÿ)æ‰€ç¦æ­¢çš„å­—ç¬¦ã€‚æ˜¯çš„ã€‚ æˆ‘ä»¬å»ºè®®å¯¹é›†ç¾¤idä½¿ç”¨éå¸¸çŸ­çš„å­—ç¬¦ä¸²ï¼Œå› ä¸ºé›†ç¾¤idç»å¸¸ä¼ è¾“ï¼Œå¹¶ä¸”å¯èƒ½ç”±ä¸€äº›æ—¥å¿—è§†å›¾æä¾›ç¨‹åºå­˜å‚¨åœ¨å­˜å‚¨å™¨ä¸­ã€‚ ç¾¤é›†ç½‘å…³ æ¯ä¸ªé›†ç¾¤éƒ½ä¼šè‡ªåŠ¨æŒ‡å®šå…¶æ´»åŠ¨silosçš„ä¸€ä¸ªå­é›†ä½œä¸º ç¾¤é›†ç½‘å…³ æ˜¯çš„ã€‚ç¾¤é›†ç½‘å…³ç›´æ¥å‘å…¶ä»–ç¾¤é›†å…¬å¸ƒå…¶IPåœ°å€ï¼Œå› æ­¤å¯ä»¥å……å½“â€œç¬¬ä¸€è”ç³»äººâ€ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæœ€å¤š10ä¸ªsilos(æˆ–é…ç½®ä¸º MaxMultiClusterGatewaysç³»åˆ— )è¢«æŒ‡å®šä¸ºç¾¤é›†ç½‘å…³ã€‚ ä¸åŒé›†ç¾¤ä¸­çš„silosä¹‹é—´çš„é€šä¿¡ ä¸ æ€»æ˜¯ç»è¿‡ä¸€ä¸ªå…³å£ã€‚ä¸€æ—¦ä¸€ä¸ªsilosçŸ¥é“å¹¶ç¼“å­˜äº†ä¸€ä¸ªGrainsæ¿€æ´»çš„ä½ç½®(æ— è®ºåœ¨å“ªä¸ªé›†ç¾¤ä¸­)ï¼Œå®ƒå°±ç›´æ¥å‘è¯¥siloså‘é€æ¶ˆæ¯ï¼Œå³ä½¿silosä¸æ˜¯é›†ç¾¤ç½‘å…³ã€‚ å…«å¦ gossipæ˜¯é›†ç¾¤å…±äº«é…ç½®å’ŒçŠ¶æ€ä¿¡æ¯çš„æœºåˆ¶ã€‚é¡¾åæ€ä¹‰ï¼Œå…«å¦æ˜¯åˆ†æ•£çš„ã€åŒå‘çš„ï¼šæ¯ä¸ªsilosç›´æ¥ä¸å…¶ä»–silosé€šä¿¡ï¼Œæ— è®ºæ˜¯åœ¨åŒä¸€ä¸ªé›†ç¾¤ä¸­è¿˜æ˜¯åœ¨å…¶ä»–é›†ç¾¤ä¸­ï¼Œä»¥ä¾¿åœ¨ä¸¤ä¸ªæ–¹å‘ä¸Šäº¤æ¢ä¿¡æ¯ã€‚ å†…å®¹ æ˜¯çš„ã€‚å…«å¦åŒ…å«ä»¥ä¸‹éƒ¨åˆ†æˆ–å…¨éƒ¨ä¿¡æ¯ï¼š å½“å‰æ—¶é—´æˆ³ å¤šç¾¤é›†é…ç½® æ˜¯çš„ã€‚ åŒ…å«æœ‰å…³ç¾¤é›†ç½‘å…³ä¿¡æ¯çš„å­—å…¸ã€‚å¯†é’¥æ˜¯silosåœ°å€ï¼Œè¯¥å€¼åŒ…å«(1)æ—¶é—´æˆ³ï¼Œ(2)ç¾¤é›†IDå’Œ(3)çŠ¶æ€ï¼ŒçŠ¶æ€å¯ä»¥æ˜¯æ´»åŠ¨çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯éæ´»åŠ¨çš„ã€‚ å¿«é€Ÿå’Œæ…¢é€Ÿä¼ æ’­ æ˜¯çš„ã€‚å½“ç½‘å…³æ›´æ”¹å…¶çŠ¶æ€ï¼Œæˆ–å½“æ“ä½œå‘˜æ³¨å…¥æ–°é…ç½®æ—¶ï¼Œæ­¤å…«å¦ä¿¡æ¯å°†ç«‹å³å‘é€åˆ°æ‰€æœ‰silosã€é›†ç¾¤å’Œå…«å¦é¢‘é“ã€‚è¿™ç§æƒ…å†µå‘ç”Ÿå¾—å¾ˆå¿«ï¼Œä½†å¹¶ä¸å¯é ã€‚å¦‚æœæ¶ˆæ¯ç”±äºä»»ä½•åŸå› (å¦‚ç«äº‰ã€å¥—æ¥å­—ä¸­æ–­ã€silosæ•…éšœ)è€Œä¸¢å¤±ï¼Œæˆ‘ä»¬å®šæœŸçš„èƒŒæ™¯å…«å¦ä¼šç¡®ä¿ä¿¡æ¯æœ€ç»ˆä¼ æ’­ï¼Œå°½ç®¡ä¼ æ’­é€Ÿåº¦ä¼šæ›´æ…¢ã€‚æ‰€æœ‰ä¿¡æ¯æœ€ç»ˆéƒ½ä¼šåœ¨ä»»ä½•åœ°æ–¹ä¼ æ’­ï¼Œå¹¶ä¸”å¯¹å¶å°”çš„æ¶ˆæ¯ä¸¢å¤±å’Œå¤±è´¥å…·æœ‰å¾ˆå¼ºçš„å¼¹æ€§ã€‚ æ‰€æœ‰å…«å¦æ•°æ®éƒ½æœ‰æ—¶é—´æˆ³ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿æ›´æ–°çš„ä¿¡æ¯æ›¿æ¢æ—§çš„ä¿¡æ¯ï¼Œè€Œä¸ç®¡æ¶ˆæ¯çš„ç›¸å¯¹æ—¶é—´ã€‚ä¾‹å¦‚ï¼Œè¾ƒæ–°çš„å¤šç¾¤é›†é…ç½®æ›¿æ¢è¾ƒæ—§çš„é…ç½®ï¼Œè€Œæœ‰å…³ç½‘å…³çš„è¾ƒæ–°ä¿¡æ¯æ›¿æ¢æœ‰å…³è¯¥ç½‘å…³çš„è¾ƒæ—§ä¿¡æ¯ã€‚æœ‰å…³å…«å¦æ•°æ®è¡¨ç¤ºçš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ å¤šç°‡æ•°æ® ä¸Šè¯¾ã€‚å®ƒæœ‰ä¸€ä¸ª åˆå¹¶ æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç»“åˆå…«å¦æ•°æ®ï¼Œä½¿ç”¨æ—¶é—´æˆ³è§£å†³å†²çªã€‚ å…«å¦é¢‘é“ å½“silosé¦–æ¬¡å¯åŠ¨æˆ–æ•…éšœåé‡æ–°å¯åŠ¨æ—¶ï¼Œå®ƒéœ€è¦æœ‰ä¸€ç§æ–¹æ³• æ­å‘æµè¨€èœšè¯­ æ˜¯çš„ã€‚è¿™æ˜¯ å…«å¦é¢‘é“ ï¼Œå¯ä»¥åœ¨ silosé…ç½® æ˜¯çš„ã€‚å¯åŠ¨æ—¶ï¼Œä¸€ä¸ªç«–äº•ä»å…«å¦é¢‘é“è·å–æ‰€æœ‰ä¿¡æ¯ã€‚å¯åŠ¨åï¼Œsilosæ¯éš”30ç§’æˆ–ä»»ä½•é…ç½®ä¸º èƒŒæ™¯æ¶ˆæ¯é—´éš” æ˜¯çš„ã€‚æ¯æ¬¡å®ƒä¸ä»æ‰€æœ‰ç¾¤é›†ç½‘å…³å’Œå…«å¦é¢‘é“ä¸­éšæœºé€‰æ‹©çš„ä¼™ä¼´åŒæ­¥å…«å¦ä¿¡æ¯ã€‚ ç¬”è®°ï¼š è™½ç„¶ä¸æ˜¯ä¸¥æ ¼è¦æ±‚ï¼Œä½†æˆ‘ä»¬å»ºè®®å§‹ç»ˆåœ¨ä¸åŒçš„åŒºåŸŸé…ç½®è‡³å°‘ä¸¤ä¸ªå…«å¦é¢‘é“ï¼Œä»¥è·å¾—æ›´å¥½çš„å¯ç”¨æ€§ã€‚ ä¸å…«å¦é¢‘é“æ²Ÿé€šçš„å»¶è¿Ÿå¹¶ä¸é‡è¦ã€‚ åªè¦serviceid guid(ç”±å®ƒä»¬å„è‡ªçš„é…ç½®æŒ‡å®š)æ˜¯ä¸åŒçš„ï¼Œå¤šä¸ªä¸åŒçš„æœåŠ¡å°±å¯ä»¥ä½¿ç”¨ç›¸åŒçš„å…«å¦é¢‘é“è€Œä¸å—å¹²æ‰°ã€‚ æ²¡æœ‰ä¸¥æ ¼è¦æ±‚æ‰€æœ‰silosä½¿ç”¨ç›¸åŒçš„å…«å¦é¢‘é“ï¼Œåªè¦é¢‘é“è¶³å¤Ÿè®©silosåœ¨å¯åŠ¨æ—¶æœ€åˆä¸â€œå…«å¦ç¤¾åŒºâ€è¿æ¥ã€‚ä½†æ˜¯ï¼Œå¦‚æœå…«å¦é¢‘é“ä¸æ˜¯silosé…ç½®çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”silosæ˜¯ç½‘å…³ï¼Œåˆ™å®ƒä¸ä¼šå°†å…¶çŠ¶æ€æ›´æ–°æ¨é€åˆ°é¢‘é“(å¿«é€Ÿä¼ æ’­)ï¼Œå› æ­¤åœ¨é€šè¿‡å‘¨æœŸæ€§èƒŒæ™¯å…«å¦(æ…¢é€Ÿä¼ æ’­)åˆ°è¾¾é¢‘é“ä¹‹å‰ï¼Œå¯èƒ½éœ€è¦æ›´é•¿çš„æ—¶é—´ã€‚ åŸºäºazureè¡¨çš„å…«å¦é¢‘é“ æˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªåŸºäºazureè¡¨çš„å…«å¦é¢‘é“ã€‚é…ç½®æŒ‡å®šç”¨äºazureå¸æˆ·çš„æ ‡å‡†è¿æ¥å­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªé…ç½®å¯ä»¥ä½¿ç”¨å•ç‹¬çš„azureå­˜å‚¨å¸æˆ·æŒ‡å®šä¸¤ä¸ªå…«å¦é¢‘é“ ç¾å›½ å’Œ æ¬§æ´² å…·ä½“å¦‚ä¸‹ï¼š var silo = new SiloHostBuilder() [...] .Configure<MultiClusterOptions>(options => { [...] options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"); options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\") [...] }) [...] å¤šä¸ªä¸åŒçš„æœåŠ¡å¯ä»¥ä½¿ç”¨ç›¸åŒçš„å…«å¦é¢‘é“è€Œä¸å—å¹²æ‰°ï¼Œåªè¦å®ƒä»¬å„è‡ªé…ç½®æŒ‡å®šçš„serviceid guidæ˜¯ä¸åŒçš„ã€‚ å…¶ä»–å…«å¦é¢‘é“å®ç° æˆ‘ä»¬æ­£åœ¨ç ”ç©¶å…¶ä»–å…«å¦é¢‘é“æä¾›å•†ï¼Œç±»ä¼¼äºå¦‚ä½•ä¸ºè®¸å¤šä¸åŒçš„å­˜å‚¨åç«¯æ‰“åŒ…æˆå‘˜èµ„æ ¼å’Œæé†’ã€‚"
  },
  "Documentation/deployment/multi-cluster_support/GlobalSingleInstance.html": {
    "href": "Documentation/deployment/multi-cluster_support/GlobalSingleInstance.html",
    "title": "Global-Single-Instance Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "grainsåè°ƒå±æ€§ å¼€å‘äººå‘˜å¯ä»¥æŒ‡ç¤ºé›†ç¾¤åº”è¯¥åœ¨ä½•æ—¶ä»¥åŠå¦‚ä½•æ ¹æ®ç‰¹å®šçš„grainç±»åè°ƒå…¶grainç›®å½•ã€‚è¿™ä¸ª [å…¨çƒç…§æ˜] å±æ€§æ„å‘³ç€æˆ‘ä»¬éœ€è¦ä¸åœ¨å•ä¸ªå…¨å±€é›†ç¾¤ä¸­è¿è¡Œorleansæ—¶ç›¸åŒçš„è¡Œä¸ºï¼šå³å°†æ‰€æœ‰è°ƒç”¨è·¯ç”±åˆ°ä¸€ä¸ªå•ä¸€çš„grainæ¿€æ´»ã€‚ç›¸ååœ°ï¼Œ [OneInstancePerCluster] å±æ€§æŒ‡ç¤ºæ¯ä¸ªç¾¤é›†å¯ä»¥æœ‰è‡ªå·±çš„ç‹¬ç«‹æ¿€æ´»ã€‚å¦‚æœé›†ç¾¤ä¹‹é—´çš„é€šä¿¡æ˜¯ä¸éœ€è¦çš„ï¼Œè¿™æ˜¯åˆé€‚çš„ã€‚ å±æ€§æ”¾åœ¨grainå®ç°ä¸Šã€‚ä¾‹å¦‚ï¼š using Orleans.MultiCluster; [GlobalSingleInstance] public class MyGlobalGrain : Orleans.Grain, IMyGrain { ... } [OneInstancePerCluster] public class MyLocalGrain : Orleans.Grain, IMyGrain { ... } å¦‚æœgrainç±»æ²¡æœ‰æŒ‡å®šè¿™äº›å±æ€§ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œåˆ™é»˜è®¤ä¸º [OneInstancePerCluster] æˆ– [å…¨çƒç…§æ˜] å¦‚æœé…ç½®å‚æ•° é»˜è®¤ä¸ºUseGlobalSingleInstances è®¾ç½®ä¸ºtrueã€‚ å…¨å±€å•å®ä¾‹Grainåè®® å½“è®¿é—®å…¨å±€å•å®ä¾‹(GSI)grainsï¼Œå¹¶ä¸”ä¸çŸ¥é“å­˜åœ¨æ¿€æ´»æ—¶ï¼Œåœ¨æ¿€æ´»æ–°å®ä¾‹ä¹‹å‰æ‰§è¡Œç‰¹æ®ŠGSIæ¿€æ´»åè®®ã€‚ç‰¹åˆ«åœ°ï¼Œè¯·æ±‚è¢«å‘é€åˆ°å½“å‰ å¤šç¾¤é›†é…ç½® æ£€æŸ¥ä»–ä»¬æ˜¯å¦å·²ç»æ¿€æ´»äº†è¿™ç§Grainsã€‚å¦‚æœæ‰€æœ‰å“åº”å‡ä¸ºè´Ÿï¼Œåˆ™åœ¨æ­¤ç¾¤é›†ä¸­åˆ›å»ºæ–°æ¿€æ´»ã€‚å¦åˆ™ï¼Œå°†ä½¿ç”¨è¿œç¨‹æ¿€æ´»(å¹¶åœ¨æœ¬åœ°ç›®å½•ä¸­ç¼“å­˜å¯¹å®ƒçš„å¼•ç”¨)ã€‚ æ¯ä¸ªé›†ç¾¤Grainä¸€ä¸ªå®ä¾‹çš„åè®® å¯¹äºæ¯ä¸ªé›†ç¾¤Grainçš„ä¸€ä¸ªå®ä¾‹ï¼Œæ²¡æœ‰é›†ç¾¤é—´é€šä¿¡ã€‚å®ƒä»¬åªéœ€åœ¨æ¯ä¸ªé›†ç¾¤ä¸­ç‹¬ç«‹ä½¿ç”¨æ ‡å‡†çš„orleansæœºåˆ¶ã€‚åœ¨orleansæ¡†æ¶æœ¬èº«ä¸­ï¼Œä»¥ä¸‹grainç±»ç”¨ [OneInstancePerCluster] å±æ€§ï¼š ç®¡ç†grain ï¼Œè¯· grainsæ•°æ®åº“æˆå‘˜è¡¨ ï¼Œå’Œ Grain æ˜¯çš„ã€‚ å¯ç–‘æ¿€æ´» å¦‚æœGSIåè®®åœ¨3æ¬¡é‡è¯•(æˆ–é…ç½®å‚æ•°æŒ‡å®šçš„ä»»ä½•æ•°ç›®)åæ²¡æœ‰ä»æ‰€æœ‰é›†ç¾¤æ¥æ”¶åˆ°ç»“è®ºæ€§å“åº” GlobalSingleInstanceNumberEntrieså…¨å±€ ï¼Œå®ƒä¹è§‚åœ°åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„æœ¬åœ°â€œå¯ç–‘â€æ¿€æ´»ï¼Œæ”¯æŒå¯ç”¨æ€§è€Œä¸æ˜¯ä¸€è‡´æ€§ã€‚ å¯ç–‘çš„æ¿€æ´»å¯èƒ½æ˜¯é‡å¤çš„(å› ä¸ºæŸäº›åœ¨GSIåè®®æ¿€æ´»æœŸé—´æ²¡æœ‰å“åº”çš„è¿œç¨‹é›†ç¾¤å¯èƒ½ä»ç„¶æ¿€æ´»äº†æ­¤grains)ã€‚å› æ­¤ï¼Œæ¯éš”30ç§’(æˆ–é…ç½®å‚æ•°æŒ‡å®šçš„ä»»ä½•é—´éš”)å®šæœŸ GlobalSingleInstanceRetryInterval )å¯¹äºæ‰€æœ‰å¯ç–‘çš„æ¿€æ´»ï¼Œå†æ¬¡è¿è¡Œgsiåè®®ã€‚è¿™ç¡®ä¿ä¸€æ—¦æ¢å¤é›†ç¾¤ä¹‹é—´çš„é€šä¿¡ï¼Œå°±å¯ä»¥æ£€æµ‹å¹¶åˆ é™¤é‡å¤çš„æ¿€æ´»ã€‚"
  },
  "Documentation/deployment/multi-cluster_support/SiloConfiguration.html": {
    "href": "Documentation/deployment/multi-cluster_support/SiloConfiguration.html",
    "title": "Multi-Cluster Silo Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleanssilosé…ç½® ä¸ºäº†å¿«é€Ÿäº†è§£ï¼Œæˆ‘ä»¬åœ¨ä¸‹é¢çš„XMLè¯­æ³•ä¸­æ˜¾ç¤ºäº†æ‰€æœ‰ç›¸å…³çš„é…ç½®å‚æ•°(åŒ…æ‹¬å¯é€‰å‚æ•°)ï¼š <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <MultiClusterNetwork ClusterId=\"clusterid\" DefaultMultiCluster=\"uswest,europewest,useast\" BackgroundGossipInterval=\"30s\" UseGlobalSingleInstanceByDefault=\"false\" GlobalSingleInstanceRetryInterval=\"30s\" GlobalSingleInstanceNumberRetries=\"3\" MaxMultiClusterGateways=\"10\"> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> <GossipChannel Type=\"...\" ConnectionString=\"...\"/> </MultiClusterNetwork> <SystemStore ... ServiceId=\"some-guid\" .../> </Globals> </OrleansConfiguration> var silo = new SiloHostBuilder() [...] .Configure<ClusterInfo>(options => { options.ClusterId = \"us3\"; options.ServiceId = \"myawesomeservice\"; }) .Configure<MultiClusterOptions>(options => { options.HasMultiClusterNetwork = true; options.DefaultMultiCluster = new[] { \"us1\", \"eu1\", \"us2\" }; options.BackgroundGossipInterval = TimeSpan.FromSeconds(30); options.UseGlobalSingleInstanceByDefault = false; options.GlobalSingleInstanceRetryInterval = TimeSpan.FromSeconds(30); options.GlobalSingleInstanceNumberRetries = 3; options.MaxMultiClusterGateways = 10; options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=usa;AccountKey=...\"); options.GossipChannels.Add(\"AzureTable\", \"DefaultEndpointsProtocol=https;AccountName=europe;AccountKey=...\") [...] }) [...] ä¸å¾€å¸¸ä¸€æ ·ï¼Œæ‰€æœ‰é…ç½®è®¾ç½®ä¹Ÿå¯ä»¥é€šè¿‡ å…¨çƒé…ç½® ä¸Šè¯¾ã€‚ è¿™ä¸ª æœåŠ¡ID æ˜¯ç”¨äºæ ‡è¯†æ­¤æœåŠ¡çš„ä»»æ„IDã€‚æ‰€æœ‰é›†ç¾¤å’Œæ‰€æœ‰siloså¿…é¡»ç›¸åŒã€‚ è¿™ä¸ª å¤šé›†ç¾¤ç½‘ç»œ èŠ‚æ˜¯å¯é€‰çš„-å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ç¦ç”¨æ­¤silosçš„æ‰€æœ‰å¤šç¾¤é›†æ”¯æŒã€‚ è¿™ä¸ª æ‰€éœ€å‚æ•° æ£’çŠ¶çš„ å’Œ å…«å¦é¢‘é“ åœ¨ å¤šé›†ç¾¤é€šä¿¡ æ˜¯çš„ã€‚ å¯é€‰å‚æ•° MaxMultiClusterGatewaysç³»åˆ— å’Œ èƒŒæ™¯æ¶ˆæ¯é—´éš” åœ¨ å¤šé›†ç¾¤é€šä¿¡ æ˜¯çš„ã€‚ å¯é€‰å‚æ•° é»˜è®¤å¤šç¾¤é›† åœ¨ å¤šç¾¤é›†é…ç½® æ˜¯çš„ã€‚ å¯é€‰å‚æ•° é»˜è®¤ä¸ºUseGlobalSingleInstances ï¼Œè¯· GlobalSingleInstanceRetryInterval å’Œ GlobalSingleInstanceNumberEntrieså…¨å±€ åœ¨ å…¨å±€å•å®ä¾‹Grain æ˜¯çš„ã€‚ Orleanså®¢æˆ·ç«¯é…ç½® Orleanså®¢æˆ·ç«¯ä¸éœ€è¦é¢å¤–é…ç½®ã€‚åŒä¸€å®¢æˆ·ç«¯å¯èƒ½æ— æ³•è¿æ¥åˆ°ä¸åŒé›†ç¾¤ä¸­çš„silos(silosåœ¨è¿™ç§æƒ…å†µä¸‹æ‹’ç»è¿æ¥)ã€‚"
  },
  "Documentation/deployment/index.html": {
    "href": "Documentation/deployment/index.html",
    "title": "Running the Application | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansåº”ç”¨ å…¸å‹çš„Orleansåº”ç”¨ç¨‹åºç”±ä¸€ç»„æœåŠ¡å™¨è¿›ç¨‹(silo)å’Œä¸€ç»„å®¢æˆ·ç«¯è¿›ç¨‹(é€šå¸¸æ˜¯webæœåŠ¡å™¨)ç»„æˆï¼Œè¿™äº›è¿›ç¨‹æ¥æ”¶å¤–éƒ¨è¯·æ±‚ï¼Œå°†å®ƒä»¬è½¬æ¢ä¸ºgrainæ–¹æ³•è°ƒç”¨ï¼Œå¹¶è¿”å›ç»“æœã€‚å› æ­¤ï¼Œè¿è¡ŒOrleansåº”ç”¨ç¨‹åºé¦–å…ˆéœ€è¦å¯åŠ¨ä¸€ä¸ªsilosé›†ç¾¤ã€‚å‡ºäºæµ‹è¯•ç›®çš„ï¼Œé›†ç¾¤å¯ä»¥ç”±å•ä¸ªsilosç»„æˆã€‚å¯¹äºå¯é çš„ç”Ÿäº§éƒ¨ç½²ï¼Œæˆ‘ä»¬æ˜¾ç„¶å¸Œæœ›é›†ç¾¤ä¸­æœ‰å¤šä¸ªsilosç”¨äºå®¹é”™å’Œæ‰©å±•ã€‚ é›†ç¾¤è¿è¡Œåï¼Œæˆ‘ä»¬å¯ä»¥å¯åŠ¨ä¸€ä¸ªæˆ–å¤šä¸ªå®¢æˆ·ç«¯è¿›ç¨‹ï¼Œè¿™äº›è¿›ç¨‹è¿æ¥åˆ°é›†ç¾¤å¹¶å¯ä»¥å‘grainså‘é€è¯·æ±‚ã€‚å®¢æˆ·ç«¯è¿æ¥åˆ°silos-gatewayä¸Šçš„ç‰¹æ®Štcpç«¯ç‚¹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œç¾¤é›†ä¸­çš„æ¯ä¸ªsiloséƒ½å¯ç”¨äº†å®¢æˆ·ç«¯ç½‘å…³ã€‚å› æ­¤ï¼Œå®¢æˆ·å¯ä»¥åŒæ—¶è¿æ¥åˆ°æ‰€æœ‰silosï¼Œä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½å’Œå¼¹æ€§ã€‚ é…ç½®å’Œå¯åŠ¨silos silosé€šè¿‡ ç¾¤é›†é…ç½® åå¯¹ã€‚å®ƒå¯ä»¥ç›´æ¥å®ä¾‹åŒ–å’Œå¡«å……ï¼Œä»æ–‡ä»¶ä¸­åŠ è½½è®¾ç½®ï¼Œæˆ–è€…ä½¿ç”¨å¤šä¸ªé€‚ç”¨äºä¸åŒéƒ¨ç½²ç¯å¢ƒçš„å¯ç”¨å¸®åŠ©å™¨æ–¹æ³•åˆ›å»ºã€‚å¯¹äºæœ¬åœ°æµ‹è¯•ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ clusterconfiguration.localhostprimarysilo() åŠ©æ‰‹æ–¹æ³•ã€‚ç„¶åå°†é…ç½®å¯¹è±¡ä¼ é€’ç»™ silos ç±»ï¼Œå¯ä»¥åœ¨è¯¥ç±»ä¹‹ååˆå§‹åŒ–å’Œå¯åŠ¨ã€‚ æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªç©ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ï¼Œç›®æ ‡æ˜¯.NETFramework4.6.1æˆ–æ›´é«˜ç‰ˆæœ¬ï¼Œç”¨äºæ‰˜ç®¡silosã€‚æ·»åŠ  Microsoft.Orleans.Server é¡¹ç›®çš„nugetå…ƒåŒ…ã€‚ PM> Install-Package Microsoft.Orleans.Server ä»¥ä¸‹æ˜¯å¦‚ä½•å¯åŠ¨æœ¬åœ°silosçš„ç¤ºä¾‹ï¼š var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"Test Silo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Press Enter to close.\"); // wait here Console.ReadLine(); // shut the silo down after we are done. silo.ShutdownOrleansSilo(); é…ç½®å’Œè¿æ¥å®¢æˆ·ç«¯ é€šè¿‡ä¸€ä¸ª å®¢æˆ·ç«¯é…ç½® å¯¹è±¡å’Œ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ æ˜¯çš„ã€‚ å®¢æˆ·ç«¯é…ç½® å¯¹è±¡å¯ä»¥ç›´æ¥å®ä¾‹åŒ–å’Œå¡«å……ï¼Œä»æ–‡ä»¶åŠ è½½è®¾ç½®ï¼Œæˆ–è€…ä½¿ç”¨å¤šä¸ªé€‚ç”¨äºä¸åŒéƒ¨ç½²ç¯å¢ƒçš„å¯ç”¨å¸®åŠ©å™¨æ–¹æ³•åˆ›å»ºã€‚å¯¹äºæœ¬åœ°æµ‹è¯•ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨ clientconfiguration.localhostsilo() åŠ©æ‰‹æ–¹æ³•ã€‚ç„¶åå°†é…ç½®å¯¹è±¡ä¼ é€’ç»™ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ ä¸Šè¯¾ã€‚ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ å…¬å¼€é…ç½®å…¶ä»–å®¢æˆ·ç«¯åŠŸèƒ½çš„æ›´å¤šæ–¹æ³•ã€‚ä¹‹å å»ºç«‹ æ–¹æ³• å®¢æˆ·ç«¯ç”Ÿæˆå™¨ è°ƒç”¨å¯¹è±¡ä»¥è·å– IClusterClient æ¥å£ã€‚æœ€åï¼Œæˆ‘ä»¬è°ƒç”¨ è¿æ¥() æ–¹æ³•è¿æ¥åˆ°ç¾¤é›†ã€‚ æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªç©ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ï¼Œç›®æ ‡æ˜¯.net framework 4.6.1æˆ–æ›´é«˜ç‰ˆæœ¬ä»¥è¿è¡Œå®¢æˆ·ç«¯ï¼Œæˆ–è€…é‡ç”¨ä¸ºæ‰˜ç®¡silosè€Œåˆ›å»ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ã€‚æ·»åŠ  Microsoft.Orleans.client é¡¹ç›®çš„nugetå…ƒåŒ…ã€‚ PM> Install-Package Microsoft.Orleans.Client ä»¥ä¸‹æ˜¯å®¢æˆ·ç«¯å¦‚ä½•è¿æ¥åˆ°æœ¬åœ°silosçš„ç¤ºä¾‹ï¼š var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder().UseConfiguration(config). var client = builder.Build(); await client.Connect(); ç”Ÿäº§é…ç½® æˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨çš„é…ç½®ç¤ºä¾‹ç”¨äºæµ‹è¯•ä¸ æœ¬åœ°æœåŠ¡å™¨ æ˜¯çš„ã€‚åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œsiloså’Œå®¢æˆ·ç«¯é€šå¸¸è¿è¡Œåœ¨ä¸åŒçš„æœåŠ¡å™¨ä¸Šï¼Œå¹¶ä½¿ç”¨å¯é çš„ç¾¤é›†é…ç½®é€‰é¡¹ä¹‹ä¸€è¿›è¡Œé…ç½®ã€‚æ‚¨å¯ä»¥åœ¨ã€Šé…ç½®æŒ‡å—ã€‹](../clusters\\u and\\u clients/configuration\\u guide/index.md)å’Œ ç¾¤é›†ç®¡ç† æ˜¯çš„ã€‚"
  },
  "Documentation/benefits.html": {
    "href": "Documentation/benefits.html",
    "title": "Main Benefits | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¥½å¤„ Orleansçš„ä¸»è¦å¥½å¤„æ˜¯ï¼š å¼€å‘äººå‘˜ç”Ÿäº§åŠ› ï¼Œå³ä½¿å¯¹äºéä¸“ä¸šç¨‹åºå‘˜ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œ é»˜è®¤æƒ…å†µä¸‹é€æ˜çš„å¯ä¼¸ç¼©æ€§ ä¸éœ€è¦ç¨‹åºå‘˜çš„ç‰¹åˆ«åŠªåŠ›ã€‚æˆ‘ä»¬åœ¨ä¸‹é¢å¯¹è¿™ä¸¤ä¸ªå¥½å¤„è¿›è¡Œäº†æ‰©å±•ã€‚ å¼€å‘äººå‘˜ç”Ÿäº§åŠ› Orleansç¼–ç¨‹æ¨¡å‹é€šè¿‡æä¾›ä»¥ä¸‹å…³é”®æŠ½è±¡ã€ä¿è¯å’Œç³»ç»ŸæœåŠ¡ï¼Œæé«˜äº†ä¸“å®¶å’Œéä¸“å®¶ç¨‹åºå‘˜çš„ç”Ÿäº§ç‡ã€‚ ç†Ÿæ‚‰çš„é¢å‘å¯¹è±¡ç¼–ç¨‹(oop)èŒƒå¼ grainsæ˜¯ç”¨å¼‚æ­¥æ–¹æ³•å®ç°å£°æ˜çš„.net grainæ¥å£çš„.netç±»ã€‚å› æ­¤ï¼Œåœ¨ç¨‹åºå‘˜çœ‹æ¥ï¼Œgrainsæ˜¯å¯ä»¥ç›´æ¥è°ƒç”¨å…¶æ–¹æ³•çš„è¿œç¨‹å¯¹è±¡ã€‚é€šè¿‡å°†æ–¹æ³•è°ƒç”¨è½¬æ¢ä¸ºæ¶ˆæ¯ã€å°†å®ƒä»¬è·¯ç”±åˆ°æ­£ç¡®çš„ç«¯ç‚¹ã€è°ƒç”¨ç›®æ ‡Grainçš„æ–¹æ³•ä»¥åŠä»¥å®Œå…¨é€æ˜çš„æ–¹å¼å¤„ç†å¤±è´¥å’Œè§’è½æƒ…å†µï¼Œè¿™ä¸ºç¨‹åºå‘˜æä¾›äº†ç†Ÿæ‚‰çš„oopèŒƒä¾‹ã€‚ grains å•çº¿ç¨‹æ‰§è¡Œ è¿è¡Œæ—¶ä¿è¯ä¸€ä¸ªGrainä¸€æ¬¡ä¸ä¼šåœ¨å¤šä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œã€‚å†åŠ ä¸Šä¸å…¶ä»–Grainçš„éš”ç¦»ï¼Œç¨‹åºå‘˜æ°¸è¿œä¸ä¼šåœ¨Grainçº§åˆ«é¢ä¸´å¹¶å‘ï¼Œä¹Ÿä¸éœ€è¦ä½¿ç”¨é”æˆ–å…¶ä»–åŒæ­¥æœºåˆ¶æ¥æ§åˆ¶å¯¹å…±äº«æ•°æ®çš„è®¿é—®ã€‚ä»…æ­¤ç‰¹æ€§å°±ä½¿å¾—åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„å¼€å‘å¯¹äºéä¸“å®¶ç¨‹åºå‘˜æ¥è¯´æ˜¯å®¹æ˜“çš„ã€‚ é€æ˜æ¿€æ´» è¿è¡Œæ—¶ä»…å½“æœ‰è¦å¤„ç†çš„æ¶ˆæ¯æ—¶æ‰æ¿€æ´»Grainsã€‚è¿™å°†åˆ›å»ºå¯¹åº”ç”¨ç¨‹åºä»£ç å¯è§å¹¶ç”±å…¶æ§åˆ¶çš„grainçš„å¼•ç”¨çš„æ¦‚å¿µä¸å¯¹åº”ç”¨ç¨‹åºé€æ˜çš„å†…å­˜ä¸­grainçš„ç‰©ç†æ¿€æ´»çš„æ¦‚å¿µå®Œå…¨åˆ†ç¦»ã€‚åœ¨è®¸å¤šæ–¹é¢ï¼Œè¿™ç±»ä¼¼äºè™šæ‹Ÿå†…å­˜ï¼Œå› ä¸ºå®ƒå†³å®šä½•æ—¶â€œåˆ†é¡µâ€(åœç”¨)æˆ–â€œåˆ†é¡µâ€(æ¿€æ´»)ä¸€ä¸ªgrainsï¼›åº”ç”¨ç¨‹åºå¯ä»¥ä¸é—´æ–­åœ°è®¿é—®é€»è¾‘åˆ›å»ºçš„grainsçš„å…¨éƒ¨â€œå†…å­˜ç©ºé—´â€ï¼Œæ— è®ºå®ƒä»¬æ˜¯å¦åœ¨ä»»ä½•ç‰¹å®šæ—¶é—´ç‚¹ä½äºç‰©ç†å†…å­˜ä¸­ã€‚é€æ˜æ¿€æ´»é€šè¿‡åœ¨ç¡¬ä»¶èµ„æºæ± ä¸­å­˜å‚¨å’Œè¿ç§»Grainå®ç°åŠ¨æ€ã€è‡ªé€‚åº”çš„è´Ÿè½½å¹³è¡¡ã€‚è¿™ä¸ªç‰¹æ€§æ˜¯å¯¹ä¼ ç»Ÿçš„actoræ¨¡å‹çš„ä¸€ä¸ªé‡å¤§æ”¹è¿›ï¼Œå…¶ä¸­actorç”Ÿå‘½å‘¨æœŸæ˜¯ç”±åº”ç”¨ç¨‹åºç®¡ç†çš„ã€‚ ä½ç½®é€æ˜åº¦ ç¨‹åºå‘˜ç”¨æ¥è°ƒç”¨grainæ–¹æ³•æˆ–ä¼ é€’ç»™å…¶ä»–ç»„ä»¶çš„grainå¼•ç”¨(ä»£ç†å¯¹è±¡)åªåŒ…å«grainçš„é€»è¾‘æ ‡è¯†ã€‚Grainsé€»è¾‘æ ‡è¯†åˆ°å…¶ç‰©ç†ä½ç½®çš„è½¬æ¢å’Œç›¸åº”çš„æ¶ˆæ¯è·¯ç”±æ˜¯ç”±orleansè¿è¡Œæ—¶é€æ˜å®Œæˆçš„ã€‚åº”ç”¨ç¨‹åºä»£ç ä¸grainè¿›è¡Œé€šä¿¡ï¼Œè€Œä¸æ³¨æ„å®ƒä»¬çš„ç‰©ç†ä½ç½®ï¼Œè¿™å¯èƒ½ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œæ”¹å˜ï¼ŒåŸå› æ˜¯å¤±è´¥æˆ–èµ„æºç®¡ç†ï¼Œæˆ–è€…æ˜¯grainåœ¨è°ƒç”¨æ—¶è¢«åœç”¨ã€‚ ä¸æŒä¹…å­˜å‚¨çš„é€æ˜é›†æˆ orleanså…è®¸å£°æ˜æ€§åœ°å°†grainçš„å†…å­˜çŠ¶æ€æ˜ å°„åˆ°æŒä¹…åŒ–å­˜å‚¨ã€‚å®ƒåŒæ­¥æ›´æ–°ï¼Œé€æ˜åœ°ç¡®ä¿è°ƒç”¨æ–¹ä»…åœ¨æˆåŠŸæ›´æ–°æŒä¹…çŠ¶æ€åæ‰èƒ½æ¥æ”¶ç»“æœã€‚æ‰©å±•å’Œ/æˆ–å®šåˆ¶ç°æœ‰æŒä¹…å­˜å‚¨æä¾›ç¨‹åºé›†æ˜¯ç›´æˆªäº†å½“çš„ã€‚ å¼‚å¸¸çš„è‡ªåŠ¨ä¼ æ’­ è¿è¡Œæ—¶ä½¿ç”¨å¼‚æ­¥å’Œåˆ†å¸ƒå¼try/catchçš„è¯­ä¹‰è‡ªåŠ¨å°†æœªå¤„ç†çš„é”™è¯¯ä¼ æ’­åˆ°è°ƒç”¨é“¾ä¸Šã€‚å› æ­¤ï¼Œé”™è¯¯ä¸ä¼šåœ¨åº”ç”¨ç¨‹åºä¸­ä¸¢å¤±ã€‚ è¿™å…è®¸ç¨‹åºå‘˜å°†é”™è¯¯å¤„ç†é€»è¾‘æ”¾åœ¨é€‚å½“çš„ä½ç½®ï¼Œè€Œæ— éœ€åœ¨æ¯ä¸ªçº§åˆ«æ‰‹åŠ¨ä¼ æ’­é”™è¯¯çš„ç¹çå·¥ä½œã€‚ é»˜è®¤æƒ…å†µä¸‹é€æ˜çš„å¯ä¼¸ç¼©æ€§ orleansç¼–ç¨‹æ¨¡å‹æ—¨åœ¨å¼•å¯¼ç¨‹åºå‘˜åœ¨å‡ ä¸ªæ•°é‡çº§ä¸ŠæˆåŠŸåœ°æ‰©å±•åº”ç”¨ç¨‹åºæˆ–æœåŠ¡ã€‚è¿™æ˜¯é€šè¿‡ç»“åˆç»éªŒè¯çš„æœ€ä½³å®è·µå’Œæ¨¡å¼ä»¥åŠé€šè¿‡æä¾›è¾ƒä½çº§åˆ«ç³»ç»ŸåŠŸèƒ½çš„æœ‰æ•ˆå®ç°æ¥å®ç°çš„ã€‚ä»¥ä¸‹æ˜¯å®ç°å¯ä¼¸ç¼©æ€§å’Œæ€§èƒ½çš„ä¸€äº›å…³é”®å› ç´ ï¼š åº”ç”¨çŠ¶æ€çš„éšå¼ç»†Grainåˆ’åˆ† é€šè¿‡ä½¿ç”¨Grainä½œä¸ºç›´æ¥å¯å¯»å€çš„å®ä½“ï¼Œç¨‹åºå‘˜éšå¼åœ°åˆ†è§£äº†åº”ç”¨ç¨‹åºçš„æ•´ä½“çŠ¶æ€ã€‚è™½ç„¶Orleansç¼–ç¨‹æ¨¡å‹æ²¡æœ‰è§„å®šGrainsåº”è¯¥æœ‰å¤šå¤§æˆ–å¤šå°ï¼Œä½†åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‹¥æœ‰ç›¸å¯¹è¾ƒå¤§æ•°é‡çš„Grains(æ•°ç™¾ä¸‡æˆ–æ›´å¤š)æ˜¯æœ‰æ„ä¹‰çš„ï¼Œæ¯ä¸ªGrainsä»£è¡¨åº”ç”¨ç¨‹åºçš„è‡ªç„¶å®ä½“ï¼Œå¦‚ç”¨æˆ·å¸æˆ·æˆ–é‡‡è´­è®¢å•ã€‚ç”±äºgrainsæ˜¯ç‹¬ç«‹å¯å¯»å€çš„ï¼Œè€Œç‰©ç†ä½ç½®æ˜¯ç”±è¿è¡Œæ—¶æŠ½è±¡å‡ºæ¥çš„ï¼Œå› æ­¤Orleansåœ¨ä»¥é€æ˜å’Œé€šç”¨çš„æ–¹å¼å¹³è¡¡è´Ÿè½½å’Œå¤„ç†çƒ­ç‚¹æ–¹é¢å…·æœ‰æå¤§çš„çµæ´»æ€§ï¼Œè€Œä¸éœ€è¦åº”ç”¨ç¨‹åºå¼€å‘äººå‘˜çš„ä»»ä½•æƒ³æ³•ã€‚ é€‚åº”æ€§èµ„æºç®¡ç† Grainsä¸å…¶ä»–Grainsç›¸äº’ä½œç”¨æ—¶ï¼Œä¸ä¼šå‡è®¾å®ƒä»¬çš„ä½ç½®ã€‚ç”±äºè¿™ç§ä½ç½®é€æ˜æ€§ï¼Œè¿è¡Œæ—¶å¯ä»¥åŠ¨æ€åœ°ç®¡ç†å’Œè°ƒæ•´å¯ç”¨ç¡¬ä»¶èµ„æºçš„åˆ†é…ã€‚è¿è¡Œæ—¶é€šè¿‡é’ˆå¯¹åŠ è½½å’Œé€šä¿¡æ¨¡å¼åœ¨è®¡ç®—é›†ç¾¤ä¸­å¯¹Grainçš„å­˜å‚¨å’Œè¿ç§»åšå‡ºç»†Grainçš„å†³ç­–æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œè€Œä¸ä¼šä½¿ä¼ å…¥çš„è¯·æ±‚å¤±è´¥ã€‚é€šè¿‡åˆ›å»ºç‰¹å®šGrainçš„å¤šä¸ªå‰¯æœ¬ï¼Œè¿è¡Œæ—¶å¯ä»¥åœ¨ä¸æ›´æ”¹åº”ç”¨ç¨‹åºä»£ç çš„æƒ…å†µä¸‹æé«˜Grainçš„ååé‡ã€‚ å¤šè·¯é€šä¿¡ Orleansçš„Grainsæœ‰é€»è¾‘ç«¯ç‚¹ï¼Œå®ƒä»¬ä¹‹é—´çš„æ¶ˆæ¯ä¼ é€’é€šè¿‡ä¸€ç»„å›ºå®šçš„å…¨å¯¹æ‰€æœ‰ç‰©ç†è¿æ¥(TCPå¥—æ¥å­—)è¿›è¡Œå¤šè·¯å¤ç”¨ã€‚è¿™å…è®¸è¿è¡Œæ—¶ä»¥è¾ƒä½çš„æ¯ç²’æ“ä½œç³»ç»Ÿå¼€é”€æ‰˜ç®¡æ•°ç™¾ä¸‡ä¸ªå¯å¯»å€å®ä½“ã€‚æ­¤å¤–ï¼ŒGrainsçš„æ¿€æ´»å’Œåœç”¨ä¸ä¼šäº§ç”Ÿæ³¨å†Œ/æ³¨é”€ç‰©ç†ç«¯ç‚¹(å¦‚TCPç«¯å£æˆ–HTTP URL)æˆ–ç”šè‡³å…³é—­TCPè¿æ¥çš„æˆæœ¬ã€‚ é«˜æ•ˆè°ƒåº¦ è¿è¡Œæ—¶è®¡åˆ’åœ¨æ¯ä¸ªç‰©ç†å¤„ç†å™¨å†…æ ¸ä¸€ä¸ªçº¿ç¨‹çš„è‡ªå®šä¹‰çº¿ç¨‹æ± ä¸­æ‰§è¡Œå¤§é‡å•çº¿ç¨‹Grainã€‚ä½¿ç”¨ä»¥éé˜»å¡ã€åŸºäºè¿ç»­æ€§çš„é£æ ¼(Orleansç¼–ç¨‹æ¨¡å‹çš„è¦æ±‚)ç¼–å†™çš„Grainä»£ç ï¼Œåº”ç”¨ç¨‹åºä»£ç ä»¥éå¸¸é«˜æ•ˆçš„â€œåä½œâ€å¤šçº¿ç¨‹æ–¹å¼è¿è¡Œï¼Œæ²¡æœ‰äº‰ç”¨ã€‚è¿™ä½¿å¾—ç³»ç»Ÿèƒ½å¤Ÿè¾¾åˆ°é«˜ååé‡ï¼Œå¹¶ä»¥éå¸¸é«˜çš„CPUåˆ©ç”¨ç‡(é«˜è¾¾90%+)è¿è¡Œï¼Œå…·æœ‰æå¤§çš„ç¨³å®šæ€§ã€‚ç³»ç»Ÿä¸­grainsæ•°é‡çš„å¢é•¿å’Œè´Ÿè½½çš„å¢åŠ ä¸ä¼šå¯¼è‡´é¢å¤–çš„çº¿ç¨‹æˆ–å…¶ä»–æ“ä½œç³»ç»ŸåŸè¯­ï¼Œè¿™ä¸€äº‹å®æœ‰åŠ©äºå•ä¸ªèŠ‚ç‚¹å’Œæ•´ä¸ªç³»ç»Ÿçš„å¯ä¼¸ç¼©æ€§ã€‚ æ˜¾å¼å¼‚æ­¥ orleansç¼–ç¨‹æ¨¡å‹ä½¿åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„å¼‚æ­¥ç‰¹æ€§å˜å¾—æ˜ç¡®ï¼Œå¹¶æŒ‡å¯¼ç¨‹åºå‘˜ç¼–å†™éé˜»å¡å¼‚æ­¥ä»£ç ã€‚ç»“åˆå¼‚æ­¥æ¶ˆæ¯ä¼ é€’å’Œé«˜æ•ˆçš„è°ƒåº¦ï¼Œè¿™ä½¿å¾—æ— éœ€æ˜¾å¼åœ°ä½¿ç”¨å¤šçº¿ç¨‹å°±å¯ä»¥å®ç°å¾ˆå¤§ç¨‹åº¦çš„åˆ†å¸ƒå¼å¹¶è¡Œæ€§å’Œæ€»ååé‡ã€‚"
  },
  "Documentation/Orleans-2.0.html": {
    "href": "Documentation/Orleans-2.0.html",
    "title": "Orleans 2.0 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleans2.0 2.0æ˜¯Orleansçš„ä¸€ä¸ªä¸»è¦ç‰ˆæœ¬ï¼Œå…¶ä¸»è¦ç›®æ ‡æ˜¯ä½¿å…¶ä¸.NETæ ‡å‡†2.0å…¼å®¹å¹¶è·¨å¹³å°(é€šè¿‡.NET Core)ã€‚ä½œä¸ºè¿™é¡¹å·¥ä½œçš„ä¸€éƒ¨åˆ†ï¼ŒOrleansAPIè¿›è¡Œäº†å‡ æ¬¡ç°ä»£åŒ–ï¼Œä»¥ä½¿å…¶æ›´ç¬¦åˆåƒASP.NETè¿™æ ·çš„æŠ€æœ¯åœ¨å½“ä»Šçš„é…ç½®å’Œæ‰˜ç®¡æ–¹å¼ã€‚ å› ä¸ºå®ƒä¸.NETæ ‡å‡†2.0å…¼å®¹ï¼Œæ‰€ä»¥Orleans 2.0å¯ä»¥è¢«é’ˆå¯¹.NETæ ¸å¿ƒæˆ–å®Œæ•´.NETæ¡†æ¶çš„åº”ç”¨ç¨‹åºä½¿ç”¨ã€‚æ ¸å¿ƒå›¢é˜Ÿå¯¹è¿™ä¸ªç‰ˆæœ¬è¿›è¡Œæµ‹è¯•çš„é‡ç‚¹æ˜¯åœ¨.NETFrameworkæ¡†æ¶ä¸Šï¼Œä»¥ç¡®ä¿ç°æœ‰çš„åº”ç”¨ç¨‹åºå¯ä»¥è½»æ¾åœ°ä»1.5è¿ç§»åˆ°2ï¼Œå¹¶å…·æœ‰å®Œå…¨å‘åå…¼å®¹æ€§ã€‚ 2.0ä¸­æœ€æ˜¾è‘—çš„å˜åŒ–å¦‚ä¸‹ï¼š å®Œå…¨è½¬ç§»åˆ°åˆ©ç”¨fluid builderæ¨¡å¼apiçš„ä¾èµ–æ³¨å…¥çš„ç¼–ç¨‹é…ç½®ã€‚ åŸºäºé…ç½®å¯¹è±¡å’Œxmlæ–‡ä»¶çš„æ—§apiæ˜¯ä¸ºäº†å‘åå…¼å®¹è€Œä¿ç•™çš„ï¼Œä½†ä¸ä¼šå‘å‰ç§»åŠ¨ï¼Œå°†æ¥ä¼šè¢«å¼ƒç”¨ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ é…ç½® ç« èŠ‚ã€‚ åº”ç”¨ç¨‹åºç¨‹åºé›†çš„æ˜¾å¼ç¼–ç¨‹è§„èŒƒï¼Œå®ƒå–ä»£äº†Orleansè¿è¡Œæ—¶åœ¨silosæˆ–å®¢æˆ·ç«¯åˆå§‹åŒ–æ—¶è‡ªåŠ¨æ‰«ææ–‡ä»¶å¤¹çš„åŠŸèƒ½ã€‚ orleansä»ç„¶ä¼šåœ¨æŒ‡å®šçš„ç¨‹åºé›†ä¸­è‡ªåŠ¨æŸ¥æ‰¾ç›¸å…³ç±»å‹ï¼Œå¦‚grainæ¥å£å’Œç±»ã€åºåˆ—åŒ–ç¨‹åºç­‰ï¼Œä½†å®ƒä¸å†å°è¯•åŠ è½½åœ¨æ–‡ä»¶å¤¹ä¸­å¯ä»¥æ‰¾åˆ°çš„æ¯ä¸ªç¨‹åºé›†ã€‚ä¸ºäº†å‘åå…¼å®¹ï¼Œæä¾›äº†ç”¨äºåŠ è½½æ–‡ä»¶å¤¹ä¸­æ‰€æœ‰ç¨‹åºé›†çš„å¯é€‰åŠ©æ‰‹æ–¹æ³•ï¼š iapplicationpartmanager.addfromapplicationbasedirectory() æ˜¯çš„ã€‚ è§ é…ç½® å’Œ è¿ç§» éƒ¨åˆ†äº†è§£æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚ ä»£ç ç”Ÿæˆçš„å½»åº•æ£€æŸ¥ã€‚ è™½ç„¶ä»£ç ç”Ÿæˆå¯¹å¼€å‘äººå‘˜æ¥è¯´åŸºæœ¬ä¸Šæ˜¯ä¸å¯è§çš„ï¼Œä½†æ˜¯åœ¨å¤„ç†å„ç§å¯èƒ½ç±»å‹çš„åºåˆ—åŒ–æ—¶ï¼Œä»£ç ç”Ÿæˆå˜å¾—æ›´åŠ å¥å£®ã€‚Fç»„ä»¶éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚è§ ä»£ç ç”Ÿæˆ éƒ¨åˆ†äº†è§£æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚ åˆ›å»ºäº† Microsoft.Orleans.Core.Abstractions nugetåŒ…å¹¶å°†å‡ ä¸ªç±»å‹ç§»åŠ¨/é‡æ„åˆ°å…¶ä¸­ã€‚ grainä»£ç å¾ˆå¯èƒ½åªéœ€è¦å¼•ç”¨è¿™äº›æŠ½è±¡ï¼Œè€Œsiloä¸»æœºå’Œå®¢æˆ·ç«¯å°†å¼•ç”¨æ›´å¤šçš„orleansåŒ…ã€‚æˆ‘ä»¬è®¡åˆ’ä¸ç»å¸¸æ›´æ–°è¿™ä¸ªåŒ…ã€‚ æ·»åŠ å¯¹ä½œç”¨åŸŸæœåŠ¡çš„æ”¯æŒã€‚ è¿™æ„å‘³ç€æ¯ä¸ªgrainæ¿€æ´»éƒ½æœ‰è‡ªå·±çš„ä½œç”¨åŸŸæœåŠ¡æä¾›è€…ï¼Œè€Œorleansæ³¨å†Œäº†ä¸€ä¸ªä¸Šä¸‹æ–‡ IGrainActivationContext å¯ä»¥æ³¨å…¥ ç¬å˜çš„ æˆ– èŒƒå›´ è·å–æ¿€æ´»ç‰¹å®šä¿¡æ¯å’ŒGrainsæ¿€æ´»ç”Ÿå‘½å‘¨æœŸäº‹ä»¶è®¿é—®æƒé™çš„æœåŠ¡ã€‚è¿™ä¸asp.net core 2.0ä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºä½œç”¨åŸŸä¸Šä¸‹æ–‡çš„æ–¹å¼ç±»ä¼¼ï¼Œä½†å¯¹äºorleansï¼Œå®ƒé€‚ç”¨äºgrainæ¿€æ´»çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸã€‚è§ ä½¿ç”¨å¯¿å‘½å’Œæ³¨å†Œé€‰é¡¹ åœ¨ASP.NETæ ¸å¿ƒæ–‡æ¡£ä¸­è·å–æœ‰å…³æœåŠ¡ç”Ÿå‘½å‘¨æœŸçš„è¯¦ç»†ä¿¡æ¯ã€‚ è¿ç§»äº†è¦ä½¿ç”¨çš„æ—¥å¿—åŸºç¡€ç»“æ„ Microsoft.Extensions.Logging (ä¸ASP.NET Core 2.0ç›¸åŒçš„æ‘˜è¦)ã€‚ 2.0åŒ…å«äº†å¯¹acidåˆ†å¸ƒå¼è·¨Grainäº‹åŠ¡çš„æµ‹è¯•ç‰ˆæ”¯æŒã€‚ è¯¥åŠŸèƒ½å°†ä¸ºåŸå‹è®¾è®¡å’Œå¼€å‘åšå¥½å‡†å¤‡ï¼Œå¹¶å°†åœ¨2.0ç‰ˆæœ¬å‘å¸ƒåçš„æŸä¸ªæ—¶é—´æ¯•ä¸šç”¨äºç”Ÿäº§ã€‚è§ äº¤æ˜“ æ›´å¤šç»†èŠ‚ã€‚"
  },
  "Documentation/whats_new_in_orleans.html": {
    "href": "Documentation/whats_new_in_orleans.html",
    "title": "What's new in Orleans | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæœ‰ä»€ä¹ˆæ–°é²œäº‹ï¼Ÿ v2.3.2ç‰ˆ 2019å¹´5æœˆ9æ—¥ ä¸‰ä¸ªé”™è¯¯ä¿®å¤ã€‚ v2.3.1ç‰ˆ 2019å¹´4æœˆ26æ—¥ ä¸€äº›æ”¹è¿›ï¼Œä¸€ä¸ªbugä¿®å¤ï¼Œä»¥åŠæ‰¹å¤„ç†æµAPIã€‚ v2.3.0ç‰ˆ 2019å¹´3æœˆ20æ—¥ ä¸»è¦æ”¹è¿› æ”¯æŒASP.NETæ ¸å¿ƒæ‰˜ç®¡API(Microsoft.Extensions.Hosting). æ„Ÿè°¢@galvesribeiroï¼ å°†å‘½åé€‰é¡¹çš„è‡ªå®šä¹‰å®ç°æ›¿æ¢ä¸ºMicrosoft.Extensions.Options. EventHubæµæä¾›ç¨‹åºå·²å‡çº§åˆ°EvenHub 2.2.1ï¼Œå¹¶ä¸3.0.0å…¼å®¹ã€‚ é›†ç¾¤æˆå‘˜å…³ç³»è¡¨ä¸­çš„æ—§æ­»æ¡ç›®ç°åœ¨ä¼šè‡ªåŠ¨æ¸…ç†ï¼Œè¿™å¯¹äºæ‰˜ç®¡ä½¿ç”¨æ–°IPç«¯ç‚¹æ¥é‡æ–°å¯åŠ¨silosçš„ç¯å¢ƒå¾ˆæœ‰å¸®åŠ©ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œå…è®¸åœ¨æ€æ´›è¿›ç¨‹ä¸­æœ‰æ•ˆæ‰˜ç®¡å‰ç«¯ä»£ç çš„æ‰˜ç®¡å®¢æˆ·ç«¯ã€‚ æ”¯æŒ IHostEnvironmentStatistics åœ¨Linuxä¸Šï¼Œå®ƒæ”¯æŒCPUå’Œå†…å­˜æŒ‡æ ‡ä»¥åŠè´Ÿè½½å‰Šå‡ã€‚æ„Ÿè°¢@martinothamarï¼ v2.3.0-rc2ç‰ˆ 2019å¹´3æœˆ13æ—¥ é‡æ„æµæ‰¹å¤„ç†è¡Œä¸ºä»¥æ”¯æŒæ‰¹å¤„ç†æ¶ˆè´¹ã€‚ (5425)æ˜¯å”¯ä¸€çš„å˜åŒ–ã€‚è™½ç„¶ä»æŠ€æœ¯ä¸Šè®²ï¼Œç”±äºæ‰¹å¤„ç†æµAPIçš„æ›´æ”¹ï¼Œå®ƒæ­£åœ¨å´©æºƒï¼Œä½†å®ƒä¸åº”è¯¥ç ´åä»»ä½•æ­£åœ¨å·¥ä½œçš„åº”ç”¨ç¨‹åºä»£ç ï¼Œå› ä¸ºæ‰¹å¤„ç†åŠŸèƒ½ä»¥å‰æ²¡æœ‰å®Œå…¨è¿æ¥ã€‚åœ¨æœ‰çº¿åè®®æˆ–æŒä¹…åŒ–æ–¹é¢æ²¡æœ‰çªç ´æ€§çš„å˜åŒ–ã€‚æ­¤ç‰ˆæœ¬ä¸2.xç‰ˆæœ¬å‘åå…¼å®¹ã€‚ v2.3.0-rc1ç‰ˆ 2019å¹´3æœˆ5æ—¥ ä¸»è¦æ”¹è¿› æ”¯æŒASP.NETæ ¸å¿ƒæ‰˜ç®¡API(Microsoft.Extensions.Hosting). å°†å‘½åé€‰é¡¹çš„è‡ªå®šä¹‰å®ç°æ›¿æ¢ä¸ºMicrosoft.Extensions.Options. EventHubæµæä¾›ç¨‹åºå·²å‡çº§åˆ°EvenHub 2.2.1ï¼Œå¹¶ä¸3.0.0å…¼å®¹ã€‚ é›†ç¾¤æˆå‘˜å…³ç³»è¡¨ä¸­çš„æ—§æ­»æ¡ç›®ç°åœ¨ä¼šè‡ªåŠ¨æ¸…ç†ï¼Œè¿™å¯¹äºæ‰˜ç®¡ä½¿ç”¨æ–°IPç«¯ç‚¹æ¥é‡æ–°å¯åŠ¨silosçš„ç¯å¢ƒå¾ˆæœ‰å¸®åŠ©ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œå…è®¸åœ¨æ€æ´›è¿›ç¨‹ä¸­æœ‰æ•ˆæ‰˜ç®¡å‰ç«¯ä»£ç çš„æ‰˜ç®¡å®¢æˆ·ç«¯ã€‚ 1.5.7ç‰ˆ 2019å¹´2æœˆ28æ—¥ ä»v2.xåç§»æ¤çš„ä¸¤ä¸ªä¿®å¤ç¨‹åº ä¸é—´æ–­çš„é”™è¯¯ä¿®å¤ ä¿®å¤äº†å¤šç¾¤é›†æ”¯æŒ(#3974) æ·»åŠ GSIç¼“å­˜ç»´æŠ¤å’Œæµ‹è¯•(#5184) 2.2.0ç‰ˆ 2018å¹´12æœˆ13æ—¥ è¿™ä¸ªç‰ˆæœ¬ä¸»è¦æ˜¯ä¸ºäº†æ”¯æŒACIDè·¨Grainäº‹åŠ¡ï¼Œä»¥è¾¾åˆ°ç”Ÿäº§å°±ç»ªçš„è´¨é‡ã€‚ æ­¤ç‰ˆæœ¬ä¸åŒ…å«ä»»ä½•é‡å¤§æ›´æ”¹ï¼Œå¹¶ä¸”ä¸2.0.*ç‰ˆæœ¬å‘åå…¼å®¹ï¼Œå…è®¸å¯¹æ­£åœ¨è¿è¡Œçš„ç¾¤é›†è¿›è¡Œå°±åœ°å‡çº§ã€‚ v2.1.0ç‰ˆ 2018å¹´9æœˆ28æ—¥ é‡å¤§å˜åŒ– æ–°å»ºè®¡åˆ’ç¨‹åº( #3792ä¸ª ) æ‰˜ç®¡å®¢æˆ·ç«¯( #3362ä¸ª ) åˆ†å¸ƒå¼äº‹åŠ¡ç®¡ç†å™¨( #3820ä¸ª , #4502ä¸ª , #4538ä¸ª , #4566ä¸ª , #4568 , #4591 , #4599 , #4613 , #4609 , #4616 , #4608 , #4628 , #4638 , #4685 , #4714 , #4739 , #4768 , #4799 , #4781 , #4810ä¸ª , #4820ä¸ª , #4838ä¸ª , #4831ä¸ª , #4871ä¸ª , #4887ä¸ª ) æ–°ä»£ç ç”Ÿæˆå™¨( #4934ä¸ª , #5010å· , #5011å· ) æ”¯æŒäº¤æ˜“ä¸­çš„åè°ƒè½¬ç§»( #4860ä¸ª , #4894ä¸ª , #4949ä¸ª , #5026ä¸ª , ï¼ƒ5024 ) v1.5.6 2018å¹´9æœˆ27æ—¥ è‡ª1.5.5ç‰ˆä»¥æ¥çš„æ”¹è¿›å’Œé”™è¯¯ä¿®å¤ã€‚ ä¸é—´æ–­çš„æ”¹è¿› ä½¿SocketManagerä¸­çš„MaxSocketså¯é…ç½® ï¼ƒ5033 ã€‚ v2.1.0-rc2 2018å¹´9æœˆ21æ—¥ ä¸»è¦å˜åŒ– æ–°ä»£ç ç”Ÿæˆå™¨( ï¼ƒ4934 ï¼Œ ï¼ƒ5010 ï¼Œ ï¼ƒ5011 )ã€‚ v2.1.0-rc1 2018å¹´9æœˆ14æ—¥ ä¸»è¦å˜åŒ– äº¤æ˜“(beta2)( ï¼ƒ4851 ï¼Œ ï¼ƒ4923 ï¼Œ ï¼ƒ4951 ï¼Œ ï¼ƒ4950 ï¼Œ ï¼ƒ4953 ) æ”¯æŒäº¤æ˜“ä¸­çš„åè°ƒè½¬ç§»( ï¼ƒ4860 ï¼Œ ï¼ƒ4894 ï¼Œ ï¼ƒ4949 ) v1.5.5 2018å¹´9æœˆ7æ—¥ è‡ª1.5.4ç‰ˆä»¥æ¥çš„æ”¹è¿›å’Œé”™è¯¯ä¿®å¤ã€‚ ä¸é—´æ–­çš„é”™è¯¯ä¿®å¤ ä¿®å¤ç¨‹åºåŒ–è®¢é˜…é”™è¯¯( ï¼ƒ4943 -- ï¼ƒ3843 ) å°†æ¶ˆæ¯åºåˆ—åŒ–é”™è¯¯ä¼ æ’­ç»™è®¿é—®è€…( ï¼ƒ4944 -- ï¼ƒ4907 ) æ¼æ´ä¿®å¤ æ·»åŠ StreamSubscriptionHandleFactoryä»¥ä»£è¡¨åŠŸèƒ½è®¢é˜…( ï¼ƒ4943 -- ï¼ƒ3843 )ã€‚ä»æŠ€æœ¯ä¸Šæ¥è¯´ï¼Œè¿™è™½ç„¶æ˜¯ä¸€é¡¹é‡å¤§çªç ´ï¼Œä½†å®ƒåªä¼šå½±å“é€šè¿‡è§£å†³è¯¥é—®é¢˜(å°è¯•ä¸è¯¥æ–¹æ¡ˆä¸€èµ·ç”¨äºSMSæµ)çš„ç¨‹åºåŒ–è®¢é˜…åŠŸèƒ½çš„ç”¨æˆ·ã€‚ ï¼ƒ3843 )ã€‚ v2.0.4 2018å¹´8æœˆ7æ—¥ ä¸é—´æ–­çš„é”™è¯¯ä¿®å¤ å¦‚æœä½¿ç”¨dotnetæ ¸å¿ƒmsbuildä½†ä»¥å®Œæ•´çš„.netä¸ºç›®æ ‡ï¼Œåˆ™å°†netcoreapp2.0ç”¨äºmsbuildç›®æ ‡dllã€‚ ï¼ƒ4895 ) v2.1.0 2018å¹´8æœˆ28æ—¥ ä¸»è¦å˜åŒ– æ–°çš„è°ƒåº¦ç¨‹åº( ï¼ƒ3792 ) æ‰˜ç®¡å®¢æˆ·ç«¯( ï¼ƒ3362 ) åˆ†å¸ƒå¼äº‹åŠ¡ç®¡ç†å™¨(æµ‹è¯•ç‰ˆ)( ï¼ƒ3820 ï¼Œ ï¼ƒ4502 ï¼Œ ï¼ƒ4538 ï¼Œ ï¼ƒ4566 ï¼Œ ï¼ƒ4568 ï¼Œ ï¼ƒ4591 ï¼Œ ï¼ƒ4599 ï¼Œ ï¼ƒ4613 ï¼Œ ï¼ƒ4609 ï¼Œ ï¼ƒ4616 ï¼Œ ï¼ƒ4608 ï¼Œ ï¼ƒ4628 ï¼Œ ï¼ƒ4638 ï¼Œ ï¼ƒ4685 ï¼Œ ï¼ƒ4714 ï¼Œ ï¼ƒ4739 ï¼Œ ï¼ƒ4768 ï¼Œ ï¼ƒ4799 ï¼Œ ï¼ƒ4781 ï¼Œ ï¼ƒ4810 ï¼Œ ï¼ƒ4820 ï¼Œ ï¼ƒ4838 ï¼Œ ï¼ƒ4831 ï¼Œ ï¼ƒ4871 ï¼Œ ï¼ƒ4887 ) v2.0.4 2018å¹´8æœˆ7æ—¥ è‡ª2.0.3ä»¥æ¥çš„æ”¹è¿›å’Œé”™è¯¯ä¿®å¤ã€‚ ä¸é—´æ–­çš„é”™è¯¯ä¿®å¤ åœ¨.NET Coreä¸Šè¿è¡Œæ—¶CoreFx /ï¼ƒ30781çš„è§£å†³æ–¹æ³•( ï¼ƒ4736 ) ä¿®å¤.NET Core 2.1æ„å»ºæ—¶ä»£ç ç”Ÿæˆ( ï¼ƒ4673 ) v1.5.4 2018å¹´6æœˆ13æ—¥ v2.0.3 2018å¹´5æœˆ14æ—¥ è¿™æ˜¯å…·æœ‰éƒ¨åˆ†æ„å»ºçš„ç¬¬ä¸€ä¸ªä¿®è¡¥ç¨‹åºç‰ˆæœ¬-ä»…æ›´æ–°äº†9ä¸ªNuGetè½¯ä»¶åŒ…ï¼š Microsoft.Orleans.OrleansRuntime Microsoft.Orleans.OrleansServiceBus Microsoft.Orleans.Runtime.Legacy Microsoft.Orleans.OrleansCodeGenerator.Build å¾®è½¯Orleansæ ¸å¿ƒé—äº§ å¾®è½¯Orleansäº¤æ˜“ Microsoft.Orleans.OrleansCodeGenerator å¾®è½¯Orleansæ ¸å¿ƒ å¾®è½¯Orleansæµ‹è¯•ä¸»æœº å…¶ä½™è½¯ä»¶åŒ…å‡ä¿æŒåœ¨2.0.0ä¸å˜ï¼Œé™¤äº† Microsoft.Orleans.ServiceFabric å…ƒè½¯ä»¶åŒ…ï¼Œç‰ˆæœ¬ä¸º2.0.2ã€‚ v2.0.0 2018å¹´3æœˆ28æ—¥ ä¸»è¦æ›´æ”¹(è‡ª2.0.0-rc2å¼€å§‹) æ‰€æœ‰åŒ…å«çš„æä¾›ç¨‹åºéƒ½ä»å…¨å±€ClusterOptionsè·å¾—ServiceIdå’ŒClusterIdï¼Œå¹¶ä¸”åœ¨å…¶è‡ªå·±çš„é€‰é¡¹ç±»ä¸Šæ²¡æœ‰é‚£äº›å±æ€§(ï¼ƒ4235ï¼Œï¼ƒ4277ã€4290) ä½¿ç”¨å­—ç¬¦ä¸²ä½œä¸ºServiceIdè€Œä¸æ˜¯Guid(ï¼ƒ4262) v2.0.0-rc2 2018å¹´3æœˆ12æ—¥ ä¸»è¦æ›´æ”¹(è‡ª2.0.0-rc1å¼€å§‹) æ–°çš„â€œå¤–è§‚â€ APIå¯ç®€åŒ–æµæä¾›è€…å„ä¸ªæ–¹é¢çš„é…ç½®ï¼šæŒä¹…æµé…ç½®å™¨ v2.0.0-rc1 2018å¹´2æœˆ27æ—¥ é‡å¤§æ›´æ”¹(è‡ª2.0.0-beta3å¼€å§‹) æ–°çš„æä¾›è€…ç”Ÿå‘½å‘¨æœŸæ¨¡å‹å°†å–ä»£æ—§çš„æ¨¡å‹ æ„å»ºå™¨æ¨¡å¼å’ŒåŸºäºé€‰é¡¹çš„ç»„ä»¶å’Œæ‰©å±•é…ç½® v2.0.0-beta3 2017å¹´12æœˆ21æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ15 Orleans2.0ä¸æ ¸å¿ƒå›¢é˜Ÿ 2017å¹´12æœˆ13æ—¥ ä»‹ç» v2.0.0-beta2 2017å¹´12æœˆ12æ—¥ v1.5.3 2017å¹´12æœˆ8æ—¥ v2.0.0-beta1 2017å¹´10æœˆ26æ—¥ ä¸»è¦æ–°åŠŸèƒ½ ç°åœ¨ï¼Œå¤§å¤šæ•°è½¯ä»¶åŒ…éƒ½é’ˆå¯¹.NET Standard 2.0(è¿™æ„å‘³ç€å®ƒä»¬å¯ä»¥åœ¨.NET Frameworkæˆ–.NET Core 2.0ä¸­ä½¿ç”¨)ä»¥åŠåœ¨éWindowså¹³å°ä¸Šä½¿ç”¨ã€‚ v1.5.2 2017å¹´10æœˆ17æ—¥ v1.5.1 2017å¹´8æœˆ28æ—¥ v1.5.0 2017å¹´7æœˆ6æ—¥ ä¸»è¦æ–°åŠŸèƒ½ é€šè¿‡ClientBuilderçš„éé™æ€Grainså®¢æˆ·ç«¯å¯ä»¥ä»åŒä¸€åº”ç”¨ç¨‹åºåŸŸè¿æ¥åˆ°å¤šä¸ªOrleansç¾¤é›†ï¼Œå¹¶ä»ä¸€ä¸ªsilosä¸­è¿æ¥åˆ°å…¶ä»–ç¾¤é›†ã€‚ æ”¯æŒç”¨äºéåœæœºå‡çº§çš„grainæ¥å£çš„ç‰ˆæœ¬æ§åˆ¶ã€‚ æ”¯æŒè‡ªå®šä¹‰Grainså­˜å‚¨ç­–ç•¥å’Œå¯¼æ¼”ã€‚ æ”¯æŒåŸºäºæ•£åˆ—çš„Grainså­˜å‚¨ã€‚ v1.4.2 2017å¹´6æœˆ9æ—¥ v1.4.1 2017å¹´3æœˆ27æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ14 OrleansFSM ä¸ çº¦ç¿°Â·é˜¿æ‰é‡Œäºš(John Azariah) 2017å¹´3æœˆ22æ—¥ v1.4.0 2017å¹´2æœˆ21æ—¥ ä¸»è¦æ–°åŠŸèƒ½ æ”¹è¿›äº†JournaledGrainï¼Œç”¨äºäº‹ä»¶æºï¼Œå¹¶æ”¯æŒåŸºäºåœ°ç†åˆ†å¸ƒçš„åŸºäºæ—¥å¿—çš„ä¸€è‡´æ€§æä¾›ç¨‹åºã€‚ å…·æœ‰å›ºå®šå­˜å‚¨çš„æ¯ä»“åº“åº”ç”¨ç¨‹åºç»„ä»¶çš„Grain Servicesçš„æŠ½è±¡ï¼Œå…¶å·¥ä½œè´Ÿè½½é€šè¿‡é›†ç¾¤ä¸€è‡´æ€§ç¯è¿›è¡Œåˆ†åŒºã€‚ æ”¯æŒä¸å‡åŒ€åˆ†å¸ƒçš„å¯ç”¨ç²®ä»“çš„å¼‚æ„silosã€‚ Service Fabricçš„ç¾¤é›†æˆå‘˜èµ„æ ¼æä¾›ç¨‹åºã€‚ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ13 å‡çº§Orleansåº”ç”¨ç¨‹åº ä¸ è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov) å’Œå›¢é˜Ÿ2017å¹´2æœˆ8æ—¥ ä»‹ç» v1.4.0-beta 2017å¹´2æœˆ1æ—¥ ä¸»è¦æ–°åŠŸèƒ½ æ”¹è¿›äº†JournaledGrainï¼Œç”¨äºäº‹ä»¶æºï¼Œå¹¶æ”¯æŒåŸºäºåœ°ç†åˆ†å¸ƒçš„åŸºäºæ—¥å¿—çš„ä¸€è‡´æ€§æä¾›ç¨‹åºã€‚ å…·æœ‰å›ºå®šå­˜å‚¨çš„æ¯ä»“åº“åº”ç”¨ç¨‹åºç»„ä»¶çš„Grain Servicesçš„æŠ½è±¡ï¼Œå…¶å·¥ä½œè´Ÿè½½é€šè¿‡é›†ç¾¤ä¸€è‡´æ€§ç¯è¿›è¡Œåˆ†åŒºã€‚ æ”¯æŒä¸å‡åŒ€åˆ†å¸ƒçš„å¯ç”¨ç²®ä»“çš„å¼‚æ„silosã€‚ Service Fabricçš„ç¾¤é›†æˆå‘˜èµ„æ ¼æä¾›ç¨‹åºã€‚ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ12 éƒ¨ç½²Orleans ä¸ é›…åº“å¸ƒÂ·ç§‘å†…åŸº(Jakub Konecki) 2016å¹´12æœˆ8æ—¥ ä»‹ç» v1.3.1 2016å¹´11æœˆ15æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ11 ç›‘æ§å’Œå¯è§†åŒ–å±•ç¤º ä¸ ç†æŸ¥å¾·Â·é˜¿æ–¯ç‰¹ä¼¯é‡Œ ï¼Œ ä¸¹Â·èŒƒå¾·å¸ƒå§† å’Œ ç½—æ°Â·å…‹é›·å…‹ 2016å¹´10æœˆ13æ—¥ 1.3.0ç‰ˆ 2016å¹´10æœˆ11æ—¥ v1.2.4 2016å¹´10æœˆ5æ—¥ v1.3.0-beta2 2016å¹´9æœˆ27æ—¥ æ˜¾ç€çš„æ–°åŠŸèƒ½ æ”¯æŒåœ°ç†åˆ†å¸ƒçš„å¤šé›†ç¾¤éƒ¨ç½² ï¼ƒ1108 ï¼ƒ1109 ï¼ƒ1800 æ·»åŠ äº†æ–°çš„Amazon AWSåŸºæœ¬Orleansæä¾›ç¨‹åº ï¼ƒ2006 æ”¯æŒGrainæ–¹æ³•ä¸­çš„åˆ†å¸ƒå¼å–æ¶ˆä»¤ç‰Œ ï¼ƒ1599 ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ10 æ ¸å¿ƒå›¢é˜Ÿä¸Orleans2.0çš„è·¯çº¿å›¾ 2016å¹´8æœˆ25æ—¥ v1.2.3 2016å¹´7æœˆ11æ—¥ 1.2.2ç‰ˆ 2016å¹´6æœˆ15æ—¥ v1.2.1 2016å¹´5æœˆ19æ—¥ v1.2.0 2016å¹´5æœˆ4æ—¥ v1.2.0-beta 2016å¹´4æœˆ18æ—¥ é‡å¤§æ”¹è¿› æ ¹æ®Halo 5ä¸­ä½¿ç”¨çš„ç›¸åŒä»£ç æ·»åŠ äº†EventHubæµæä¾›ç¨‹åºã€‚ æ ¹æ®æƒ…å†µï¼Œååé‡æé«˜äº†5ï¼…è‡³26ï¼…ã€‚ å°†30ä¸ªåŠŸèƒ½æµ‹è¯•ä»¥å¤–çš„æ‰€æœ‰åŠŸèƒ½è¿ç§»åˆ°GitHubã€‚ GrainsçŠ¶æ€ä¸å¿…æ‰©å±• GrainsçŠ¶æ€ ä¸å†(æ ‡è®°ä¸º [è¿‡æ—¶] )ï¼Œå¹¶ä¸”å¯ä»¥æ˜¯ç®€å•çš„POCOç±»ã€‚ å¢åŠ äº†å¯¹æ¯ç±»çš„æ”¯æŒ å’Œ å…¨å±€æœåŠ¡å™¨ç«¯æ‹¦æˆªå™¨ã€‚ æ·»åŠ äº†å¯¹å°†Consul 0.6.0ç”¨ä½œæˆå‘˜èµ„æ ¼æä¾›ç¨‹åºçš„æ”¯æŒã€‚ æ”¯æŒCï¼ƒ6ã€‚ åˆ‡æ¢åˆ°xUnitè¿›è¡Œæµ‹è¯•ï¼Œä»¥å®ç°CoreCLRå…¼å®¹æ€§ã€‚ v1.1.3 2016å¹´3æœˆ9æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ9 å†…å§†Â·æ¯”æ‹‰(Nehme Bilal) å’Œ é²æœ¬Â·é‚¦å¾· è°ˆè®ºéƒ¨ç½²Orleans ä¸ å±±è¯ å’Œ æœåŠ¡é¢æ–™ 2016å¹´2æœˆ26æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ8.5 ç½‘ç»œè®¨è®º ç”±ä¸»åŠ æ°æ£®Â·å¸ƒæ‹‰æ ¼ 2016å¹´2æœˆ11æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ8 Orleansæ ¸å¿ƒå›¢é˜Ÿä»‹ç»è·¯çº¿å›¾ 2016å¹´1æœˆ21æ—¥ v1.1.2 2016å¹´1æœˆ20æ—¥ v1.1.1 2016å¹´1æœˆ11æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ7 åœ£è¯ç‰¹è¾‘- å¶æ–‡Â·é²å‹ƒç½—å¤«(Yevhen Bobrov) ä¸Š Orleanså¡ 2015å¹´12æœˆ17æ—¥ v1.1.0 2015å¹´12æœˆ14æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ6 åœ°ç†åˆ†å¸ƒOrleanspçš„MSRåšå£« 2015å¹´10æœˆ23æ—¥ v1.0.10 2015å¹´9æœˆ22æ—¥ v1.0.9 2015å¹´7æœˆ15æ—¥ v1.0.8 2015å¹´5æœˆ26æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ5 åŠ å¸ƒé‡ŒåŸƒå°”Â·å…‹åˆ©å¥¥ç‰¹(Gabriel Kliot) äºæ–°OrleansStreaming APIä¸Šå‘è¡¨2015å¹´5æœˆ22æ—¥ v1.0.7 2015å¹´5æœˆ15æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ4 é²æœ¬Â·é‚¦å¾· åœ¨FreeBayä¸Šä½¿ç”¨Orleansçš„æœºä¼š2015å¹´4æœˆ15æ—¥ v1.0.5 2015å¹´3æœˆ30æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ3 å¶æ–‡Â·é²å‹ƒç½—å¤«(Yevhen Bobrov) äºOrleansçš„Uniform APIä¸Šä½¿ç”¨2015å¹´3æœˆ6æ—¥ ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ2 Orleanså›¢é˜Ÿç°åœºé—®ç­”å’Œè·¯çº¿å›¾2015å¹´1æœˆ12æ—¥ Orleanså¼€æºv1.0æ›´æ–°(2015å¹´1æœˆ) ç¤¾åŒºè™šæ‹Ÿèšä¼šï¼ƒ1 é›…åº“å¸ƒÂ·ç§‘å†…åŸº(Jakub Konecki) å…³äºäº‹ä»¶æ¥æºçš„Grains2014å¹´12æœˆ18æ—¥"
  },
  "1.5/Documentation/Samples-Overview/Twitter-Sentiment.html": {
    "href": "1.5/Documentation/Samples-Overview/Twitter-Sentiment.html",
    "title": "Twitter Sentiment | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Twitter Sentiment The Twitter Sentiment application records Twitter sentiment by consuming the Twitter streaming API, calulates a sentiment score for each tweet (i.e. is it a positive/negative/neutral tone of lanuage), and then records that sentiment against each hashtag in the tweet using an Orleans grain to maintain a total score for each unique hashtag. The sample illustrates using Orleans to manipulate data with high volumes of input traffic, where each grain owns a row in a table (or a key in a key/value store, or a document in a document store) and all updates go through one single grain, reducing contention for individual rows, keys, or documents. Client The sentiment processing on each tweet is performed in a Node.js application, in server.js, and uses the sentiment library to perform the analysis, which uses key words to determine sentiment. The sentiment score and the actual tweet are posted to the ASP.NET MVC program for processing. The ASP.NET MVC application serves two main roles. It acts as the end point to post sentiment scores into Orleans, and it provides the UI to view hashtag sentiment scores from Orleans. When updating a sentiment score, the SetScore function in GrainContoller.cs gets a handle for a stateless TweetDispatcher grain, and calls its AddScore method. The GetScores method retrieves the score for an arbitrary list of hashtags, each score being expressed as a combination of the overall positive sentiment score, the overall negative sentiment score, and the total number of tweets tracked containing that hashtag. Recall that some sentiment analysis will often result in a neutral weighting, so it is good to track the total number of tweets containing the hashtag. The controller also retrieves a count of the total number of hashtags that the system is tracking, to help give a sense of the scale of data coming in from the Twitter fire hose. Orleans There are three main Orleans grains in the sample. The TweetDispatcher is the public â€œendpointâ€ for sentiment analysis. [StatelessWorker] public interface ITweetDispatcherGrain : Orleans.IGrain { Task AddScore(int score, string[] hashtags, string tweet); Task<Totals[]> GetTotals(string[] hashtags); } Note that it is a stateless grain, and its main role is to pass the work to stateful grains for processing. AddScore takes a tweet, and parses out each hashtag for processing by the appropriate grain. GetTotals retrieves get the number of tweets that have included a specific list of hashtags. This grain exists in part to support the â€œbatch processingâ€ of several hashtags within a single tweet. One Orleans grain is created for each unique hashtag, and this grain is used to track the current sentiment score. [ExtendedPrimaryKey] public interface IHashtagGrain : Orleans.IGrain { Task AddScore(int score, string lastTweet); Task<Totals> GetTotals(); } Note that the ExtendedPrimaryKey attribute indicates that a string, in this case the twitter hashtag, is being used as a composite key for the grain, instead of the more usual Guid or long, which is a more natural fit for grains that have strings rather than numeric keys. The AddMethod updates the current state with the latest sentiment score, and GetTotals returns a Totals structure, with the breakdown of the sentiment analysis, along with the date stamp for the last processed tweet, and the test of the last tweet. The last tweet is kept just to allow the UI to display it, to help give the sentiment more context. When first activated, the grain tracks this activation by calling the IncrementCounter method on a Counter grain. public interface ICounter : Orleans.IGrain { Task IncrementCounter(); Task ResetCounter(); Task<int> GetTotalCounter(); } To increase performance, the counter grain only persists its internal state periodically, in this case, every 100 calls. The running total does not have to be one hundred percent accurate, so if the data were lost due to a silo failure between updates, that would not be critical. If this grain were to be called repeatedly from other grains, it could become a bottleneck, and some form of aggregation pattern would be needed, but as its only called once from each grain, upon grain initialization, this should not be an issue. Prerequisites The following must be installed prior to running the sample: Visual Studio 2013 Orleans SDK Node.js Tools for Visual Studio . Make sure to read the instructions and also install Node.js, not just the VS tools! A Windows Azure storage account A Twitter account and Twitter application development credentials. Sign up as a Twitter Developer and create an application. Make a note of the 'API key', 'API secret', 'Access token' and 'Access secret'. It is important to set the application permissions to include all rights, and then regenerating the keys and tokens before using them. If you don't, the client will silently fail. Running the Sample Open the OrleansTwitterDemo.sln file in Visual Studio 2013, and build the solution. Enter the details from Twitter into the TwitterClient\\app.js file. Start Azure Storage Emulator or replace \"UseDevelopmentStorage=true\" in DevTestServerConfiguration.xml in the Host project with your Azure Storage account Start the local Orleans Silo by running the Host project. Start the TwitterClient project. The Twitter Client should start, showing you every tweet it is consuming. Start the TwitterWebApplication project. Your browser should open on http://localhost:5190/ showing you a few preset hashtags you can monitor. Try adding a couple of hashtags to track using the browser UI. Got get a cup of coffee or do something else for a while, because it may take some time before the tags you care about are seen in the feed."
  },
  "1.5/Documentation/Samples-Overview/GPS-Tracker.html": {
    "href": "1.5/Documentation/Samples-Overview/GPS-Tracker.html",
    "title": "GPS Tracker | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . GPS Tracker A sample application to show how Orleans could be used in conjunction with SignalR to monitor the position of a number of GPS enabled devices, and report these to a web browser. In order to run this sample, you need a Bing Maps API key. The key is used by the GPSTracker.Web project, in Views\\Home\\Index.cshtml. Get a Bing Maps Key Running the Sample Running the sample locally: Open the GPSTracker.sln file in Visual Studio 2013, and build the solution. Start the local Orleans Silo by running the Host project of the solution. In Visual Studio, right click on the GPSTracker.Web project, and click Set as StartUp Project . Press F5 to start GPSTracker.Web web application. Your browser should open on a map of San Francisco. In a command window, navigate to the GPSTracker.FakeDeviceGateway\\bin\\Debug directory, and run the 'GPSTracker.FakeDeviceGateway.exe' program. Pushpins should appear on the map, and move around. Blue ones are moving slow, orange faster. How it Works The GPSTracker.FakeDeviceGateway.exe program simulates data generated from 20 GPS devices. It randomly alters their speed and heading to simulate the devices moving within rectangular boundaries. It sends the position data to Orleans once a second. In Orleans, each device is represented by a Device grain. The grain records the previous position of the device, and can therefore calculate the speed of the device. If the devices has moved, the 'Device' grain forwards position and speed to a PushNotification grain. This 'PushNotification' grain maintains a C# SignalR client, which connects to a SignalR hub hosted in the GPSTracker.Web project. This allows the grain to 'push' messages to the hub without the need for polling the Orleans API. The grain will batch messages together to improve network performance. The GPSTracker.Web application forwards all messages to connected web browsers using SignalR. JavaScript running in the browser positions the pins using a Bing Maps control. If the pin has a low velocity it colors it blue, otherwise orange. Advantages of using Orleans This sample is designed to show Orleans as a low-latency messaging system. Orleans is able to hold state for each device in memory (of which there may be many), allowing a quick calculation to be performed (calculating velocity) based on previous state. The grain in Orleans can also decide whether the message is worthy of forwarding downstream (has the device moved?) and can therefore filter out unnecessary messages and reduce noise. The sample also illustrates how SignalR may be used from inside a grain to allow 'push' messaging directly to clients. In a real life scenario you would probably not forward all messages to the browser, and would filter based on groups or device type."
  },
  "1.5/Documentation/Samples-Overview/Tic-Tac-Toe.html": {
    "href": "1.5/Documentation/Samples-Overview/Tic-Tac-Toe.html",
    "title": "Tic Tac Toe | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Tic Tac Toe TicTacToe is based on the classic board game, also known as \"noughts and crosses.\" Its game logic is simple, which makes it an excellent sample for showing how a turn-based game could be easily implemented in Orleans. A game like this may not at first sight seem a natural fit for Orleans, if you only think about it in terms of a single player game. However, within a social game context, such as a Facebook game, where thousands of players could be playing dozens of games at any one time - some games waiting for the opponent to join, others mid game, waiting for the next move to play out, then it is a much more natural fit. Orleans enables the developer to concentrate on expressing game logic as grains, letting the runtime handle the scale. This sample also demonstrates how an Orleans application can be deployed to Windows Azure. Running the Sample The sample comes complete with a Windows Azure project, so it can be run locally in the Windows Azure local emulator, or deployed as a real cloud service. If running locally, you will need to create multiple \"private\" browsing sessions, to ensure each browser session is recognized as a new player. To run locally without the emulator: Open the TicTacToe.sln file in Visual Studio and build the solution. Set the TicTacToe.Grains project as the startup project. Press F5 to start the application. Start the TicTacToe.Web project manually using the Project context menu -> Debug -> Start new instance Your browser should open, asking you to enter your name. To run locally using the Azure emulator: Open the TicTacToe.sln file in Visual Studio and build the solution. Set the TicTacToe.Azure project as the startup project. Start the Azure Compute Emulator if necessary. Press F5 to start the application. Your browser should open, asking you to enter your name. To run in Windows Azure: Open the TicTacToe.sln file in Visual Studio and build the solution. Expand the TicTacToe.Azure project, and in the Roles folder, open the properties for TicTacToe.Web and TicTacToe.WorkerRole . Set the value for the DataConnectionString setting for both roles to a Windows Azure Storage Account. Right click on the TicTacToe.Azure project, and click Publish . Follow the instructions in the wizard to deploy the application on Azure. The application will deploy, and you will be able to access on http://YOURCLOUDSERVICE.cloudapp.net/ How it works There are two main grain types in OrleansXO, one represents a player, the other representing a game. User Grain A PlayerGrain is activated for each player logging in to the system. A GUID is used to uniquely identify the user, which is stored in a cookie by the MVC web application. The IPlayer interface defines the operations a player can perform: public interface IPlayer : IGrain { Task<List<GameSummary>> GetGameSummaries(); Task<Guid> CreateGame(); Task<GameState> JoinGame(Guid gameId); Task LeaveGame(Guid gameId, GameOutcome outcome); Task SetUsername(string username); Task<string> GetUsername(); } The player grain handles the creating of new games (so another player can then join), leaving a game (once it is over), and tracking the progress of all active games. Game Grain Each game is also represented by a GameGrain . They are also uniquely identify using a GUID. public interface IGame : Orleans.IGrain { Task<GameState> AddPlayerToGame(Guid player); Task<GameState> GetState(); Task<List<GameMove>> GetMoves(); Task<GameState> MakeMove(GameMove move); Task<GameSummary> GetSummary(Guid player); Task SetName(string name); } Once a user grain creates a game, that user is automatically added as one of the players. Once a game is joined by a second player, the game can start. The players make their turns until the game ends with either a draw or a winner. The GameGrain maintains the state of the game, the players in the game, whose turn it is next, and whether the game is in play or finished. The MakeMove method handles the game logic, checking the validity of a move and, once played, checks if that move ends the game. In the case of the game ending, the player grains are informed of the outcome via the LeaveGame call. The game was designed with social gaming in mind, so the main mechanism for inviting other players is an \"out of band\" from the game, and would probably be an invite to a friend, sending the GUID that represents the game. As an optimization purely for testing, a pairing grain was created that uses MemoryCache to hold a the list of games that are available to join, with an expiry of one hour, to stop \"stale\" games appearing on the list. An ASP.NET MVC application serves an HTML page. JavaScript running in the browser polls the web server, and retrieve JSON data, which it renders using Handlebars templates ."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Cluster-Management.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Cluster-Management.html",
    "title": "Cluster Management in Orleans | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Cluster Management in Orleans Orleans provides cluster management via a built-in membership protocol, which we sometimes refer to as Silo Membership . The goal of this protocol is for all silos (Orleans servers) to agree on the set of currently alive silos, detect failed silos, and allow new silos to join the cluster. The protocol relies on an external service to provide an abstraction of MembershipTable . MembershipTable is a flat No-SQL like durable table that we use for 2 purposes. First, it is used as a rendezvous point for silos to find each other and Orleans clients to find silos. Second, it is used to store the current membership view (list of alive silos) and helps coordinate the agreement on the membership view. We currently have 6 implementations of the MembershipTable : based on Azure Table Storage , SQL server, Apache ZooKeeper , Consul IO , AWS DynamoDB , and in-memory emulation for development. In addition to the MembershipTable each silo participates in fully distributed peer-to-peer membership protocol that detects failed silos and reaches agreement on a set alive silos. We start by describing the internal implementation of the Orleans's membership protocol below and later on describe the implementation of the MembershipTable . The Basic Membership Protocol: Upon startup every silo writes itself into a well-known MembershipTable (passed via config). A combination of silo identity ( ip:port:epoch ) and service deployment id are used as unique keys in the table. Epoch is just time in ticks when this silo started, and as such ip:port:epoch is guaranteed to be unique in a given Orleans deployment. Silos monitor each other directly, via application pings (\"are you alive\" heartbeats ). Pings are sent as direct messages from silo to silo, over the same TCP sockets that silos communicate. That way, pings fully correlate with actual networking problems and server health. Every silo pings X other silos. A silo picks whom to ping by calculating consistent hashes on other silos' identity, forming a virtual ring of all identities and picking X successor silos on the ring (this is a well-known distributed technique called consistent hashing and is widely used in many distributed hash tables, like Chord DHT ). If a silo S does not get Y ping replies from a monitored servers P, it suspects it by writing its timestamped suspicion into Pâ€™s row in the MembershipTable . If P has more than Z suspicions within K seconds, then S writes that P is dead into Pâ€™s row, and broadcasts a request for all silos to re-read the membership table (which theyâ€™ll do anyway periodically). In more details: 5.1 Suspicion is written to the MembershipTable , in a special column in the row corresponding to P. When S suspects P it writes: â€œat time TTT S suspected Pâ€. 5.2 One suspicion is not enough to declare P as dead. You need Z suspicions from different silos in a configurable time window T, typically 3 minutes, to declare P as dead. The suspicion is written using optimistic concurrency control provided by the MembershipTable . 5.3 The suspecting silo S reads P's row. 5.4 If S is the last suspector (there have already been Z-1 suspectors within time period T, as written in the suspicion column), S decides to declare P as Dead. In this case, S adds itself to list of suspectors and also writes in P's Status column that P is Dead. 5.5 Otherwise, if S is not the last suspector, S just adds itself to the suspectors column. 5.6 In either case the write back uses the version number or etag that was read, so the updates to this row are serialized. In case the write has failed due to version/etag mismatch, S retries (read again, and try to write, unless P was already marked dead). 5.7 At a high level this sequence of \"read, local modify, write back\" is a transaction. However, we are not using storage transactions to do that. â€œTransactionâ€ code executes locally on a server and we use optimistic concurrency provided by the MembershipTable to ensure isolation and atomicity. Every silo periodically reads the entire membership table for its deployment. That way silos learn about new silos joining and about other silos being declared dead. Configuration : we provide a default configuration, which was hand tuned during our production usage in Azure. Currently the default is: every silo is monitored by 3 other silos, 2 suspicions are enough to declare a silo dead, suspicions only from last 3 minutes (otherwise they are outdated). Pings are send every 10 seconds and you needs to miss 3 pings to suspect a silo. Enforcing Perfect Failure detection â€“ it is theoretically possible that a silo will be declared dead if it lost communication with other silos, while the silo process itself is still running. To solve this problem once the silo is declared dead in the table it is considered dead by everyone, even if it is in fact not dead (just partitioned temporarily or heartbeat messages got lost). Everyone stops communicating with it and once it learns that it is dead (by reading its own new status from the table) it commits suicide and shuts down its process. As a result, there must be an infrastructure in place to restart the silo as a new process (a new epoch number is generated upon start). When it's hosted in Azure, that happens automatically. When it isn't, another infrastructure is required. For example, a Windows Service configured to auto restart on failure. Optimization to reduce the frequency of periodical table reads and speed up all silos learning about new joining silos and dead silos . Every time any silo writes anything successfully to the table (suspicion, new join, â€¦) it also broadcasts to all other silos â€“ â€œgo and reread the table nowâ€. The silo does NOT tell others what it wrote in the table (since this information could already be outdated/wrong), it just tells them to re-read the table. That way we learn very quickly about membership changes without the need to wait for the full periodic read cycle. We still need the periodic read, in case the â€œre-read the tableâ€ message gets lost. Properties of the Basic Membership Protocol and FAQ: Can handle any number of failures â€“ our algorithm can handle any number of failures (that is, f<=n), including full cluster restart. This is in contrast with â€œtraditionalâ€ Paxos based solutions, which require quorum, which is usually a majority. We have seen in production situations when more than half of the silos were down. Our system stayed functional, while Paxos based membership would not be able to make progress. Traffic to the table is very light - The actual pings go directly between servers and not to the table. This would generate a lot of traffic plus would be less accurate from the failure detection perspective - if a silo could not reach the table, it would miss to write its I am alive heartbeat and others would kill him. Tunable accuracy vs. completeness â€“ both perfect and accurate failure detection is not possible in general . One usually wants an ability to tradeoff accuracy (donâ€™t want to declare a silo that is really alive as dead) with completeness (want to declare dead a silo that is indeed dead as soon as possible). The configurable #votes to declare dead and #missed pings allows to trade those two. Scale - the basic protocol can handle thousands and probably even tens of thousands of servers. This is in contrast with traditional Paxos based solutions, such as group communication protocols, which are known not to scale beyond tens. Diagnostics - the table is also very convenient for diagnostics and troubleshooting. System administrator can instantaneously find in the table the current list of alive silos, as well as see the history of all killed silos and suspicions. This is especially useful when diagnosing problems. Why do we need reliable persistent storage for implementation of the MembershipTable ? - we use persistent storage (Azure table, SQL server, AWS DynamoDB, Apache ZooKeeper or Consul IO KV) for the MembershipTable for 2 purposes. First, it is used as a rendezvous point for silos to find each other and Orleans clients to find silos. Second, we use the reliable storage to help us coordinate the agreement on the membership view. While we perform failure detection directly in a peer to peer fashion between the silos, we store the membership view in a reliable storage and use the concurrency control mechanism provided by this storage to reach agreement of who is alive and who is dead. That way, in a sense, our protocol outsources the hard problem of distributed consensus to the cloud. In that we fully utilize the power of the underlying cloud platform, using it truly as \"Platform as a Service\". What happens if the table is not accessible for some time? (storage service is down, unavailable, or there are communication problems with it) â€“ our protocol will NOT declare silos as dead by mistake in such a case. Currently operational silos will keep working without any problems. However, we won't be able to declare a silo dead (if we detected some silo is dead via missed pings we wonâ€™t be able to write this fact to the table) and also won't be able to allow new silos to join. So completeness will suffer, but accuracy will not - partitioning from the table will never cause us to declare silo as dead by mistake. Also, in case of a partial network partition (if some silos can access the table and some not), it could happen that we will declare a dead silo as dead, but it will take some time until all other silos learn about it. So detection could be delayed, but we will never wrongly kill someone due to table un-availability. Direct IAmAlive writes into the table for diagnostics only - in addition to heartbeats that are sent between the silos, each silo also periodically updates an \"I Am Alive\" column in his row in the table. This \"I Am Alive\" column is only used for manual troubleshooting and diagnostics and is not used by the membership protocol itself. It is usually written at much lower frequency (once every 5 minutes) and serves as a very useful tool for system administrators to check the liveness of the cluster or easily find out when the silo was last alive. Extension to totally order membership views: The basic membership protocol described above was later extended to support totally ordered membership views. We will briefly describe the reasons for this extension and how it is implemented. The extension does not change anything in the above design, just adds an additional property that all membership configurations are globally totally ordered. Why it is useful to totally order membership views? This allows serializing the joining of new silos to the cluster. That way, when a new silo joins the cluster it can validate two-way connectivity to every other silo that has already started. If some of the already joined silos do not answer it (potentially indicating a network connectivity problem with the new silo), the new silo is not allowed to join. This ensures that at least when a silo starts, there is a full connectivity between all silos in the cluster (this is implemented). Higher level protocols in the silo, such as distributed grain directory, can utilize the fact that membership views are ordered and use this information to perform smarter duplicate activations resolution. In particular, when directory finds out that 2 activations were created when membership was in flux, it may decide to deactivate the older activation that was created based on the now-outdated membership information (this is currently not implemented). Extended Membership Protocol: For implementation of this feature we utilize the support for transactions over multiple rows that is provided by the MembershipTable .. We add a membership-version row to the table that tracks table changes. When silo S wants to write suspicion or death declaration for silo P: 3.1 S reads the latest table content. If P is already dead, do nothing. Otherwise, 3.2 In the same transaction, write the changes to P's row as well as increment the version number and write it back to the table. 3.3 Both writes are conditioned with eTags. 3.4 If transaction aborts due to eTag mismatch on either P's row or on the version row, attempt again. All writes to the table modify and increment the version row. That way all writes to the table are serialized (via serializing the updates to the version row) and since silos only increment the version number, the writes are also totally ordered in increasing order. Scalability of the Extended Membership Protocol: In the extended version of the protocol all writes are serialized via one row. This can potentially hurt the scalability of the cluster managemenet protocol, since it increases the risk of conflicts between concurrent table writes. To partially mitigate this problem silos retry all their writes to the table by using exponential backoff. We have observed the extended protocols to work smoothly in production environment in Azure with up to 200 silos. However, we do think the protocol might have problems to scale beyond a thousand silos. In such large setups the updates to version row may be easily disabled, essentially maintaining the rest of the cluster managemenet protocol and giving up on the total ordering property. Please also note that we refer here to the scalability of the cluster management protocol, not the rest of Orleans. We believe that other parts of the Orleans runtime (messaging, distributed directory, grain hosting, client to gateway connectivity) are scalable way beyond hundreds of silos. Membership Table: As already mentioned, MembershipTable is used as a rendezvous point for silos to find each other and Orleans clients to find silos and also helps coordinate the agreement on the membership view. We currently have 6 implementation of the MembershipTable : based on Azure Table, SQL server, Apache ZooKeeper, Consul IO, AWS DynamoDB, and in-memory emulation for development. The interface for MembershipTable is defined in IMembershipTable . Azure Table Storage - in this implementation we use Azure deployment ID as partition key and the silo identity ( ip:port:epoch ) as row key. Together they guarantee a unique key per silo. For concurrency control we use optimistic concurrency control based on Azure Table ETags . Every time we read from the table we store the etag for every read row and use that eTag when we try to write back. etags are automatically assigned and checked by Azure Table service on every write. For multi-row transactions we utilize the support for batch transactions provided by Azure table , which guarantees serializale transactions over rows with the same partition key. SQL Server - in this implementation the configured deployment ID is used to distinguish between deployments and which silos belong to which deployments. The silo identity is defined as a combination of deploymentID, ip, port, epoch in appropriate tables and columns. The relational backend uses optimistic concurrency control and transactions, similar to the procedure of using ETags on Azure Table implementation. The relational implementation expects the database engine to generate the ETag used. In case of SQL Server, on SQL Server 2000 the generated ETag is one acquired from a call to NEWID() . On SQL Server 2005 and later ROWVERSION is used. Orleans reads and writes relational ETags as opaque VARBINARY(16) tags and stores them in memory as base64 encoded strings. Orleans supports multi-row inserts using UNION ALL (for Oracle including DUAL), which is currently used to insert statistics data. The exact implementation and rationale for SQL Server can be seen at CreateOrleansTables_SqlServer.sql . Apache ZooKeeper - in this implementation we use the configured deployment ID as a root node and the silo identity ( ip:port@epoch ) as its child node. Together they guarantee a unique path per silo. For concurrency control we use optimistic concurrency control based on the node version . Every time we read from the deployment root node we store the version for every read child silo node and use that version when we try to write back. Each time a node's data changes, the version number increases atomically by the ZooKeeper service. For multi-row transactions we utilize the multi method , which guarantees serializale transactions over silo nodes with the same parent deployment ID node. Consul IO - we used Consul's Key/Value store to impelement the membershop table. Refer to Consul-Deployment for more details. AWS DynamoDB - In this implementation we use the cluster Deployment ID as the Partition Key and Silo Identity ( ip-port-generation ) as the RangeKey making the record unity. The optimistic concurrency is made by the ETag attribute by making conditional writes on DynamoDB. The implementation logic is quite similar to Azure Table Storage. We only implemented the basic membership protocol (and not the extended protocol). In-memory emulation for development setup. We use a special system grain, called MembershipTableGrain , for that implementation. This grain lives on a designated primary silo, which is only used for a development setup . In any real production usage primary silo is not required . Configuration: Membership protocol is configured via the Liveness element in the Globals section in OrleansConfiguration.xml file. The default values were tuned in years of production usage in Azure and we believe they represent good default settings. There is no need in general to change them. Sample config element: <Liveness ProbeTimeout = \"5s\" TableRefreshTimeout =\"10s DeathVoteExpirationTimeout =\"80s\" NumMissedProbesLimit = \"3\" NumProbedSilos=\"3\" NumVotesForDeathDeclaration=\"2\" /> There are 4 types of liveness implemented. The type of the liveness protocol is configured via the SystemStoreType attribute of the SystemStore element in the Globals section in OrleansConfiguration.xml file. MembershipTableGrain - membership table is stored in a grain on primary silo. This is a development setup only . AzureTable - membership table is stored in Azure table. SqlServer - membership table is stored in a relational database. ZooKeeper - membership table is stored in a ZooKeeper ensemble . Consul - configured as Custom system store with MembershipTableAssembly = \"OrleansConsulUtils\" . Refer to Consul-Deployment for more details. DynamoDB - configured as a Custom system store with MembershipTableAssembly = \"OrleansAWSUtils\" . For all liveness types the common configuration variables are defined in Globals.Liveness element: ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send \"I am alive\" heartbeat messages about itself. Default is 10 seconds. TableRefreshTimeout - The number of seconds to fetch updates from the membership table. Default is 60 seconds. DeathVoteExpirationTimeout - Expiration time in seconds for death vote in the membership table. Default is 120 seconds NumMissedProbesLimi t - The number of missed \"I am alive\" heartbeat messages from a silo or number of un-replied probes that lead to suspecting this silo as dead. Default is 3. NumProbedSilos - The number of silos each silo probes for liveness. Default is 3. NumVotesForDeathDeclaration - The number of non-expired votes that are needed to declare some silo as dead (should be at most NumMissedProbesLimit). Default is 2. UseLivenessGossip - Whether to use the gossip optimization to speed up spreading liveness information. Default is true. IAmAliveTablePublishTimeout - The number of seconds to periodically write in the membership table that this silo is alive. Used only for diagnostics. Default is 5 minutes. NumMissedTableIAmAliveLimit - The number of missed \"I am alive\" updates in the table from a silo that causes warning to be logged. Does not impact the liveness protocol. Default is 2. MaxJoinAttemptTime - The number of seconds to attempt to join a cluster of silos before giving up. Default is 5 minutes. ExpectedClusterSize - The expected size of a cluster. Need not be very accurate, can be an overestimate. Used to tune the exponential backoff algorithm of retries to write to Azure table. Default is 20. Design Rationale: A natural question that might be asked is why not to rely completely on Apache ZooKeeper for the cluster membership implementation, potentially by using it's out of the box support for group membership with ephemeral nodes ? Why did we bother implementing our own membership protocol? There were primarily three reasons: 1) Deployment/Hosting in the Cloud - Zookeeper is not a hosted service (at least at the time of this writing July 2015 and definitely when we first implemented this protocol in the summer of 2011 there was no version of Zookeeper running as a hosted service by any major cloud provider). It means that in the Cloud environment Orleans customers would have to deploy/run/manage their own instance of a ZK cluster. This is just yet another unnecessary burden, that we did not want to force on our customers. By using Azure Table we rely on a hosted, managed service which makes our customers lives much simpler. Basically, in the Cloud, use Cloud as a Platform, not as an Infrastructure. On the other hand, when running on premises and managing your own servers, relying on ZK as an implementation of the MembershipTable is a viable option. 2) Direct failure detection - when using ZK's group membership with ephemeral nodes the failure detection is performed between the Orleans servers (ZK clients) and ZK servers. This may not necessarily correlate with the actual network problems between Orleans servers. Our desire was that the failure detection would accurately reflect the intra-cluster state of the communication. Specifically, in our design, if an Orleans silo cannot communicate with the MembershipTable it is not considered dead and can keep working. As opposite to that, have we used ZK group membership with ephemeral nodes a disconnection from a ZK server may cause an Orleans silo (ZK client) to be declared dead, while it may actually be alive and fully functional. 3) Portability and flexibility - as part of Orleans's philosophy, we do not want to force a strong dependence on any particular technology, but rather have a flexible design where different components can be easily switched with different implementations. This is exactly the purpuse that MembershipTable abstraction serves. Acknowledgements: We would to acknowledge the contribution of Alex Kogan to the design and implementation of the first version of this protocol. This work was done as part of summer internship in Microsoft Research in the Summer of 2011. The implementation of ZooKeeper based MembershipTable was done by Shay Hazor , the implementation of SQL MembershipTable was done by Veikko Eeva , the implementation of AWS DynamoDB MembershipTable was done by Gutemberg Ribeiro and the implementation of Consul based MembershipTable was done by Paul North ."
  },
  "1.5/Documentation/Convert-Orleans-v0.9-csproj-to-Use-v1.0-NuGet.html": {
    "href": "1.5/Documentation/Convert-Orleans-v0.9-csproj-to-Use-v1.0-NuGet.html",
    "title": "Convert Orleans v0.9 csproj to use V1.0 NuGet | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . How To Convert a .csproj File To Use Orleans NuGet Packages This note shows how to manually convert a Visual Studio .csproj file which was created with Orleans v0.9 Visual Studio templates from using assembly references based on the $(OrleansSDK) environment variable to using Orleans NuGet packages. These examples assume you are using the latest v1.0.3 NuGet packages from Feb-2015. For simplicity I will use \"v0.9\" to refer to the \"old\" .csproj and \"v1.0\" to refer to the \"new\" .csproj although strictly speaking \"v1.0 really means \">= v1.0.3\" in practice because there was significant restructuring and changes in the Orleans NuGet packages before that point. Grain Interface Project Orleans Grain Interface project -- Example: HelloWorldInterfaces.csproj You might want to preserve a copy of the old .csproj file before you start, if you do not have a copy already preserved in your source code control system. Steps to to change Orleans Grain Interface project: Do Build->Clean on the project to remove any old binaries. Remove old v0.9 assembly references for any Orleans binaries. <ItemGroup> <Reference Include=\"Orleans\"> <HintPath>$(OrleansSDK)\\Binaries\\OrleansClient\\Orleans.dll</HintPath> <Private>False</Private> </Reference> </ItemGroup> Remove old v0.9 Orleans code-gen metadata and script trigger. <PropertyGroup> <OrleansProjectType>Server</OrleansProjectType> </PropertyGroup> <Import Project=\"$(OrleansSDK)\\Binaries\\OrleansClient\\Orleans.SDK.targets\" /> Make sure to re-save the .csproj to disk at this point, otherwise the next step will fail ! Use Visual Studio Package manager to add the Microsoft.Orleans.Templates.Interfaces package to the grain interfaces project. Do this by right-click on project node in Solution Explorer, select \"Manage NuGet Packages...\" context menu item, then search for Orleans and select the Microsoft.Orleans.Templates.Interfaces package. This will add a packages.config file to the project, and add the normal NuGet link code into the .csproj This will also add the Orleans assembly references into the project, and recreate the code-gen metadata and script links for you. Ensure .csproj file is saved to disk again. Do Build->Rebuild on the project to rebuild with the new packages and binaries. Going forward, you should only need to change the version number in packages.config to use a newer package -- either manually edit the packages.config file or use NuGet Package Manager UI in Visual Studio. Orleans Grain Class project -- Example: HelloWorldGrains.csproj Steps to to change Orleans Grain Class project: Steps 1..4 and 6..8 are the same as for the grain interfaces .csproj above. Build->Clean Remove old v0.9 Orleans assembly references Remove old v0.9 Orleans code-gen metadata Save .csproj file to disk Use Visual Studio Package manager to add the Microsoft.Orleans.Templates.Grains package to the project. Follow Steps 6..8 from the grain interfaces .csproj above. Problems? If you have problems getting these conversions to work for you, then please post a full copy of your .csproj into a Gist on your GitHub account and then open a new Issue in the Orleans GitHub Project asking for assistance and pointing to the Gist for your specific project file."
  },
  "1.5/Documentation/Benefits.html": {
    "href": "1.5/Documentation/Benefits.html",
    "title": "Main Benefits | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Benefits The main benefits of Orleans are: developer productivity , even for non-expert programmers; and transparent scalability by default with no special effort from the programmer. We expand on each of these benefits below. Developer Productivity The Orleans programming model raises productivity of both expert and non-expert programmers by providing the following key abstractions, guarantees and system services. Familiar object-oriented programming (OOP) paradigm . Actors are .NET classes that implement declared .NET actor interfaces with asynchronous methods. Thus actors appear to the programmer as remote objects whose methods can be directly invoked. This provides the programmer the familiar OOP paradigm by turning method calls into messages, routing them to the right endpoints, invoking the target actorâ€™s methods and dealing with failures and corner cases in a completely transparent way. Single-threaded execution of actors . The runtime guarantees that an actor never executes on more than one thread at a time. Combined with the isolation from other actors, the programmer never faces concurrency at the actor level, and hence never needs to use locks or other synchronization mechanisms to control access to shared data. This feature alone makes development of distributed applications tractable for non-expert programmers. Transparent activation . The runtime activates an actor as-needed, only when there is a message for it to process. This cleanly separates the notion of creating a reference to an actor, which is visible to and controlled by application code, and physical activation of the actor in memory, which is transparent to the application. In many ways, this is similar to virtual memory in that it decides when to â€œpage outâ€ (deactivate) or â€œpage inâ€ (activate) an actor; the application has uninterrupted access to the full â€œmemory spaceâ€ of logically created actors, whether or not they are in the physical memory at any particular point in time. Transparent activation enables dynamic, adaptive load balancing via placement and migration of actors across the pool of hardware resources. This features is a significant improvement on the traditional actor model, in which actor lifetime is application-managed. Location transparency . An actor reference (proxy object) that the programmer uses to invoke the actorâ€™s methods or pass to other components only contains the logical identity of the actor. The translation of the actorâ€™s logical identity to its physical location and the corresponding routing of messages are done transparently by the Orleans runtime. Application code communicates with actors oblivious to their physical location, which may change over time due to failures or resource management, or because an actor is deactivated at the time it is called. Transparent integration with persistent store . Orleans allows for declarative mapping of actorsâ€™ in-memory state to persistent store. It synchronizes updates, transparently guaranteeing that callers receive results only after the persistent state has been successfully updated. Extending and/or customizing the set of existing persistent storage providers available is straight-forward. Automatic propagation of errors . The runtime automatically propagates unhandled errors up the call chain with the semantics of asynchronous and distributed try/catch. As a result, errors do not get lost within an application. This allows the programmer to put error handling logic at the appropriate places, without the tedious work of manually propagating errors at each level. Transparent Scalability by Default The Orleans programming model is designed to guide the programmer down a path of likely success in scaling their application or service through several orders of magnitude. This is done by incorporating the proven best practices and patterns, and providing an efficient implementation of the lower level system functionality. Here are some key factors that enable scalability and performance. Implicit fine grain partitioning of application state . By using actors as directly addressable entities, the programmer implicitly breaks down the overall state of their application. While the Orleans programming model does not prescribe how big or small an actor should be, in most cases it makes sense to have a relative large number of actors â€“ millions or more â€“ with each representing a natural entity of the application, such as a user account, a purchase order, etc. With actors being individually addressable and their physical location abstracted away by the runtime, Orleans has enormous flexibility in balancing load and dealing with hot spots in a transparent and generic way without any thought from the application developer. Adaptive resource management . With actors making no assumption about locality of other actors they interact with and because of the location transparency, the runtime can manage and adjust allocation of available HW resources in a very dynamic way by making fine grain decisions on placement/migration of actors across the compute cluster in reaction to load and communication patterns without failing incoming requests. By creating multiple replicas of a particular actor the runtime can increase throughput of the actor if necessary without making any changes to the application code. Multiplexed communication . Actors in Orleans have logical endpoints, and messaging between them is multiplexed across a fixed set of all-to-all physical connections (TCP sockets). This allows the runtime to host a very large number (millions) of addressable entities with low OS overhead per actor. In addition, activation/deactivation of an actor does not incur the cost of registering/unregistering of a physical endpoint, such as a TCP port or a HTTP URL, or even closing a TCP connection. Efficient scheduling . The runtime schedules execution of a large number of single-threaded actors across a custom thread pool with a thread per physical processor core. With actor code written in the non-blocking continuation based style (a requirement of the Orleans programming model) application code runs in a very efficient â€œcooperativeâ€ multi-threaded manner with no contention. This allows the system to reach high throughput and run at very high CPU utilization (up to 90%+) with great stability. The fact that a growth in the number of actors in the system and the load does not lead to additional threads or other OS primitives helps scalability of individual nodes and the whole system. Explicit asynchrony . The Orleans programming model makes the asynchronous nature of a distributed application explicit and guides programmers to write non-blocking asynchronous code. Combined with asynchronous messaging and efficient scheduling, this enables a large degree of distributed parallelism and overall throughput without the explicit use of multi-threading."
  },
  "1.5/warning-banner.html": {
    "href": "1.5/warning-banner.html",
    "title": "| Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here ."
  },
  "blog/dmitry-vakulenko.html": {
    "href": "blog/dmitry-vakulenko.html",
    "title": "å¾·ç±³ç‰¹é‡ŒÂ·ç“¦åº“è¿ç§‘(Dmitry Vakulenko) | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¾·ç±³ç‰¹é‡ŒÂ·ç“¦åº“è¿ç§‘(Dmitry Vakulenko) è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov) 2018/11/19ä¸‹åˆ1:57:59 Dmitry Vakulenkoä¸‰å¹´å‰åŠ å…¥äº†Orleanså¼€æºç¤¾åŒºï¼Œå¹¶å¼€å§‹æäº¤ä¾§é‡äºæé«˜Orleansä»£ç åº“æ€§èƒ½çš„è¯·æ±‚ã€‚åœ¨æ ¸å¿ƒå›¢é˜Ÿçš„ç°ä»»å’Œå‰ä»»æˆå‘˜ä¹‹å¤–ï¼Œä»–æˆä¸ºäº†æœ€å¤šäº§çš„è´¡çŒ®è€…ã€‚ å¾·ç±³ç‰¹é‡Œ(Dmitry)ä¹Ÿåšå‡ºäº†å…¶ä»–æ”¹è¿›ï¼Œä½†ä»–çš„æ¿€æƒ…å§‹ç»ˆæ˜¯è¡¨ç°ã€‚ç”±äºå¢é‡ä¼˜åŒ–çš„å¤åˆæ€§è´¨ï¼Œéšç€æ—¶é—´çš„æµé€ï¼Œè¿™äº›æ”¹è¿›åŠ èµ·æ¥è¾¾åˆ°äº†æƒŠäººçš„æ€»å’Œã€‚æˆ‘ä»¬çš„ä¿å®ˆä¼°è®¡æ˜¯ï¼Œå¾·ç±³ç‰¹é‡Œçš„è´¡çŒ®ä½¿Orleansçš„è¡¨ç°æé«˜äº†çº¦2.6å€ã€‚ Dmitryçš„æœ€æ–°è´¡çŒ®æ˜¯é‡æ–°å®ç°äº†Schedulerã€‚è°ƒåº¦ç¨‹åºæ˜¯Orleansè¿è¡Œæ—¶çš„â€œå¿ƒè„â€ï¼Œè´Ÿè´£é«˜æ•ˆå¤„ç†ä¼ å…¥çš„è¯·æ±‚ï¼ŒåŒæ—¶ç¡®ä¿æˆåƒä¸Šä¸‡çš„Grainsæ¿€æ´»ä¸­çš„æ¯ä¸€ä¸ªéƒ½ä»¥å•çº¿ç¨‹æ‰§è¡Œã€‚Dmitryè´¡çŒ®çš„Schedulerçš„æ–°ç‰ˆæœ¬æ¯”åŸå§‹ç‰ˆæœ¬å¿«30ï¼…ï¼Œä½†æ›´ç®€å•ï¼Œè°ƒè¯•æ›´å‹å¥½ã€‚å®ƒæˆä¸º2.1.0ç‰ˆæœ¬çš„å…³é”®åŠŸèƒ½ã€‚ ç»è¿‡æ•°æœˆçš„ç­‰å¾…ç­¾è¯ï¼Œå¾·ç±³ç‰¹é‡Œç»ˆäºè®¡åˆ’åœ¨10æœˆ15æ—¥ä½œä¸ºå¾®è½¯çš„å…¨èŒå‘˜å·¥åŠ å…¥æ ¸å¿ƒå›¢é˜Ÿã€‚åæ¥æˆ‘ä»¬å¾—çŸ¥ä»–åœ¨é‚£æ—¥æœŸå‰ä¸‰å¤©å»ä¸–äº†ã€‚ å¯¹äºæˆ‘ä»¬å’ŒOrleanså‘¨å›´çš„æ•´ä¸ªå¼€æºç¤¾åŒºæ¥è¯´ï¼Œè¿™éƒ½æ˜¯ä¸€ä¸ªå·¨å¤§çš„æ‚²å‰§ï¼Œå¹¶ä¸”æ˜¯å·¨å¤§çš„æŸå¤±ã€‚æˆ‘ä»¬å¤±å»äº†ä¸€ä½éå¸¸æœ‰æ‰åçš„å·¥ç¨‹å¸ˆï¼Œä»–åœ¨ä»–çš„èŒä¸šç”Ÿæ¶¯ä¸­è¿˜å¤„äºæ—©æœŸé˜¶æ®µï¼Œå¹¶ä¸”ä¸ºä»–å¼€è¾Ÿäº†æ‰€æœ‰é“è·¯ã€‚æˆ‘ä»¬å¤±å»äº†ä¸æˆ‘ä»¬åˆä½œå¤šå¹´çš„åŒäº‹å’Œæœ‹å‹ï¼Œå¹¶æœŸå¾…ç€æ›´åŠ ç´§å¯†çš„åˆä½œã€‚ æˆ‘ä»¬éå¸¸æ„Ÿè°¢å¾·ç±³ç‰¹é‡Œ(Dmitry)æ‰€åšçš„ä¸€åˆ‡ã€‚ä»ç„¶å¾ˆéš¾ç›¸ä¿¡ä»–å·²ç»ä¸åœ¨æˆ‘ä»¬èº«è¾¹äº†ã€‚ä»–ä¼šè¢«è®°ä½ï¼Œä»–æ˜¯ä¸€ä¸ªèªæ˜çš„äººï¼Œä¸€ä¸ªè„¾æ°”æš´èºçš„äººï¼Œæ€»æ˜¯ä¹äºæ¥å—æ–°æƒ³æ³•å¹¶ä¹äºåŠ©äººã€‚è°¢è°¢ä½ æ‰€åšçš„ä¸€åˆ‡ï¼Œå¾·ç±³ç‰¹é‡Œï¼"
  },
  "blog/fix-visual-studio-2015-with-orleans-tools-for-visual-studio-1.4.0 installed.html": {
    "href": "blog/fix-visual-studio-2015-with-orleans-tools-for-visual-studio-1.4.0 installed.html",
    "title": "ä½¿ç”¨é€‚ç”¨äºVisual Studio 1.4.0çš„Orleanså·¥å…·ä¿®å¤Visual Studio 2015 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä½¿ç”¨é€‚ç”¨äºVisual Studio 1.4.0çš„Orleanså·¥å…·ä¿®å¤Visual Studio 2015 é˜¿ææ‹‰Â·å“ˆä¼Šå¾·é‡Œå…‹(Attila Hajdrik) 2017/3/10ä¸Šåˆ10:06:17 ä»Šå¤©ï¼Œå¦‚æœä¸¤ä¸ªç¤¾åŒºæˆå‘˜å®‰è£…äº†Orleans VSIXè½¯ä»¶åŒ…çš„1.4.0ç‰ˆæœ¬ï¼Œå°±ä¼šå—åˆ°Visual Studio 2015é—®é¢˜çš„æ‰“å‡»ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªå…¬å¼€çš„é—®é¢˜å¯ä»¥è·Ÿè¸ª çš„GitHub ã€‚å¦‚æœæ‚¨åœ¨Visual Studio 2017ä¸Šå®‰è£…äº†æ‰©å±•ç¨‹åºï¼Œå®ƒå°†å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œåªæœ‰2015å¹´æœ‰æ­¤é—®é¢˜ã€‚æˆ‘ä»¬çœ‹åˆ°çš„é—®é¢˜æ˜¯æ‚¨æ— æ³•æ‰“å¼€â€œå·¥å…·å’Œæ‰©å±•â€çª—å£ï¼ŒVSå°†æ˜¾ç¤ºæ­¤é”™è¯¯å¯¹è¯æ¡†ï¼š åœ¨ç ”ç©¶è§£å†³æ–¹æ¡ˆæ—¶ï¼Œæˆ‘ä»¬æœªå‘å¸ƒæœ‰é—®é¢˜çš„ç‰ˆæœ¬ï¼Œå¹¶å‘å¸ƒäº†è¯¥æ‰©å±•çš„è¾ƒæ—§ç‰ˆæœ¬ï¼Œè¯¥æ‰©å±•ä¸é€‚ç”¨äºVisual Studio 2017ï¼Œä½†éƒ½ä¸ä¼šä½¿Visual Studio 2015æ— æ³•ä½¿ç”¨ã€‚å¦‚æœæ‚¨è¢«æ­¤é—®é¢˜æ‰€å›°æ‰°ï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è¿›è¡Œä¿®å¤ï¼š 1)é€€å‡ºæ‰€æœ‰Visual Studioå®ä¾‹ã€‚ 2)æ‰“å¼€ç®¡ç†å‘˜Visual Studioå¼€å‘äººå‘˜å‘½ä»¤æç¤ºç¬¦ã€‚ 3)cd / Dâ€œï¼…USERPROFILEï¼…\\æœ¬åœ°è®¾ç½®ï¼Œæœ¬åœ°é…ç½®\\å¾®è½¯\\è§†è§‰å·¥ä½œå®¤\\14.0\\æ‰©å±•ç¨‹åºâ€ 4)dir OrleansVSTools.dll / s æ‚¨å°†å¾—åˆ°å¦‚ä¸‹ç»“æœï¼š Cï¼š\\ Users \\\\ Local Settings \\ Microsoft \\ VisualStudio \\ 14.0 \\ Extensions \\ pxzkggpq.50tçš„ç›®å½• 2017/03/10ä¸‹åˆ02:36 18,608 OrleansVSTools.dll 1ä¸ªæ–‡ä»¶18,608å­—èŠ‚ 5)å°†å®Œæ•´ç›®å½•è·¯å¾„å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚ 6)rmdirâ€œâ€ / q / s ç¡®ä¿æ‚¨ä»åœ¨Extensionsç›®å½•ä¸­ã€‚ 7)åˆ é™¤*.cache 8)devenv /è®¾ç½® è¿™å¯èƒ½ä¼šæŒç»­å‡ åˆ†é’Ÿ...è¯·è€å¿ƒç­‰å¾…ã€‚ ç°åœ¨ï¼Œæ‚¨å¯ä»¥å¯åŠ¨Visual Studio 2015ï¼Œå¹¶éªŒè¯â€œæ‰©å±•â€å¯¹è¯æ¡†æ˜¯å¦æ‰“å¼€å¹¶ä¸”ä¸€åˆ‡æ­£å¸¸ã€‚ å¦‚æœæ‚¨ä¸ºVisual Studio 2015é…ç½®äº†ç‰¹æ®Šçš„æ ¹åç¼€ï¼Œåˆ™å¿…é¡»ä¸ºè¯¥ç‰¹å®šå®ä¾‹æ‰§è¡Œè¿™äº›å‘½ä»¤ï¼Œå› æ­¤ä¸åœ¨14.0ä¸­æ‰§è¡Œï¼Œè€Œå¯èƒ½åœ¨14.0Expç›®å½•ä¸­æ‰§è¡Œã€‚ æ›´æ–°2017å¹´3æœˆ17æ—¥ æˆ‘ä»¬å‘å¸ƒäº†æ›´æ–°çš„VSIXï¼Œè¯¥VSIXå¯ä¸VS2013ï¼ŒVS2015ï¼ŒVS2017ä¸€èµ·æ­£å¸¸ä½¿ç”¨ï¼š Microsoft Orleans Visual Studioå·¥å…·"
  },
  "blog/index.html": {
    "href": "blog/index.html",
    "title": "Orleans Blog | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è§£å†³äº¤æ˜“ç»©æ•ˆä¹‹è°œ é²æœ¬Â·é‚¦å¾· 2018/12/7ä¸Šåˆ10:08:58 åˆ°è¾¾é›·å¾·è’™å¾·å¹¶å®Œæˆå¼ºåˆ¶æ€§çš„æ–°å‘˜å·¥å…¥èŒåŸ¹è®­åï¼Œæˆ‘åœ¨Orleanså›¢é˜Ÿçš„é¦–è¦ä»»åŠ¡æ˜¯ååŠ©è¿›è¡Œä¸€äº›æŒç»­çš„ç»©æ•ˆè°ƒæŸ¥ï¼Œä»¥ç¡®ä¿å†…éƒ¨äººå‘˜å¯ä»¥ä½¿ç”¨Orleansçš„äº¤æ˜“æ”¯æŒå¹¶å› æ­¤è€Œé‡Šæ”¾ã€‚ åœ¨é’ˆå¯¹æˆ‘ä»¬çš„æµ‹è¯•é›†ç¾¤çš„å‹åŠ›/è´Ÿè½½æµ‹è¯•ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸¥é‡çš„æ€§èƒ½é—®é¢˜å’Œå¤§é‡äº‹åŠ¡å¤±è´¥ã€‚å¾ˆå¤§ä¸€éƒ¨åˆ†äº‹åŠ¡ä¸€ç›´æš‚åœç›´åˆ°è¶…æ—¶ã€‚ å¾·ç±³ç‰¹é‡ŒÂ·ç“¦åº“è¿ç§‘(Dmitry Vakulenko) è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov) 2018/11/19ä¸‹åˆ1:57:59 Dmitry Vakulenkoä¸‰å¹´å‰åŠ å…¥äº†Orleanså¼€æºç¤¾åŒºï¼Œå¹¶å¼€å§‹æäº¤ä¾§é‡äºæé«˜Orleansä»£ç åº“æ€§èƒ½çš„è¯·æ±‚ã€‚åœ¨æ ¸å¿ƒå›¢é˜Ÿçš„ç°ä»»å’Œå‰ä»»æˆå‘˜ä¹‹å¤–ï¼Œä»–æˆä¸ºäº†æœ€å¤šäº§çš„è´¡çŒ®è€…ã€‚ å¾·ç±³ç‰¹é‡Œ(Dmitry)ä¹Ÿåšå‡ºäº†å…¶ä»–æ”¹è¿›ï¼Œä½†ä»–çš„æ¿€æƒ…å§‹ç»ˆæ˜¯è¡¨ç°ã€‚ç”±äºå¢é‡ä¼˜åŒ–çš„å¤åˆæ€§è´¨ï¼Œéšç€æ—¶é—´çš„æµé€ï¼Œè¿™äº›æ”¹è¿›åŠ èµ·æ¥è¾¾åˆ°äº†æƒŠäººçš„æ€»å’Œã€‚æˆ‘ä»¬çš„ä¿å®ˆä¼°è®¡æ˜¯ï¼Œå¾·ç±³ç‰¹é‡Œçš„è´¡çŒ®ä½¿Orleansçš„è¡¨ç°æé«˜äº†çº¦2.6å€ã€‚ å®£å¸ƒOrleans2.1 é²æœ¬Â·é‚¦å¾· 2018/10/1ä¸‹åˆ7:17:59 ä»Šå¤©ï¼Œæˆ‘ä»¬å®£å¸ƒäº†Orleans2.1ã€‚æ­¤ç‰ˆæœ¬åŒ…æ‹¬å¯¹2.0çš„é‡å¤§æ€§èƒ½æ”¹è¿›ï¼Œå¯¹åˆ†å¸ƒå¼äº‹åŠ¡æ”¯æŒçš„é‡å¤§æ›´æ–°ï¼Œæ–°çš„ä»£ç ç”Ÿæˆå™¨ä»¥åŠç”¨äºå…±åŒæ‰˜ç®¡æ–¹æ¡ˆçš„æ–°åŠŸèƒ½ï¼Œä»¥åŠè¾ƒå°çš„ä¿®å¤å’Œæ”¹è¿›ã€‚é˜…è¯» åœ¨è¿™é‡Œå‘å¸ƒè¯´æ˜ ã€‚"
  },
  "Documentation/implementation/streams_implementation.html": {
    "href": "Documentation/implementation/streams_implementation.html",
    "title": "Streams Implementation Details | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæµå®æ–½ç»†èŠ‚ æœ¬èŠ‚æä¾›äº†Orleans Streamå®æ–½çš„é«˜çº§æ¦‚è¿°ã€‚å®ƒæè¿°äº†åœ¨åº”ç”¨ç¨‹åºçº§åˆ«ä¸Šä¸å¯è§çš„æ¦‚å¿µå’Œç»†èŠ‚ã€‚å¦‚æœä»…è®¡åˆ’ä½¿ç”¨æµï¼Œåˆ™ä¸å¿…é˜…è¯»æœ¬èŠ‚ã€‚ æœ¯è¯­ ï¼š æˆ‘ä»¬ç”¨â€œé˜Ÿåˆ—â€ä¸€è¯æ¥æŒ‡ä»£ä»»ä½•å¯ä»¥å¸æ”¶æµäº‹ä»¶å¹¶å…è®¸æå–äº‹ä»¶æˆ–æä¾›åŸºäºæ¨é€çš„æœºåˆ¶æ¥ä½¿ç”¨äº‹ä»¶çš„æŒä¹…å­˜å‚¨æŠ€æœ¯ã€‚é€šå¸¸ï¼Œä¸ºäº†æä¾›å¯ä¼¸ç¼©æ€§ï¼Œè¿™äº›æŠ€æœ¯æä¾›äº†åˆ†ç‰‡/åˆ†åŒºé˜Ÿåˆ—ã€‚ä¾‹å¦‚ï¼ŒAzureé˜Ÿåˆ—å…è®¸åˆ›å»ºå¤šä¸ªé˜Ÿåˆ—ï¼Œäº‹ä»¶ä¸­å¿ƒå…·æœ‰å¤šä¸ªä¸­å¿ƒï¼ŒKafkaä¸»é¢˜ï¼Œ... æŒä¹…æµ æ‰€æœ‰OrleansæŒä¹…æµæä¾›è€…å…±äº«ä¸€ä¸ªå…±åŒçš„å®ç° PersistentStreamProvider ã€‚è¯¥é€šç”¨æµæä¾›è€…éœ€è¦é…ç½®æœ‰ç‰¹å®šäºæŠ€æœ¯çš„ IQueueAdapterFactory ã€‚ ä¾‹å¦‚ï¼Œå‡ºäºæµ‹è¯•ç›®çš„ï¼Œæˆ‘ä»¬æœ‰é˜Ÿåˆ—é€‚é…å™¨ï¼Œå®ƒä»¬ç”Ÿæˆè‡ªå·±çš„æµ‹è¯•æ•°æ®ï¼Œè€Œä¸æ˜¯ä»é˜Ÿåˆ—ä¸­è¯»å–æ•°æ®ã€‚ä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†æˆ‘ä»¬å¦‚ä½•é…ç½®æŒä¹…æµæä¾›ç¨‹åºä»¥ä½¿ç”¨æˆ‘ä»¬çš„è‡ªå®šä¹‰(ç”Ÿæˆå™¨)é˜Ÿåˆ—é€‚é…å™¨ã€‚å®ƒé€šè¿‡ä½¿ç”¨ç”¨äºåˆ›å»ºé€‚é…å™¨çš„å·¥å‚åŠŸèƒ½é…ç½®æŒä¹…æµæä¾›ç¨‹åºæ¥å®ç°ã€‚ hostBuilder.AddPersistentStreams(StreamProviderName, GeneratorAdapterFactory.Create); å½“æµç”Ÿäº§è€…ç”Ÿæˆæ–°çš„æµé¡¹ç›®å¹¶è°ƒç”¨æ—¶ stream.OnNext() ï¼ŒOrleans Streaming Runtimeåœ¨ä¸Šè°ƒç”¨é€‚å½“çš„æ–¹æ³• IQueueAdapter è¯¥æµæä¾›ç¨‹åºå°†æ¡ç›®ç›´æ¥æ’é˜Ÿåˆ°é€‚å½“çš„é˜Ÿåˆ—ä¸­ã€‚ ç‰µå¼•å‰‚ æŒä¹…æµæä¾›è€…çš„æ ¸å¿ƒæ˜¯æ‹‰åŠ¨ä»£ç†ã€‚æ‹‰åŠ¨ä»£ç†ç¨‹åºä»ä¸€ç»„æŒä¹…é˜Ÿåˆ—ä¸­æ‹‰å‡ºäº‹ä»¶ï¼Œç„¶åå°†äº‹ä»¶ä»¥æ¶ˆè€—å®ƒä»¬çš„æ–¹å¼ä¼ é€’ç»™åº”ç”¨ç¨‹åºä»£ç ã€‚å¯ä»¥å°†æ‹‰åŠ¨ä»£ç†è§†ä¸ºä¸€ç§åˆ†å¸ƒå¼â€œå¾®æœåŠ¡â€ï¼Œå³ä¸€ç§åˆ†åŒºçš„ï¼Œé«˜åº¦å¯ç”¨çš„å¼¹æ€§åˆ†å¸ƒå¼ç»„ä»¶ã€‚æ‹‰åŠ¨ä»£ç†åœ¨æ‰˜ç®¡åº”ç”¨ç¨‹åºGrainçš„ç›¸åŒsilosä¸­è¿è¡Œï¼Œå¹¶ç”±Orleans Streaming Runtimeå®Œå…¨ç®¡ç†ã€‚ StreamQueueMapperå’ŒStreamQueueBalancer ç‰µå¼•å‰‚çš„å‚æ•°è®¾ç½®ä¸º IStreamQueueMapper å’Œ IStreamQueueBalancer ã€‚ IStreamQueueMapper æä¾›æ‰€æœ‰é˜Ÿåˆ—çš„åˆ—è¡¨ï¼Œè¿˜è´Ÿè´£å°†æµæ˜ å°„åˆ°é˜Ÿåˆ—ã€‚è¿™æ ·ï¼ŒæŒä¹…æµæä¾›è€…çš„ç”Ÿäº§è€…æ–¹å°±çŸ¥é“å°†æ¶ˆæ¯æ”¾å…¥å“ªä¸ªé˜Ÿåˆ—ä¸­ã€‚ IStreamQueueBalancer è¡¨ç¤ºé˜Ÿåˆ—åœ¨Orleanssiloså’Œç‰¹å·¥ä¹‹é—´å¹³è¡¡çš„æ–¹å¼ã€‚ç›®æ ‡æ˜¯ä»¥å¹³è¡¡çš„æ–¹å¼ä¸ºä»£ç†åˆ†é…é˜Ÿåˆ—ï¼Œä»¥é˜²æ­¢ç“¶é¢ˆå¹¶æ”¯æŒå¼¹æ€§ã€‚å°†æ–°çš„silosæ·»åŠ åˆ°Orleansé›†ç¾¤åï¼Œæ–°æ—§silosä¹‹é—´çš„é˜Ÿåˆ—ä¼šè‡ªåŠ¨é‡æ–°å¹³è¡¡ã€‚StreamQueueBalancerå…è®¸è‡ªå®šä¹‰è¯¥è¿‡ç¨‹ã€‚Orleanså…·æœ‰è®¸å¤šå†…ç½®çš„StreamQueueBalancersï¼Œä»¥æ”¯æŒä¸åŒçš„å¹³è¡¡æ–¹æ¡ˆ(é˜Ÿåˆ—æ•°é‡å¤§è€Œå°‘)å’Œä¸åŒçš„ç¯å¢ƒ(Azureï¼ŒPremï¼Œé™æ€)ã€‚ ä½¿ç”¨ä¸Šé¢çš„æµ‹è¯•ç”Ÿæˆå™¨ç¤ºä¾‹ï¼Œä»¥ä¸‹ä»£ç æ˜¾ç¤ºäº†å¦‚ä½•é…ç½®é˜Ÿåˆ—æ˜ å°„å™¨å’Œé˜Ÿåˆ—å¹³è¡¡å™¨ã€‚ hostBuilder .AddPersistentStreams(StreamProviderName, GeneratorAdapterFactory.Create, providerConfigurator=>providerConfigurator .Configure<HashRingStreamQueueMapperOptions>(ob=>ob.Configure( options=>{ options.TotalQueueCount = 8; })) .UseDynamicClusterConfigDeploymentBalancer() ); ä¸Šé¢çš„ä»£ç å°†GeneratorAdapteré…ç½®ä¸ºä½¿ç”¨å…·æœ‰8ä¸ªé˜Ÿåˆ—çš„é˜Ÿåˆ—æ˜ å°„å™¨ï¼Œå¹¶ä½¿ç”¨ DynamicClusterConfigDeploymentBalancer ã€‚ æ‹‰åè®® æ¯ä¸ªsiloséƒ½è¿è¡Œä¸€ç»„æ‹‰åŠ¨ä»£ç†ï¼Œæ¯ä¸ªä»£ç†éƒ½ä»ä¸€ä¸ªé˜Ÿåˆ—ä¸­æ‹‰å‡ºã€‚æ‹‰åŠ¨ä»£ç†ç¨‹åºæœ¬èº«ç”±å†…éƒ¨è¿è¡Œæ—¶ç»„ä»¶(ç§°ä¸º SystemTarget ã€‚SystemTargetsæœ¬è´¨ä¸Šæ˜¯è¿è¡Œæ—¶Grainï¼Œå—å•çº¿ç¨‹å¹¶å‘æ€§çš„å½±å“ï¼Œå¯ä»¥ä½¿ç”¨å¸¸è§„çš„Grainæ¶ˆæ¯ä¼ é€’ï¼Œå¹¶ä¸”è½»å·§ã€‚ä¸Grainsç›¸åï¼ŒSystemTargetä¸æ˜¯è™šæ‹Ÿçš„ï¼šå®ƒä»¬æ˜¯ç”±è¿è¡Œæ—¶æ˜¾å¼åˆ›å»ºçš„ï¼Œå¹¶ä¸”ä½ç½®ä¸é€æ˜ã€‚é€šè¿‡å°†æ‹‰åŠ¨ä»£ç†å®ç°ä¸ºSystemTargetsï¼ŒOrleans Streaming Runtimeå¯ä»¥ä¾èµ–äºå†…ç½®çš„OrleansåŠŸèƒ½å¹¶å¯ä»¥æ‰©å±•åˆ°å¤§é‡é˜Ÿåˆ—ï¼Œå› ä¸ºåˆ›å»ºæ–°çš„æ‹‰åŠ¨ä»£ç†ä¸åˆ›å»ºæ–°çš„Grainsä¸€æ ·ä¾¿å®œã€‚ æ¯ä¸ªæ‹‰åŠ¨ä»£ç†éƒ½è¿è¡Œä¸€ä¸ªå®šæœŸè®¡æ—¶å™¨ï¼Œè¯¥å®šæ—¶ä»é˜Ÿåˆ—ä¸­æ‹‰å‡º(é€šè¿‡è°ƒç”¨ IQueueAdapterReceiver ) GetQueueMessagesAsync() æ–¹æ³•ã€‚è¿”å›çš„æ¶ˆæ¯æ”¾åœ¨å†…éƒ¨çš„æ¯ä¸ªä»£ç†çš„æ•°æ®ç»“æ„ä¸­ï¼Œç§°ä¸º IQueueCache ã€‚æ£€æŸ¥æ¯ä¸ªæ¶ˆæ¯ä»¥æ‰¾å‡ºå…¶ç›®æ ‡æµã€‚ä»£ç†ä½¿ç”¨Pub Subæ¥æŸ¥æ‰¾è®¢é˜…æ­¤æµçš„æµä½¿ç”¨è€…åˆ—è¡¨ã€‚æ£€ç´¢åˆ°ä½¿ç”¨è€…åˆ—è¡¨åï¼Œä»£ç†ä¼šå°†å…¶å­˜å‚¨åœ¨æœ¬åœ°(åœ¨å…¶pub-subç¼“å­˜ä¸­)ï¼Œå› æ­¤æ— éœ€åœ¨æ¯æ¡æ¶ˆæ¯ä¸Šéƒ½ä¸Pub Subè¿›è¡Œåå•†ã€‚ä»£ç†è¿˜è®¢é˜…pub-subï¼Œä»¥æ¥æ”¶æœ‰å…³è®¢é˜…è¯¥æµçš„ä»»ä½•æ–°ä½¿ç”¨è€…çš„é€šçŸ¥ã€‚ä»£ç†ä¸pub-subä¿è¯ä¹‹é—´çš„è¿™ç§æ¡æ‰‹ å¼ºå¤§çš„æµè®¢é˜…è¯­ä¹‰ ï¼š æ¶ˆè´¹è€…è®¢é˜…äº†æµä¹‹åï¼Œå®ƒå°†çœ‹åˆ°è®¢é˜…åç”Ÿæˆçš„æ‰€æœ‰äº‹ä»¶ ã€‚å¦å¤–ï¼Œä½¿ç”¨ StreamSequenceToken å…è®¸å…¶è¿‡å»è®¢é˜…ã€‚ é˜Ÿåˆ—ç¼“å­˜ IQueueCache æ˜¯å†…éƒ¨çš„æ¯ä¸ªä»£ç†ç¨‹åºæ•°æ®ç»“æ„ï¼Œè¯¥ç»“æ„å…è®¸å°†æ–°äº‹ä»¶ä»é˜Ÿåˆ—ä¸­åˆ†ç¦»å‡ºæ¥å¹¶å°†å®ƒä»¬ä¼ é€’ç»™ä½¿ç”¨è€…ã€‚å®ƒè¿˜å…è®¸å°†ä¼ é€’åˆ°ä¸åŒæµå’Œä¸åŒæ¶ˆè´¹è€…çš„è€¦åˆè§£è€¦ã€‚ æƒ³è±¡è¿™æ ·ä¸€ç§æƒ…å†µï¼Œå…¶ä¸­ä¸€ä¸ªæµæœ‰3ä¸ªæµä½¿ç”¨è€…ï¼Œå…¶ä¸­ä¸€ä¸ªå¾ˆæ…¢ã€‚å¦‚æœä¸æ³¨æ„ï¼Œè¿™ç§ç¼“æ…¢çš„ä½¿ç”¨è€…å¯èƒ½ä¼šå½±å“ä»£ç†çš„è¿›åº¦ï¼Œå‡æ…¢è¯¥æµçš„å…¶ä»–ä½¿ç”¨è€…çš„æ¶ˆè€—ï¼Œç”šè‡³å‡æ…¢å…¶ä»–æµçš„äº‹ä»¶çš„å‡ºé˜Ÿå’Œä¼ é€’ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µå¹¶å…è®¸ä»£ç†ä¸­çš„æœ€å¤§å¹¶è¡Œåº¦ï¼Œæˆ‘ä»¬ä½¿ç”¨ IQueueCache ã€‚ IQueueCache ç¼“å†²æµäº‹ä»¶ï¼Œå¹¶ä¸ºä»£ç†æä¾›ä¸€ç§ä»¥è‡ªå·±çš„èŠ‚å¥å°†äº‹ä»¶ä¼ é€’ç»™æ¯ä¸ªä½¿ç”¨è€…çš„æ–¹å¼ã€‚æ¯ä¸ªæ¶ˆè´¹è€…çš„äº¤ä»˜éƒ½æ˜¯é€šè¿‡å†…éƒ¨ç»„ä»¶å®ç°çš„ IQueueCacheCursor ï¼Œå®ƒè·Ÿè¸ªæ¯ä¸ªæ¶ˆè´¹è€…çš„è¿›åº¦ã€‚è¿™æ ·ï¼Œæ¯ä¸ªä½¿ç”¨è€…å°±å¯ä»¥æŒ‰ç…§è‡ªå·±çš„èŠ‚å¥æ¥æ”¶äº‹ä»¶ï¼šå¿«é€Ÿçš„ä½¿ç”¨è€…åœ¨ä»é˜Ÿåˆ—ä¸­å‡ºé˜Ÿåå°±å¯ä»¥å°½å¿«æ¥æ”¶äº‹ä»¶ï¼Œè€Œè¾ƒæ…¢çš„ä½¿ç”¨è€…åˆ™åœ¨ä»¥åæ¥æ”¶äº‹ä»¶ã€‚ä¸€æ—¦æ¶ˆæ¯ä¼ é€’ç»™æ‰€æœ‰ä½¿ç”¨è€…ï¼Œå°±å¯ä»¥ä»ç¼“å­˜ä¸­å°†å…¶åˆ é™¤ã€‚ èƒŒå‹ Orleansæµè¿è¡Œæ—¶ä¸­çš„èƒŒå‹åœ¨ä¸¤ä¸ªåœ°æ–¹é€‚ç”¨ï¼š å°†æµäº‹ä»¶ä»é˜Ÿåˆ—å¸¦åˆ°ä»£ç† å’Œ å°†äº‹ä»¶ä»ä»£ç†ä¼ é€’åˆ°æµæ¶ˆè´¹è€… ã€‚ åè€…ç”±å†…ç½®çš„Orleansæ¶ˆæ¯ä¼ é€’æœºåˆ¶æä¾›ã€‚æ¯ä¸ªæµäº‹ä»¶éƒ½é€šè¿‡æ ‡å‡†çš„OrleansGrainsæ¶ˆæ¯ä¼ é€’ä¸€æ¬¡ä»ä»£ç†ä¼ é€’åˆ°æ¶ˆè´¹è€…ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä»£ç†å°†ä¸€ä¸ªäº‹ä»¶(æˆ–æ•°é‡æœ‰é™çš„äº‹ä»¶)å‘é€ç»™æ¯ä¸ªå•ç‹¬çš„æµä½¿ç”¨è€…ï¼Œå¹¶ç­‰å¾…æ­¤è®¿é—®ã€‚åœ¨è§£å†³æˆ–ç ´åä¸Šä¸€ä¸ªäº‹ä»¶çš„ä»»åŠ¡ä¹‹å‰ï¼Œä¸‹ä¸€ä¸ªäº‹ä»¶å°†ä¸ä¼šå¼€å§‹ä¼ é€’ã€‚è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬è‡ªç„¶ä¼šå°†æ¯æ¬¡æ¶ˆè´¹è€…çš„æŠ•æ”¾é€Ÿåº¦é™åˆ¶ä¸ºä¸€æ¬¡åªå‘é€ä¸€æ¡æ¶ˆæ¯ã€‚ å…³äºå°†æµäº‹ä»¶ä»é˜Ÿåˆ—ä¼ é€’åˆ°ä»£ç†ï¼ŒOrleans Streamingæä¾›äº†ä¸€ç§æ–°çš„ç‰¹æ®ŠèƒŒå‹æœºåˆ¶ã€‚ç”±äºä»£ç†å°†äº‹ä»¶çš„å‡ºé˜Ÿä»é˜Ÿåˆ—ä¸­è§£è€¦å¹¶ä¼ é€’ç»™ä½¿ç”¨è€…ï¼Œå› æ­¤å•ä¸ªç¼“æ…¢çš„ä½¿ç”¨è€…å¯èƒ½ä¼šè½åå¾ˆå¤šï¼Œä»¥è‡³äº IQueueCache å°†å¡«æ»¡ã€‚é˜»æ­¢ IQueueCache ä¸ºäº†é¿å…æ— é™æœŸå¢é•¿ï¼Œæˆ‘ä»¬é™åˆ¶äº†å®ƒçš„å¤§å°(å¤§å°é™åˆ¶æ˜¯å¯é…ç½®çš„)ã€‚ä½†æ˜¯ï¼Œä»£ç†æ°¸è¿œä¸ä¼šä¸¢å¼ƒæœªäº¤ä»˜çš„äº‹ä»¶ã€‚ç›¸åï¼Œå½“ç¼“å­˜å¼€å§‹å¡«æ»¡æ—¶ï¼Œä»£ç†ä¼šå‡æ…¢äº‹ä»¶ä»é˜Ÿåˆ—ä¸­å‡ºé˜Ÿçš„é€Ÿåº¦ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒæ•´ä»é˜Ÿåˆ—ä¸­æ¶ˆè€—çš„é€Ÿç‡(â€œèƒŒå‹â€)æ¥â€œæ‘†è„±â€ç¼“æ…¢çš„äº¤ä»˜å‘¨æœŸï¼Œç„¶åç¨åæ¢å¤ä¸ºå¿«é€Ÿçš„æ¶ˆè€—é€Ÿç‡ã€‚è¦æ£€æµ‹â€œç¼“æ…¢æŠ•æ”¾â€çš„å±±è°· IQueueCache ä½¿ç”¨é«˜é€Ÿç¼“å­˜å­˜å‚¨åŒºçš„å†…éƒ¨æ•°æ®ç»“æ„æ¥è·Ÿè¸ªå°†äº‹ä»¶äº¤ä»˜ç»™å„ä¸ªæµä½¿ç”¨è€…çš„è¿›åº¦ã€‚è¿™å¯¼è‡´äº†ä¸€ä¸ªéå¸¸æ•æ„Ÿå’Œè‡ªæˆ‘è°ƒæ•´çš„ç³»ç»Ÿã€‚"
  },
  "Documentation/implementation/messaging_delivery_guarantees.html": {
    "href": "Documentation/implementation/messaging_delivery_guarantees.html",
    "title": "Messaging Delivery Guarantees | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ¶ˆæ¯ä¼ é€’ä¿è¯ Orleansæ¶ˆæ¯ä¼ é€’ä¿è¯æ˜¯ æœ€å¤šä¸€æ¬¡ ï¼Œ é»˜è®¤ã€‚å¯é€‰åœ°ï¼Œå¦‚æœé…ç½®ä¸ºåœ¨è¶…æ—¶åé‡è¯•ï¼Œåˆ™Orleansæä¾›è‡³å°‘ä¸€æ¬¡ä¼ é€ã€‚ æ›´è¯¦ç»†åœ°ï¼š Orleansä¸­çš„æ¯æ¡æ¶ˆæ¯éƒ½æœ‰è‡ªåŠ¨è¶…æ—¶(å¯ä»¥é…ç½®ç¡®åˆ‡çš„è¶…æ—¶)ã€‚å¦‚æœç­”å¤æœªæŒ‰æ—¶åˆ°è¾¾ï¼Œåˆ™è¿”å›çš„Taskä¼šä¸­æ–­ï¼Œå¹¶å‡ºç°è¶…æ—¶å¼‚å¸¸ã€‚ å¯ä»¥å°†Orleansé…ç½®ä¸ºåœ¨è¶…æ—¶åè‡ªåŠ¨é‡è¯•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä¸ä¼šè‡ªåŠ¨é‡è¯•ã€‚ å½“ç„¶ï¼Œåº”ç”¨ç¨‹åºä»£ç ä¹Ÿå¯ä»¥é€‰æ‹©åœ¨è¶…æ—¶æ—¶é‡è¯•ã€‚ å¦‚æœå°†Orleansç³»ç»Ÿé…ç½®ä¸ºä¸æ‰§è¡Œè‡ªåŠ¨é‡è¯•(é»˜è®¤è®¾ç½®)ï¼Œå¹¶ä¸”åº”ç”¨ç¨‹åºæœªé‡æ–°å‘é€ï¼Œ Orleansæœ€å¤šæä¾›ä¸€æ¬¡æ¶ˆæ¯ä¼ é€’ ã€‚ä¸€æ¡æ¶ˆæ¯å°†è¢«å‘é€ä¸€æ¬¡æˆ–å®Œå…¨ä¸å‘é€ã€‚ å®ƒæ°¸è¿œä¸ä¼šè¢«äº¤ä»˜ä¸¤æ¬¡ã€‚ åœ¨å…·æœ‰é‡è¯•åŠŸèƒ½çš„ç³»ç»Ÿä¸­(é€šè¿‡è¿è¡Œæ—¶æˆ–åº”ç”¨ç¨‹åº)ï¼Œæ¶ˆæ¯å¯èƒ½å¤šæ¬¡åˆ°è¾¾ã€‚Orleansç›®å‰ä¸é‡‡å–ä»»ä½•æªæ–½æ¥æŒä¹…å­˜å‚¨å“ªäº›æ¶ˆæ¯å·²ç»åˆ°è¾¾å¹¶ç¦æ­¢ç¬¬äºŒæ¬¡å‘é€ã€‚(æˆ‘ä»¬ç›¸ä¿¡è¿™ä¼šéå¸¸æ˜‚è´µã€‚)å› æ­¤ï¼Œåœ¨é‡è¯•ç³»ç»Ÿä¸­ï¼ŒOrleansæœ€å¤šä¸èƒ½ä¿è¯ä¸€æ¬¡äº¤è´§ã€‚ å¦‚æœæ‚¨æ— é™æœŸåœ°é‡è¯• ï¼Œ æ¶ˆæ¯æœ€ç»ˆå°†åˆ°è¾¾ ï¼Œå› æ­¤æä¾›äº†è‡³å°‘ä¸€æ¬¡çš„äº¤è´§ä¿è¯ã€‚æ³¨æ„ï¼Œâ€œå°†æœ€ç»ˆåˆ°è¾¾â€æ˜¯è¿è¡Œæ—¶éœ€è¦ä¿è¯çš„ã€‚å³ä½¿æ‚¨ç»§ç»­é‡è¯•ï¼Œå®ƒä¹Ÿä¸æ˜¯å…è´¹çš„ã€‚Orleansæä¾›æœ€ç»ˆäº¤ä»˜æ–¹å¼ï¼Œå› ä¸ºGrainsæ°¸è¿œä¸ä¼šè¿›å…¥ä»»ä½•æ°¸ä¹…æ€§å¤±æ•ˆçŠ¶æ€ï¼Œè€Œå¤±æ•ˆçš„Grainsæœ€ç»ˆå°†åœ¨å¦ä¸€ä¸ªsilosä¸­é‡æ–°æ¿€æ´»ã€‚ æ‰€ä»¥æ€»ç»“ä¸€ä¸‹ ï¼šåœ¨ä¸é‡è¯•çš„ç³»ç»Ÿä¸­ï¼ŒOrleansä¿è¯æœ€å¤šå‘é€ä¸€æ¬¡æ¶ˆæ¯ã€‚åœ¨æ— é™æ¬¡é‡è¯•çš„ç³»ç»Ÿä¸­ï¼ŒOrleansä¿è¯è‡³å°‘ä¸€æ¬¡(å¹¶ä¸”ä¸ä¿è¯æœ€å¤šä¸€æ¬¡)ã€‚ æ³¨æ„ ï¼š åœ¨é‡Œé¢ OrleansæŠ€æœ¯æŠ¥å‘Š æˆ‘ä»¬æ— æ„ä¸­åªæåˆ°äº†ç¬¬äºŒä¸ªé€‰é¡¹ï¼Œå³è‡ªåŠ¨é‡è¯•ã€‚æˆ‘ä»¬å¿˜è®°æåŠé»˜è®¤æƒ…å†µä¸‹ä¸é‡è¯•ï¼ŒOrleansæœ€å¤šæä¾›ä¸€æ¬¡äº¤ä»˜ã€‚"
  },
  "Documentation/implementation/orleans_lifecycle.html": {
    "href": "Documentation/implementation/orleans_lifecycle.html",
    "title": "Orleans Lifecycle | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansç”Ÿå‘½å‘¨æœŸ æ€»è§ˆ Orleansçš„æŸäº›è¡Œä¸ºéå¸¸å¤æ‚ï¼Œå› æ­¤éœ€è¦æœ‰åºåœ°å¯åŠ¨å’Œå…³é—­ã€‚å…·æœ‰æ­¤ç±»è¡Œä¸ºçš„æŸäº›ç»„ä»¶åŒ…æ‹¬Grainsï¼Œsiloså’Œå®¢æˆ·ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¼•å…¥äº†é€šç”¨ç»„ä»¶ç”Ÿå‘½å‘¨æœŸæ¨¡å¼ã€‚æ­¤æ¨¡å¼åŒ…æ‹¬ä¸€ä¸ªå¯è§‚å¯Ÿçš„ç”Ÿå‘½å‘¨æœŸï¼Œè¯¥ç”Ÿå‘½å‘¨æœŸè´Ÿè´£åœ¨ç»„ä»¶å¯åŠ¨å’Œå…³é—­çš„å„ä¸ªé˜¶æ®µå‘å‡ºä¿¡å·ï¼Œè€Œç”Ÿå‘½å‘¨æœŸè§‚å¯Ÿå™¨åˆ™è´Ÿè´£åœ¨ç‰¹å®šé˜¶æ®µæ‰§è¡Œå¯åŠ¨æˆ–å…³é—­æ“ä½œã€‚ ä¹Ÿå¯ä»¥çœ‹çœ‹ Grainsç”Ÿå‘½å‘¨æœŸ å’Œ silosç”Ÿå‘½å‘¨æœŸ ã€‚ å¯è§‚å¯Ÿçš„ç”Ÿå‘½å‘¨æœŸ éœ€è¦é¡ºåºå¯åŠ¨å’Œå…³é—­çš„ç»„ä»¶å¯ä»¥ä½¿ç”¨å¯è§‚å¯Ÿçš„ç”Ÿå‘½å‘¨æœŸï¼Œè¯¥å‘¨æœŸå¯å…è®¸å…¶ä»–ç»„ä»¶è§‚å¯ŸLiveCycleå¹¶åœ¨å¯åŠ¨æˆ–å…³é—­è¿‡ç¨‹ä¸­åˆ°è¾¾æŸä¸ªé˜¶æ®µæ—¶æ¥æ”¶é€šçŸ¥ã€‚ public interface ILifecycleObservable { IDisposable Subscribe(string observerName, int stage, ILifecycleObserver observer); } è®¢é˜…è®¿é—®åœ¨å¯åŠ¨æˆ–åœæ­¢æ—¶è¾¾åˆ°é˜¶æ®µæ—¶ä¼šæ³¨å†Œè§‚å¯Ÿè€…ä»¥è¿›è¡Œé€šçŸ¥ã€‚è§‚å¯Ÿè€…åç§°ç”¨äºæŠ¥å‘Šã€‚æŒ‡ç¤ºåœ¨å¯åŠ¨/å…³é—­é¡ºåºä¸­çš„å“ªä¸€ç‚¹å°†é€šçŸ¥è§‚å¯Ÿè€…çš„é˜¶æ®µã€‚ç”Ÿå‘½å‘¨æœŸçš„æ¯ä¸ªé˜¶æ®µéƒ½æ˜¯å¯è§‚å¯Ÿçš„ã€‚å½“å¼€å§‹å’Œåœæ­¢åˆ°è¾¾é˜¶æ®µæ—¶ï¼Œå°†é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…ã€‚é˜¶æ®µä»¥å‡åºå¼€å§‹ï¼Œä»¥é™åºåœæ­¢ã€‚è§‚å¯Ÿè€…å¯ä»¥é€šè¿‡å¤„ç½®è¿”å›çš„IDisposableç‰©å“æ¥é€€è®¢ã€‚ ç”Ÿå‘½å‘¨æœŸè§‚å¯Ÿè€… éœ€è¦å‚ä¸å¦ä¸€ä¸ªç»„ä»¶ç”Ÿå‘½å‘¨æœŸçš„ç»„ä»¶éœ€è¦ä¸ºå…¶å¯åŠ¨å’Œå…³é—­è¡Œä¸ºæä¾›æŒ‚é’©ï¼Œå¹¶è®¢é˜…å¯è§‚å¯Ÿåˆ°çš„ç”Ÿå‘½å‘¨æœŸçš„ç‰¹å®šé˜¶æ®µã€‚ public interface ILifecycleObserver { Task OnStart(CancellationToken ct); Task OnStop(CancellationToken ct); } OnStart / OnStop åœ¨å¯åŠ¨/å…³é—­æœŸé—´è¾¾åˆ°è®¢é˜…çš„é˜¶æ®µæ—¶å°†è°ƒç”¨ã€‚ å®ç”¨å·¥å…· ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œå·²ç»ä¸ºå¸¸è§çš„ç”Ÿå‘½å‘¨æœŸä½¿ç”¨æ¨¡å¼åˆ›å»ºäº†è¾…åŠ©åŠŸèƒ½ã€‚ æ‰©å±•å å­˜åœ¨ç”¨äºè®¢é˜…å¯è§‚å¯Ÿç”Ÿå‘½å‘¨æœŸçš„æ‰©å±•åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½ä¸éœ€è¦è®¢é˜…ç»„ä»¶å®ç°ILifecycleObserverã€‚è€Œæ˜¯ï¼Œè¿™äº›å…è®¸ç»„ä»¶ä¼ é€’lambdaæˆ–åœ¨é¢„è®¢é˜¶æ®µè°ƒç”¨æˆå‘˜å‡½æ•°ã€‚ IDisposable Subscribe(this ILifecycleObservable observable, string observerName, int stage, Func<CancellationToken, Task> onStart, Func<CancellationToken, Task> onStop); IDisposable Subscribe(this ILifecycleObservable observable, string observerName, int stage, Func<CancellationToken, Task> onStart); ç±»ä¼¼çš„æ‰©å±•åŠŸèƒ½å…è®¸ä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°æ¥ä»£æ›¿è§‚å¯Ÿè€…åç§°ã€‚ IDisposable Subscribe<TObserver>(this ILifecycleObservable observable, int stage, Func<CancellationToken, Task> onStart, Func<CancellationToken, Task> onStop); IDisposable Subscribe<TObserver>(this ILifecycleObservable observable, int stage, Func<CancellationToken, Task> onStart); ç”Ÿå‘½å‘¨æœŸå‚ä¸ ä¸€äº›å¯æ‰©å±•æ€§ç‚¹éœ€è¦ä¸€ç§æ–¹æ³•æ¥è¯†åˆ«å“ªäº›ç»„ä»¶å¯¹å‚ä¸ç”Ÿå‘½å‘¨æœŸæ„Ÿå…´è¶£ã€‚ä¸ºæ­¤ï¼Œå¼•å…¥äº†ç”Ÿå‘½å‘¨æœŸå‚ä¸è€…æ ‡è®°æ¥å£ã€‚æ¢ç´¢siloså’ŒGrainsçš„ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œå°†è¯¦ç»†ä»‹ç»å¦‚ä½•ä½¿ç”¨å®ƒã€‚ public interface ILifecycleParticipant<TLifecycleObservable> where TLifecycleObservable : ILifecycleObservable { void Participate(TLifecycleObservable lifecycle); } ä¾‹ æ ¹æ®æˆ‘ä»¬çš„ç”Ÿå‘½å‘¨æœŸæµ‹è¯•ï¼Œä»¥ä¸‹æ˜¯åœ¨ç”Ÿå‘½å‘¨æœŸçš„å¤šä¸ªé˜¶æ®µå‚ä¸å¯è§‚å¯Ÿç”Ÿå‘½å‘¨æœŸçš„ç»„ä»¶ç¤ºä¾‹ã€‚ enum TestStages { Down, Initialize, Configure, Run, } class MultiStageObserver : ILifecycleParticipant<ILifecycleObservable> { public Dictionary<TestStages,bool> Started { get; } = new Dictionary<TestStages, bool>(); public Dictionary<TestStages, bool> Stopped { get; } = new Dictionary<TestStages, bool>(); private Task OnStartStage(TestStages stage) { this.Started[stage] = true; return Task.CompletedTask; } private Task OnStopStage(TestStages stage) { this.Stopped[stage] = true; return Task.CompletedTask; } public void Participate(ILifecycleObservable lifecycle) { lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Down, ct => OnStartStage(TestStages.Down), ct => OnStopStage(TestStages.Down)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Initialize, ct => OnStartStage(TestStages.Initialize), ct => OnStopStage(TestStages.Initialize)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Configure, ct => OnStartStage(TestStages.Configure), ct => OnStopStage(TestStages.Configure)); lifecycle.Subscribe<MultiStageObserver>((int)TestStages.Run, ct => OnStartStage(TestStages.Run), ct => OnStopStage(TestStages.Run)); } }"
  },
  "Documentation/implementation/load_balancing.html": {
    "href": "Documentation/implementation/load_balancing.html",
    "title": "Load Balancing | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è´Ÿè½½å‡è¡¡ ä»å¹¿ä¹‰ä¸Šè®²ï¼Œè´Ÿè½½å¹³è¡¡æ˜¯Orleansè¿è¡Œæ—¶çš„æ”¯æŸ±ä¹‹ä¸€ ã€‚Orleansè¿è¡Œæ—¶ä¼šå°è¯•ä½¿æ‰€æœ‰å†…å®¹ä¿æŒå¹³è¡¡ï¼Œå› ä¸ºå¹³è¡¡å¯ä»¥æœ€å¤§ç¨‹åº¦åœ°åˆ©ç”¨èµ„æºå¹¶é¿å…å‡ºç°çƒ­ç‚¹ï¼Œä»è€Œæé«˜æ€§èƒ½ï¼Œå¹¶æœ‰åŠ©äºæé«˜å¼¹æ€§ã€‚Orleansçš„è´Ÿè½½å¹³è¡¡é€‚ç”¨äºå¤šä¸ªåœ°æ–¹ã€‚ä»¥ä¸‹æ˜¯è¿è¡Œæ—¶è¿›è¡Œå¹³è¡¡çš„åœ°æ–¹çš„éè¯¦å°½åˆ—è¡¨ï¼š é»˜è®¤çš„æ¼”å‘˜å­˜å‚¨ç­–ç•¥æ˜¯éšæœºçš„ -æ–°çš„æ¿€æ´»éšæœºåˆ†å¸ƒåœ¨å„ä¸ªå­¤å²›ä¸­ã€‚è¿™æ ·å¯ä»¥åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹å¹³è¡¡å­˜å‚¨å¹¶é˜²æ­¢å‡ºç°çƒ­ç‚¹ã€‚ æ›´é«˜çº§ ActivationCountPlacement å°è¯•ä½¿æ‰€æœ‰silosä¸Šçš„æ¿€æ´»æ¬¡æ•°ç›¸ç­‰ï¼Œä»è€Œå¯¼è‡´å„ä¸ªsilosä¸Šçš„æ¿€æ´»åˆ†å¸ƒæ›´åŠ å‡åŒ€ã€‚è¿™å¯¹äºå¼¹æ€§å°¤å…¶é‡è¦ã€‚ Grainsç›®å½•æœåŠ¡ åœ¨åˆ†å¸ƒå¼å“ˆå¸Œè¡¨çš„é¡¶éƒ¨æ„å»ºï¼Œè¯¥å“ˆå¸Œè¡¨æœ¬è´¨ä¸Šæ˜¯å¹³è¡¡çš„ã€‚ç›®å½•æœåŠ¡å°†Grainsæ˜ å°„åˆ°æ¿€æ´»ï¼Œæ¯ä¸ªsiloséƒ½æ‹¥æœ‰å…¨å±€æ˜ å°„è¡¨çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶ä¸”è¯¥è¡¨ä»¥å¹³è¡¡çš„æ–¹å¼åœ¨æ‰€æœ‰silosä¸­è¿›è¡Œå…¨å±€åˆ†åŒºã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä¸€è‡´çš„å“ˆå¸Œä¸è™šæ‹Ÿå­˜å‚¨æ¡¶ä¸€èµ·ä½¿ç”¨ã€‚ å®¢æˆ·ç«¯è¿æ¥åˆ°æ‰€æœ‰ ç½‘å…³ å¹¶å¹³è¡¡åœ°åˆ†æ•£ä»–ä»¬çš„è¦æ±‚ã€‚ æé†’æœåŠ¡ æ˜¯åˆ†å¸ƒå¼åˆ†åŒºè¿è¡Œæ—¶æœåŠ¡ã€‚å°±åƒç²®ä»“ç›®å½•ä¸­ä¸€æ ·ï¼Œå“ªä¸ªsilosçš„åˆ†é…è´Ÿè´£æœåŠ¡å“ªä¸ªæé†’ï¼Œå¹¶é€šè¿‡ä¸€è‡´çš„å“ˆå¸Œåœ¨æ‰€æœ‰silosä¹‹é—´è¿›è¡Œå¹³è¡¡ã€‚ silosä¸­å¯¹æ€§èƒ½è‡³å…³é‡è¦çš„ç»„ä»¶è¿›è¡Œäº†åˆ†åŒºï¼Œå¹¶ä¸”å®ƒä»¬ä¹‹é—´çš„å·¥ä½œæ˜¯æœ¬åœ°å¹³è¡¡çš„ ã€‚è¿™æ ·ï¼Œå­¤å²›è¿è¡Œæ—¶å¯ä»¥å……åˆ†åˆ©ç”¨æ‰€æœ‰å¯ç”¨çš„CPUå†…æ ¸ï¼Œè€Œä¸ä¼šé€ æˆå­¤å²›ç“¶é¢ˆã€‚è¿™é€‚ç”¨äºæ‰€æœ‰æœ¬åœ°èµ„æºï¼šå°†å·¥ä½œåˆ†é…ç»™çº¿ç¨‹ï¼Œå¥—æ¥å­—ï¼Œè°ƒåº¦è´£ä»»ï¼Œé˜Ÿåˆ—ç­‰ã€‚ StreamQueueBalance å¹³è¡¡äº†ä»æŒä¹…åŒ–é˜Ÿåˆ—ä¸­è·¨é›†ç¾¤ä¸­å„ä¸ªå­¤å²›æå–äº‹ä»¶çš„è´£ä»»ã€‚ å¦è¯·æ³¨æ„ ä»å¹¿ä¹‰ä¸Šè®²ï¼Œå¹³è¡¡å¹¶ä¸ä¸€å®šæ„å‘³ç€å¤±å»å±€åŸŸæ€§ ã€‚ä¸€ä¸ªå¯ä»¥ä¿æŒå¹³è¡¡ï¼Œå¹¶ä¸”ä»ç„¶ä¿æŒè‰¯å¥½çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼Œå½“å¹³è¡¡æ„å‘³ç€åˆ†ç‰‡/åˆ†åŒºæ—¶ï¼Œæ‚¨å¯ä»¥å¯¹æŸä¸ªé€»è¾‘ä»»åŠ¡è¿›è¡Œåˆ†åŒºï¼ŒåŒæ—¶ä»ä¿æŒæ¯ä¸ªåˆ†åŒºå†…çš„å±€éƒ¨æ€§ã€‚è¿™é€‚ç”¨äºæœ¬åœ°å’Œåˆ†å¸ƒå¼å¹³è¡¡ã€‚ è¯·å‚é˜…æ­¤æ¼”ç¤ºæ–‡ç¨¿ Orleansçš„å¹³è¡¡æŠ€æœ¯ æ›´å¤šç»†èŠ‚ã€‚"
  },
  "Documentation/implementation/index.html": {
    "href": "Documentation/implementation/index.html",
    "title": "Implementation Details | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å®æ–½ç»†èŠ‚æ¦‚è¿° Orleansç”Ÿå‘½å‘¨æœŸ Orleansçš„æŸäº›è¡Œä¸ºéå¸¸å¤æ‚ï¼Œå› æ­¤éœ€è¦æœ‰åºåœ°å¯åŠ¨å’Œå…³é—­ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¼•å…¥äº†é€šç”¨ç»„ä»¶ç”Ÿå‘½å‘¨æœŸæ¨¡å¼ã€‚ æ¶ˆæ¯ä¼ é€’ä¿è¯ Orleansæ¶ˆæ¯ä¼ é€’ä¿è¯æ˜¯ æœ€å¤šä¸€æ¬¡ ï¼Œ é»˜è®¤ã€‚(å¯é€‰)å¦‚æœé…ç½®ä¸ºåœ¨è¶…æ—¶åé‡è¯•ï¼Œåˆ™Orleansæä¾›è‡³å°‘ä¸€æ¬¡äº¤ä»˜ã€‚ æ’ç¨‹å™¨ Orleans Scheduleræ˜¯Orleansè¿è¡Œæ—¶ä¸­çš„ä¸€ä¸ªç»„ä»¶ï¼Œè´Ÿè´£æ‰§è¡Œåº”ç”¨ç¨‹åºä»£ç å’Œéƒ¨åˆ†è¿è¡Œæ—¶ä»£ç ï¼Œä»¥ç¡®ä¿å•çº¿ç¨‹æ‰§è¡Œè¯­ä¹‰ã€‚ é›†ç¾¤ç®¡ç† Orleansé€šè¿‡å†…ç½®çš„æˆå‘˜èµ„æ ¼åè®®(æœ‰æ—¶ç§°ä¸ºâ€œsilosæˆå‘˜èµ„æ ¼â€)æä¾›é›†ç¾¤ç®¡ç†ã€‚è¯¥åè®®çš„ç›®æ ‡æ˜¯è®©æ‰€æœ‰å­¤å²›(OrleansæœåŠ¡å™¨)å°±å½“å‰æ´»åŠ¨çš„å­¤å²›é›†è¾¾æˆå…±è¯†ï¼Œæ£€æµ‹å‡ºæ•…éšœçš„å­¤å²›ï¼Œå¹¶å…è®¸æ–°çš„å­¤å²›åŠ å…¥é›†ç¾¤ã€‚ æµå®æ–½ æœ¬èŠ‚æä¾›äº†Orleans Streamå®æ–½çš„é«˜çº§æ¦‚è¿°ã€‚å®ƒæè¿°äº†åœ¨åº”ç”¨ç¨‹åºçº§åˆ«ä¸Šä¸å¯è§çš„æ¦‚å¿µå’Œç»†èŠ‚ã€‚ è´Ÿè½½å‡è¡¡ ä»å¹¿ä¹‰ä¸Šè®²ï¼Œè´Ÿè½½å¹³è¡¡æ˜¯Orleansè¿è¡Œæ—¶çš„æ”¯æŸ±ä¹‹ä¸€ã€‚ å•å…ƒæµ‹è¯• æœ¬èŠ‚è¯´æ˜å¦‚ä½•å¯¹Grainsè¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œä»¥ç¡®ä¿å…¶è¡Œä¸ºæ­£ç¡®ã€‚"
  },
  "Documentation/implementation/cluster_management.html": {
    "href": "Documentation/implementation/cluster_management.html",
    "title": "Cluster Management in Orleans | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansçš„é›†ç¾¤ç®¡ç† Orleansé€šè¿‡ä¸€ä¸ªå†…ç½®çš„æˆå‘˜åè®®æä¾›é›†ç¾¤ç®¡ç†ï¼Œæˆ‘ä»¬æœ‰æ—¶å°†å…¶ç§°ä¸º silosæˆå‘˜èµ„æ ¼ . ä¸ºäº†è®©æ–°Orleansçš„æ‰€æœ‰æœåŠ¡å™¨éƒ½åŠ å…¥åˆ°silos(silos)çš„åè®®ä¸­ï¼Œç›®å‰è¿˜æ²¡æœ‰è¾¾æˆä¸€è‡´ï¼Œå³å…è®¸æ–°Orleansçš„silosåŠ å…¥åˆ°silosä¸­ã€‚ åè®®ä¾èµ–äºä¸€ä¸ªå¤–éƒ¨æœåŠ¡æ¥æä¾› æˆå‘˜èµ„æ ¼è¡¨ . æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ä¸€ä¸ªå¹³é¢çš„éSQLç±»å‹çš„æŒä¹…è¡¨ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç”¨é€”ã€‚é¦–å…ˆï¼Œå®ƒè¢«ç”¨ä½œä¸€ä¸ªé›†åˆç‚¹ï¼Œä¾›å„è‡ªä¸ºæ”¿çš„äººäº’ç›¸å¯»æ‰¾ï¼Œè€ŒOrleansçš„å®¢æˆ·åˆ™ç”¨æ¥å¯»æ‰¾silosã€‚å…¶æ¬¡ï¼Œå®ƒç”¨äºå­˜å‚¨å½“å‰çš„æˆå‘˜èµ„æ ¼è§†å›¾(æ´»åŠ¨silosåˆ—è¡¨)ï¼Œå¹¶å¸®åŠ©åè°ƒæˆå‘˜èµ„æ ¼è§†å›¾ä¸Šçš„åè®®ã€‚æˆ‘ä»¬ç›®å‰æœ‰6ä¸ª æˆå‘˜èµ„æ ¼è¡¨ ï¼šåŸºäº Azureè¡¨å­˜å‚¨ ï¼ŒSQL serverï¼Œ é˜¿å¸•å¥‡åŠ¨ç‰©å›­ç®¡ç†å‘˜ , IOé¢†äº‹ , AWSå‘ç”µæœºB ï¼Œä»¥åŠå†…å­˜ä»¿çœŸä»¥è¿›è¡Œå¼€å‘ã€‚é™¤äº† æˆå‘˜èµ„æ ¼è¡¨ æ¯ä¸ªsiloséƒ½å‚ä¸å®Œå…¨åˆ†å¸ƒå¼çš„å¯¹ç­‰æˆå‘˜èº«ä»½åè®®ï¼Œè¯¥åè®®æ£€æµ‹å‡ºæ•…éšœçš„silosï¼Œå¹¶å°±â€œè®¾ç½®æ´»åŠ¨silosâ€è¾¾æˆä¸€è‡´ã€‚æˆ‘ä»¬é¦–å…ˆåœ¨ä¸‹é¢æè¿°Orleansæˆå‘˜åè®®çš„å†…éƒ¨å®ç°ï¼Œç„¶åæè¿° æˆå‘˜èµ„æ ¼è¡¨ . åŸºæœ¬æˆå‘˜åè®®ï¼š åœ¨å¯åŠ¨æ—¶ï¼Œæ¯ä¸ªsiloséƒ½å°†è‡ªå·±å†™å…¥ä¸€ä¸ªè‘—åçš„ æˆå‘˜èµ„æ ¼è¡¨ (é€šè¿‡é…ç½®ä¼ é€’)ã€‚silosæ ‡è¯†çš„ç»„åˆ( ipåœ°å€ï¼šç«¯å£ï¼šepoch )å’ŒæœåŠ¡éƒ¨ç½²idç”¨ä½œè¡¨ä¸­çš„å”¯ä¸€é”®ã€‚Epochå°±æ˜¯è¿™ä¸ªsiloså¼€å§‹æ—¶çš„è®¡æ—¶å•ä½ ipåœ°å€ï¼šç«¯å£ï¼šepoch ä¿è¯åœ¨ç»™å®šçš„Orleanséƒ¨ç½²ä¸­æ˜¯ç‹¬ä¸€æ— äºŒçš„ã€‚ silosé€šè¿‡åº”ç”¨ç¨‹åºpingç›¸äº’ç›´æ¥ç›‘è§†(â€œä½ è¿˜æ´»ç€å—â€ å¿ƒè·³ ). pingä½œä¸ºç›´æ¥æ¶ˆæ¯ä»siloså‘é€åˆ°silosï¼Œé€šè¿‡silosé€šä¿¡çš„åŒä¸€ä¸ªTCPå¥—æ¥å­—ã€‚è¿™æ ·ï¼Œpingä¸å®é™…çš„ç½‘ç»œé—®é¢˜å’ŒæœåŠ¡å™¨è¿è¡ŒçŠ¶å†µå®Œå…¨ç›¸å…³ã€‚æ¯ä¸€ä¸ªsiloséƒ½ä¼šå‘å‡ºå¦ä¸€ä¸ªsilosçš„å£°éŸ³ã€‚ä¸€ä¸ªsilosé€šè¿‡è®¡ç®—å…¶ä»–silosæ ‡è¯†ä¸Šçš„ä¸€è‡´æ•£åˆ—å€¼æ¥æŒ‘é€‰è¦pingçš„å¯¹è±¡ï¼Œå½¢æˆä¸€ä¸ªåŒ…å«æ‰€æœ‰æ ‡è¯†çš„è™šæ‹Ÿç¯ï¼Œå¹¶åœ¨è¯¥ç¯ä¸Šé€‰æ‹©Xä¸ªåç»§silo(è¿™æ˜¯ä¸€ç§è‘—åçš„åˆ†å¸ƒå¼æŠ€æœ¯ï¼Œç§°ä¸º ä¸€è‡´å“ˆå¸Œ åœ¨è®¸å¤šåˆ†å¸ƒå¼å“ˆå¸Œè¡¨ä¸­è¢«å¹¿æ³›ä½¿ç”¨ï¼Œæ¯”å¦‚ å¼¦å¼DHT ). å¦‚æœsilosSæ²¡æœ‰ä»å—ç›‘è§†çš„æœåŠ¡å™¨Pè·å¾—Y pingå“åº”ï¼Œå®ƒä¼šé€šè¿‡å°†å…¶å¸¦æœ‰æ—¶é—´æˆ³çš„æ€€ç–‘å†™å…¥Pçš„è¡Œä¸­æ¥æ€€ç–‘å®ƒ æˆå‘˜èµ„æ ¼è¡¨ . å¦‚æœPåœ¨Kç§’å†…æœ‰è¶…è¿‡Zä¸ªæ€€ç–‘ï¼Œé‚£ä¹ˆSä¼šå°†På†™å…¥Pçš„è¡Œä¸­ï¼Œå¹¶å‘æ‰€æœ‰siloså¹¿æ’­ä¸€ä¸ªé‡æ–°è¯»å–æˆå‘˜è¡¨çš„è¯·æ±‚(æ— è®ºå¦‚ä½•ï¼Œå®ƒä»¬éƒ½ä¼šå®šæœŸæ‰§è¡Œ)ã€‚ æ›´å¤šè¯¦æƒ…ï¼š 5.1æ€€ç–‘è¢«å†™å…¥ æˆå‘˜èµ„æ ¼è¡¨ ï¼Œåœ¨å¯¹åº”äºPçš„è¡Œä¸­çš„ä¸€ä¸ªç‰¹æ®Šåˆ—ä¸­ã€‚å½“Sæ€€ç–‘Pæ—¶ï¼Œå®ƒå†™ä¸‹ï¼šâ€œat time TTT S successed Pâ€ã€‚ 5.2ä¸€æ¬¡æ€€ç–‘ä¸è¶³ä»¥å®£å‘ŠPæ­»äº¡ã€‚æ‚¨éœ€è¦åœ¨ä¸€ä¸ªå¯é…ç½®çš„æ—¶é—´çª—å£T(é€šå¸¸ä¸º3åˆ†é’Ÿ)å†…ï¼Œä»ä¸åŒçš„silosä¸­å¾—åˆ°Zä¸ªæ€€ç–‘ï¼Œæ‰èƒ½å°†På£°æ˜ä¸ºdeadã€‚ä½¿ç”¨ç”± æˆå‘˜èµ„æ ¼è¡¨ . 5.3å¯ç–‘silosSæ˜¾ç¤ºPè¡Œã€‚ 5.4å¦‚æœSæ˜¯æœ€åä¸€ä¸ªå«Œç–‘çŠ¯(å¦‚å«Œç–‘æ ä¸­æ‰€è¿°ï¼Œåœ¨æ—¶é—´æ®µTå†…å·²ç»æœ‰Z-1å«Œç–‘çŠ¯)ï¼ŒSå†³å®šå®£å¸ƒPæ­»äº¡ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼ŒSå°†è‡ªå·±æ·»åŠ åˆ°suspencersåˆ—è¡¨ä¸­ï¼Œå¹¶åœ¨Pçš„Statusåˆ—ä¸­å†™å…¥P is Deadã€‚ 5.5å¦åˆ™ï¼Œå¦‚æœSä¸æ˜¯æœ€åä¸€ä¸ªsuspencersï¼Œåˆ™Såªå°†è‡ªå·±æ·»åŠ åˆ°suspencersåˆ—ä¸­ã€‚ 5.6åœ¨ä»»ä½•ä¸€ç§æƒ…å†µä¸‹ï¼Œå›å†™éƒ½ä½¿ç”¨è¯»å–çš„ç‰ˆæœ¬å·æˆ–etagï¼Œå› æ­¤å¯¹æ­¤è¡Œçš„æ›´æ–°æ˜¯åºåˆ—åŒ–çš„ã€‚å¦‚æœç”±äºç‰ˆæœ¬/etagä¸åŒ¹é…è€Œå¯¼è‡´å†™å…¥å¤±è´¥ï¼ŒSå°†é‡è¯•(å†æ¬¡è¯»å–å¹¶å°è¯•å†™å…¥ï¼Œé™¤éPå·²æ ‡è®°ä¸ºdead)ã€‚ 5.7åœ¨è¾ƒé«˜çš„å±‚æ¬¡ä¸Šï¼Œâ€œè¯»å–ã€æœ¬åœ°ä¿®æ”¹ã€å›å†™â€åºåˆ—æ˜¯ä¸€ä¸ªäº‹åŠ¡ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨å­˜å‚¨äº‹åŠ¡æ¥å®ç°è¿™ä¸€ç‚¹ã€‚â€œäº‹åŠ¡â€ä»£ç åœ¨æœåŠ¡å™¨ä¸Šæœ¬åœ°æ‰§è¡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ æˆå‘˜èµ„æ ¼è¡¨ ä»¥ç¡®ä¿éš”ç¦»å’ŒåŸå­æ€§ã€‚ æ¯ä¸ªsiloså®šæœŸè¯»å–æ•´ä¸ªæˆå‘˜è¡¨ä»¥è¿›è¡Œéƒ¨ç½²ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œsilosäº†è§£åˆ°æ–°çš„silosåŠ å…¥ä»¥åŠå…¶ä»–silosè¢«å®£å¸ƒæ­»äº¡ã€‚ é…ç½® ï¼šæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªé»˜è®¤é…ç½®ï¼Œå®ƒæ˜¯åœ¨æˆ‘ä»¬åœ¨Azureä¸­çš„ç”Ÿäº§ä½¿ç”¨è¿‡ç¨‹ä¸­æ‰‹åŠ¨è°ƒæ•´çš„ã€‚ç›®å‰çš„é»˜è®¤å€¼æ˜¯ï¼šæ¯ä¸ªsilosç”±å¦å¤–3ä¸ªsilosç›‘è§†ï¼Œ2ä¸ªæ€€ç–‘è¶³ä»¥å®£å¸ƒä¸€ä¸ªsiloså¤±æ•ˆï¼Œæ€€ç–‘ä»…ä»æœ€å3åˆ†é’Ÿå¼€å§‹(å¦åˆ™å®ƒä»¬å°±è¿‡æ—¶äº†)ã€‚æ¯10ç§’å‘é€ä¸€æ¬¡pingï¼Œæ‚¨éœ€è¦é”™è¿‡3æ¬¡pingæ‰èƒ½æ€€ç–‘ä¸€ä¸ªsilosã€‚ å®æ–½å®Œç¾æ•…éšœæ£€æµ‹ â€“ç†è®ºä¸Šï¼Œå¦‚æœä¸€ä¸ªsilosä¸å…¶ä»–siloså¤±å»é€šä¿¡ï¼Œè€Œsilosè¿›ç¨‹æœ¬èº«ä»åœ¨è¿è¡Œï¼Œåˆ™è¯¥siloså°†è¢«å®£å¸ƒä¸ºæ­»æœºã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸€æ—¦silosåœ¨è¡¨ä¸­è¢«å£°æ˜ä¸ºdeadï¼Œæ¯ä¸ªäººéƒ½è®¤ä¸ºå®ƒå·²ç»æ­»äº†ï¼Œå³ä½¿å®ƒå®é™…ä¸Šæ²¡æœ‰æ­»(åªæ˜¯æš‚æ—¶åˆ†åŒºæˆ–è€…å¿ƒè·³æ¶ˆæ¯ä¸¢å¤±)ã€‚æ¯ä¸ªäººéƒ½åœæ­¢ä¸å®ƒäº¤æµï¼Œä¸€æ—¦å®ƒçŸ¥é“å®ƒæ­»äº†(é€šè¿‡ä»è¡¨ä¸­è¯»å–å®ƒè‡ªå·±çš„æ–°çŠ¶æ€)ï¼Œå®ƒå°±ä¼šè‡ªæ€å¹¶å…³é—­è¿›ç¨‹ã€‚å› æ­¤ï¼Œå¿…é¡»æœ‰ä¸€ä¸ªé€‚å½“çš„åŸºç¡€è®¾æ–½æ¥é‡æ–°å¯åŠ¨silosä½œä¸ºä¸€ä¸ªæ–°çš„è¿›ç¨‹(åœ¨å¯åŠ¨æ—¶ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„epochç¼–å·)ã€‚å½“å®ƒæ‰˜ç®¡åœ¨Azureä¸­æ—¶ï¼Œä¼šè‡ªåŠ¨å‘ç”Ÿè¿™ç§æƒ…å†µã€‚å¦‚æœæ²¡æœ‰ï¼Œå°±éœ€è¦å¦ä¸€ä¸ªåŸºç¡€è®¾æ–½ã€‚ä¾‹å¦‚ï¼Œé…ç½®ä¸ºåœ¨å‘ç”Ÿæ•…éšœæ—¶è‡ªåŠ¨é‡æ–°å¯åŠ¨çš„WindowsæœåŠ¡ã€‚ ä¼˜åŒ–ä»¥å‡å°‘å®šæœŸè¡¨è¯»å–çš„é¢‘ç‡ï¼Œå¹¶åŠ å¿«æ‰€æœ‰siloså­¦ä¹ æ–°çš„è¿æ¥siloså’Œæ­»silos . æ¯å½“ä»»ä½•silosæˆåŠŸåœ°å‘è¡¨ä¸­å†™å…¥ä»»ä½•å†…å®¹(æ€€ç–‘ã€æ–°è”æ¥ï¼Œâ€¦)æ—¶ï¼Œå®ƒä¹Ÿä¼šå¹¿æ’­åˆ°æ‰€æœ‰å…¶ä»–silosâ€”â€œç°åœ¨å°±å»é‡æ–°è¯»å–è¡¨â€ã€‚silosä¸ä¼šå‘Šè¯‰å…¶ä»–äººå®ƒåœ¨è¡¨ä¸­å†™äº†ä»€ä¹ˆ(å› ä¸ºè¿™äº›ä¿¡æ¯å¯èƒ½å·²ç»è¿‡æ—¶/é”™è¯¯)ï¼Œå®ƒåªæ˜¯å‘Šè¯‰ä»–ä»¬é‡æ–°è¯»å–è¡¨ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¾ˆå¿«åœ°äº†è§£æˆå‘˜èº«ä»½çš„å˜åŒ–ï¼Œè€Œä¸éœ€è¦ç­‰å¾…æ•´ä¸ªå‘¨æœŸæ€§çš„è¯»å–å‘¨æœŸã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦å®šæœŸè¯»å–ï¼Œä»¥é˜²â€œé‡æ–°è¯»å–è¡¨â€æ¶ˆæ¯ä¸¢å¤±ã€‚ åŸºæœ¬æˆå‘˜åè®®çš„å±æ€§å’Œå¸¸è§é—®é¢˜è§£ç­”ï¼š å¯ä»¥å¤„ç†ä»»ä½•æ•°é‡çš„å¤±è´¥ â€“æˆ‘ä»¬çš„ç®—æ³•å¯ä»¥å¤„ç†ä»»ä½•æ•°é‡çš„å¤±è´¥(å³f<=n)ï¼ŒåŒ…æ‹¬å®Œå…¨é‡å¯é›†ç¾¤ã€‚è¿™ä¸â€œä¼ ç»Ÿâ€å½¢æˆé²œæ˜å¯¹æ¯” å¸•å…‹ç´¢æ–¯ åŸºäºè§£å†³æ–¹æ¡ˆï¼Œéœ€è¦æ³•å®šäººæ•°ï¼Œé€šå¸¸æ˜¯å¤šæ•°ã€‚æˆ‘ä»¬å·²ç»çœ‹åˆ°åœ¨ç”Ÿäº§æƒ…å†µä¸‹ï¼Œä¸€åŠä»¥ä¸Šçš„siloséƒ½å…³é—­äº†ã€‚æˆ‘ä»¬çš„ç³»ç»Ÿä»ç„¶æ­£å¸¸è¿è¡Œï¼Œè€ŒåŸºäºPaxosçš„ä¼šå‘˜åˆ¶å°†æ— æ³•å–å¾—è¿›å±•ã€‚ å»é¤æ¡Œçš„äº¤é€šéå¸¸å°‘ -å®é™…çš„pingç›´æ¥åœ¨æœåŠ¡å™¨ä¹‹é—´è¿›è¡Œï¼Œè€Œä¸æ˜¯å‘é€åˆ°è¡¨ä¸­ã€‚è¿™å°†äº§ç”Ÿå¤§é‡çš„æµé‡ï¼Œè€Œä¸”ä»æ•…éšœæ£€æµ‹çš„è§’åº¦æ¥çœ‹æ˜¯ä¸å¤Ÿå‡†ç¡®çš„-å¦‚æœä¸€ä¸ªsilosæ— æ³•åˆ°è¾¾è¡¨ï¼Œå®ƒå°†æ— æ³•å†™å…¥å®ƒçš„â€œæˆ‘æ˜¯æ´»ç€çš„â€å¿ƒè·³ï¼Œå…¶ä»–äººä¼šæ€æ­»ä»–ã€‚ å¯è°ƒç²¾åº¦ä¸å®Œæ•´æ€§ â€“ ä¸€èˆ¬æ¥è¯´ï¼Œå®Œç¾å’Œå‡†ç¡®çš„æ•…éšœæ£€æµ‹æ˜¯ä¸å¯èƒ½çš„ . äººä»¬é€šå¸¸å¸Œæœ›èƒ½å¤Ÿåœ¨å‡†ç¡®æ€§å’Œå®Œæ•´æ€§ä¹‹é—´è¿›è¡Œæƒè¡¡(ä¸æƒ³å°†ä¸€ä¸ªçœŸæ­£æ´»ç€çš„siloså£°æ˜ä¸ºæ­»silos)å’Œå®Œæ•´æ€§(å¸Œæœ›å°½å¿«å£°æ˜ä¸€ä¸ªå®é™…ä¸Šå·²ç»æ­»äº†çš„silos)ã€‚å¯é…ç½®çš„å£°æ˜æ­»äº¡å’Œé”™è¿‡pingçš„æŠ•ç¥¨å…è®¸äº¤æ˜“è¿™ä¸¤ä¸ªã€‚ æ¯”ä¾‹å°º -åŸºæœ¬åè®®å¯ä»¥å¤„ç†æ•°åƒä¸ªç”šè‡³å¯èƒ½æ˜¯æ•°ä¸‡ä¸ªæœåŠ¡å™¨ã€‚è¿™ä¸ä¼ ç»Ÿçš„ å¸•å…‹ç´¢æ–¯ åŸºäºè§£å†³æ–¹æ¡ˆï¼Œå¦‚ç»„é€šä¿¡åè®®ï¼Œå·²çŸ¥å…¶è§„æ¨¡ä¸ä¼šè¶…è¿‡10ä¸ªã€‚ è¯Šæ–­å­¦ -è¯¥è¡¨ä¹Ÿéå¸¸ä¾¿äºè¯Šæ–­å’Œæ•…éšœæ’é™¤ã€‚ç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥ç«‹å³åœ¨è¡¨ä¸­æ‰¾åˆ°æ´»åŠ¨çš„silosçš„å½“å‰åˆ—è¡¨ï¼Œä»¥åŠæŸ¥çœ‹æ‰€æœ‰è¢«æ€æ­»çš„siloså’Œæ€€ç–‘çš„å†å²ã€‚è¿™åœ¨è¯Šæ–­é—®é¢˜æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚ ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦å¯é çš„æŒä¹…å­˜å‚¨æ¥å®ç° æˆå‘˜èµ„æ ¼è¡¨ ? -æˆ‘ä»¬ä¸º æˆå‘˜èµ„æ ¼è¡¨ æœ‰ä¸¤ä¸ªç›®çš„ã€‚é¦–å…ˆï¼Œå®ƒè¢«ç”¨ä½œä¸€ä¸ªé›†åˆç‚¹ï¼Œä¾›å„è‡ªä¸ºæ”¿çš„äººäº’ç›¸å¯»æ‰¾ï¼Œè€ŒOrleansçš„å®¢æˆ·åˆ™ç”¨æ¥å¯»æ‰¾silosã€‚ç¬¬äºŒï¼Œæˆ‘ä»¬ä½¿ç”¨å¯é çš„å­˜å‚¨æ¥å¸®åŠ©æˆ‘ä»¬åè°ƒæˆå‘˜è§‚ç‚¹ä¸Šçš„åè®®ã€‚å½“æˆ‘ä»¬ä»¥å¯¹ç­‰çš„æ–¹å¼åœ¨silosä¹‹é—´ç›´æ¥æ‰§è¡Œæ•…éšœæ£€æµ‹æ—¶ï¼Œæˆ‘ä»¬å°†æˆå‘˜èµ„æ ¼è§†å›¾å­˜å‚¨åœ¨ä¸€ä¸ªå¯é çš„å­˜å‚¨å™¨ä¸­ï¼Œå¹¶ä½¿ç”¨è¯¥å­˜å‚¨å™¨æä¾›çš„å¹¶å‘æ§åˆ¶æœºåˆ¶æ¥è¾¾æˆè°æ´»ç€è°æ­»çš„åè®®ã€‚è¿™æ ·ï¼Œåœ¨æŸç§æ„ä¹‰ä¸Šï¼Œæˆ‘ä»¬çš„åè®®å°†åˆ†å¸ƒå¼å…±è¯†çš„éš¾é¢˜å¤–åŒ…ç»™äº†äº‘ã€‚å› ä¸ºæˆ‘ä»¬å……åˆ†åˆ©ç”¨äº†åº•å±‚äº‘å¹³å°çš„åŠ›é‡ï¼ŒçœŸæ­£å°†å…¶ä½œä¸ºâ€œå¹³å°å³æœåŠ¡â€ã€‚ å¦‚æœä¸€æ®µæ—¶é—´å†…æ— æ³•è®¿é—®è¯¥è¡¨ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ (å­˜å‚¨æœåŠ¡å…³é—­ã€ä¸å¯ç”¨æˆ–å­˜åœ¨é€šä¿¡é—®é¢˜)â€“åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„åè®®ä¸ä¼šé”™è¯¯åœ°å®£å¸ƒsilosæ­»æœºã€‚ç›®å‰è¿è¡Œçš„siloså°†ç»§ç»­å·¥ä½œï¼Œæ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½å£°æ˜ä¸€ä¸ªsilosæ­»æœº(å¦‚æœæˆ‘ä»¬é€šè¿‡ä¸¢å¤±çš„pingæ£€æµ‹åˆ°ä¸€äº›silosæ­»æœºï¼Œæˆ‘ä»¬å°†æ— æ³•å°†æ­¤äº‹å®å†™å…¥è¡¨ä¸­)ï¼Œä¹Ÿæ— æ³•å…è®¸æ–°çš„silosåŠ å…¥ã€‚æ‰€ä»¥å®Œæ•´æ€§ä¼šå—åˆ°å½±å“ï¼Œä½†æ˜¯å‡†ç¡®æ€§ä¸ä¼šâ€”â€”ä»è¡¨ä¸­è¿›è¡Œåˆ†åŒºæ°¸è¿œä¸ä¼šå¯¼è‡´æˆ‘ä»¬é”™è¯¯åœ°å®£å¸ƒæ€æ´›æ­»äº†ã€‚å¦å¤–ï¼Œåœ¨éƒ¨åˆ†ç½‘ç»œåˆ†åŒºçš„æƒ…å†µä¸‹(å¦‚æœä¸€äº›siloså¯ä»¥è®¿é—®è¡¨ï¼Œè€Œå¦ä¸€äº›silosä¸èƒ½è®¿é—®è¡¨)ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå°†ä¸€ä¸ªæ­»siloså£°æ˜ä¸ºæ­»silosï¼Œä½†åœ¨æ‰€æœ‰å…¶ä»–silosäº†è§£åˆ°å®ƒä¹‹å‰ï¼Œè¿˜éœ€è¦ä¸€äº›æ—¶é—´ã€‚æ‰€ä»¥æ£€æµ‹å¯ä»¥å»¶è¿Ÿï¼Œä½†æˆ‘ä»¬ç»ä¸ä¼šå› ä¸ºè¡¨æ ¼ä¸å¯ç”¨è€Œè¯¯æ€ä»–äººã€‚ ç›´æ¥IAmAliveå†™å…¥è¡¨ä»…ç”¨äºè¯Šæ–­ -é™¤äº†åœ¨silosä¹‹é—´å‘é€çš„å¿ƒè·³ä¿¡å·å¤–ï¼Œæ¯ä¸ªsilosè¿˜å®šæœŸæ›´æ–°è¡¨ä¸­å…¶è¡Œä¸­çš„â€œæˆ‘è¿˜æ´»ç€â€åˆ—ã€‚â€œæˆ‘è¿˜æ´»ç€â€ä¸€æ åªä¾›ä½¿ç”¨ ç”¨äºæ‰‹åŠ¨æ•…éšœæ’é™¤å’Œè¯Šæ–­ å¹¶ä¸”ä¸è¢«æˆå‘˜åè®®æœ¬èº«ä½¿ç”¨ã€‚å®ƒé€šå¸¸ä»¥è¾ƒä½çš„é¢‘ç‡ç¼–å†™(æ¯5åˆ†é’Ÿä¸€æ¬¡)ï¼Œå®ƒæ˜¯ç³»ç»Ÿç®¡ç†å‘˜æ£€æŸ¥é›†ç¾¤æ´»åŠ¨æ€§æˆ–è½»æ¾æ‰¾å‡ºsilosä¸Šæ¬¡æ´»åŠ¨çš„æ—¶é—´çš„éå¸¸æœ‰ç”¨çš„å·¥å…·ã€‚ å®Œå…¨è®¢è´­æˆå‘˜èµ„æ ¼è§†å›¾çš„æ‰©å±•ï¼š ä¸Šé¢æè¿°çš„åŸºæœ¬æˆå‘˜åè®®åæ¥è¢«æ‰©å±•ä¸ºæ”¯æŒå®Œå…¨æœ‰åºçš„æˆå‘˜å…³ç³»è§†å›¾ã€‚æˆ‘ä»¬å°†ç®€è¦æè¿°è¿™ä¸ªæ‰©å±•çš„åŸå› ä»¥åŠå®ƒæ˜¯å¦‚ä½•å®ç°çš„ã€‚æ‰©å±•åœ¨ä¸Šè¿°è®¾è®¡ä¸­æ²¡æœ‰ä»»ä½•æ”¹å˜ï¼Œåªæ˜¯æ·»åŠ äº†ä¸€ä¸ªé™„åŠ å±æ€§ï¼Œå³æ‰€æœ‰æˆå‘˜é…ç½®éƒ½æ˜¯å…¨å±€å®Œå…¨æœ‰åºçš„ã€‚ ä¸ºä»€ä¹ˆå®Œå…¨è®¢è´­æˆå‘˜è§†å›¾æ˜¯æœ‰ç”¨çš„ï¼Ÿ è¿™å…è®¸åºåˆ—åŒ–æ–°silosåˆ°é›†ç¾¤çš„è¿æ¥ã€‚è¿™æ ·ï¼Œå½“ä¸€ä¸ªæ–°çš„silosåŠ å…¥é›†ç¾¤æ—¶ï¼Œå®ƒå°±å¯ä»¥éªŒè¯ä¸å…¶ä»–å·²ç»å¯åŠ¨çš„silosçš„åŒå‘è¿æ¥ã€‚å¦‚æœä¸€äº›å·²åŠ å…¥çš„silosæ²¡æœ‰åº”ç­”(å¯èƒ½è¡¨æ˜æ–°siloså­˜åœ¨ç½‘ç»œè¿æ¥é—®é¢˜)ï¼Œåˆ™ä¸å…è®¸æ–°silosåŠ å…¥ã€‚è¿™å¯ä»¥ç¡®ä¿è‡³å°‘åœ¨ä¸€ä¸ªsiloså¯åŠ¨æ—¶ï¼Œé›†ç¾¤ä¸­æ‰€æœ‰silosä¹‹é—´éƒ½æœ‰å®Œæ•´çš„è¿æ¥(è¿™æ˜¯å®ç°çš„)ã€‚ silosä¸­çš„æ›´é«˜çº§åˆ«åè®®(å¦‚åˆ†å¸ƒå¼grain directory)å¯ä»¥åˆ©ç”¨æˆå‘˜å…³ç³»è§†å›¾è¢«æ’åºçš„äº‹å®ï¼Œå¹¶ä½¿ç”¨è¿™äº›ä¿¡æ¯æ¥æ‰§è¡Œæ›´æ™ºèƒ½çš„é‡å¤æ¿€æ´»è§£æã€‚ç‰¹åˆ«æ˜¯ï¼Œå½“directoryå‘ç°åœ¨æˆå‘˜èº«ä»½ä¸æ–­å˜åŒ–æ—¶åˆ›å»ºäº†2ä¸ªæ¿€æ´»ï¼Œå®ƒå¯èƒ½ä¼šå†³å®šåœç”¨åŸºäºç°åœ¨è¿‡æ—¶çš„æˆå‘˜èº«ä»½ä¿¡æ¯åˆ›å»ºçš„æ—§æ¿€æ´»(ç›®å‰å°šæœªå®ç°)ã€‚ æ‰©å±•æˆå‘˜åè®®ï¼š ä¸ºäº†å®ç°æ­¤åŠŸèƒ½ï¼Œæˆ‘ä»¬åˆ©ç”¨äº† æˆå‘˜èµ„æ ¼è¡¨ .. æˆ‘ä»¬å‘è·Ÿè¸ªè¡¨æ›´æ”¹çš„è¡¨æ·»åŠ æˆå‘˜èº«ä»½ç‰ˆæœ¬è¡Œã€‚ å½“silo Sæƒ³ä¸ºsilo På†™æ€€ç–‘æˆ–æ­»äº¡å£°æ˜æ—¶ï¼š 3.1sè¯»å–æœ€æ–°çš„è¡¨æ ¼å†…å®¹ã€‚å¦‚æœPå·²ç»æ­»äº†ï¼Œä»€ä¹ˆä¹Ÿä¸åšã€‚å¦åˆ™ï¼Œ 3.2åœ¨åŒä¸€äº‹åŠ¡ä¸­ï¼Œå°†æ›´æ”¹å†™å…¥Pçš„è¡Œï¼Œå¹¶å¢åŠ ç‰ˆæœ¬å·å¹¶å°†å…¶å†™å›è¡¨ä¸­ã€‚ 3.3ä¸¤æ¬¡å†™å…¥éƒ½ä½¿ç”¨ETagè¿›è¡Œè°ƒèŠ‚ã€‚ 3.4å¦‚æœäº‹åŠ¡å› Pè¡Œæˆ–ç‰ˆæœ¬è¡Œä¸Šçš„eTagä¸åŒ¹é…è€Œä¸­æ­¢ï¼Œè¯·é‡è¯•ã€‚ æ‰€æœ‰å¯¹è¡¨çš„å†™å…¥éƒ½ä¼šä¿®æ”¹å’Œå¢åŠ ç‰ˆæœ¬è¡Œã€‚è¿™æ ·ï¼Œæ‰€æœ‰å¯¹è¡¨çš„å†™å…¥éƒ½è¢«åºåˆ—åŒ–(é€šè¿‡å°†æ›´æ–°åºåˆ—åŒ–åˆ°versionè¡Œ)ï¼Œå¹¶ä¸”ç”±äºsilosåªå¢åŠ ç‰ˆæœ¬å·ï¼Œæ‰€ä»¥å†™å…¥æ“ä½œä¹Ÿå®Œå…¨æŒ‰é€’å¢é¡ºåºæ’åˆ—ã€‚ æ‰©å±•æˆå‘˜åè®®çš„å¯æ‰©å±•æ€§ï¼š åœ¨åè®®çš„æ‰©å±•ç‰ˆæœ¬ä¸­ï¼Œæ‰€æœ‰å†™æ“ä½œéƒ½é€šè¿‡ä¸€è¡Œè¿›è¡Œåºåˆ—åŒ–ã€‚è¿™å¯èƒ½ä¼šæŸå®³é›†ç¾¤managemenetåè®®çš„å¯ä¼¸ç¼©æ€§ï¼Œå› ä¸ºå®ƒå¢åŠ äº†å¹¶å‘è¡¨å†™å…¥ä¹‹é—´å‘ç”Ÿå†²çªçš„é£é™©ã€‚ä¸ºäº†éƒ¨åˆ†ç¼“è§£è¿™ä¸ªé—®é¢˜ï¼Œsilosé€šè¿‡ä½¿ç”¨æŒ‡æ•°å›é€€æ¥é‡è¯•å®ƒä»¬å¯¹è¡¨çš„æ‰€æœ‰å†™å…¥æ“ä½œã€‚æˆ‘ä»¬å·²ç»è§‚å¯Ÿåˆ°æ‰©å±•çš„åè®®åœ¨Azureä¸­æœ‰å¤šè¾¾200ä¸ªsilosçš„ç”Ÿäº§ç¯å¢ƒä¸­èƒ½å¤Ÿé¡ºåˆ©åœ°å·¥ä½œã€‚ç„¶è€Œï¼Œæˆ‘ä»¬ç¡®å®è®¤ä¸ºè¯¥åè®®åœ¨æ‰©å±•åˆ°ä¸€åƒä¸ªsilosä¹‹å¤–å¯èƒ½å­˜åœ¨é—®é¢˜ã€‚åœ¨è¿™æ ·çš„å¤§å‹è®¾ç½®ä¸­ï¼Œå¯¹ç‰ˆæœ¬è¡Œçš„æ›´æ–°å¾ˆå®¹æ˜“è¢«ç¦ç”¨ï¼ŒåŸºæœ¬ä¸Šä¿ç•™äº†é›†ç¾¤managemenetåè®®çš„å…¶ä½™éƒ¨åˆ†ï¼Œå¹¶æ”¾å¼ƒäº†total orderingå±æ€§ã€‚è¿˜è¯·æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬æŒ‡çš„æ˜¯é›†ç¾¤ç®¡ç†åè®®çš„å¯ä¼¸ç¼©æ€§ï¼Œè€Œä¸æ˜¯Orleansçš„å…¶ä»–åœ°æ–¹ã€‚æˆ‘ä»¬ç›¸ä¿¡Orleansè¿è¡Œæ—¶çš„å…¶ä»–éƒ¨åˆ†(æ¶ˆæ¯ä¼ é€’ã€åˆ†å¸ƒå¼ç›®å½•ã€grainæ‰˜ç®¡ã€å®¢æˆ·ç«¯åˆ°ç½‘å…³è¿æ¥)çš„å¯æ‰©å±•æ€§è¿œè¿œè¶…è¿‡äº†æ•°ç™¾ä¸ªç«–äº•ã€‚ æˆå‘˜è¡¨ï¼š å¦‚å‰æ‰€è¿°ï¼Œ æˆå‘˜èµ„æ ¼è¡¨ å®ƒè¢«ç”¨ä½œä¸€ä¸ªé›†åˆç‚¹ï¼Œä¾›æ€æ´›å¯»æ‰¾å½¼æ­¤å’ŒOrleanså®¢æˆ·æŸ¥æ‰¾æ€æ´›ï¼Œè¿˜å¸®åŠ©åè°ƒæˆå‘˜å…³ç³»è§†å›¾ä¸Šçš„åè®®ã€‚æˆ‘ä»¬ç›®å‰æœ‰6ä¸ª æˆå‘˜èµ„æ ¼è¡¨ ï¼šåŸºäºAzure Tableã€SQL serverã€Apache ZooKeeperã€Consult IOã€AWS DynamoDBå’Œå†…å­˜ä»¿çœŸè¿›è¡Œå¼€å‘ã€‚çš„æ¥å£ æˆå‘˜èµ„æ ¼è¡¨ åœ¨ä¸­å®šä¹‰ IMembershipTable . Azureè¡¨å­˜å‚¨ -åœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨Azureéƒ¨ç½²IDä½œä¸ºåˆ†åŒºé”®å’Œsilosæ ‡è¯†( ipåœ°å€ï¼šç«¯å£ï¼šepoch )ä½œä¸ºè¡Œé”®ã€‚å®ƒä»¬ä¸€èµ·ä¿è¯æ¯ä¸ªsiloséƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„å¯†é’¥ã€‚å¯¹äºå¹¶å‘æ§åˆ¶ï¼Œæˆ‘ä»¬ä½¿ç”¨åŸºäº Azureè¡¨ETag . æ¯æ¬¡ä»è¡¨ä¸­è¯»å–æ—¶ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªè¯»å–è¡Œå­˜å‚¨etagï¼Œå¹¶åœ¨å°è¯•å›å†™æ—¶ä½¿ç”¨è¯¥etagã€‚æ¯æ¬¡å†™å…¥æ—¶ï¼ŒAzureè¡¨æœåŠ¡éƒ½ä¼šè‡ªåŠ¨åˆ†é…å’Œæ£€æŸ¥etagã€‚å¯¹äºå¤šè¡Œäº‹åŠ¡ï¼Œæˆ‘ä»¬åˆ©ç”¨ Azureè¡¨æä¾›çš„æ‰¹å¤„ç†äº‹åŠ¡ ï¼Œå®ƒä¿è¯åœ¨å…·æœ‰ç›¸åŒåˆ†åŒºé”®çš„è¡Œä¸Šåºåˆ—åŒ–äº‹åŠ¡ã€‚ SQL Serverâ€”åœ¨æ­¤å®ç°ä¸­ï¼Œé…ç½®çš„éƒ¨ç½²IDç”¨äºåŒºåˆ†éƒ¨ç½²ä»¥åŠå“ªäº›siloså±äºå“ªäº›éƒ¨ç½²ã€‚silosæ ‡è¯†å®šä¹‰ä¸º éƒ¨ç½²IDï¼Œipï¼Œç«¯å£ï¼Œepoch åœ¨é€‚å½“çš„è¡¨å’Œåˆ—ä¸­ã€‚å…³ç³»åç«¯ä½¿ç”¨ä¹è§‚å¹¶å‘æ§åˆ¶å’Œäº‹åŠ¡ï¼Œç±»ä¼¼äºåœ¨Azureè¡¨å®ç°ä¸Šä½¿ç”¨etagçš„è¿‡ç¨‹ã€‚å…³ç³»å®ç°æœŸæœ›æ•°æ®åº“å¼•æ“ç”Ÿæˆæ‰€ä½¿ç”¨çš„ETagã€‚å¯¹äºSQL Serverï¼Œåœ¨SQL Server 2000ä¸Šï¼Œç”Ÿæˆçš„ETagæ˜¯é€šè¿‡è°ƒç”¨ æ–°ID() . åœ¨SQL Server 2005åŠæ›´é«˜ç‰ˆæœ¬ä¸Š è¡Œç‰ˆæœ¬ è¢«ä½¿ç”¨ã€‚Orleansè¯»å†™å…³ç³»etagæ˜¯ä¸é€æ˜çš„ å˜é‡äºŒè¿›åˆ¶(16) æ ‡è®°å¹¶å°†å®ƒä»¬å­˜å‚¨åœ¨å†…å­˜ä¸­ä½œä¸º åŸºå‡†64 ç¼–ç å­—ç¬¦ä¸²ã€‚Orleansæ”¯æŒä½¿ç”¨UNION ALL(å¯¹äºOracleåŒ…æ‹¬DUAL)çš„å¤šè¡Œæ’å…¥ï¼ŒUNION ALLå½“å‰ç”¨äºæ’å…¥ç»Ÿè®¡æ•°æ®ã€‚SQL Serverçš„å…·ä½“å®ç°å’ŒåŸºæœ¬åŸç†è¯·å‚è§ åˆ›å»ºæˆ–æ¸…ç†é©¬å©_sqlæœåŠ¡å™¨.sql . é˜¿å¸•å¥‡åŠ¨ç‰©å›­ç®¡ç†å‘˜ -åœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é…ç½®çš„éƒ¨ç½²IDä½œä¸ºæ ¹èŠ‚ç‚¹å’Œsilosæ ‡è¯†( ip:ç«¯å£@epoch )ä½œä¸ºå…¶å­èŠ‚ç‚¹ã€‚å®ƒä»¬å…±åŒä¿è¯äº†æ¯ä¸ªsilosçš„å”¯ä¸€è·¯å¾„ã€‚å¯¹äºå¹¶å‘æ§åˆ¶ï¼Œæˆ‘ä»¬ä½¿ç”¨åŸºäº èŠ‚ç‚¹ç‰ˆæœ¬ . æ¯æ¬¡ä»éƒ¨ç½²æ ¹èŠ‚ç‚¹è¯»å–æ—¶ï¼Œéƒ½ä¼šå­˜å‚¨æ¯ä¸ªè¯»å–å­æ€æ´›èŠ‚ç‚¹çš„ç‰ˆæœ¬ï¼Œå¹¶åœ¨å°è¯•å›å†™æ—¶ä½¿ç”¨è¯¥ç‰ˆæœ¬ã€‚æ¯å½“ä¸€ä¸ªèŠ‚ç‚¹çš„æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼ŒZooKeeperæœåŠ¡å°±ä¼šè‡ªåŠ¨åœ°å¢åŠ ç‰ˆæœ¬å·ã€‚å¯¹äºå¤šè¡Œäº‹åŠ¡ï¼Œæˆ‘ä»¬ä½¿ç”¨ å¤šæ–¹æ³• ï¼Œå®ƒä¿è¯åœ¨å…·æœ‰ç›¸åŒçˆ¶éƒ¨ç½²IDèŠ‚ç‚¹çš„silosèŠ‚ç‚¹ä¸Šå¯åºåˆ—åŒ–äº‹åŠ¡ã€‚ IOé¢†äº‹ -æˆ‘ä»¬ç”¨è¿‡ æ‰§æ”¿å®˜çš„é’¥åŒ™/ä»·å€¼å•†åº— æ¨åŠ¨membershopè¡¨ã€‚å‚è€ƒ æ‰§æ”¿å®˜éƒ¨ç½² æ›´å¤šç»†èŠ‚ã€‚ AWSå‘ç”µæœºB -åœ¨è¿™ä¸ªå®ç°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é›†ç¾¤éƒ¨ç½²IDä½œä¸ºåˆ†åŒºé”®å’Œsilosæ ‡è¯†( ipç«¯å£ç”Ÿæˆ )ä½œä¸ºä½¿è®°å½•ç»Ÿä¸€çš„RangeKeyã€‚ä¹è§‚å¹¶å‘ç”± ETag å±æ€§é€šè¿‡åœ¨DynamoDBä¸Šè¿›è¡Œæ¡ä»¶å†™å…¥æ¥å®ç°ã€‚å®ç°é€»è¾‘ä¸Azureè¡¨å­˜å‚¨éå¸¸ç›¸ä¼¼ã€‚æˆ‘ä»¬åªå®ç°äº†åŸºæœ¬æˆå‘˜åè®®(è€Œä¸æ˜¯æ‰©å±•åè®®)ã€‚ å†…å­˜æ¨¡æ‹Ÿå¼€å‘è®¾ç½®ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸€ç§ç‰¹æ®Šçš„ç³»ç»Ÿgrainsï¼Œå«åš æˆå‘˜èµ„æ ¼è¡¨ ï¼Œä»¥ä¾¿å®ç°ã€‚è¿™äº›Grainså­˜æ”¾åœ¨æŒ‡å®šçš„ä¸»silosä¸­ï¼Œè¯¥silosä»…ç”¨äº å¼€å‘è®¾ç½® . åœ¨ä»»ä½•å®é™…ç”Ÿäº§ä½¿ç”¨æƒ…å†µä¸‹ï¼Œä¸»silos ä¸æ˜¯å¿…éœ€çš„ . é…ç½®ï¼š æˆå‘˜åè®®é€šè¿‡ æ´»æ³¼ å…ƒç´  å…¨çƒ åˆ†æ®µ Orleansé…ç½®.xml æ–‡ä»¶ã€‚é»˜è®¤å€¼åœ¨Azureçš„ç”Ÿäº§ä½¿ç”¨å¹´é™ä¸­è¿›è¡Œäº†è°ƒæ•´ï¼Œæˆ‘ä»¬ç›¸ä¿¡å®ƒä»¬ä»£è¡¨äº†è‰¯å¥½çš„é»˜è®¤è®¾ç½®ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ²¡æœ‰å¿…è¦æ”¹å˜å®ƒä»¬ã€‚ é…ç½®å…ƒç´ ç¤ºä¾‹ï¼š <Liveness ProbeTimeout = \"5s\" TableRefreshTimeout =\"10s DeathVoteExpirationTimeout =\"80s\" NumMissedProbesLimit = \"3\" NumProbedSilos=\"3\" NumVotesForDeathDeclaration=\"2\" /> å®ç°äº†4ç§ç±»å‹çš„æ´»è·ƒåº¦ã€‚æ´»åŠ¨åè®®çš„ç±»å‹é€šè¿‡ ç³»ç»Ÿå­˜å‚¨ç±»å‹ å±æ€§ ç³»ç»Ÿå­˜å‚¨ å…ƒç´  å…¨çƒ åˆ†æ®µ Orleansé…ç½®.xml æ–‡ä»¶ã€‚ æˆå‘˜èµ„æ ¼è¡¨ -æˆå‘˜è¡¨å­˜å‚¨åœ¨ä¸»silosä¸Šçš„ä¸€ä¸ªGrainsä¸­ã€‚è¿™æ˜¯ä¸€ä¸ª ä»…å¼€å‘è®¾ç½® . å¯å®šåˆ¶ -æˆå‘˜è¡¨å­˜å‚¨åœ¨Azureè¡¨ä¸­ã€‚ SQLæœåŠ¡å™¨ -æˆå‘˜è¡¨å­˜å‚¨åœ¨å…³ç³»æ•°æ®åº“ä¸­ã€‚ åŠ¨ç‰©å›­ç®¡ç†å‘˜ -æˆå‘˜è¡¨å­˜å‚¨åœ¨ZooKeeperä¸­ åˆå¥ . æ‰§æ”¿å®˜ -é…ç½®ä¸ºè‡ªå®šä¹‰ç³»ç»Ÿå­˜å‚¨ MembershipTableAssembly=â€œorleansConsultilsâ€ . å‚è€ƒ æ‰§æ”¿å®˜éƒ¨ç½² æ›´å¤šç»†èŠ‚ã€‚ å‘ç”µæœºB -é…ç½®ä¸ºè‡ªå®šä¹‰ç³»ç»Ÿå­˜å‚¨ MembershipTableAssembly=â€œOrleansAWSUtilsâ€ . å¯¹äºæ‰€æœ‰æ´»åŠ¨ç±»å‹ï¼Œå…¬å…±é…ç½®å˜é‡åœ¨ä¸­å®šä¹‰ å…¨çƒåŒ–ã€‚æ´»åŠ› è¦ç´ ï¼š é—®é¢˜æ—¶é—´ -æˆ‘è¦ç»™ä»–ä»¬çš„â€œå‘å°„å®¤â€å‘é€ä¿¡å·ã€‚é»˜è®¤å€¼ä¸º10ç§’ã€‚ è¡¨åˆ·æ–°è¶…æ—¶ -ä»æˆå‘˜èµ„æ ¼è¡¨è·å–æ›´æ–°çš„ç§’æ•°ã€‚é»˜è®¤å€¼ä¸º60ç§’ã€‚ æ­»äº¡å‘¼æ°”è¶…æ—¶ -æˆå‘˜è¡¨ä¸­æ­»äº¡æŠ•ç¥¨çš„è¿‡æœŸæ—¶é—´(ç§’)ã€‚é»˜è®¤å€¼ä¸º120ç§’ åŠªç±³å¡å¾·æ™®æ–¯é‡Œç±³ t-ä»ä¸€ä¸ªsilosä¸¢å¤±çš„â€œæˆ‘è¿˜æ´»ç€â€å¿ƒè·³ä¿¡å·æ¶ˆæ¯çš„æ•°é‡ï¼Œæˆ–è€…å¯¼è‡´æ€€ç–‘è¯¥siloså·²æ­»äº¡çš„æœªåº”ç­”æ¢æµ‹çš„æ•°é‡ã€‚é»˜è®¤å€¼ä¸º3ã€‚ çº½æ™®ç½—è´æ–¯æ´›æ–¯ -æ¯ä¸ªsilosæ¢æµ‹æ´»è·ƒåº¦çš„silosæ•°é‡ã€‚é»˜è®¤å€¼ä¸º3ã€‚ NumVotesForDeathå£°æ˜ -å®£å¸ƒæŸä¸ªsilosæ­»äº¡æ‰€éœ€çš„æœªè¿‡æœŸæŠ•ç¥¨æ•°(æœ€å¤šåº”ä¸ºnumissedprobeslimit)ã€‚é»˜è®¤å€¼ä¸º2ã€‚ é—²è¨€ç¢è¯­ -æ˜¯å¦ä½¿ç”¨å…«å¦ä¼˜åŒ–æ¥åŠ é€Ÿæ´»è·ƒåº¦ä¿¡æ¯çš„ä¼ æ’­ã€‚é»˜è®¤å€¼ä¸ºtrueã€‚ IAmAliveTablePublishTimeout -å®šæœŸåœ¨æˆå‘˜èµ„æ ¼è¡¨ä¸­å†™å…¥æ­¤siloså¤„äºæ´»åŠ¨çŠ¶æ€çš„ç§’æ•°ã€‚ä»…ç”¨äºè¯Šæ–­ã€‚é»˜è®¤å€¼ä¸º5åˆ†é’Ÿã€‚ NumMissedTableIAmAliveLimit -è¡¨ä¸­ä»silosä¸­ä¸¢å¤±çš„å¯¼è‡´è®°å½•è­¦å‘Šçš„â€œæˆ‘è¿˜æ´»ç€â€æ›´æ–°çš„æ•°é‡ã€‚ä¸å½±å“æ´»åŠ¨åè®®ã€‚é»˜è®¤å€¼ä¸º2ã€‚ MaxJoinAttemptTime -åœ¨æ”¾å¼ƒä¹‹å‰å°è¯•åŠ å…¥ä¸€ä¸ªsilosç¾¤çš„ç§’æ•°ã€‚é»˜è®¤å€¼ä¸º5åˆ†é’Ÿã€‚ é¢„æœŸç¾¤é›†å¤§å° -ç¾¤é›†çš„é¢„æœŸå¤§å°ã€‚ä¸å¿…å¾ˆå‡†ç¡®ï¼Œå¯ä»¥é«˜ä¼°ã€‚ç”¨äºä¼˜åŒ–è¦å†™å…¥Azureè¡¨çš„é‡è¯•çš„æŒ‡æ•°é€€é¿ç®—æ³•ã€‚é»˜è®¤å€¼ä¸º20ã€‚ è®¾è®¡åŸç†ï¼š ä¸€ä¸ªå¾ˆè‡ªç„¶çš„é—®é¢˜æ˜¯ä¸ºä»€ä¹ˆä¸å®Œå…¨ä¾èµ– é˜¿å¸•å¥‡åŠ¨ç‰©å›­ç®¡ç†å‘˜ å¯¹äºé›†ç¾¤æˆå‘˜èº«ä»½å®ç°ï¼Œå¯èƒ½ä¼šä½¿ç”¨ å…·æœ‰çŸ­æš‚èŠ‚ç‚¹çš„ç¾¤æˆå‘˜å…³ç³» ? ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦è´¹å¿ƒå®æ–½æˆ‘ä»¬è‡ªå·±çš„ä¼šå‘˜åè®®ï¼Ÿä¸»è¦æœ‰ä¸‰ä¸ªåŸå› ï¼š (ä¸€) åœ¨äº‘ä¸­éƒ¨ç½²/æ‰˜ç®¡ -Zookeeperä¸æ˜¯ä¸€ä¸ªæ‰˜ç®¡æœåŠ¡(è‡³å°‘åœ¨æ’°å†™æœ¬æ–‡çš„2015å¹´7æœˆï¼Œå½“ç„¶ï¼Œå½“æˆ‘ä»¬åœ¨2011å¹´å¤å¤©é¦–æ¬¡å®ç°è¯¥åè®®æ—¶ï¼Œæ²¡æœ‰ä»»ä½•ä¸€ä¸ªä¸»æµäº‘æä¾›å•†å°†Zookeeperä½œä¸ºæ‰˜ç®¡æœåŠ¡è¿è¡Œ)ã€‚è¿™æ„å‘³ç€åœ¨äº‘ç¯å¢ƒä¸­ï¼ŒOrleansçš„å®¢æˆ·å¿…é¡»éƒ¨ç½²/è¿è¡Œ/ç®¡ç†è‡ªå·±çš„ZKé›†ç¾¤å®ä¾‹ã€‚è¿™åªæ˜¯åˆä¸€ä¸ªä¸å¿…è¦çš„è´Ÿæ‹…ï¼Œæˆ‘ä»¬ä¸æƒ³å¼ºè¿«æˆ‘ä»¬çš„å®¢æˆ·ã€‚é€šè¿‡ä½¿ç”¨Azureè¡¨ï¼Œæˆ‘ä»¬ä¾èµ–äºæ‰˜ç®¡çš„æ‰˜ç®¡æœåŠ¡ï¼Œè¿™ä½¿æˆ‘ä»¬çš„å®¢æˆ·çš„ç”Ÿæ´»æ›´åŠ ç®€å•ã€‚ åŸºæœ¬ä¸Šï¼Œåœ¨äº‘è®¡ç®—ä¸­ï¼Œå°†äº‘ç”¨ä½œå¹³å°ï¼Œè€Œä¸æ˜¯åŸºç¡€è®¾æ–½ã€‚ å¦ä¸€æ–¹é¢ï¼Œåœ¨æœ¬åœ°è¿è¡Œå’Œç®¡ç†è‡ªå·±çš„æœåŠ¡å™¨æ—¶ï¼Œä¾èµ–ZKä½œä¸º æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ä¸€ä¸ªå¯è¡Œçš„é€‰æ‹©ã€‚ (äºŒ) ç›´æ¥æ•…éšœæ£€æµ‹ -å½“å°†ZKçš„ç»„æˆå‘˜èµ„æ ¼ç”¨äºä¸´æ—¶èŠ‚ç‚¹æ—¶ï¼Œå°†åœ¨OrleansæœåŠ¡å™¨(ZKå®¢æˆ·ç«¯)å’ŒZKæœåŠ¡å™¨ä¹‹é—´æ‰§è¡Œæ•…éšœæ£€æµ‹ã€‚è¿™å¯èƒ½ä¸ä¸€å®šä¸OrleansæœåŠ¡å™¨ä¹‹é—´çš„å®é™…ç½‘ç»œé—®é¢˜ç›¸å…³ã€‚ æˆ‘ä»¬å¸Œæœ›æ•…éšœæ£€æµ‹èƒ½å¤Ÿå‡†ç¡®åœ°åæ˜ é›†ç¾¤å†…é€šä¿¡çš„çŠ¶æ€ã€‚ å…·ä½“æ¥è¯´ï¼Œåœ¨æˆ‘ä»¬çš„è®¾è®¡ä¸­ï¼Œå¦‚æœOrleanssilosä¸èƒ½ä¸ æˆå‘˜èµ„æ ¼è¡¨ å®ƒä¸è¢«è®¤ä¸ºæ˜¯æ­»çš„ï¼Œå¯ä»¥ç»§ç»­å·¥ä½œã€‚ä¸æ­¤ç›¸åï¼Œå¦‚æœæˆ‘ä»¬å°†ZKç»„æˆå‘˜èµ„æ ¼ç”¨äºä¸´æ—¶èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸ZKæœåŠ¡å™¨çš„æ–­å¼€è¿æ¥å¯èƒ½ä¼šå¯¼è‡´Orleans silo(ZK client)è¢«å£°æ˜ä¸ºdeadï¼Œè€Œå®é™…ä¸Šå®ƒå¯èƒ½æ˜¯æ´»åŠ¨çš„å¹¶ä¸”å®Œå…¨æ­£å¸¸å·¥ä½œã€‚ (ä¸‰) ä¾¿æºæ€§å’Œçµæ´»æ€§ -ä½œä¸ºOrleanså“²å­¦çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä¸æƒ³å¼ºè¿«ä»»ä½•ç‰¹å®šçš„æŠ€æœ¯ï¼Œè€Œæ˜¯è¦æœ‰ä¸€ä¸ªçµæ´»çš„è®¾è®¡ï¼Œåœ¨è¿™ç§è®¾è®¡ä¸­ï¼Œä¸åŒçš„ç»„ä»¶å¯ä»¥å¾ˆå®¹æ˜“åœ°ç”¨ä¸åŒçš„å®ç°è¿›è¡Œåˆ‡æ¢ã€‚è¿™æ­£æ˜¯ç´«è‰² æˆå‘˜èµ„æ ¼è¡¨ æŠ½è±¡æœåŠ¡ã€‚ è‡´è°¢ï¼š æˆ‘ä»¬è¦æ„Ÿè°¢ äºšå†å…‹æ–¯Â·ç§‘æ ¹ æœ¬åè®®çš„ç¬¬ä¸€ç‰ˆçš„è®¾è®¡ä¸å®ç°ã€‚è¿™é¡¹å·¥ä½œæ˜¯2011å¹´å¤å¤©å¾®è½¯ç ”ç©¶æ‰€æš‘æœŸå®ä¹ çš„ä¸€éƒ¨åˆ†ã€‚åŸºäºZooKeeperçš„å®ç° æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ç”±è°å®Œæˆçš„ å¤ä¼ŠÂ·å“ˆä½ SQLçš„å®ç° æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ç”±è°å®Œæˆçš„ ç»´ç§‘Â·ä¼Šå¨ƒ AWS DynamoDBçš„å®ç° æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ç”±è°å®Œæˆçš„ å¤è…¾å ¡é‡Œè´ç½— å¹¶ä»¥consurä¸ºåŸºç¡€å®ç° æˆå‘˜èµ„æ ¼è¡¨ æ˜¯ç”±è°å®Œæˆçš„ ä¿ç½—Â·è¯ºæ–¯ ."
  },
  "Documentation/streaming/streams_quick_start.html": {
    "href": "Documentation/streaming/streams_quick_start.html",
    "title": "Orleans Streams Quick Start | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "OrleansStreamså¿«é€Ÿå…¥é—¨ æœ¬æŒ‡å—å°†å‘æ‚¨å±•ç¤ºè®¾ç½®å’Œä½¿ç”¨Orleans Streamsçš„å¿«é€Ÿæ–¹æ³•ã€‚è¦äº†è§£æœ‰å…³æµåŠŸèƒ½çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·é˜…è¯»æœ¬æ–‡æ¡£çš„å…¶ä»–éƒ¨åˆ†ã€‚ æ‰€éœ€é…ç½® åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨åŸºäºç®€å•æ¶ˆæ¯çš„æµï¼Œè¯¥æµä½¿ç”¨Grainsæ¶ˆæ¯ä¼ é€’å°†æµæ•°æ®å‘é€ç»™è®¢é˜…è€…ã€‚æˆ‘ä»¬å°†ä½¿ç”¨å†…å­˜ä¸­çš„å­˜å‚¨æä¾›ç¨‹åºæ¥å­˜å‚¨è®¢é˜…åˆ—è¡¨ï¼Œå› æ­¤å¯¹äºå®é™…çš„ç”Ÿäº§åº”ç”¨ç¨‹åºæ¥è¯´ï¼Œè¿™ä¸æ˜¯æ˜æ™ºçš„é€‰æ‹©ã€‚ åœ¨silosä¸Šï¼Œå…¶ä¸­hostBuilderæ˜¯ISiloHostBuilder hostBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\") .AddMemoryGrainStorage(\"PubSubStore\"); åœ¨ç¾¤é›†å®¢æˆ·ç«¯ä¸Šï¼Œå…¶ä¸­clientBuilderæ˜¯IClientBuilder clientBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\"); ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºæµï¼Œä½¿ç”¨å®ƒä»¬ä½œä¸ºç”Ÿäº§è€…å‘é€æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºè®¢é˜…è€…æ¥æ”¶æ•°æ®ã€‚ ç”Ÿäº§æ´»åŠ¨ ä¸ºæµç”Ÿæˆäº‹ä»¶ç›¸å¯¹å®¹æ˜“ã€‚æ‚¨åº”è¯¥é¦–å…ˆè®¿é—®åœ¨ä¸Šè¿°é…ç½®ä¸­å®šä¹‰çš„æµæä¾›ç¨‹åº( çŸ­ä¿¡æä¾›å•† )ï¼Œç„¶åé€‰æ‹©ä¸€ä¸ªæµå¹¶å°†æ•°æ®æ¨é€åˆ°è¯¥æµã€‚ //Pick a guid for a chat room grain and chat room stream var guid = some guid identifying the chat room //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); å¦‚æ‚¨æ‰€è§ï¼Œæˆ‘ä»¬çš„æµå…·æœ‰GUIDå’Œåç§°ç©ºé—´ã€‚è¿™å°†ä½¿è¯†åˆ«å”¯ä¸€æµå˜å¾—å®¹æ˜“ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªèŠå¤©å®¤çš„åç§°ç©ºé—´å¯ä»¥æ˜¯â€œ Roomsâ€ï¼ŒGUIDå¯ä»¥æ˜¯æ‹¥æœ‰çš„RoomGrainçš„GUIDã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€äº›å·²çŸ¥èŠå¤©å®¤çš„GUIDã€‚ç°åœ¨ä½¿ç”¨ OnNext æµçš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°æ®æ¨é€åˆ°å®ƒã€‚è®©æˆ‘ä»¬åœ¨è®¡æ—¶å™¨å†…å¹¶ä½¿ç”¨éšæœºæ•°è¿›è¡Œæ“ä½œã€‚æ‚¨ä¹Ÿå¯ä»¥å¯¹æµä½¿ç”¨ä»»ä½•å…¶ä»–æ•°æ®ç±»å‹ã€‚ RegisterTimer(s => { return stream.OnNextAsync(new System.Random().Next()); }, null, TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000)); è®¢é˜…å’Œæ¥æ”¶æµæ•°æ® ä¸ºäº†æ¥æ”¶æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨éšå¼/æ˜¾å¼è®¢é˜…ï¼Œè¿™åœ¨æ‰‹å†Œçš„å…¶ä»–é¡µé¢ä¸­æœ‰å®Œæ•´ä»‹ç»ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨éšå¼è®¢é˜…ï¼Œè¿™æ›´å®¹æ˜“ã€‚å½“Grainsç±»å‹æƒ³è¦éšå¼è®¢é˜…æµæ—¶ï¼Œå®ƒä½¿ç”¨å±æ€§ ImplicitStreamSubscription(å‘½åç©ºé—´)] ã€‚ å¯¹äºæˆ‘ä»¬çš„æƒ…å†µï¼Œæˆ‘ä»¬å°†å®šä¹‰å¦‚ä¸‹çš„ReceiverGrainï¼š [ImplicitStreamSubscription(\"RANDOMDATA\")] public class ReceiverGrain : Grain, IRandomReceiver ç°åœ¨ï¼Œæ¯å½“åƒè®¡æ—¶å™¨ä¸­ä¸€æ ·å°†æŸäº›æ•°æ®æ¨é€åˆ°åç§°ç©ºé—´RANDOMDATAçš„æµä¸­æ—¶ï¼Œ æ¥æ”¶å™¨grain å…·æœ‰ç›¸åŒGUIDçš„æµå°†æ¥æ”¶åˆ°è¯¥æ¶ˆæ¯ã€‚å³ä½¿å½“å‰ä¸å­˜åœ¨ä»»ä½•æ¿€æ´»çš„Grainsï¼Œè¿è¡Œæ—¶ä¹Ÿä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªæ–°çš„Grainså¹¶å°†æ¶ˆæ¯å‘é€ç»™å®ƒã€‚ ä¸ºäº†ä½¿å…¶æ­£å¸¸å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡è®¾ç½®æˆ‘ä»¬çš„è®¢é˜…æ¥å®Œæˆè®¢é˜…è¿‡ç¨‹ OnNext æ¥æ”¶æ•°æ®çš„æ–¹æ³•ã€‚æ‰€ä»¥æˆ‘ä»¬ æ¥æ”¶å™¨grain åº”è¯¥è°ƒç”¨ç»™å®ƒ OnActivateAsync åƒè¿™æ ·çš„ä¸œè¥¿ //Create a GUID based on our GUID as a grain var guid = this.GetPrimaryKey(); //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); //Set our OnNext method to the lambda which simply prints the data, this doesn't make new subscriptions await stream.SubscribeAsync<int>(async (data, token) => Console.WriteLine(data)); æˆ‘ä»¬éƒ½å‡†å¤‡å¥½äº†ã€‚å”¯ä¸€çš„è¦æ±‚æ˜¯ï¼ŒæŸäº›äº‹æƒ…ä¼šè§¦å‘æˆ‘ä»¬çš„ç”Ÿäº§è€…Grainsçš„åˆ›å»ºï¼Œç„¶åå®ƒå°†æ³¨å†Œè®¡æ—¶å™¨å¹¶å¼€å§‹å‘æ‰€æœ‰æ„Ÿå…´è¶£çš„æ–¹å‘é€éšæœºæ•´æ•°ã€‚ åŒæ ·ï¼Œæœ¬æŒ‡å—è·³è¿‡äº†è®¸å¤šç»†èŠ‚ï¼Œä»…é€‚åˆäºå±•ç¤ºå¤§å›¾ã€‚é˜…è¯»æœ¬æ‰‹å†Œçš„å…¶ä»–éƒ¨åˆ†ä»¥åŠæœ‰å…³RXçš„å…¶ä»–èµ„æºï¼Œä»¥æ›´å¥½åœ°äº†è§£å¯ç”¨çš„å†…å®¹å’Œæ–¹æ³•ã€‚ ååº”å¼ç¼–ç¨‹å¯ä»¥æ˜¯è§£å†³è®¸å¤šé—®é¢˜çš„éå¸¸æœ‰æ•ˆçš„æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥åœ¨è®¢æˆ·ä¸­ä½¿ç”¨LINQæ¥è¿‡æ»¤æ•°å­—å¹¶åšå„ç§æœ‰è¶£çš„äº‹æƒ…ã€‚ ä¸‹ä¸€ä¸ª Orleansæµç¼–ç¨‹API"
  },
  "Documentation/resources/Migration/index.html": {
    "href": "Documentation/resources/Migration/index.html",
    "title": "Migration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ï¼ƒè¿ç§»ä¿¡æ¯ /// TODOï¼šè¯„ä¼°è¿ç§»ä¿¡æ¯åï¼Œå†™ä¸€ä¸ªæœ‰å…³å°†è¦ä¿ç•™çš„å†…å®¹çš„é¡µé¢ï¼Œç­‰ç­‰ã€‚"
  },
  "Documentation/resources/Presentations/index.zh.html": {
    "href": "Documentation/resources/Presentations/index.zh.html",
    "title": "Orleans Presentations | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæœ€ä½³å®è·µ ä¸€ç³»åˆ—æŠ€å·§å’Œçªé—¨ï¼Œå¯å¸®åŠ©è®¾è®¡ï¼Œæ„å»ºå’Œè¿è¡ŒåŸºäºOrleansçš„åº”ç”¨ç¨‹åºã€‚ ç¬¬28å±Šå›½é™…åˆ†å¸ƒå¼è®¡ç®—ç ”è®¨ä¼š(2014å¹´DISC)ä¸Šçš„Orleansæ¼”è®² Orleansåœ¨ç¬¬15å±Šé«˜æ€§èƒ½äº¤æ˜“ç³»ç»Ÿå›½é™…ç ”è®¨ä¼šä¸Šçš„æ¼”è®²(HPTS 2013) Orleansçš„å¹³è¡¡æŠ€æœ¯ ç»Ÿä¸€APIæ˜¯42-è™šæ‹Ÿèšä¼šï¼ƒ3 Orleansåœ¨FreeBay-è™šæ‹Ÿèšä¼šï¼ƒ4 Orleansæµåª’ä½“-è™šæ‹Ÿèšä¼šï¼ƒ5-2015å¹´5æœˆ Geo Distributed Orleans-è™šæ‹Ÿèšä¼šï¼ƒ6-2015å¹´10æœˆ é€‚ç”¨äºOrleansçš„Orleankka Functional API-è™šæ‹Ÿèšä¼šï¼ƒ7 Orleansè·¯çº¿å›¾-è™šæ‹Ÿèšä¼šï¼ƒ8-2016å¹´1æœˆ Orleansç½‘ç»œè®¨è®º-è™šæ‹Ÿèšä¼šï¼ƒ8.5-2016å¹´2æœˆ æœåŠ¡ç»“æ„ä¸Šçš„Orleans-è™šæ‹Ÿèšä¼šï¼ƒ9ç¬¬1éƒ¨åˆ†-2016å¹´2æœˆ Orleansä¸YAMS-è™šæ‹Ÿèšä¼šï¼ƒ9ç¬¬2éƒ¨åˆ†-2016å¹´2æœˆ ä¸Orleansä¸€èµ·èµ°è¿›åˆ†å¸ƒå¼ç³»ç»Ÿå›­"
  },
  "Documentation/tutorials_and_samples/overview_helloworld.html": {
    "href": "Documentation/tutorials_and_samples/overview_helloworld.html",
    "title": "Tutorial 1 Hello World | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ¦‚è¿°ï¼šHello World æ­¤æ¦‚è¿°ä¸å¯ç”¨çš„Hello Worldç¤ºä¾‹åº”ç”¨ç¨‹åºç›¸å…³è” è¿™é‡Œ ã€‚ Orleansçš„ä¸»è¦æ¦‚å¿µåŒ…æ‹¬silosï¼Œå®¢æˆ·å’Œä¸€ç§æˆ–å¤šç§Grainsã€‚åˆ›å»ºOrleansåº”ç”¨ç¨‹åºæ¶‰åŠé…ç½®silosï¼Œé…ç½®å®¢æˆ·ç«¯å’Œç¼–å†™Grainã€‚ é…ç½®silos é€šè¿‡ä»¥ä¸‹æ–¹å¼ä»¥ç¼–ç¨‹æ–¹å¼é…ç½®silos SiloHostBuilder å’Œè®¸å¤šè¡¥å……æœŸæƒç±»åˆ«ã€‚å¯ä»¥æ‰¾åˆ°æ‰€æœ‰é€‰é¡¹çš„åˆ—è¡¨ è¿™é‡Œã€‚ [...] private static async Task<ISiloHost> StartSilo() { // define the cluster configuration var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences()) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } é€‰é¡¹ ç”¨äº .UseLocalhostClustering() å°†å®¢æˆ·ç«¯é…ç½®ä¸ºè¿æ¥åˆ°æœ¬åœ°ä¸»æœºä¸Šçš„silosã€‚ é›†ç¾¤é€‰é¡¹ ClusterIdæ˜¯Orleansç¾¤é›†çš„åç§°ï¼Œå¯¹äºsiloså’Œå®¢æˆ·ç«¯ï¼Œåç§°å¿…é¡»ç›¸åŒï¼Œä»¥ä¾¿å½¼æ­¤å¯¹è¯ã€‚ServiceIdæ˜¯ç”¨äºåº”ç”¨ç¨‹åºçš„IDï¼Œå¹¶ä¸”åœ¨éƒ¨ç½²ä¹‹é—´ä¸å¾—æ›´æ”¹ EndpointOptions è¿™å‘Šè¯‰silosåœ¨å“ªé‡Œå¬ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† å›é€ ã€‚ é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ å°†Grainç±»å’Œæ¥å£ç¨‹åºé›†ä½œä¸ºåº”ç”¨ç¨‹åºéƒ¨åˆ†æ·»åŠ åˆ°æ‚¨çš„orleansåº”ç”¨ç¨‹åºä¸­ã€‚ åŠ è½½é…ç½®åï¼Œå°†æ„å»ºSiloHostï¼Œç„¶åå¼‚æ­¥å¯åŠ¨ã€‚ é…ç½®å®¢æˆ·ç«¯ ä¸silosç±»ä¼¼ï¼Œå®¢æˆ·ç«¯é€šè¿‡ä»¥ä¸‹æ–¹å¼é…ç½® ClientBuilder ä»¥åŠç±»ä¼¼çš„æœŸæƒç±»åˆ«é›†åˆã€‚ private static async Task<IClusterClient> StartClientWithRetries() { attempt = 0; IClusterClient client; client = new ClientBuilder() .UseLocalhostClustering() .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"HelloWorldApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build(); await client.Connect(RetryFilter); Console.WriteLine(\"Client successfully connect to silo host\"); return client; } é€‰é¡¹ ç”¨äº .UseLocalhostClustering() ä¸SiloHostç›¸åŒ é›†ç¾¤é€‰é¡¹ ä¸SiloHostç›¸åŒ å¯ä»¥æ‰¾åˆ°æœ‰å…³é…ç½®å®¢æˆ·ç«¯çš„æ›´æ·±å…¥çš„æŒ‡å— åœ¨é…ç½®æŒ‡å—çš„å®¢æˆ·ç«¯é…ç½®éƒ¨åˆ†ä¸­ã€‚ å†™ä¸€ç²’ Grainsæ˜¯Orleansç¼–ç¨‹æ¨¡å‹çš„å…³é”®åŸè¯­ã€‚Grainsæ˜¯Orleansåº”ç”¨ç¨‹åºçš„åŸºç¡€ï¼Œå®ƒä»¬æ˜¯éš”ç¦»ï¼Œåˆ†å¸ƒå’ŒæŒä¹…åŒ–çš„åŸå­å•ä½ã€‚Grainsæ˜¯ä»£è¡¨åº”ç”¨ç¨‹åºå®ä½“çš„å¯¹è±¡ã€‚å°±åƒç»å…¸çš„é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸€æ ·ï¼Œgrainå°è£…äº†å®ä½“çš„çŠ¶æ€ï¼Œå¹¶åœ¨ä»£ç é€»è¾‘ä¸­å¯¹å…¶è¡Œä¸ºè¿›è¡Œäº†ç¼–ç ã€‚Grainså¯ä»¥ç›¸äº’ä¿æŒå¼•ç”¨ï¼Œå¹¶å¯ä»¥é€šè¿‡è°ƒç”¨å½¼æ­¤é€šè¿‡æ¥å£å…¬å¼€çš„æ–¹æ³•è¿›è¡Œäº¤äº’ã€‚ æ‚¨å¯ä»¥åœ¨ Orleansæ–‡æ¡£çš„â€œæ ¸å¿ƒæ¦‚å¿µâ€éƒ¨åˆ†ã€‚ è¿™æ˜¯Hello World Grainçš„ä»£ç ä¸»ä½“ï¼š [...] namespace HelloWorld.Grains { public class HelloGrain : Orleans.Grain, IHello { Task<string> IHello.SayHello(string greeting) { logger.LogInformation($\"SayHello message received: greeting = '{greeting}'\"); return Task.FromResult($\"You said: '{greeting}', I say: Hello!\"); } } } æ‚¨å¯ä»¥é˜…è¯»ï¼Œgrainç±»å®ç°ä¸€ä¸ªæˆ–å¤šä¸ªgrainæ¥å£ åœ¨è¿™é‡Œï¼Œåœ¨Grainséƒ¨åˆ†ã€‚ ) [...] namespace HelloWorld.Interfaces { public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } } é›¶ä»¶å¦‚ä½•ååŒå·¥ä½œ å»ºç«‹æ­¤ç¼–ç¨‹æ¨¡å‹æ˜¯æˆ‘ä»¬åˆ†å¸ƒå¼é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µçš„ä¸€éƒ¨åˆ†ã€‚SiloHosté¦–å…ˆå¯åŠ¨ã€‚ç„¶åï¼Œå¯åŠ¨OrleansClientç¨‹åºã€‚OrleansClientçš„Mainæ–¹æ³•è°ƒç”¨å¯åŠ¨å®¢æˆ·ç«¯çš„æ–¹æ³•ï¼Œ StartClientWithRetries()ã€‚ å®¢æˆ·ç«¯è¢«ä¼ é€’ç»™ DoClientWork() æ–¹æ³•ã€‚ private static async Task DoClientWork(IClusterClient client) { // example of calling grains from the initialized client var friend = client.GetGrain<IHello>(0); var response = await friend.SayHello(\"Good morning, my friend!\"); Console.WriteLine(\"\\n\\n{0}\\n\\n\", response); } æ­¤æ—¶ï¼ŒOrleansClientåˆ›å»ºå¯¹IHellograinsçš„å¼•ç”¨ï¼Œå¹¶é€šè¿‡å…¶æ¥å£IHelloè°ƒç”¨å…¶SayHello()æ–¹æ³•ã€‚æ­¤è°ƒç”¨æ¿€æ´»silosä¸­çš„Grainsã€‚OrleansClientå‘æ¿€æ´»çš„Grainså‘é€é—®å€™è¯­ã€‚Grainsè¿”å›é—®å€™ä½œä¸ºå¯¹OrleansClientçš„å“åº”ï¼ŒOrleansClientåœ¨æ§åˆ¶å°ä¸Šæ˜¾ç¤ºè¯¥é—®å€™ã€‚ è¿è¡Œç¤ºä¾‹åº”ç”¨ è¦è¿è¡Œç¤ºä¾‹åº”ç”¨ç¨‹åºï¼Œè¯·å‚é˜… è‡ªè¿°æ–‡ä»¶ã€‚"
  },
  "Documentation/tutorials_and_samples/Adventure.html": {
    "href": "Documentation/tutorials_and_samples/Adventure.html",
    "title": "Adventure | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å†’é™© ä¸€ä¸ªç®€å•çš„å¤šäººæ–‡æœ¬å†’é™©æ¸¸æˆçš„çµæ„Ÿæ¥è‡ªè€å¼çš„ï¼ŒåŸºäºæ–‡æœ¬çš„å†’é™©æ¸¸æˆã€‚ è¯´æ˜ä¹¦ æ‰“å¼€OrleansAdventure.slnåœ¨Visual Studioä¸­ã€‚æ‰¾åˆ°äº† åœ¨è¿™é‡Œã€‚ å¯åŠ¨â€œAdventureSetupâ€é¡¹ç›®ã€‚ ä¸€æ—¦AdventureSetupè¿è¡Œï¼Œå¯åŠ¨â€œAdventureClientâ€é¡¹ç›®ã€‚ ç„¶åç³»ç»Ÿä¼šæç¤ºæ‚¨åœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥æ‚¨çš„å§“åã€‚è¿›å…¥å¹¶å¼€å§‹æ¸¸æˆã€‚ æ¦‚è¿° AdventureSetupç¨‹åºä»ä¸­è¯»å–æ¸¸æˆæè¿°(â€œåœ°å›¾â€)å†’é™©é…ç½®.txt. å®ƒè®¾ç½®äº†ä¸€ç³»åˆ—çš„â€œæˆ¿é—´â€ï¼Œå¦‚æ£®æ—ã€æµ·æ»©ã€æ´ç©´ã€ç©ºåœ°ç­‰ã€‚è¿™äº›ä½ç½®ä¸å…¶ä»–æˆ¿é—´ç›¸è¿ï¼Œä»¥æ¨¡æ‹Ÿæ¸¸æˆçš„åœ°ç‚¹å’Œå¸ƒå±€ã€‚ç¤ºä¾‹é…ç½®åªæè¿°äº†å°‘æ•°å‡ ä¸ªä½ç½®ã€‚ æˆ¿é—´é‡Œå¯ä»¥æ”¾é’¥åŒ™ã€å‰‘ç­‰â€œä¸œè¥¿â€ã€‚ AdventureClientç¨‹åºè®¾ç½®æ‚¨çš„æ’­æ”¾å™¨ï¼Œå¹¶æä¾›ä¸€ä¸ªç®€å•çš„åŸºäºæ–‡æœ¬çš„ç”¨æˆ·æ¥å£ï¼Œå…è®¸æ‚¨ç©æ¸¸æˆã€‚ ä½ å¯ä»¥åœ¨æˆ¿é—´é‡Œèµ°åŠ¨ï¼Œç”¨ä¸€ç§ç®€å•çš„å‘½ä»¤è¯­è¨€ä¸äº‹ç‰©äº’åŠ¨ï¼Œæ¯”å¦‚è¯´â€œå¾€åŒ—èµ°â€æˆ–â€œæ‹¿é»„é“œé’¥åŒ™â€ã€‚ ä¸ºä»€ä¹ˆæ˜¯Orleansï¼Ÿ Orleanså…è®¸æ¸¸æˆé€šè¿‡éå¸¸ç®€å•çš„Cä»£ç æ¥æè¿°ï¼ŒåŒæ—¶å…è®¸å®ƒæ‰©å±•åˆ°å¤§å‹å¤šäººæ¸¸æˆã€‚ä¸ºäº†ä½¿è¿™ä¸ªåŠ¨æœºæœ‰æ„ä¹‰ï¼Œè¿·å®«èˆ¬çš„æˆ¿é—´éœ€è¦éå¸¸å¤§ï¼Œå¹¶ä¸”éœ€è¦åŒæ—¶æ”¯æŒå¤§é‡ç©å®¶ã€‚Orleansçš„ä¸€ä¸ªä»·å€¼æ˜¯ï¼Œè¯¥æœåŠ¡å¯ä»¥é’ˆå¯¹å¢é•¿è€Œè®¾è®¡ï¼Œä»¥å°è§„æ¨¡è¿è¡Œå®ƒçš„å¼€é”€å¹¶ä¸æ˜¾è‘—ï¼Œè€Œä¸”æ‚¨å¯ä»¥ä¿æŒä¿¡å¿ƒï¼Œå¦‚æœéœ€è¦ï¼Œå®ƒå°†æ‰©å±•ã€‚ å®ƒæ˜¯å¦‚ä½•å»ºæ¨¡çš„ï¼Ÿ ç©å®¶å’Œæˆ¿é—´è¢«å»ºæ¨¡ä¸ºGrainsã€‚è¿™äº›grainsä½¿æˆ‘ä»¬èƒ½å¤Ÿç”¨æ¯ä¸ªgrainsæ¨¡å‹çŠ¶æ€å’ŒåŠŸèƒ½æ¥åˆ†å‘æ¸¸æˆã€‚ åƒå¯†é’¥è¿™æ ·çš„ä¸œè¥¿è¢«å»ºæ¨¡ä¸ºç®€å•çš„æ—§å¯¹è±¡â€”â€”å®ƒä»¬å®é™…ä¸Šåªæ˜¯ç®€å•çš„ä¸å¯å˜çš„æ•°æ®ç»“æ„ï¼Œåœ¨æˆ¿é—´é‡Œå’Œç©å®¶ä¹‹é—´ç§»åŠ¨ï¼›å®ƒä»¬ä¸éœ€è¦æ˜¯grainsã€‚ å¯èƒ½çš„æ”¹è¿› æŠŠåœ°å›¾å¼„å¾—æ›´å¤§ï¼Œæ›´å¤§ è®©é“œé’¥åŒ™æ‰“å¼€ä»€ä¹ˆä¸œè¥¿ å…è®¸ç©å®¶äº’ç›¸ç•™è¨€ ä½¿é£Ÿç‰©å’Œé¥®ç”¨æ°´æˆä¸ºå¯èƒ½å’Œæœ‰æ„ä¹‰çš„"
  },
  "Documentation/deployment/multi-cluster_support/Overview.html": {
    "href": "Documentation/deployment/multi-cluster_support/Overview.html",
    "title": "å¤šé›†ç¾¤æ”¯æŒ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤šé›†ç¾¤æ”¯æŒ Orleans V.1.3.0å¢åŠ äº†å¯¹å°†å¤šä¸ªOrleansé›†ç¾¤è”åˆåˆ°æ¾æ•£è¿æ¥çš„ å¤šç°‡ å°±åƒä¸€ä¸ªå•ä¸€çš„æœåŠ¡ã€‚ å¤šé›†ç¾¤ä¿ƒè¿› åœ°ç†åˆ†å¸ƒ ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å…¨ä¸–ç•Œçš„å¤šä¸ªæ•°æ®ä¸­å¿ƒè¿è¡Œä¸€ä¸ªOrleansåº”ç”¨ç¨‹åºæ›´åŠ å®¹æ˜“ã€‚æ­¤å¤–ï¼Œå¤šé›†ç¾¤å¯ä»¥åœ¨å•ä¸ªæ•°æ®ä¸­å¿ƒå†…è¿è¡Œï¼Œä»¥è·å¾—æ›´å¥½çš„æ•…éšœå’Œæ€§èƒ½éš”ç¦»ã€‚ æ‰€æœ‰æœºåˆ¶çš„è®¾è®¡éƒ½ç‰¹åˆ«æ³¨æ„(1)æœ€å°åŒ–é›†ç¾¤ä¹‹é—´çš„é€šä¿¡ï¼Œå’Œ(2)è®©æ¯ä¸ªé›†ç¾¤ç‹¬ç«‹è¿è¡Œï¼Œå³ä½¿å…¶ä»–é›†ç¾¤å¤±è´¥æˆ–æ— æ³•è®¿é—®ã€‚ é…ç½®å’Œæ“ä½œ ä¸‹é¢æˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•é…ç½®å’Œæ“ä½œå¤šé›†ç¾¤ã€‚ æ²Ÿé€š æ˜¯çš„ã€‚é›†ç¾¤é€šè¿‡é›†ç¾¤ä¸­ä½¿ç”¨çš„åŒä¸€ä¸ªsilosåˆ°silosçš„è¿æ¥è¿›è¡Œé€šä¿¡ã€‚ä¸ºäº†äº¤æ¢çŠ¶æ€å’Œé…ç½®ä¿¡æ¯ï¼Œé›†ç¾¤ä½¿ç”¨gossipæœºåˆ¶å’Œgossipé€šé“å®ç°ã€‚ silosé…ç½® æ˜¯çš„ã€‚éœ€è¦é…ç½®silosï¼Œä»¥ä¾¿å®ƒä»¬çŸ¥é“è‡ªå·±å±äºå“ªä¸ªé›†ç¾¤(æ¯ä¸ªé›†ç¾¤ç”±ä¸€ä¸ªå”¯ä¸€çš„å­—ç¬¦ä¸²æ ‡è¯†)ã€‚æ­¤å¤–ï¼Œæ¯ä¸ªsiloséƒ½éœ€è¦é…ç½®è¿æ¥å­—ç¬¦ä¸²ï¼Œä»¥å…è®¸å®ƒä»¬è¿æ¥åˆ°ä¸€ä¸ªæˆ–å¤šä¸ª å…«å¦é¢‘é“ å¯åŠ¨æ—¶ã€‚ å¤šé›†ç¾¤é…ç½®æ³¨å…¥ . åœ¨è¿è¡Œæ—¶ï¼ŒæœåŠ¡æ“ä½œå‘˜å¯ä»¥æŒ‡å®šå’Œ/æˆ–æ›´æ”¹ å¤šç¾¤é›†é…ç½® ï¼Œå…¶ä¸­åŒ…å«ç¾¤é›†IDçš„åˆ—è¡¨ï¼Œä»¥æŒ‡å®šå“ªäº›ç¾¤é›†æ˜¯å½“å‰å¤šç¾¤é›†çš„ä¸€éƒ¨åˆ†ã€‚è¿™æ˜¯é€šè¿‡è°ƒç”¨ä»»ä½•é›†ç¾¤ä¸­çš„ç®¡ç†Grainæ¥å®Œæˆçš„ã€‚ å¤šç°‡grains ä¸‹é¢æˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•åœ¨åº”ç”¨ç¨‹åºçº§åˆ«ä½¿ç”¨å¤šé›†ç¾¤åŠŸèƒ½ã€‚ å…¨å±€å•å®ä¾‹Grain . å¼€å‘äººå‘˜å¯ä»¥æŒ‡ç¤ºé›†ç¾¤åº”è¯¥åœ¨ä½•æ—¶ä»¥åŠå¦‚ä½•æ ¹æ®ç‰¹å®šçš„grainç±»åè°ƒå…¶grainç›®å½•ã€‚è¿™ä¸ª [å…¨çƒç…§æ˜] å±æ€§æ„å‘³ç€æˆ‘ä»¬éœ€è¦ä¸åœ¨å•ä¸ªå…¨å±€é›†ç¾¤ä¸­è¿è¡Œorleansæ—¶ç›¸åŒçš„è¡Œä¸ºï¼šå³å°†æ‰€æœ‰è°ƒç”¨è·¯ç”±åˆ°ä¸€ä¸ªå•ä¸€çš„grainæ¿€æ´»ã€‚ç›¸ååœ°ï¼Œ [OneInstancePerCluster] å±æ€§æŒ‡ç¤ºæ¯ä¸ªç¾¤é›†å¯ä»¥æœ‰è‡ªå·±çš„ç‹¬ç«‹æ¿€æ´»ã€‚å¦‚æœé›†ç¾¤ä¹‹é—´çš„é€šä¿¡æ˜¯ä¸éœ€è¦çš„ï¼Œè¿™æ˜¯åˆé€‚çš„ã€‚ åŸæœ¨è§†å›¾grains (ä¸åœ¨V.1.3.0ä¸­) . ä¸€ç§ç‰¹æ®Šç±»å‹çš„Grainï¼Œä½¿ç”¨ä¸äº‹ä»¶æºç±»ä¼¼çš„æ–°apiæ¥åŒæ­¥æˆ–æŒä¹…åŒ–GrainçŠ¶æ€ã€‚å®ƒå¯ä»¥ç”¨æ¥è‡ªåŠ¨å’Œæœ‰æ•ˆåœ°åŒæ­¥é›†ç¾¤ä¹‹é—´å’Œå­˜å‚¨grainçš„çŠ¶æ€ã€‚å› ä¸ºå®ƒçš„åŒæ­¥ç®—æ³•å¯ä»¥å®‰å…¨åœ°ä¸Reentrantçš„grainsä¸€èµ·ä½¿ç”¨ï¼Œå¹¶ä¸”ä¼˜åŒ–ä¸ºä½¿ç”¨æ‰¹å¤„ç†å’Œå¤åˆ¶ï¼Œæ‰€ä»¥å½“ä¸€ä¸ªgrainsåœ¨å¤šä¸ªé›†ç¾¤ä¸­é¢‘ç¹è®¿é—®å’Œ/æˆ–å½“å®ƒè¢«é¢‘ç¹å†™å…¥å­˜å‚¨å™¨æ—¶ï¼Œå®ƒå¯ä»¥æ¯”æ ‡å‡†grainsæ‰§è¡Œå¾—æ›´å¥½ã€‚å¯¹æ—¥å¿—è§†å›¾Grainçš„æ”¯æŒè¿˜ä¸æ˜¯ä¸»åˆ†æ”¯çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªé¢„å‘è¡Œç‰ˆï¼ŒåŒ…æ‹¬ç¤ºä¾‹å’Œä¸€äº›æ–‡æ¡£ åœ°ç†Orleansåˆ†è¡Œ . å®ƒç›®å‰æ­£ç”±ä¸€ä¸ªæ—©æœŸé‡‡ç”¨è€…åœ¨ç”Ÿäº§ä¸­è¿›è¡Œè¯„ä¼°ã€‚"
  },
  "Documentation/deployment/troubleshooting_azure_cloud_services_deployments.html": {
    "href": "Documentation/deployment/troubleshooting_azure_cloud_services_deployments.html",
    "title": "æ’é™¤éƒ¨ç½²æ•…éšœ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "éƒ¨ç½²ç–‘éš¾è§£ç­” æ­¤é¡µé¢æä¾›äº†ä¸€äº›å¸¸è§„æŒ‡å—ï¼Œç”¨äºè§£å†³éƒ¨ç½²åˆ°azureäº‘æœåŠ¡æ—¶å‡ºç°çš„ä»»ä½•é—®é¢˜ã€‚è¿™äº›éƒ½æ˜¯éå¸¸å¸¸è§çš„é—®é¢˜éœ€è¦æ³¨æ„ã€‚ä¸€å®šè¦æ£€æŸ¥æ—¥å¿—ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚ è·å–silounavailableexception åœ¨å°è¯•åˆå§‹åŒ–å®¢æˆ·ç«¯ä¹‹å‰ï¼Œé¦–å…ˆæ£€æŸ¥ä»¥ç¡®ä¿å®é™…å¯åŠ¨äº†silosã€‚æœ‰æ—¶ï¼Œsiloséœ€è¦å¾ˆé•¿æ—¶é—´æ‰èƒ½å¯åŠ¨ï¼Œå› æ­¤å°è¯•å¤šæ¬¡åˆå§‹åŒ–å®¢æˆ·ç«¯æ˜¯æœ‰ç›Šçš„ã€‚å¦‚æœå®ƒä»ç„¶æŠ›å‡ºå¼‚å¸¸ï¼Œé‚£ä¹ˆsiloså¯èƒ½è¿˜æœ‰å¦ä¸€ä¸ªé—®é¢˜ã€‚ æ£€æŸ¥silosé…ç½®å¹¶ç¡®ä¿silosæ­£ç¡®å¯åŠ¨ã€‚ å¸¸è§çš„è¿æ¥å­—ç¬¦ä¸²é—®é¢˜ åœ¨éƒ¨ç½²åˆ°azureæ—¶ä½¿ç”¨æœ¬åœ°è¿æ¥å­—ç¬¦ä¸²-ç½‘ç«™å°†æ— æ³•è¿æ¥ ä¸ºsiloså’Œå‰ç«¯(webå’Œworkerè§’è‰²)ä½¿ç”¨ä¸åŒçš„è¿æ¥å­—ç¬¦ä¸²-ç½‘ç«™å°†æ— æ³•åˆå§‹åŒ–å®¢æˆ·ç«¯ï¼Œå› ä¸ºå®ƒæ— æ³•è¿æ¥åˆ°silos å¯ä»¥åœ¨azureé—¨æˆ·ä¸­æ£€æŸ¥è¿æ¥å­—ç¬¦ä¸²é…ç½®ã€‚å¦‚æœè¿æ¥å­—ç¬¦ä¸²è®¾ç½®ä¸æ­£ç¡®ï¼Œæ—¥å¿—å¯èƒ½æ— æ³•æ­£ç¡®æ˜¾ç¤ºã€‚ ä¸æ­£ç¡®åœ°ä¿®æ”¹é…ç½®æ–‡ä»¶ è¯·ç¡®ä¿åœ¨serviceDefinition.csdefæ–‡ä»¶ä¸­é…ç½®äº†æ­£ç¡®çš„ç»ˆç»“ç‚¹ï¼Œå¦åˆ™éƒ¨ç½²å°†æ— æ³•å·¥ä½œã€‚å®ƒå°†ç»™å‡ºé”™è¯¯ï¼Œè¯´æ˜å®ƒæ— æ³•è·å–ç«¯ç‚¹ä¿¡æ¯ã€‚ ä¸¢å¤±çš„æ—¥å¿— ç¡®ä¿è¿æ¥å­—ç¬¦ä¸²è®¾ç½®æ­£ç¡®ã€‚ å¾ˆå¯èƒ½Webè§’è‰²ä¸­çš„web.configæ–‡ä»¶æˆ–å·¥ä½œè§’è‰²ä¸­çš„app.configæ–‡ä»¶ä¿®æ”¹ä¸æ­£ç¡®ã€‚è¿™äº›æ–‡ä»¶ä¸­çš„ä¸æ­£ç¡®ç‰ˆæœ¬å¯èƒ½å¯¼è‡´éƒ¨ç½²é—®é¢˜ã€‚å¤„ç†æ›´æ–°æ—¶è¦å°å¿ƒã€‚ ç‰ˆæœ¬é—®é¢˜ ç¡®ä¿è§£å†³æ–¹æ¡ˆä¸­çš„æ¯ä¸ªé¡¹ç›®éƒ½ä½¿ç”¨ç›¸åŒç‰ˆæœ¬çš„Orleansã€‚ä¸è¿™æ ·åšä¼šå¯¼è‡´å·¥äººè§’è‰²çš„å›æ”¶ã€‚æŸ¥çœ‹æ—¥å¿—ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚visual studioåœ¨éƒ¨ç½²å†å²è®°å½•ä¸­æä¾›äº†ä¸€äº›siloså¯åŠ¨é”™è¯¯æ¶ˆæ¯ã€‚ è§’è‰²ä¸æ–­å¾ªç¯ æ£€æŸ¥æ‰€æœ‰é€‚å½“çš„orleansç¨‹åºé›†æ˜¯å¦åœ¨è§£å†³æ–¹æ¡ˆä¸­ï¼Œå¹¶å°†copy localè®¾ç½®ä¸ºtrueã€‚ æ£€æŸ¥æ—¥å¿—ä»¥æŸ¥çœ‹åˆå§‹åŒ–æ—¶æ˜¯å¦å­˜åœ¨æœªå¤„ç†çš„å¼‚å¸¸ã€‚ ç¡®ä¿è¿æ¥å­—ç¬¦ä¸²æ­£ç¡®ã€‚ æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹azureäº‘æœåŠ¡ç–‘éš¾è§£ç­”é¡µé¢ã€‚ å¦‚ä½•æ£€æŸ¥æ—¥å¿— ä½¿ç”¨visual studioä¸­çš„äº‘èµ„æºç®¡ç†å™¨å¯¼èˆªåˆ°å­˜å‚¨å¸æˆ·ä¸­ç›¸åº”çš„å­˜å‚¨è¡¨æˆ–blobã€‚Wadlogstableæ˜¯æŸ¥çœ‹æ—¥å¿—çš„è‰¯å¥½èµ·ç‚¹ã€‚ æ‚¨å¯èƒ½åªè®°å½•äº†é”™è¯¯ã€‚å¦‚æœè¿˜éœ€è¦ä¿¡æ¯æ—¥å¿—ï¼Œåˆ™éœ€è¦ä¿®æ”¹é…ç½®ä»¥è®¾ç½®æ—¥å¿—ä¸¥é‡æ€§çº§åˆ«ã€‚ ç¼–ç¨‹é…ç½®ï¼š å½“åˆ›å»º ç¾¤é›†é…ç½® å¯¹è±¡ï¼Œè®¾ç½® config.defaults.defaulttracelevel=ä¸¥é‡æ€§ã€‚ä¿¡æ¯ æ˜¯çš„ã€‚ å½“åˆ›å»º å®¢æˆ·ç«¯é…ç½® å¯¹è±¡ï¼Œè®¾ç½® config.defaulttracelevel=ä¸¥é‡æ€§ã€‚ä¿¡æ¯ æ˜¯çš„ã€‚ å£°æ˜æ€§é…ç½®ï¼š æ·»åŠ  <tracing defaulttracelevel=â€œinfoâ€/> è‡´ orleansconfiguration.xmlæ–‡ä»¶ å’Œ/æˆ– å®¢æˆ·ç«¯é…ç½®.xml æ–‡ä»¶å¤¹ã€‚ åœ¨ è¯Šæ–­.wadcfgx æ–‡ä»¶ä¸­çš„webå’Œworkerè§’è‰²ï¼Œè¯·ç¡®ä¿è®¾ç½® scheduledTransferLogLevelFilter ä¸­çš„å±æ€§ åŸæœ¨ å…ƒç´ åˆ° é—®è¯¢å¤„ ï¼Œå› ä¸ºè¿™æ˜¯è·Ÿè¸ªç­›é€‰çš„é™„åŠ å±‚ï¼Œå®ƒå®šä¹‰å°†å“ªäº›è·Ÿè¸ªå‘é€åˆ° ç“¦å¾·æ´›æ–¯æ³°å¸ƒå°” åœ¨azureå­˜å‚¨ä¸­ã€‚ æ‚¨å¯ä»¥åœ¨ã€Šé…ç½®æŒ‡å—ã€‹ä¸­æ‰¾åˆ°æœ‰å…³æ­¤çš„æ›´å¤šä¿¡æ¯ã€‚ ä¸asp.netçš„å…¼å®¹æ€§ åŒ…å«åœ¨asp.netä¸­çš„razorè§†å›¾å¼•æ“ä½¿ç”¨ä¸orleansç›¸åŒçš„ä»£ç ç”Ÿæˆç¨‹åºé›†( Microsoft.codeåˆ†æ å’Œ å¾®è½¯ä»£ç åˆ†æ.csharp )ä¸­ã€‚è¿™å¯èƒ½ä¼šåœ¨è¿è¡Œæ—¶å‡ºç°ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜ã€‚ è‹¥è¦è§£å†³æ­¤é—®é¢˜ï¼Œè¯·å°è¯•å‡çº§ Microsoft.codedom.providers.dotnetCompilerPlatform (è¿™æ˜¯ASP.NETç”¨äºåŒ…å«ä¸Šè¿°ç¨‹åºé›†çš„NuGetåŒ…)åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶è®¾ç½®ç»‘å®šé‡å®šå‘ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "Documentation/deployment/docker_deployment.html": {
    "href": "Documentation/deployment/docker_deployment.html",
    "title": "Docker Deployment | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Dockeréƒ¨ç½² æ³¨æ„ ï¼šå³ä½¿ä½ éå¸¸ç†Ÿæ‚‰Dockerå’Œ/æˆ–Orleansï¼Œå°±åƒä»»ä½•å…¶ä»–Orleansæ–‡æ¡£ä¸€æ ·ï¼Œæˆ‘å»ºè®®ä½ è¯»åˆ°æœ€åï¼Œä»¥é¿å…ä½ å¯èƒ½é¢ä¸´çš„é—®é¢˜ï¼Œæˆ‘ä»¬å·²ç»è§£å†³äº†ã€‚ æ³¨æ„ ï¼šæœ¬æ–‡åŠå…¶ç¤ºä¾‹æ˜¯æ­£åœ¨è¿›è¡Œçš„å·¥ä½œã€‚ä»»ä½•åé¦ˆï¼Œå…¬å…³æˆ–å»ºè®®éƒ½æ˜¯éå¸¸æ¬¢è¿çš„ã€‚ å°†Orleansè§£å†³æ–¹æ¡ˆéƒ¨ç½²åˆ°Docker è€ƒè™‘åˆ°Docker Orchestratorå’Œé›†ç¾¤å †æ ˆçš„è®¾è®¡æ–¹å¼ï¼Œå°†Orleanséƒ¨ç½²åˆ°Dockerå¯èƒ½ä¼šå¾ˆæ£˜æ‰‹ã€‚æœ€å¤æ‚çš„æ˜¯è¦ç†è§£ è¦†ç›–ç½‘ç»œ æ¥è‡ªDocker Swarmå’ŒKubernetsçš„ç½‘ç»œæ¨¡å‹ã€‚ Dockerå®¹å™¨å’Œç½‘ç»œæ¨¡å‹çš„è®¾è®¡ä¸»è¦æ˜¯è¿è¡Œæ— çŠ¶æ€å’Œä¸å¯å˜çš„å®¹å™¨ã€‚å› æ­¤ï¼Œå¯åŠ¨è¿è¡Œnode.jsæˆ–nginxåº”ç”¨ç¨‹åºçš„é›†ç¾¤éå¸¸å®¹æ˜“ã€‚ä½†æ˜¯ï¼Œå¦‚æœæ‚¨å°è¯•ä½¿ç”¨æ›´ç²¾ç»†çš„ä¸œè¥¿ï¼Œæ¯”å¦‚çœŸæ­£çš„é›†ç¾¤æˆ–åˆ†å¸ƒå¼åº”ç”¨ç¨‹åº(æ¯”å¦‚åŸºäºOrleansçš„åº”ç”¨ç¨‹åº)ï¼Œé‚£ä¹ˆæ‚¨æœ€ç»ˆå°†æ— æ³•è®¾ç½®å®ƒã€‚è¿™æ˜¯å¯èƒ½çš„ï¼Œä½†ä¸åƒåŸºäºwebçš„åº”ç”¨ç¨‹åºé‚£ä¹ˆç®€å•ã€‚ Dockeré›†ç¾¤åŒ…æ‹¬å°†å¤šä¸ªä¸»æœºç»„åˆæˆä¸€ä¸ªèµ„æºæ± ï¼Œä½¿ç”¨ å®¹å™¨ç¼–æ’å™¨ æ˜¯çš„ã€‚ Docker æä¾› èœ‚ç¾¤ ä½œä¸ºå®¹å™¨ç¼–æ’çš„é€‰é¡¹ è°·æ­Œ æœ‰ åº“ä¼¯å†…ç‰¹æ–¯ (åˆå K8Så‹ )ä¸­ã€‚è¿˜æœ‰å…¶ä»–çš„ç¼–æ›²è€…åƒ ç›´æµ/æ“ä½œç³»ç»Ÿ ï¼Œ ä»‹å­ ï¼Œç­‰ç­‰ï¼Œä½†åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºswarmå’Œk8sï¼Œå› ä¸ºå®ƒä»¬ä½¿ç”¨å¾—æ›´å¹¿æ³›ã€‚ åŒæ ·çš„grainæ¥å£å’Œå®ç°åœ¨Orleansçš„ä»»ä½•åœ°æ–¹éƒ½å·²ç»å¾—åˆ°æ”¯æŒï¼Œä¹Ÿå°†åœ¨dockerå®¹å™¨ä¸Šè¿è¡Œï¼Œå› æ­¤ä¸éœ€è¦ç‰¹åˆ«è€ƒè™‘å°±å¯ä»¥åœ¨dockerå®¹å™¨ä¸­è¿è¡Œæ‚¨çš„åº”ç”¨ç¨‹åºã€‚ è¿™ä¸ª Orleansç å¤´å·¥äºº ç¤ºä¾‹æä¾›äº†å¦‚ä½•è¿è¡Œä¸¤ä¸ªæ§åˆ¶å°åº”ç”¨ç¨‹åºçš„å·¥ä½œç¤ºä¾‹ã€‚ä¸€ä¸ªä½œä¸ºOrleanså®¢æˆ·ç«¯ï¼Œå¦ä¸€ä¸ªä½œä¸ºsilosï¼Œè¯¦ç»†ä¿¡æ¯å¦‚ä¸‹æ‰€è¿°ã€‚ è¿™é‡Œè®¨è®ºçš„æ¦‚å¿µæ—¢å¯ä»¥ç”¨äº.NET Coreï¼Œä¹Ÿå¯ä»¥ç”¨äº.NET 4.6.1ç‰ˆæœ¬çš„Orleansï¼Œä½†æ˜¯ä¸ºäº†è¯´æ˜Dockerå’Œ.NET Coreçš„è·¨å¹³å°ç‰¹æ€§ï¼Œè€ƒè™‘åˆ°æ‚¨æ­£åœ¨ä½¿ç”¨.NET Coreï¼Œæˆ‘ä»¬å°†é‡ç‚¹è®¨è®ºè¿™ä¸ªç¤ºä¾‹ã€‚æœ¬æ–‡å°†æä¾›ç‰¹å®šäºå¹³å°(windows/linux/osx)çš„è¯¦ç»†ä¿¡æ¯ã€‚ é¢„å¤‡çŸ¥è¯† æœ¬æ–‡å‡è®¾æ‚¨å®‰è£…äº†ä»¥ä¸‹å…ˆå†³æ¡ä»¶ï¼š ç å¤´å·¥äºº -Docker4xä¸ºä¸»è¦æ”¯æŒçš„å¹³å°æä¾›äº†æ˜“äºä½¿ç”¨çš„å®‰è£…ç¨‹åºã€‚å®ƒåŒ…å«Dockerå¼•æ“å’ŒDocker Swarmã€‚ åº“ä¼¯å†…ç‰¹æ–¯(K8S) -è°·æ­Œæä¾›çš„å®¹å™¨ç¼–æ’ã€‚å®ƒåŒ…å«å®‰è£…æŒ‡å— è¿·ä½ åº“è´ (K8Sçš„æœ¬åœ°éƒ¨ç½²)å’Œ åº“è´å…‹ç‰¹ ä»¥åŠå®ƒæ‰€æœ‰çš„ä¾èµ–å…³ç³»ã€‚ .NETæ ¸å¿ƒ -.netçš„è·¨å¹³å°é£æ ¼ Visual Studioä»£ç (VScode) -ä½ æƒ³ç”¨ä»€ä¹ˆå°±ç”¨ä»€ä¹ˆã€‚vscodeæ˜¯è·¨å¹³å°çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨å®ƒæ¥ç¡®ä¿å®ƒå¯ä»¥åœ¨æ‰€æœ‰å¹³å°ä¸Šå·¥ä½œã€‚å®‰è£…vscodeåï¼Œè¯·å®‰è£… Cæ‰©å±• æ˜¯çš„ã€‚ æ³¨æ„ ï¼šå¦‚æœæ‚¨ä¸æ‰“ç®—ä½¿ç”¨kubernetesï¼Œåˆ™ä¸éœ€è¦å®‰è£…å®ƒã€‚Docker4xå®‰è£…ç¨‹åºå·²ç»åŒ…å«Swarmï¼Œå› æ­¤æ— éœ€é¢å¤–å®‰è£…å³å¯ä½¿ç”¨ã€‚ Windowsç”¨æˆ·æ³¨æ„äº‹é¡¹ ï¼šåœ¨Windowsä¸Šï¼ŒDockerå®‰è£…ç¨‹åºå°†åœ¨å®‰è£…è¿‡ç¨‹ä¸­å¯ç”¨Hyper-Vã€‚ç”±äºæœ¬æ–‡åŠå…¶ç¤ºä¾‹ä½¿ç”¨çš„æ˜¯.NET Coreï¼Œå› æ­¤ä½¿ç”¨çš„å®¹å™¨æ˜ åƒåŸºäº WindowsæœåŠ¡å™¨NanoServer æ˜¯çš„ã€‚å¦‚æœæ‚¨ä¸æ‰“ç®—ä½¿ç”¨.net coreå¹¶å°†ç›®æ ‡é”å®šä¸º.net 4.6.1full frameworkï¼Œåˆ™ä½¿ç”¨çš„æ˜ åƒåº”è¯¥æ˜¯ WindowsæœåŠ¡å™¨æ ¸å¿ƒ ä»¥åŠOrleansçš„1.4+ç‰ˆæœ¬(ä»…æ”¯æŒ.NETå®Œæ•´æ¡†æ¶)ã€‚ åˆ›å»ºOrleansè§£å†³æ–¹æ¡ˆ ä¸‹é¢çš„è¯´æ˜æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ ç‚¹ç½‘ å·¥å…·ã€‚ æ³¨æ„ ï¼šè¯·æ ¹æ®æ‚¨çš„å¹³å°ä¸­çš„é€‚å½“æƒ…å†µè°ƒæ•´å‘½ä»¤ã€‚å¦å¤–ï¼Œç›®å½•ç»“æ„åªæ˜¯ä¸€ä¸ªå»ºè®®ã€‚è¯·æ ¹æ®æ‚¨çš„éœ€è¦è°ƒæ•´å®ƒã€‚ mkdir Orleans-Docker cd Orleans-Docker dotnet new sln mkdir -p src/OrleansSilo mkdir -p src/OrleansClient mkdir -p src/OrleansGrains mkdir -p src/OrleansGrainInterfaces dotnet new console -o src/OrleansSilo --framework netcoreapp1.1 dotnet new console -o src/OrleansClient --framework netcoreapp1.1 dotnet new classlib -o src/OrleansGrains --framework netstandard1.5 dotnet new classlib -o src/OrleansGrainInterfaces --framework netstandard1.5 dotnet sln add src/OrleansSilo/OrleansSilo.csproj dotnet sln add src/OrleansClient/OrleansClient.csproj dotnet sln add src/OrleansGrains/OrleansGrains.csproj dotnet sln add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansClient/OrleansClient.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansGrains/OrleansGrains.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrains/OrleansGrains.csproj åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æ‰€åšçš„åªæ˜¯åˆ›å»ºè§£å†³æ–¹æ¡ˆç»“æ„ã€é¡¹ç›®å’Œåœ¨é¡¹ç›®ä¹‹é—´æ·»åŠ å¼•ç”¨çš„æ ·æ¿ä»£ç ã€‚æ²¡æœ‰ä»€ä¹ˆä¸åŒäºå¸¸è§„çš„Orleansé¡¹ç›®ã€‚ åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼ŒOrleans 2.0(è¿™æ˜¯å”¯ä¸€æ”¯æŒ.NET Coreå’Œè·¨å¹³å°çš„ç‰ˆæœ¬)å·²ç»è¿›å…¥äº†æŠ€æœ¯é¢„è§ˆç‰ˆï¼Œå› æ­¤å®ƒçš„nugetæ‰˜ç®¡åœ¨myget feedä¸­ï¼Œè€Œä¸æ˜¯å‘å¸ƒåˆ°nuget.orgå®˜æ–¹feedã€‚ä¸ºäº†å®‰è£…preview nugetï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ç‚¹ç½‘ cliå¼ºåˆ¶mygetæä¾›æºæè¦å’Œç‰ˆæœ¬ï¼š dotnet add src/OrleansClient/OrleansClient.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrains/OrleansGrains.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.OrleansRuntime -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet restore å¥½äº†ï¼Œç°åœ¨æ‚¨å·²ç»æ‹¥æœ‰äº†è¿è¡Œä¸€ä¸ªç®€å•çš„Orleansåº”ç”¨ç¨‹åºçš„æ‰€æœ‰åŸºæœ¬ä¾èµ–é¡¹ã€‚è¯·æ³¨æ„ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨çš„å¸¸è§„Orleansç”³è¯·æ²¡æœ‰ä»»ä½•å˜åŒ–ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ·»åŠ ä¸€äº›ä»£ç ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç”¨å®ƒåšäº›ä»€ä¹ˆäº†ã€‚ å®ç°æ‚¨çš„Orleansåº”ç”¨ç¨‹åº å‡è®¾ä½ æ­£åœ¨ä½¿ç”¨ ç”šå°ç  ï¼Œä»è§£å†³æ–¹æ¡ˆç›®å½•ä¸­è¿è¡Œ ä»£ç ã€‚ æ˜¯çš„ã€‚å°†åœ¨ä¸­æ‰“å¼€ç›®å½•çš„ ç”šå°ç  å¹¶åŠ è½½è§£å†³æ–¹æ¡ˆã€‚ è¿™æ˜¯æˆ‘ä»¬åˆšæ‰åˆ›å»ºçš„è§£å†³æ–¹æ¡ˆç»“æ„ã€‚ æˆ‘ä»¬è¿˜æ·»åŠ äº† ç¨‹åº.cs ï¼Œ Orleansé‹ç±»åŒ…è£… ï¼Œ å†°è°· å’Œ è¿å®¾ç²® åˆ†åˆ«æŒ‡å‘æ¥å£å’ŒGrainé¡¹ç›®çš„æ–‡ä»¶ï¼Œä»¥ä¸‹æ˜¯è¿™äº›æ–‡ä»¶çš„ä»£ç ï¼š igreetinggrain.cs ä»¥ä¸‹å†…å®¹ï¼š using System; using System.Threading.Tasks; using Orleans; namespace OrleansGrainInterfaces { public interface IGreetingGrain : IGrainWithGuidKey { Task<string> SayHello(string name); } } GreetingGrain.cs ä»¥ä¸‹å†…å®¹ï¼š using System; using System.Threading.Tasks; using OrleansGrainInterfaces; namespace OrleansGrains { public class GreetingGrain : Grain, IGreetingGrain { public Task<string> SayHello(string name) { return Task.FromResult($\"Hello from Orleans, {name}\"); } } } OrleanshostWrapper.cs ä»¥ä¸‹å†…å®¹ï¼š using System; using System.Net; using Orleans.Runtime; using Orleans.Runtime.Configuration; using Orleans.Runtime.Host; namespace OrleansSilo { public class OrleansHostWrapper { private readonly SiloHost siloHost; public OrleansHostWrapper(ClusterConfiguration config) { siloHost = new SiloHost(Dns.GetHostName(), config); siloHost.LoadOrleansConfig(); } public int Run() { if (siloHost == null) { return 1; } try { siloHost.InitializeOrleansSilo(); if (siloHost.StartOrleansSilo()) { Console.WriteLine($\"Successfully started Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); return 0; } else { throw new OrleansException($\"Failed to start Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); } } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } public int Stop() { if (siloHost != null) { try { siloHost.StopOrleansSilo(); siloHost.Dispose(); Console.WriteLine($\"Orleans silo '{siloHost.Name}' shutdown.\"); } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } return 0; } } } ç¨‹åº.cs (silos)ï¼š using System; using System.Collections.Generic; using System.Linq; using System.Net; using Orleans.Runtime.Configuration; namespace OrleansSilo { public class Program { private static OrleansHostWrapper hostWrapper; static int Main(string[] args) { int exitCode = InitializeOrleans(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); exitCode += ShutdownSilo(); return exitCode; } private static int InitializeOrleans() { var config = new ClusterConfiguration(); config.Globals.DataConnectionString = \"[AZURE STORAGE CONNECTION STRING HERE]\"; config.Globals.DeploymentId = \"Orleans-Docker\"; config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable; config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable; config.Defaults.PropagateActivityId = true; config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any, 10400); config.Defaults.Port = 10300; var ips = Dns.GetHostAddressesAsync(Dns.GetHostName()).Result; config.Defaults.HostNameOrIPAddress = ips.FirstOrDefault()?.ToString(); hostWrapper = new OrleansHostWrapper(config); return hostWrapper.Run(); } private static int ShutdownSilo() { if (hostWrapper != null) { return hostWrapper.Stop(); } return 0; } } } ç¨‹åº.cs (å®¢æˆ·)ï¼š using System; using System.Net; using System.Threading; using System.Threading.Tasks; using Orleans; using Orleans.Runtime.Configuration; using OrleansGrainInterfaces; namespace OrleansClient { class Program { private static IClusterClient client; private static bool running; static void Main(string[] args) { Task.Run(() => InitializeOrleans()); Console.ReadLine(); running = false; } static async Task InitializeOrleans() { var config = new ClientConfiguration(); config.DeploymentId = \"Orleans-Docker\"; config.PropagateActivityId = true; var hostEntry = await Dns.GetHostEntryAsync(\"orleans-silo\"); var ip = hostEntry.AddressList[0]; config.Gateways.Add(new IPEndPoint(ip, 10400)); Console.WriteLine(\"Initializing...\"); client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); running = true; Console.WriteLine(\"Initialized!\"); var grain = client.GetGrain<IGreetingGrain>(Guid.Empty); while(running) { var response = await grain.SayHello(\"Gutemberg\"); Console.WriteLine($\"[{DateTime.UtcNow}] - {response}\"); await Task.Delay(1000); } client.Dispose(); } } } æˆ‘ä»¬ä¸åœ¨è¿™é‡Œè¯¦ç»†è®¨è®ºgrainå®ç°ï¼Œå› ä¸ºå®ƒè¶…å‡ºäº†æœ¬æ–‡çš„èŒƒå›´ã€‚è¯·æ£€æŸ¥å…¶ä»–ç›¸å…³æ–‡ä»¶ã€‚è¿™äº›æ–‡ä»¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæœ€å°çš„Orleansåº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å°†ä»å®ƒå¼€å§‹ï¼Œç»§ç»­æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†ã€‚ æ³¨æ„ ï¼šåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ å¥¥åˆ©å®‰è¨ç¥–é²æå°” ä¼šå‘˜èµ„æ ¼æä¾›å•†ï¼Œä½†æ‚¨å¯ä»¥ä½¿ç”¨Orleanså·²ç»æ”¯æŒçš„ä»»ä½•å…¶ä»–æœåŠ¡ã€‚ åœé æ–‡ä»¶ ä¸ºäº†åˆ›å»ºå®¹å™¨ï¼ŒDockerä½¿ç”¨å›¾åƒã€‚æœ‰å…³å¦‚ä½•åˆ›å»ºè‡ªå·±çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¯ä»¥æŸ¥çœ‹ Dockeræ–‡æ¡£ æ˜¯çš„ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Microsoftå›¾åƒ æ˜¯çš„ã€‚åŸºäºç›®æ ‡å’Œå¼€å‘å¹³å°ï¼Œæ‚¨éœ€è¦é€‰æ‹©é€‚å½“çš„æ˜ åƒã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ å¾®è½¯/dotnet:1.1.2-sdk è¿™æ˜¯ä¸€ä¸ªåŸºäºlinuxçš„å›¾åƒã€‚ä½ å¯ä»¥ç”¨ microsoft/dotnet:1.1.2-sdk-nanoserver ä»¥windowsä¸ºä¾‹ã€‚é€‰ä¸€ä¸ªé€‚åˆä½ éœ€è¦çš„ã€‚ Windowsç”¨æˆ·æ³¨æ„äº‹é¡¹ ï¼šå¦‚å‰æ‰€è¿°ï¼Œä¸ºäº†è·¨å¹³å°ï¼Œæˆ‘ä»¬åœ¨æœ¬æ–‡ä¸­ä½¿ç”¨.NET Coreå’ŒOrleans Technical Preview 2.0ã€‚å¦‚æœè¦åœ¨Windowsä¸Šä½¿ç”¨Dockerå’Œå®Œå…¨å‘å¸ƒçš„Orleans 1.4+ï¼Œåˆ™éœ€è¦ä½¿ç”¨åŸºäºWindows Server Coreçš„æ˜ åƒï¼Œå› ä¸ºåŸºäºNanoServerå’ŒLinuxçš„æ˜ åƒä»…æ”¯æŒ.NET Coreã€‚ Dockerfile.debug ä»¥ä¸‹å†…å®¹ï¼š FROM microsoft/dotnet:1.1.2-sdk ENV NUGET_XMLDOC_MODE skip WORKDIR /vsdbg RUN apt-get update \\ && apt-get install -y --no-install-recommends \\ unzip \\ && rm -rf /var/lib/apt/lists/* \\ && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg WORKDIR /app ENTRYPOINT [\"tail\", \"-f\", \"/dev/null\"] è¿™ä¸ªdockerfileå®è´¨ä¸Šæ˜¯ä¸‹è½½å¹¶å®‰è£…vsdbgè°ƒè¯•å™¨ï¼Œå¹¶å¯åŠ¨ä¸€ä¸ªç©ºå®¹å™¨ï¼Œä½¿å…¶æ°¸è¿œä¿æŒæ´»åŠ¨çŠ¶æ€ï¼Œè¿™æ ·æˆ‘ä»¬åœ¨è°ƒè¯•æ—¶å°±ä¸éœ€è¦æ‹†ä¸‹/æ‹†ä¸‹ã€‚ ç°åœ¨ï¼Œå¯¹äºç”Ÿäº§ï¼Œæ˜ åƒæ›´å°ï¼Œå› ä¸ºå®ƒåªåŒ…å«.NETæ ¸å¿ƒè¿è¡Œæ—¶ï¼Œè€Œä¸åŒ…å«æ•´ä¸ªsdkï¼Œdockerfileæ›´ç®€å•ä¸€äº›ï¼š åœé æ–‡ä»¶ ä»¥ä¸‹å†…å®¹ï¼š FROM microsoft/dotnet:1.1.2-runtime WORKDIR /app ENTRYPOINT [\"dotnet\", \"OrleansSilo.dll\"] COPY . /app Dockeråˆæˆ è¿™ä¸ª docker-compose.ymlæ–‡ä»¶ æ–‡ä»¶ï¼Œæœ¬è´¨ä¸Šå®šä¹‰(åœ¨é¡¹ç›®å†…)ä¸€ç»„æœåŠ¡åŠå…¶åœ¨æœåŠ¡çº§åˆ«ä¸Šçš„ä¾èµ–å…³ç³»ã€‚æ¯ä¸ªæœåŠ¡åŒ…å«ç»™å®šå®¹å™¨çš„ä¸€ä¸ªæˆ–å¤šä¸ªå®ä¾‹ï¼Œè¯¥å®ä¾‹åŸºäºæ‚¨åœ¨DockerFileä¸Šé€‰æ‹©çš„å›¾åƒã€‚æ›´å¤šå…³äº Dockeråˆæˆ å¯ä»¥åœ¨ä¸Šæ‰¾åˆ° Dockerç¼–å†™æ–‡æ¡£ æ˜¯çš„ã€‚ å¯¹äºOrleanséƒ¨ç½²ï¼Œä¸€ä¸ªå¸¸è§çš„ç”¨ä¾‹æ˜¯ docker-compose.ymlæ–‡ä»¶ å…¶ä¸­åŒ…å«ä¸¤ä¸ªæœåŠ¡ã€‚ä¸€ä¸ªç»™Orleanssilosï¼Œå¦ä¸€ä¸ªç»™Orleanså®¢æˆ·ã€‚å®¢æˆ·ç«¯å°†ä¾èµ–äºsilosï¼Œè¿™æ„å‘³ç€ï¼Œå®ƒåªèƒ½åœ¨silosæœåŠ¡å¯åŠ¨åå¯åŠ¨ã€‚å¦ä¸€ç§æƒ…å†µæ˜¯æ·»åŠ ä¸€ä¸ªå­˜å‚¨/æ•°æ®åº“æœåŠ¡/å®¹å™¨ï¼Œä¾‹å¦‚sql serverï¼Œå®ƒåº”è¯¥é¦–å…ˆåœ¨å®¢æˆ·ç«¯å’Œsilosä¹‹å‰å¯åŠ¨ï¼Œå› æ­¤ä¸¤ä¸ªæœåŠ¡éƒ½åº”è¯¥ä¾èµ–äºå®ƒã€‚ æ³¨æ„ ï¼šåœ¨ä½ è¿›ä¸€æ­¥é˜…è¯»(å¹¶æœ€ç»ˆç–¯ç‹‚é˜…è¯»)ä¹‹å‰ï¼Œè¯·æ³¨æ„ å‡¹ç—• äº‹é¡¹ åœ¨é‡Œé¢ Dockeråˆæˆ æ–‡ä»¶å¤¹ã€‚æ‰€ä»¥å¦‚æœä½ æœ‰ä»€ä¹ˆé—®é¢˜å°±è¦æ³¨æ„äº†ã€‚ ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†å¦‚ä½•æè¿°æˆ‘ä»¬ä¸ºæœ¬æ–‡æä¾›çš„æœåŠ¡ï¼š docker-compose.override.ymlæ–‡ä»¶ (è°ƒè¯•)ï¼š version: '3.1' services: orleans-client: image: orleans-client:debug build: context: ./src/OrleansClient/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansClient/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro depends_on: - orleans-silo orleans-silo: image: orleans-silo:debug build: context: ./src/OrleansSilo/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansSilo/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro docker-compose.ymlæ–‡ä»¶ (ç”Ÿäº§)ï¼š version: '3.1' services: orleans-client: image: orleans-client depends_on: - orleans-silo orleans-silo: image: orleans-silo æ³¨æ„ï¼Œåœ¨ç”Ÿäº§ä¸­ï¼Œæˆ‘ä»¬æ²¡æœ‰æ˜ å°„æœ¬åœ°ç›®å½•ï¼Œä¹Ÿæ²¡æœ‰ ç”Ÿæˆï¼š è¡ŒåŠ¨ã€‚åŸå› æ˜¯åœ¨ç”Ÿäº§ä¸­ï¼Œå›¾åƒåº”è¯¥è¢«æ„å»ºå¹¶æ¨é€åˆ°æ‚¨è‡ªå·±çš„Dockeræ³¨å†Œè¡¨ä¸­ã€‚ æŠŠæ‰€æœ‰çš„ä¸œè¥¿æ”¾åœ¨ä¸€èµ· ç°åœ¨æˆ‘ä»¬æœ‰äº†è¿è¡Œæ‚¨çš„Orleansåº”ç”¨ç¨‹åºæ‰€éœ€çš„æ‰€æœ‰ç§»åŠ¨éƒ¨ä»¶ï¼Œæˆ‘ä»¬å°†æŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·ï¼Œä»¥ä¾¿åœ¨Dockerä¸­è¿è¡Œæˆ‘ä»¬çš„Orleansè§£å†³æ–¹æ¡ˆ(æœ€åï¼)æ˜¯çš„ã€‚ æ³¨æ„ ï¼šåº”åœ¨è§£å†³æ–¹æ¡ˆç›®å½•ä¸­æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ã€‚ é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç¡®ä¿ä»æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆè¿˜åŸæ‰€æœ‰çš„nugetåŒ…ã€‚ä½ åªéœ€è¦åšä¸€æ¬¡ã€‚åªæœ‰åœ¨æ›´æ”¹é¡¹ç›®ä¸Šçš„ä»»ä½•åŒ…ä¾èµ–é¡¹æ—¶ï¼Œæ‰éœ€è¦å†æ¬¡æ‰§è¡Œæ­¤æ“ä½œã€‚ #dotnetè¿˜åŸ ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ ç‚¹ç½‘ åƒå¾€å¸¸ä¸€æ ·ä½¿ç”¨cliå¹¶å°†å…¶å‘å¸ƒåˆ°è¾“å‡ºç›®å½•ï¼š #dotnetå‘å¸ƒ-o./bin/publishoutput æ³¨æ„ ï¼šæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨ å‡ºç‰ˆ è¿™é‡Œä¸æ˜¯æ„å»ºï¼Œè€Œæ˜¯ä¸ºäº†é¿å…æˆ‘ä»¬åœ¨Orleansè£…è½½dynamicalyçš„æ±‡ç¼–å‡ºç°é—®é¢˜ã€‚æˆ‘ä»¬ä»åœ¨å¯»æ‰¾æ›´å¥½çš„è§£å†³åŠæ³•ã€‚ éšç€åº”ç”¨ç¨‹åºçš„æ„å»ºå’Œå‘å¸ƒï¼Œæ‚¨éœ€è¦æ„å»ºDockerfileæ˜ åƒã€‚æ¯ä¸ªé¡¹ç›®åªéœ€è¦æ‰§è¡Œä¸€æ¬¡æ­¤æ­¥éª¤ï¼Œå¹¶ä¸”åªæœ‰åœ¨æ›´æ”¹dockerfileã€docker composeæˆ–ç”±äºä»»ä½•åŸå› æ¸…ç†æœ¬åœ°æ˜ åƒæ³¨å†Œè¡¨æ—¶ï¼Œæ‰åº”å†æ¬¡æ‰§è¡Œæ­¤æ­¥éª¤ã€‚ #Dockeråˆæˆç”Ÿæˆ ä¸¤ç§å›¾åƒä¸­ä½¿ç”¨çš„æ‰€æœ‰å›¾åƒ åœé æ–‡ä»¶ å’Œ docker-compose.ymlæ–‡ä»¶ ä»æ³¨å†Œè¡¨ä¸­æå–å¹¶ç¼“å­˜åœ¨å¼€å‘è®¡ç®—æœºä¸Šã€‚ä½ çš„å½¢è±¡å·²ç»å»ºç«‹ï¼Œä½ éƒ½å‡†å¤‡å¥½äº†ã€‚ ç°åœ¨è®©æˆ‘ä»¬è¿è¡Œå®ƒï¼ # docker-compose up -d Creating network \"orleansdocker_default\" with the default driver Creating orleansdocker_orleans-silo_1 ... Creating orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-client_1 ... Creating orleansdocker_orleans-client_1 ... done # ç°åœ¨å¦‚æœä½ è¿è¡Œ Dockeræ’°å†™PS ï¼Œæ‚¨å°†çœ‹åˆ°2ä¸ªå®¹å™¨æ­£åœ¨è¿è¡Œ Orleansé“å…‹ é¡¹ç›®ï¼š # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up Windowsç”¨æˆ·æ³¨æ„äº‹é¡¹ ï¼šå¦‚æœæ‚¨åœ¨Windowsä¸Šï¼Œå¹¶ä¸”å®¹å™¨ä½¿ç”¨Windowsæ˜ åƒä½œä¸ºåŸºç¡€ï¼Œåˆ™ å‘½ä»¤ åˆ—å°†æ˜¾ç¤ºpowershellç›¸å¯¹äº å°¾ åœ¨*nixç³»ç»Ÿä¸Šï¼Œè¿™æ ·å®¹å™¨å°†ä¿æŒç›¸åŒçš„æ–¹å¼ã€‚ æ—¢ç„¶ä½ å·²ç»å‡†å¤‡å¥½äº†å®¹å™¨ï¼Œä½ ä¸éœ€è¦æ¯æ¬¡å¯åŠ¨Orleansåº”ç”¨ç¨‹åºæ—¶éƒ½åœæ­¢å®ƒã€‚æ‚¨åªéœ€è¦é›†æˆæ‚¨çš„ideæ¥è°ƒè¯•ä»¥å‰æ˜ å°„åˆ°æ‚¨çš„ docker-compose.ymlæ–‡ä»¶ æ˜¯çš„ã€‚ ç¼©æ”¾æ¯”ä¾‹ è¿è¡Œcomposeé¡¹ç›®åï¼Œå¯ä»¥ä½¿ç”¨ Dockeråˆæˆæ¯”ä¾‹ å‘½ä»¤ï¼š # docker-compose scale orleans-silo=15 Starting orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-silo_2 ... Creating orleansdocker_orleans-silo_3 ... Creating orleansdocker_orleans-silo_4 ... Creating orleansdocker_orleans-silo_5 ... Creating orleansdocker_orleans-silo_6 ... Creating orleansdocker_orleans-silo_7 ... Creating orleansdocker_orleans-silo_8 ... Creating orleansdocker_orleans-silo_9 ... Creating orleansdocker_orleans-silo_10 ... Creating orleansdocker_orleans-silo_11 ... Creating orleansdocker_orleans-silo_12 ... Creating orleansdocker_orleans-silo_13 ... Creating orleansdocker_orleans-silo_14 ... Creating orleansdocker_orleans-silo_15 ... Creating orleansdocker_orleans-silo_6 Creating orleansdocker_orleans-silo_5 Creating orleansdocker_orleans-silo_3 Creating orleansdocker_orleans-silo_2 Creating orleansdocker_orleans-silo_4 Creating orleansdocker_orleans-silo_9 Creating orleansdocker_orleans-silo_7 Creating orleansdocker_orleans-silo_8 Creating orleansdocker_orleans-silo_10 Creating orleansdocker_orleans-silo_11 Creating orleansdocker_orleans-silo_15 Creating orleansdocker_orleans-silo_12 Creating orleansdocker_orleans-silo_14 Creating orleansdocker_orleans-silo_13 å‡ ç§’é’Ÿåï¼Œæ‚¨å°†çœ‹åˆ°æœåŠ¡æ‰©å±•åˆ°æ‚¨è¯·æ±‚çš„ç‰¹å®šå®ä¾‹æ•°ã€‚ # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up orleansdocker_orleans-silo_10 tail -f /dev/null Up orleansdocker_orleans-silo_11 tail -f /dev/null Up orleansdocker_orleans-silo_12 tail -f /dev/null Up orleansdocker_orleans-silo_13 tail -f /dev/null Up orleansdocker_orleans-silo_14 tail -f /dev/null Up orleansdocker_orleans-silo_15 tail -f /dev/null Up orleansdocker_orleans-silo_2 tail -f /dev/null Up orleansdocker_orleans-silo_3 tail -f /dev/null Up orleansdocker_orleans-silo_4 tail -f /dev/null Up orleansdocker_orleans-silo_5 tail -f /dev/null Up orleansdocker_orleans-silo_6 tail -f /dev/null Up orleansdocker_orleans-silo_7 tail -f /dev/null Up orleansdocker_orleans-silo_8 tail -f /dev/null Up orleansdocker_orleans-silo_9 tail -f /dev/null Up æ³¨æ„ ï¼šçš„ å‘½ä»¤ å…³äºè¿™äº›ä¾‹å­çš„ä¸“æ æ˜¾ç¤ºäº† å°¾ å‘½ä»¤ï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨è°ƒè¯•å™¨å®¹å™¨ã€‚å¦‚æœæˆ‘ä»¬åœ¨åˆ¶ä½œçš„è¯ dotnet OrleansSilo.dll ä¾‹å¦‚ã€‚ ç å¤´ç¾¤ Dockeré›†ç¾¤å †æ ˆè¢«è°ƒç”¨ èœ‚ç¾¤ ä½ å¯ä»¥é€šè¿‡é˜…è¯»å®ƒæ‰¾åˆ°æ›´å¤š æ­¤å¤„ä¸ºæ–‡æ¡£ æ˜¯çš„ã€‚ åœ¨ èœ‚ç¾¤ ç¾¤é›†ï¼Œä½ æ²¡æœ‰ä»»ä½•é¢å¤–çš„å·¥ä½œã€‚å½“ä½ è·‘çš„æ—¶å€™ Dockerç»„åˆ-D åœ¨ä¸€ä¸ª èœ‚ç¾¤ èŠ‚ç‚¹ï¼Œå®ƒå°†æ ¹æ®é…ç½®çš„è§„åˆ™è°ƒåº¦å®¹å™¨ã€‚è¿™åŒæ ·é€‚ç”¨äºå…¶ä»–åŸºäºswarmçš„æœåŠ¡ï¼Œå¦‚ Dockeræ•°æ®ä¸­å¿ƒ ï¼Œ å¤©é’ACS (åœ¨ç¾¤æ¨¡å¼ä¸‹) AWS ECSé›†è£…ç®±æœåŠ¡ ç­‰ç­‰ã€‚ä½ è¦åšçš„å°±æ˜¯éƒ¨ç½²ä½ çš„ èœ‚ç¾¤ åœ¨éƒ¨ç½²ä¹‹å‰ç¾¤é›† åœé  Orleansç”³è¯·ã€‚ æ³¨æ„ ï¼šå¦‚æœæ‚¨ä½¿ç”¨çš„Dockerå¼•æ“å…·æœ‰Swarmæ¨¡å¼ï¼Œå¹¶ä¸”å·²ç»æ”¯æŒ å †æ ˆ ï¼Œ éƒ¨ç½² å’Œ ç»„æˆ v3ï¼Œéƒ¨ç½²è§£å†³æ–¹æ¡ˆçš„æ›´å¥½æ–¹æ³•æ˜¯ docker stack deploy-c docker-compose.yml<name> . è¯·è®°ä½ï¼Œå®ƒéœ€è¦åœ¨Dockerå¼•æ“ä¸Šæä¾›V3ç»„åˆæ–‡ä»¶æ”¯æŒï¼Œè€Œå¤§å¤šæ•°æ‰˜ç®¡æœåŠ¡(å¦‚Azureå’ŒAWS)ä»ç„¶ä½¿ç”¨V2å’Œæ›´æ—§çš„å¼•æ“ã€‚ è°·æ­ŒKubernetes(K8S) å¦‚æœä½ æ‰“ç®—ä½¿ç”¨ åº“ä¼¯å†…ç‰¹æ–¯ è¦æ‰˜ç®¡Orleansï¼Œå¯ä»¥åœ¨ OrleansContrib\\Orleans.Clustering.Kubernetes åœ¨é‚£é‡Œï¼Œæ‚¨å¯ä»¥æ‰¾åˆ°å…³äºå¦‚ä½•ä½¿ç”¨æä¾›è€…æ— ç¼åœ°åœ¨Kubernetesæ‰˜ç®¡Orleansçš„æ–‡æ¡£å’Œç¤ºä¾‹ã€‚ [å¥–åŠ±ä¸»é¢˜]åœ¨å®¹å™¨ä¸­è°ƒè¯•Orleans å¥½å§ï¼Œæ—¢ç„¶ä½ çŸ¥é“å¦‚ä½•ä»å¤´å¼€å§‹åœ¨ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡ŒOrleansï¼Œé‚£ä¹ˆåˆ©ç”¨Dockerä¸­æœ€é‡è¦çš„åŸåˆ™ä¹‹ä¸€å°±å¾ˆå¥½äº†ã€‚å®¹å™¨æ˜¯ä¸å¯å˜çš„ã€‚è€Œä¸”å®ƒä»¬åœ¨å¼€å‘ä¸­åº”è¯¥(å‡ ä¹)å…·æœ‰ä¸ç”Ÿäº§ä¸­ç›¸åŒçš„æ˜ åƒã€ä¾èµ–é¡¹å’Œè¿è¡Œæ—¶ã€‚è¿™ç¡®ä¿äº†è‰¯å¥½çš„æ—§å£°æ˜ â€œå®ƒåœ¨æˆ‘çš„æœºå™¨ä¸Šå·¥ä½œï¼â€ å†ä¹Ÿä¸ä¼šå‘ç”Ÿäº†ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½ éœ€è¦æœ‰ä¸€ç§å‘å±•çš„æ–¹å¼ é‡Œé¢ å®¹å™¨å’Œå…¶ä¸­åŒ…å«ä¸€ä¸ªè°ƒè¯•å™¨ï¼Œè¯¥è°ƒè¯•å™¨é™„åŠ åˆ°å®¹å™¨å†…çš„åº”ç”¨ç¨‹åºã€‚ æœ‰å¤šç§æ–¹æ³•å¯ä»¥ä½¿ç”¨å¤šç§å·¥å…·å®ç°è¿™ä¸€ç‚¹ã€‚åœ¨è¯„ä¼°äº†å‡ ä¸ªä¹‹åï¼Œåœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œæˆ‘æœ€ç»ˆé€‰æ‹©äº†ä¸€ä¸ªçœ‹èµ·æ¥æ›´ç®€å•ã€åœ¨åº”ç”¨ç¨‹åºä¸­ä¾µå…¥æ€§æ›´å°çš„ã€‚ æ­£å¦‚æœ¬æ–‡å‰é¢æåˆ°çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨ ç”šå°ç  ä¸ºäº†å¼€å‘è¿™ä¸ªç¤ºä¾‹ï¼Œä¸‹é¢æ˜¯å¦‚ä½•å°†è°ƒè¯•å™¨é™„åŠ åˆ°å®¹å™¨ä¸­çš„orleansåº”ç”¨ç¨‹åºã€‚ é¦–å…ˆï¼Œåœ¨ä½ çš„ .vscodeä»£ç  è§£å†³æ–¹æ¡ˆä¸­çš„ç›®å½•ï¼š tasks.jsonä»»åŠ¡ ä»¥ä¸‹å†…å®¹ï¼š { \"version\": \"0.1.0\", \"command\": \"dotnet\", \"isShellCommand\": true, \"args\": [], \"tasks\": [ { \"taskName\": \"publish\", \"args\": [ \"${workspaceRoot}/Orleans-Docker.sln\", \"-c\", \"Debug\", \"-o\", \"./bin/PublishOutput\" ], \"isBuildCommand\": true, \"problemMatcher\": \"$msCompile\" } ] } è¿™ä¸ªæ–‡ä»¶å®é™…ä¸Šå‘Šè¯‰ ç”šå°ç  æ— è®ºä½•æ—¶æ„å»ºé¡¹ç›®ï¼Œå®ƒéƒ½å°†å®é™…æ‰§è¡Œ å‡ºç‰ˆ å‘½ä»¤ï¼Œå°±åƒæˆ‘ä»¬ä¹‹å‰æ‰‹åŠ¨æ‰§è¡Œçš„é‚£æ ·ã€‚ launch.jsonå¯åŠ¨ ä»¥ä¸‹å†…å®¹ï¼š { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Silo\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansSilo.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansSilo\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-silo_1 /vsdbg/vsdbg --interpreter=vscode\" ] } }, { \"name\": \"Client\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansClient.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansClient\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-client_1 /vsdbg/vsdbg --interpreter=vscode\" ] } } ] } ç°åœ¨ä½ å¯ä»¥ä» ç”šå°ç  (å°†å‘å¸ƒ)å¹¶å¯åŠ¨siloså’Œå®¢æˆ·ç«¯ã€‚å®ƒå°†å‘é€ä¸€ä¸ª Dockeræ‰§è¡Œå®˜ è¿è¡Œå‘½ä»¤ Dockeråˆæˆ æœåŠ¡å®ä¾‹/å®¹å™¨æ¥å¯åŠ¨åº”ç”¨ç¨‹åºçš„è°ƒè¯•å™¨ã€‚å°†è°ƒè¯•å™¨é™„åŠ åˆ°å®¹å™¨ï¼Œå¹¶å°†å…¶ç”¨ä½œæœ¬åœ°è¿è¡Œçš„Orleansåº”ç”¨ç¨‹åºã€‚ç°åœ¨çš„åŒºåˆ«æ˜¯å®ƒåœ¨å®¹å™¨ä¸­ï¼Œå®Œæˆåï¼Œåªéœ€å°†å®¹å™¨å‘å¸ƒåˆ°æ³¨å†Œè¡¨å¹¶åœ¨ç”Ÿäº§ä¸­çš„Dockerä¸»æœºä¸Šæ‹‰å–å®ƒã€‚"
  },
  "Documentation/deployment/service_fabric_hosting.html": {
    "href": "Documentation/deployment/service_fabric_hosting.html",
    "title": "Service Fabric Hosting | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æœåŠ¡ç»“æ„å®¿ä¸» Orleanså¯ä»¥ä½¿ç”¨ Microsoft.Orleans.hosting.ServiceFabric åŒ…è£¹ã€‚silosåº”è¯¥ä½œä¸ºæœªåˆ†åŒºçš„æ— çŠ¶æ€æœåŠ¡æ‰˜ç®¡ï¼Œå› ä¸ºOrleansä½¿ç”¨ç»†Grainçš„åŠ¨æ€åˆ†å¸ƒæ¥ç®¡ç†Grainsæœ¬èº«çš„åˆ†å¸ƒã€‚å…¶ä»–æ‰˜ç®¡é€‰é¡¹(åˆ†åŒºçš„ã€æœ‰çŠ¶æ€çš„)å½“å‰æœªç»æµ‹è¯•ä¸”ä¸å—æ”¯æŒã€‚ ä¸€ä¸ªæ¼”ç¤ºåœ¨æœåŠ¡ç»“æ„ä¸Šæ‰˜ç®¡çš„ç¤ºä¾‹ä½äº ç¤ºä¾‹/2.0/ServiceFabric æ˜¯çš„ã€‚ æ‰˜ç®¡æ”¯æŒåœ¨ Microsoft.Orleans.hosting.ServiceFabric åŒ…è£¹ã€‚å®ƒå…è®¸Orleanssilosä½œä¸ºæœåŠ¡ç»“æ„è¿è¡Œ å›¾åƒé€šä¿¡ä¾¦å¬å™¨ æ˜¯çš„ã€‚silosç”Ÿå‘½å‘¨æœŸéµå¾ªå…¸å‹çš„é€šä¿¡ä¾¦å¬å™¨ç”Ÿå‘½å‘¨æœŸï¼šå®ƒé€šè¿‡ ICommunicationListener.OpenAsync æ–¹æ³•ï¼Œå¹¶é€šè¿‡ ICommunicationListener.CloseAsync æ–¹æ³•æˆ–é€šè¿‡ ICommunicationä¾¦å¬å™¨ã€‚ä¸­æ­¢ æ–¹æ³•ã€‚ OrleansCommunicationä¾¦å¬å™¨ æä¾› å›¾åƒé€šä¿¡ä¾¦å¬å™¨ å®æ–½ã€‚æ¨èçš„æ–¹æ³•æ˜¯ä½¿ç”¨ orleansServiceListener.createStateless(æ“ä½œ<statelessServiceContextï¼ŒisiloHostBuilder>configure) åœ¨ Orleans.Hosting.ServiceFabric å‘½åç©ºé—´ã€‚ æ¯æ¬¡æ‰“å¼€é€šä¿¡ä¾¦å¬å™¨æ—¶ï¼Œ é…ç½® å§”æ‰˜ä¼ é€’ç»™ åˆ›å»ºæ— çŠ¶æ€ è°ƒç”¨ä»¥é…ç½®æ–°silosã€‚ ç¤ºä¾‹ï¼šé…ç½®æœåŠ¡ç»“æ„å®¿ä¸» ä¸‹é¢çš„ç¤ºä¾‹æ¼”ç¤ºäº†ä¸€ä¸ªæœåŠ¡ç»“æ„ æ— çŠ¶æ€æœåŠ¡ ç±»ï¼Œè¯¥ç±»æ‰˜ç®¡Orleanssilosã€‚å®Œæ•´çš„æ ·æœ¬å¯ä»¥åœ¨ ç¤ºä¾‹/2.0/ServiceFabric Orleansä»“åº“çš„ç›®å½•ã€‚ /// <summary> /// An instance of this class is created for each service instance by the Service Fabric runtime. /// </summary> internal sealed class StatelessCalculatorService : StatelessService { public StatelessCalculatorService(StatelessServiceContext context) : base(context) { } /// <summary> /// Optional override to create listeners (e.g., TCP, HTTP) for this service replica to handle /// client or user requests. /// </summary> /// <returns>A collection of listeners.</returns> protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners() { // Listeners can be opened and closed multiple times over the lifetime of a service instance. // A new Orleans silo will be both created and initialized each time the listener is opened // and will be shutdown when the listener is closed. var listener = OrleansServiceListener.CreateStateless( (fabricServiceContext, builder) => { builder.Configure<ClusterOptions>(options => { // The service id is unique for the entire service over its lifetime. This is // used to identify persistent state such as reminders and grain state. options.ServiceId = fabricServiceContext.ServiceName.ToString(); // The cluster id identifies a deployed cluster. Since Service Fabric uses rolling // upgrades, the cluster id can be kept constant. This is used to identify which // silos belong to a particular cluster. options.ClusterId = \"development\"; }); // Configure clustering. Other clustering providers are available, but for the purpose // of this sample we will use Azure Storage. // TODO: Pick a clustering provider and configure it here. builder.UseAzureStorageClustering( options => options.ConnectionString = \"UseDevelopmentStorage=true\"); // Optional: configure logging. builder.ConfigureLogging(logging => logging.AddDebug()); builder.AddStartupTask<StartupTask>(); // Service Fabric manages port allocations, so update the configuration using those // ports. // Gather configuration from Service Fabric. var activation = fabricServiceContext.CodePackageActivationContext; var endpoints = activation.GetEndpoints(); // These endpoint names correspond to TCP endpoints specified in ServiceManifest.xml var siloEndpoint = endpoints[\"OrleansSiloEndpoint\"]; var gatewayEndpoint = endpoints[\"OrleansProxyEndpoint\"]; var hostname = fabricServiceContext.NodeContext.IPAddressOrFQDN; builder.ConfigureEndpoints(hostname, siloEndpoint.Port, gatewayEndpoint.Port); // Add your application assemblies. builder.ConfigureApplicationParts(parts => { parts.AddApplicationPart(typeof(CalculatorGrain).Assembly).WithReferences(); // Alternative: add all loadable assemblies in the current base path // (see AppDomain.BaseDirectory). parts.AddFromApplicationBaseDirectory(); }); }); return new[] { listener }; } /// <summary> /// This is the main entry point for your service instance. /// </summary> /// <param name=\"cancellationToken\"> /// Canceled when Service Fabric needs to shut down this service instance. /// </param> protected override async Task RunAsync(CancellationToken cancellationToken) { while (true) { cancellationToken.ThrowIfCancellationRequested(); await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken); } } }"
  },
  "Documentation/deployment/troubleshooting_deployments.html": {
    "href": "Documentation/deployment/troubleshooting_deployments.html",
    "title": "æ’é™¤éƒ¨ç½²æ•…éšœ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "éƒ¨ç½²ç–‘éš¾è§£ç­” æ­¤é¡µé¢æä¾›äº†ä¸€äº›å¸¸è§„æŒ‡å—ï¼Œç”¨äºè§£å†³éƒ¨ç½²åˆ°azureäº‘æœåŠ¡æ—¶å‡ºç°çš„ä»»ä½•é—®é¢˜ã€‚è¿™äº›éƒ½æ˜¯éå¸¸å¸¸è§çš„é—®é¢˜éœ€è¦æ³¨æ„ã€‚ä¸€å®šè¦æ£€æŸ¥æ—¥å¿—ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚ è·å–silounavailableexception é¦–å…ˆï¼Œåœ¨å°è¯•åˆå§‹åŒ–å®¢æˆ·ç«¯ä¹‹å‰ï¼Œè¯·æ£€æŸ¥ä»¥ç¡®ä¿å®é™…å¯åŠ¨äº†silosã€‚æœ‰æ—¶ï¼Œsiloséœ€è¦å¾ˆé•¿æ—¶é—´æ‰èƒ½å¯åŠ¨ï¼Œå› æ­¤å°è¯•å¤šæ¬¡åˆå§‹åŒ–å®¢æˆ·ç«¯æ˜¯æœ‰ç›Šçš„ã€‚å¦‚æœå®ƒä»ç„¶æŠ›å‡ºå¼‚å¸¸ï¼Œé‚£ä¹ˆsiloså¯èƒ½è¿˜æœ‰å¦ä¸€ä¸ªé—®é¢˜ã€‚ æ£€æŸ¥silosé…ç½®å¹¶ç¡®ä¿silosæ­£ç¡®å¯åŠ¨ã€‚ å¸¸è§çš„è¿æ¥å­—ç¬¦ä¸²é—®é¢˜ åœ¨éƒ¨ç½²åˆ°azureæ—¶ä½¿ç”¨æœ¬åœ°è¿æ¥å­—ç¬¦ä¸²-ç½‘ç«™å°†æ— æ³•è¿æ¥ ä¸ºsiloså’Œå‰ç«¯(webå’Œworkerè§’è‰²)ä½¿ç”¨ä¸åŒçš„è¿æ¥å­—ç¬¦ä¸²-ç½‘ç«™å°†æ— æ³•åˆå§‹åŒ–å®¢æˆ·ç«¯ï¼Œå› ä¸ºå®ƒæ— æ³•è¿æ¥åˆ°silos å¯ä»¥åœ¨azureé—¨æˆ·ä¸­æ£€æŸ¥è¿æ¥å­—ç¬¦ä¸²é…ç½®ã€‚å¦‚æœè¿æ¥å­—ç¬¦ä¸²è®¾ç½®ä¸æ­£ç¡®ï¼Œæ—¥å¿—å¯èƒ½æ— æ³•æ­£ç¡®æ˜¾ç¤ºã€‚ ä¸æ­£ç¡®åœ°ä¿®æ”¹é…ç½®æ–‡ä»¶ è¯·ç¡®ä¿åœ¨serviceDefinition.csdefæ–‡ä»¶ä¸­é…ç½®äº†æ­£ç¡®çš„ç»ˆç»“ç‚¹ï¼Œå¦åˆ™éƒ¨ç½²å°†æ— æ³•å·¥ä½œã€‚å®ƒå°†ç»™å‡ºé”™è¯¯ï¼Œè¯´æ˜å®ƒæ— æ³•è·å–ç«¯ç‚¹ä¿¡æ¯ã€‚ ä¸¢å¤±çš„æ—¥å¿— ç¡®ä¿è¿æ¥å­—ç¬¦ä¸²è®¾ç½®æ­£ç¡®ã€‚ å¾ˆå¯èƒ½Webè§’è‰²ä¸­çš„web.configæ–‡ä»¶æˆ–å·¥ä½œè§’è‰²ä¸­çš„app.configæ–‡ä»¶ä¿®æ”¹ä¸æ­£ç¡®ã€‚è¿™äº›æ–‡ä»¶ä¸­çš„ä¸æ­£ç¡®ç‰ˆæœ¬å¯èƒ½å¯¼è‡´éƒ¨ç½²é—®é¢˜ã€‚å¤„ç†æ›´æ–°æ—¶è¦å°å¿ƒã€‚ ç‰ˆæœ¬é—®é¢˜ ç¡®ä¿è§£å†³æ–¹æ¡ˆä¸­çš„æ¯ä¸ªé¡¹ç›®éƒ½ä½¿ç”¨ç›¸åŒç‰ˆæœ¬çš„Orleansã€‚ä¸è¿™æ ·åšä¼šå¯¼è‡´å·¥äººè§’è‰²çš„å›æ”¶ã€‚æŸ¥çœ‹æ—¥å¿—ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚visual studioåœ¨éƒ¨ç½²å†å²è®°å½•ä¸­æä¾›äº†ä¸€äº›siloså¯åŠ¨é”™è¯¯æ¶ˆæ¯ã€‚ è§’è‰²ä¸æ–­å¾ªç¯ æ£€æŸ¥æ‰€æœ‰é€‚å½“çš„Orleansç»„ä»¶æ˜¯å¦åœ¨è§£å†³æ–¹æ¡ˆä¸­ï¼Œå¹¶ä¸” å¤åˆ¶æœ¬åœ° è®¾ç½®ä¸º çœŸçš„ . æ£€æŸ¥æ—¥å¿—ä»¥æŸ¥çœ‹åˆå§‹åŒ–æ—¶æ˜¯å¦å­˜åœ¨æœªå¤„ç†çš„å¼‚å¸¸ã€‚ ç¡®ä¿è¿æ¥å­—ç¬¦ä¸²æ­£ç¡®ã€‚ æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹azureäº‘æœåŠ¡ç–‘éš¾è§£ç­”é¡µé¢ã€‚ å¦‚ä½•æ£€æŸ¥æ—¥å¿— ä½¿ç”¨visual studioä¸­çš„äº‘èµ„æºç®¡ç†å™¨å¯¼èˆªåˆ°å­˜å‚¨å¸æˆ·ä¸­ç›¸åº”çš„å­˜å‚¨è¡¨æˆ–blobã€‚ Wadlogstableæ˜¯æŸ¥çœ‹æ—¥å¿—çš„è‰¯å¥½èµ·ç‚¹ã€‚ æ‚¨å¯èƒ½åªè®°å½•äº†é”™è¯¯ã€‚å¦‚æœè¿˜éœ€è¦ä¿¡æ¯æ—¥å¿—ï¼Œåˆ™éœ€è¦ä¿®æ”¹é…ç½®ä»¥è®¾ç½®æ—¥å¿—ä¸¥é‡æ€§çº§åˆ«ã€‚ ç¼–ç¨‹é…ç½®ï¼š å½“åˆ›å»º ç¾¤é›†é…ç½® å¯¹è±¡ï¼Œè®¾ç½® config.defaults.defaulttracelevel=ä¸¥é‡æ€§ã€‚ä¿¡æ¯ æ˜¯çš„ã€‚ å½“åˆ›å»º å®¢æˆ·ç«¯é…ç½® å¯¹è±¡ï¼Œè®¾ç½® config.defaulttracelevel=ä¸¥é‡æ€§ã€‚ä¿¡æ¯ æ˜¯çš„ã€‚ å£°æ˜æ€§é…ç½®ï¼š æ·»åŠ  <tracing defaulttracelevel=â€œinfoâ€/> è‡´ orleansconfiguration.xmlæ–‡ä»¶ å’Œ/æˆ– å®¢æˆ·ç«¯é…ç½®.xml æ–‡ä»¶å¤¹ã€‚ åœ¨ è¯Šæ–­.wadcfgx æ–‡ä»¶ä¸­çš„webå’Œworkerè§’è‰²ï¼Œè¯·ç¡®ä¿è®¾ç½® scheduledTransferLogLevelFilter ä¸­çš„å±æ€§ åŸæœ¨ å…ƒç´ åˆ° é—®è¯¢å¤„ ï¼Œå› ä¸ºè¿™æ˜¯è·Ÿè¸ªç­›é€‰çš„é™„åŠ å±‚ï¼Œå®ƒå®šä¹‰å°†å“ªäº›è·Ÿè¸ªå‘é€åˆ° ç“¦å¾·æ´›æ–¯æ³°å¸ƒå°” åœ¨azureå­˜å‚¨ä¸­ã€‚ ä½ å¯ä»¥åœ¨ é…ç½®æŒ‡å— æ˜¯çš„ã€‚ ä¸asp.netçš„å…¼å®¹æ€§ åŒ…å«åœ¨asp.netä¸­çš„razorè§†å›¾å¼•æ“ä½¿ç”¨ä¸orleansç›¸åŒçš„ä»£ç ç”Ÿæˆç¨‹åºé›†( Microsoft.codeåˆ†æ å’Œ å¾®è½¯ä»£ç åˆ†æ.csharp )ä¸­ã€‚è¿™å¯èƒ½ä¼šåœ¨è¿è¡Œæ—¶å‡ºç°ç‰ˆæœ¬å…¼å®¹æ€§é—®é¢˜ã€‚ è‹¥è¦è§£å†³æ­¤é—®é¢˜ï¼Œè¯·å°è¯•å‡çº§ Microsoft.codedom.providers.dotnetCompilerPlatform (è¿™æ˜¯ASP.NETç”¨äºåŒ…å«ä¸Šè¿°ç¨‹åºé›†çš„NuGetåŒ…)åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œå¹¶è®¾ç½®ç»‘å®šé‡å®šå‘ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis.CSharp\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly> <dependentAssembly> <assemblyIdentity name=\"Microsoft.CodeAnalysis\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"0.0.0.0-2.0.0.0\" newVersion=\"1.3.1.0\" /> </dependentAssembly>"
  },
  "Documentation/deployment/handling_failures.html": {
    "href": "Documentation/deployment/handling_failures.html",
    "title": "Handling Failures | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤„ç†æ•…éšœ æ³¨ï¼š æœ¬æ–‡ä»¶ä¸­æä¾›çš„ä»¥ä¸‹æ‰€æœ‰æŒ‡å¯¼éƒ½æ˜¯ä½œä¸ºç¤ºä¾‹å’Œæ€è€ƒçš„é£Ÿç²®ã€‚æ‚¨ä¸åº”è¯¥å°†å®ƒä»¬è§†ä¸ºè§£å†³é—®é¢˜çš„è§„èŒƒæ€§è§£å†³æ–¹æ¡ˆï¼Œå› ä¸ºæ•…éšœå¤„ç†æ˜¯ä¸€ä¸ªç›¸å½“ç‰¹å®šäºåº”ç”¨ç¨‹åºçš„ä¸»é¢˜ã€‚è¿™äº›æ¨¡å¼å’Œå…¶ä»–æ¨¡å¼åªæœ‰åœ¨å……åˆ†äº†è§£æ­£åœ¨å¤„ç†çš„å…·ä½“æ¡ˆä¾‹çš„æƒ…å†µä¸‹æ‰æœ‰ç”¨ã€‚ åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿç¼–ç¨‹ä¸­ï¼Œæœ€å›°éš¾çš„æ˜¯å¤„ç†æ•…éšœã€‚actoræ¨¡å‹åŠå…¶å·¥ä½œæ–¹å¼ä½¿å¤„ç†ä¸åŒç±»å‹çš„æ•…éšœå˜å¾—æ›´åŠ å®¹æ˜“ï¼Œä½†æ˜¯ä½œä¸ºå¼€å‘äººå‘˜ï¼Œæ‚¨è´Ÿè´£å¤„ç†æ•…éšœå¯èƒ½æ€§å¹¶ä»¥é€‚å½“çš„æ–¹å¼å¤„ç†å®ƒä»¬ã€‚ æ•…éšœç±»å‹ å½“ä½ åœ¨ç¼–ç ä½ çš„Grainsï¼Œæ‰€æœ‰çš„è°ƒç”¨éƒ½æ˜¯å¼‚æ­¥çš„ï¼Œæœ‰å¯èƒ½é€šè¿‡ç½‘ç»œã€‚ç”±äºä»¥ä¸‹åŸå› ä¹‹ä¸€ï¼Œæ¯ä¸ªGrainsè°ƒç”¨éƒ½å¯èƒ½å¤±è´¥ã€‚ Grainsæ˜¯åœ¨silosä¸Šæ¿€æ´»çš„ï¼Œç”±äºç½‘ç»œåˆ†åŒºå´©æºƒæˆ–å…¶ä»–åŸå› ï¼Œsilosç›®å‰ä¸å¯ç”¨ã€‚å¦‚æœsiloså°šæœªå£°æ˜ä¸ºå·²æ­»äº¡ï¼Œåˆ™æ‚¨çš„è¯·æ±‚å¯èƒ½ä¼šè¶…æ—¶ã€‚ grainæ–¹æ³•è°ƒç”¨å¯ä»¥æŠ›å‡ºå¼‚å¸¸ï¼Œè¡¨ç¤ºå®ƒå¤±è´¥ï¼Œæ— æ³•ç»§ç»­å…¶å·¥ä½œã€‚ ç²’å­çš„æ¿€æ´»ä¸å­˜åœ¨ï¼Œä¸èƒ½åˆ›å»ºï¼Œå› ä¸º OnActivateAsync æ–¹æ³•å¼•å‘å¼‚å¸¸æˆ–è¢«æ­»é”ã€‚ ç½‘ç»œæ•…éšœä¸å…è®¸æ‚¨åœ¨è¶…æ—¶å‰ä¸grainé€šä¿¡ã€‚ å…¶ä»–æ½œåœ¨åŸå›  æ•…éšœæ£€æµ‹ è·å–å¯¹Grainsçš„å¼•ç”¨æ€»æ˜¯æˆåŠŸçš„ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªæœ¬åœ°æ“ä½œã€‚ç„¶è€Œï¼Œæ–¹æ³•è°ƒç”¨å¯èƒ½ä¼šå¤±è´¥ï¼Œå½“å®ƒä»¬å¤±è´¥æ—¶ï¼Œæ‚¨ä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸ã€‚æ‚¨å¯ä»¥åœ¨éœ€è¦çš„ä»»ä½•çº§åˆ«æ•è·å¼‚å¸¸ï¼Œå®ƒä»¬ç”šè‡³å¯ä»¥è·¨ç«–äº•ä¼ æ’­ã€‚ ä»å¤±è´¥ä¸­æ¢å¤ åœ¨Orleansï¼Œæ¢å¤å·¥ä½œçš„ä¸€éƒ¨åˆ†æ˜¯è‡ªåŠ¨çš„ï¼Œå¦‚æœä¸€ä¸ªgrainä¸å†å¯è®¿é—®ï¼ŒOrleanså°†åœ¨ä¸‹ä¸€ä¸ªæ–¹æ³•è°ƒç”¨ä¸­é‡æ–°æ¿€æ´»å®ƒã€‚éœ€è¦å¤„ç†å¹¶ç¡®ä¿åœ¨åº”ç”¨ç¨‹åºä¸Šä¸‹æ–‡ä¸­æ­£ç¡®æ— è¯¯çš„æ˜¯çŠ¶æ€ã€‚ä¸€ä¸ªGrainsçš„çŠ¶æ€å¯ä»¥éƒ¨åˆ†æ›´æ–°ï¼Œæˆ–è€…æ“ä½œå¯èƒ½æ˜¯ä¸€äº›åº”è¯¥è·¨å¤šä¸ªGrainsæ‰§è¡Œçš„éƒ¨åˆ†æ“ä½œã€‚ å½“ä½ çœ‹åˆ°ä¸€ä¸ªGrainsæ“ä½œå¤±è´¥åï¼Œä½ å¯ä»¥åšä»¥ä¸‹ä¸€ä¸ªæˆ–å¤šä¸ªæ“ä½œã€‚ åªéœ€é‡è¯•æ‚¨çš„æ“ä½œï¼Œç‰¹åˆ«æ˜¯å¦‚æœå®ƒä¸æ¶‰åŠä»»ä½•çŠ¶æ€æ›´æ”¹ï¼Œè¿™å¯èƒ½æ˜¯åŠä¸ªå®Œæˆã€‚è¿™æ˜¯ç›®å‰ä¸ºæ­¢æœ€å…¸å‹çš„æ¡ˆä¾‹ã€‚ å°è¯•é€šè¿‡è°ƒç”¨ä¸€ä¸ªæ–¹æ³•æ¥ä¿®å¤/é‡ç½®éƒ¨åˆ†æ›´æ”¹çš„çŠ¶æ€ï¼Œè¯¥æ–¹æ³•å°†çŠ¶æ€é‡ç½®ä¸ºæœ€åä¸€ä¸ªå·²çŸ¥çš„æ­£ç¡®çŠ¶æ€ï¼Œæˆ–è€…é€šè¿‡è°ƒç”¨ è¯»çŠ¶æ€å¼‚æ­¥ æ˜¯çš„ã€‚ é‡ç½®æ‰€æœ‰ç›¸å…³æ¿€æ´»çš„çŠ¶æ€ï¼Œä»¥ç¡®ä¿æ‰€æœ‰æ¿€æ´»éƒ½å¤„äºå¹²å‡€çŠ¶æ€ã€‚ ä½¿ç”¨ è¿‡ç¨‹ç»ç† æˆ–æ•°æ®åº“äº‹åŠ¡ï¼Œä»¥ç¡®ä¿å®Œå…¨å®Œæˆæˆ–ä¸åšä»»ä½•æ›´æ”¹ä»¥é¿å…éƒ¨åˆ†æ›´æ–°çŠ¶æ€ã€‚ æ ¹æ®åº”ç”¨ç¨‹åºçš„ä¸åŒï¼Œé‡è¯•é€»è¾‘å¯èƒ½éµå¾ªç®€å•æˆ–å¤æ‚çš„æ¨¡å¼ï¼Œæ‚¨å¯èƒ½éœ€è¦æ‰§è¡Œå…¶ä»–æ“ä½œï¼Œå¦‚é€šçŸ¥å¤–éƒ¨ç³»ç»Ÿå’Œå…¶ä»–æ“ä½œï¼Œä½†é€šå¸¸ï¼Œæ‚¨è¦ä¹ˆå¿…é¡»é‡è¯•æ“ä½œï¼Œé‡æ–°å¯åŠ¨æ‰€æ¶‰åŠçš„Grain/Grainï¼Œè¦ä¹ˆåœæ­¢å“åº”ï¼Œç›´åˆ°ä¸å¯ç”¨çš„å†…å®¹å˜ä¸ºå¯ç”¨ã€‚ å¦‚æœæ‚¨æœ‰ä¸€ä¸ªè´Ÿè´£æ•°æ®åº“ä¿å­˜çš„grainï¼Œè€Œæ•°æ®åº“ä¸å¯ç”¨ï¼Œé‚£ä¹ˆæ‚¨åªéœ€ä½¿ä»»ä½•è¯·æ±‚å¤±è´¥ï¼Œç›´åˆ°æ•°æ®åº“é‡æ–°è”æœºã€‚å¦‚æœå¯ä»¥æ ¹æ®ç”¨æˆ·çš„æ„æ„¿é‡è¯•æ‚¨çš„æ“ä½œï¼Œä¾‹å¦‚åœ¨æ³¨é‡Šgrainsä¸­ä¿å­˜æ³¨é‡Šå¤±è´¥ï¼Œåˆ™å¯ä»¥åœ¨ç”¨æˆ·æŒ‰ä¸‹é‡è¯•æŒ‰é’®æ—¶é‡è¯•(ç›´åˆ°è¾¾åˆ°ä¸€å®šæ¬¡æ•°ï¼Œä»¥é¿å…ç½‘ç»œé¥±å’Œ)ã€‚å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹çš„å…·ä½“ç»†èŠ‚å–å†³äºåº”ç”¨ç¨‹åºï¼Œä½†å¯èƒ½çš„ç­–ç•¥æ˜¯ç›¸åŒçš„ã€‚ ç­–ç•¥å‚æ•°ä¸ç­–ç•¥é€‰æ‹© å¦‚ä¸Šä¸€èŠ‚æ‰€è¿°ï¼Œæ‚¨é€‰æ‹©çš„ç­–ç•¥å–å†³äºåº”ç”¨ç¨‹åºå’Œä¸Šä¸‹æ–‡ã€‚ç­–ç•¥é€šå¸¸å…·æœ‰å¿…é¡»åœ¨åº”ç”¨ç¨‹åºçº§åˆ«å†³å®šçš„å‚æ•°ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–è¿›ç¨‹ä¾èµ–äºä¸€ä¸ªåŠ¨ä½œï¼Œé‚£ä¹ˆæ‚¨å¯èƒ½å†³å®šé‡è¯•è¯¥åŠ¨ä½œæœ€å¤šæ¯åˆ†é’Ÿ5æ¬¡ï¼Œç›´åˆ°å®ƒæœ€ç»ˆå®Œæˆä¸ºæ­¢ã€‚ä½†åœ¨å¤„ç†æ¥è‡ªè¯¥ç”¨æˆ·çš„ä»»ä½•å…¶ä»–è¯·æ±‚ä¹‹å‰ï¼Œå¿…é¡»å…ˆå¤„ç†è¯¥ç”¨æˆ·çš„ç™»å½•Grainè¯·æ±‚ã€‚å¦‚æœç™»å½•æ“ä½œä¸èµ·ä½œç”¨ï¼Œåˆ™æ— æ³•ç»§ç»­ã€‚ æœ‰ä¸ªå‘å¯¼ åœ¨azureæ–‡æ¡£ä¸­ å…³äºäº‘çš„è‰¯å¥½æ¨¡å¼å’Œå®è·µï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä¹Ÿé€‚ç”¨äºOrleansã€‚ ä¸€ä¸ªç›¸å½“å¤æ‚çš„ä¾‹å­ å› ä¸ºåœ¨OrleansGrainsæ˜¯è‡ªåŠ¨æ¿€æ´»å’Œåœç”¨çš„ï¼Œä½ ä¸èƒ½å¤„ç†å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸï¼Œä½ é€šå¸¸åªå¤„ç†ç¡®ä¿GrainsçŠ¶æ€æ˜¯æ­£ç¡®çš„ï¼Œè¡ŒåŠ¨æ˜¯æ­£ç¡®çš„å¼€å§‹å’Œç»“æŸç›¸äº’å…³ç³»ã€‚äº†è§£grainså’Œå®ƒä»¬æ‰§è¡Œçš„åŠ¨ä½œä¹‹é—´çš„ä¾èµ–å…³ç³»æ˜¯ç†è§£å¦‚ä½•åœ¨ä»»ä½•å¤æ‚ç³»ç»Ÿä¸­å¤„ç†æ•…éšœçš„é‡è¦ä¸€æ­¥ã€‚å¦‚æœä½ éœ€è¦å‚¨å­˜Grainsä¹‹é—´çš„å…³ç³»ï¼Œä½ å¯ä»¥ç®€å•åœ°è¿™æ ·åšï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå¹¿æ³›éµå¾ªçš„åšæ³•ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª æ¸¸æˆç®¡ç†å™¨ èµ·æ­¢ç²® æ¸¸æˆ Grainså’Œæ·»åŠ å‰‚ ç©å®¶ å»çœ‹æ¯”èµ›ã€‚å¦‚æœæˆ‘çš„ æ¸¸æˆç®¡ç†å™¨ Grainsæ²¡æœ‰åšå®ƒå…³äºå¼€å§‹ä¸€ä¸ªæ¸¸æˆçš„åŠ¨ä½œï¼Œå±äºå®ƒçš„ç›¸å…³æ¸¸æˆåº”è¯¥æ²¡æœ‰åšå®ƒçš„ å¼€å§‹() ç»ç†ä¹Ÿå¯ä»¥é€šè¿‡ç¼–æ’æ¥å®Œæˆè¿™é¡¹å·¥ä½œã€‚åœ¨Orleansç®¡ç†å†…å­˜æ˜¯è‡ªåŠ¨çš„ï¼Œç³»ç»Ÿä¼šå¤„ç†å®ƒï¼Œä½ åªéœ€è¦ç¡®ä¿æ¸¸æˆå¼€å§‹ï¼Œå¹¶ä¸”åªæœ‰å½“ç»ç†èƒ½åšåˆ° å¼€å§‹() ä¹Ÿã€‚æ‚¨å¯ä»¥é€šè¿‡ä»¥é¡ºåºæ–¹å¼è°ƒç”¨ç›¸å…³çš„æ–¹æ³•ï¼Œæˆ–è€…é€šè¿‡å¹¶è¡Œæ‰§è¡Œè¿™äº›æ–¹æ³•ï¼Œå¹¶åœ¨å…¶ä¸­ä»»ä½•ä¸€ä¸ªæ–¹æ³•å¤±è´¥æ—¶é‡ç½®æ‰€æœ‰ç›¸å…³grainsçš„çŠ¶æ€æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ å¦‚æœå…¶ä¸­ä¸€ä¸ªæ¸¸æˆæ”¶åˆ°ä¸€ä¸ªè°ƒç”¨ï¼Œå®ƒå°†è‡ªåŠ¨é‡æ–°æ¿€æ´»ï¼Œå› æ­¤ï¼Œå¦‚æœæ‚¨éœ€è¦ç®¡ç†è€…ç®¡ç†æ¸¸æˆGrainsï¼Œé‚£ä¹ˆæ‰€æœ‰ä¸ç®¡ç†ç›¸å…³çš„å¯¹æ¸¸æˆçš„è°ƒç”¨éƒ½åº”è¯¥é€šè¿‡ æ¸¸æˆç®¡ç†å™¨ æ˜¯çš„ã€‚å¦‚æœä½ éœ€è¦åœ¨Grainsä¹‹é—´è¿›è¡Œé…å™¨ï¼ŒOrleansä¸ä¼šä¸ºä½ â€œè‡ªåŠ¨â€è§£å†³ï¼Œä½ éœ€è¦åšä½ çš„é…å™¨ã€‚ä½†äº‹å®ä¸Šï¼Œä½ æ²¡æœ‰å¤„ç†åˆ›å»º/é”€æ¯Grainsçš„é—®é¢˜ï¼Œè¿™æ„å‘³ç€ä½ ä¸éœ€è¦æ‹…å¿ƒèµ„æºç®¡ç†ã€‚ä½ ä¸éœ€è¦å›ç­”è¿™äº›é—®é¢˜ï¼š æˆ‘åº”è¯¥åœ¨å“ªé‡Œåˆ›å»ºæˆ‘çš„ç›‘ç£æ ‘ï¼Ÿ æˆ‘åº”è¯¥æ³¨å†Œå“ªäº›Grainsæ‰èƒ½æŒ‰åç§°å¯»å€ï¼Ÿ è°·ç²’xè¿˜æ´»ç€æ‰€ä»¥æˆ‘å¯ä»¥ç»™å®ƒå‘ä¸ªä¿¡æ¯å—ï¼Ÿ â€¦ æ‰€ä»¥ï¼Œæ¸¸æˆå¼€å§‹çš„ä¾‹å­å¯ä»¥æ€»ç»“å¦‚ä¸‹ï¼š æ¸¸æˆç®¡ç†å™¨ é—® æ¸¸æˆ å¼€å§‹çš„Grains æ¸¸æˆ GrainsåŠ ä¸Š ç©å®¶ Grainsè‡ªèº« æ¸¸æˆ é—® ç©å®¶ ä¸ºè‡ªå·±æ·»åŠ æ¸¸æˆçš„Grains æ¸¸æˆ å°†å…¶çŠ¶æ€è®¾ç½®ä¸ºå¯åŠ¨ã€‚ æ¸¸æˆç®¡ç†å™¨ å°†æ¸¸æˆæ·»åŠ åˆ°å…¶æ¸¸æˆåˆ—è¡¨ä¸­ã€‚ ç°åœ¨ï¼Œå¦‚æœä¸€ä¸ªç©å®¶æœªèƒ½å°†æ¸¸æˆæ·»åŠ åˆ°è‡ªèº«ä¸­ï¼Œåˆ™ä¸éœ€è¦æ€æ­»æ‰€æœ‰ç©å®¶å’Œæ¸¸æˆå¹¶é‡æ–°å¼€å§‹ã€‚æ‚¨åªéœ€é‡ç½®å°†æ¸¸æˆæ·»åŠ åˆ°è‡ªå·±çš„å…¶ä»–ç©å®¶çš„çŠ¶æ€ï¼Œé‡ç½® æ¸¸æˆ å’Œ æ¸¸æˆç®¡ç†å™¨ (å¦‚æœéœ€è¦çš„è¯)ï¼Œé‡åšä½ çš„å·¥ä½œæˆ–å®£å¸ƒå¤±è´¥ã€‚å¦‚æœæ‚¨å¯ä»¥åœ¨ä»¥åå°†æ¸¸æˆæ·»åŠ åˆ°ç©å®¶ä¸­ï¼Œåˆ™å¯ä»¥åœ¨æé†’æˆ–å…¶ä»–æ¸¸æˆè®¿é—®(å¦‚ å®Œæˆ() æ¸¸æˆæ–¹æ³•ã€‚"
  },
  "Documentation/deployment/consul_deployment.html": {
    "href": "Documentation/deployment/consul_deployment.html",
    "title": "Using Consul as a Membership Provider | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä½¿ç”¨consulä½œä¸ºæˆå‘˜èµ„æ ¼æä¾›ç¨‹åº é¢†äº‹ä»‹ç» é¢†äº‹ æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼ã€é«˜å¯ç”¨å’Œæ•°æ®ä¸­å¿ƒæ„ŸçŸ¥çš„æœåŠ¡å‘ç°å¹³å°ï¼ŒåŒ…æ‹¬ç®€å•çš„æœåŠ¡æ³¨å†Œã€è¿è¡ŒçŠ¶å†µæ£€æŸ¥ã€æ•…éšœæ£€æµ‹å’Œå¯†é’¥/å€¼å­˜å‚¨ã€‚å®ƒæ˜¯åœ¨æ•°æ®ä¸­å¿ƒçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¿è¡Œä¸€ä¸ªconsuä»£ç†çš„å‰æä¸‹æ„å»ºçš„ï¼Œconsunä»£ç†å¯ä»¥å……å½“æœåŠ¡å™¨ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºå®¢æˆ·ç«¯ï¼Œé€šè¿‡ä¸€ä¸ªå¯ä¼¸ç¼©çš„å…«å¦åè®®è¿›è¡Œé€šä¿¡ã€‚ consulæœ‰ä¸€ä¸ªéå¸¸è¯¦ç»†çš„æ¦‚è¿°ï¼ŒåŒ…æ‹¬ä¸ç±»ä¼¼è§£å†³æ–¹æ¡ˆçš„æ¯”è¾ƒ åœ¨è¿™é‡Œ æ˜¯çš„ã€‚ æ‰§æ”¿å®˜å†™çš„æ˜¯go å¼€æº ï¼›ç¼–è¯‘çš„ä¸‹è½½å¯ç”¨äº Mac OS Xã€FreeBSDã€Linuxã€solariså’ŒWindows ä¸ºä»€ä¹ˆé€‰æ‹©é¢†äº‹ï¼Ÿ ä½œä¸º Orleansä¼šå‘˜æœåŠ¡å•† ï¼Œå½“æ‚¨éœ€è¦æä¾› å†…éƒ¨è§£å†³æ–¹æ¡ˆ è¿™å¹¶ä¸è¦æ±‚æ½œåœ¨å®¢æˆ·æ‹¥æœ‰ç°æœ‰çš„åŸºç¡€è®¾æ–½ã€‚ å’Œ ä¸€å®¶åˆä½œçš„itæä¾›å•†ã€‚consulæ˜¯ä¸€ä¸ªéå¸¸è½»é‡çº§çš„å•ä¸€å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ²¡æœ‰ä¾èµ–å…³ç³»ï¼Œå› æ­¤å¯ä»¥å¾ˆå®¹æ˜“åœ°æ„å»ºåˆ°æ‚¨è‡ªå·±çš„ä¸­é—´ä»¶è§£å†³æ–¹æ¡ˆä¸­ã€‚å½“consulå·²ç»æ˜¯æ‚¨å‘ç°ã€æ£€æŸ¥å’Œç»´æŠ¤å¾®æœåŠ¡çš„è§£å†³æ–¹æ¡ˆæ—¶ï¼Œå®Œå…¨é›†æˆorleansæˆå‘˜å…³ç³»ä»¥ç®€åŒ–æ“ä½œæ˜¯æœ‰æ„ä¹‰çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨consul(ä¹Ÿç§°ä¸ºâ€œorleans custom system storeâ€)ä¸­å®ç°äº†ä¸€ä¸ªæˆå‘˜è¡¨ï¼Œå®ƒä¸orleansçš„ ç¾¤é›†ç®¡ç† æ˜¯çš„ã€‚ è®¾ç«‹é¢†äº‹ æœ‰å¾ˆå¤šå…³äº IOé¢†äº‹ å…³äºå»ºç«‹ä¸€ä¸ªç¨³å®šçš„é¢†äº‹é›†ç¾¤ï¼Œåœ¨è¿™é‡Œé‡å¤æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼›ä½†æ˜¯ä¸ºäº†æ‚¨çš„æ–¹ä¾¿ï¼Œæˆ‘ä»¬æä¾›äº†è¿™ä¸ªæŒ‡å—ï¼Œè¿™æ ·æ‚¨å¯ä»¥å¾ˆå¿«è®©Orleansè¿è¡Œä¸€ä¸ªç‹¬ç«‹çš„é¢†äº‹ä»£ç†ã€‚ 1)åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥å°†consulå®‰è£…åˆ°å…¶ä¸­ï¼Œä¾‹å¦‚c:\\ consul 2)åˆ›å»ºå­æ–‡ä»¶å¤¹ï¼šC:\\Cuxel\\Data(å¦‚æœä¸å­˜åœ¨ï¼ŒCuxlå°†ä¸åˆ›å»ºæ­¤æ–‡ä»¶) ä¸‰) ä¸‹è½½ å¹¶å°†consul.exeè§£å‹åˆ°c:\\ consul\\ 4)åœ¨C:\\ consulæ‰“å¼€å‘½ä»¤æç¤ºç¬¦\\ 5)è¿›å…¥ consun.exeä»£ç†-æœåŠ¡å™¨-å¼•å¯¼-æ•°æ®ç›®å½•â€œC:\\ consun\\dataâ€-å®¢æˆ·ç«¯=0.0.0.0 ä»£ç†äºº æŒ‡ç¤ºconsulè¿è¡Œæ‰˜ç®¡æœåŠ¡çš„ä»£ç†è¿›ç¨‹ã€‚å¦‚æœä¸è¿™æ ·åšï¼Œconsulè¿›ç¨‹å°†å°è¯•ä½¿ç”¨rpcæ¥é…ç½®æ­£åœ¨è¿è¡Œçš„ä»£ç†ã€‚ -æœåŠ¡å™¨ å°†ä»£ç†å®šä¹‰ä¸ºæœåŠ¡å™¨è€Œä¸æ˜¯å®¢æˆ·ç«¯(consul å®¢æˆ· æ˜¯æ‰˜ç®¡æ‰€æœ‰æœåŠ¡å’Œæ•°æ®çš„ä»£ç†ï¼Œä½†æ²¡æœ‰æŠ•ç¥¨æƒæ¥å†³å®šï¼Œå¹¶ä¸”ä¸èƒ½æˆä¸ºç¾¤é›†çš„é¢†å¯¼è€… -è‡ªä¸¾ ç¬¬ä¸€ä¸ª(è€Œä¸”åªæœ‰ç¬¬ä¸€ä¸ªï¼)å¿…é¡»å¼•å¯¼ç¾¤é›†ä¸­çš„èŠ‚ç‚¹ï¼Œä½¿å…¶æ‰¿æ‹…ç¾¤é›†é¢†å¯¼åœ°ä½ã€‚ -æ•°æ®ç›®å½•[è·¯å¾„] æŒ‡å®šå­˜å‚¨æ‰€æœ‰consunæ•°æ®çš„è·¯å¾„ï¼ŒåŒ…æ‹¬cluster membershipè¡¨ -å®¢æˆ·ç«¯=0.0.0.0 é€šçŸ¥é¢†äº‹åœ¨å“ªä¸ªIPä¸Šæ‰“å¼€æœåŠ¡ã€‚ è¿˜æœ‰è®¸å¤šå…¶ä»–å‚æ•°ï¼Œä»¥åŠä½¿ç”¨jsoné…ç½®æ–‡ä»¶çš„é€‰é¡¹ã€‚æœ‰å…³é€‰é¡¹çš„å®Œæ•´åˆ—è¡¨ï¼Œè¯·å‚é˜…consulæ–‡æ¡£ã€‚ 6)é€šè¿‡æ‰“å¼€ æœåŠ¡ æµè§ˆå™¨ä¸­çš„ç»ˆç»“ç‚¹ã€‚ Orleansçš„ç»“æ„ æœåŠ¡å™¨ â€œè‡ªå®šä¹‰â€æˆå‘˜èµ„æ ¼æä¾›ç¨‹åºorleansconfiguration.xmlé…ç½®æ–‡ä»¶å½“å‰å­˜åœ¨ä¸€ä¸ªå·²çŸ¥é—®é¢˜ï¼Œæ— æ³•æ­£ç¡®è§£æè¯¥æ–‡ä»¶ã€‚å› æ­¤ï¼Œåœ¨å¯åŠ¨silosä¹‹å‰ï¼Œå¿…é¡»åœ¨XMLä¸­æä¾›ä¸€ä¸ªå ä½ç¬¦SystemStoreï¼Œç„¶ååœ¨ä»£ç ä¸­é…ç½®æä¾›ç¨‹åºã€‚ orleansconfiguration.xmlæ–‡ä»¶ <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"None\" DataConnectionString=\"http://localhost:8500\" DeploymentId=\"MyOrleansDeployment\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"22222\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> ä»£ç  public void Start(ClusterConfiguration config) { _siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); _siloHost.Config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.Custom; _siloHost.Config.Globals.MembershipTableAssembly = \"OrleansConsulUtils\"; _siloHost.Config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.Disabled; _siloHost.InitializeOrleansSilo(); var startedok = _siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", _siloHost.Name, _siloHost.Type)); Log.Information(\"Orleans Silo is running.\\n\"); } æˆ–è€…ï¼Œæ‚¨å¯ä»¥å®Œå…¨ç”¨ä»£ç é…ç½®silosã€‚ é¡¾å®¢ å®¢æˆ·ç«¯é…ç½®è¦ç®€å•å¾—å¤š å®¢æˆ·ç«¯é…ç½®.xml <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"Custom\" CustomGatewayProviderAssemblyName=\"OrleansConsulUtils\" DataConnectionString=\"http://192.168.1.26:8500\" DeploymentId=\"MyOrleansDeployment\" /> </ClientConfiguration> å®¢æˆ·ç«¯sdk å¦‚æœæ‚¨æœ‰å…´è¶£ä½¿ç”¨é¢†äº‹é¦†ä¸ºæ‚¨è‡ªå·±çš„æœåŠ¡å‘ç°æœ‰ å®¢æˆ·SDK æœ€æµè¡Œçš„è¯­è¨€ã€‚ å®æ–½ç»†èŠ‚ æˆå‘˜èµ„æ ¼è¡¨æä¾›ç¨‹åºä½¿ç”¨ é¢†äº‹é’¥åŒ™/ä»·å€¼å•†åº— casçš„åŠŸèƒ½ã€‚å½“æ¯ä¸ªsiloså¯åŠ¨æ—¶ï¼Œå®ƒä¼šæ³¨å†Œä¸¤ä¸ªKVæ¡ç›®ï¼Œä¸€ä¸ªåŒ…å«silosçš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦ä¸€ä¸ªä¿å­˜silosä¸Šæ¬¡æŠ¥å‘Šå®ƒå¤„äºæ´»åŠ¨çŠ¶æ€æ—¶çš„ä¿¡æ¯(åè€…æ˜¯æŒ‡è¯Šæ–­â€œI am aliveâ€æ¡ç›®ï¼Œè€Œä¸æ˜¯æŒ‡ç›´æ¥åœ¨silosä¹‹é—´å‘é€ä¸”æœªå†™å…¥è¡¨ä¸­çš„æ•…éšœæ£€æµ‹Hearbeats)ã€‚æ ¹æ®orleansçš„éœ€è¦ï¼Œå¯¹è¡¨çš„æ‰€æœ‰å†™æ“ä½œéƒ½ç”±casæ‰§è¡Œï¼Œä»¥æä¾›å¹¶å‘æ§åˆ¶ã€‚ ç¾¤é›†ç®¡ç†åè®® æ˜¯çš„ã€‚silosè¿è¡Œåï¼Œæ‚¨å¯ä»¥åœ¨Webæµè§ˆå™¨ä¸­æŸ¥çœ‹è¿™äº›æ¡ç›® åœ¨è¿™é‡Œ ï¼Œå°†æ˜¾ç¤ºå¦‚ä¸‹å†…å®¹ï¼š [ \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753\", \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753/iamalive\" ] æ‚¨ä¼šæ³¨æ„åˆ°è¿™äº›é”®çš„å‰ç¼€æ˜¯ â€œOrleans/â€ è¿™æ˜¯åœ¨æä¾›è€…ä¸­ç¡¬ç¼–ç çš„ï¼Œæ—¨åœ¨é¿å…ä¸consulçš„å…¶ä»–ç”¨æˆ·å‘ç”Ÿå¯†é’¥ç©ºé—´å†²çªã€‚æ¯ä¸ªé”®éƒ½å¯ä»¥é€šè¿‡é™„åŠ å®ƒä»¬çš„é”®åæ¥è¯»å– (å½“ç„¶æ²¡æœ‰å¼•ç”¨) è‡´ é¢†äº‹KVæ ¹ æ˜¯çš„ã€‚è¿™æ ·åšå°†ä¸ºæ‚¨æä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š [ { \"LockIndex\": 0, \"Key\": \"orleans/MyOrleansDeployment/192.168.1.26:22222@191780753\", \"Flags\": 0, \"Value\": \"[BASE64 UTF8 Encoded String]\", \"CreateIndex\": 10, \"ModifyIndex\": 12 } ] è§£ç å­—ç¬¦ä¸²å°†æä¾›å®é™…çš„Orleansæˆå‘˜èµ„æ ¼æ•°æ®ï¼š http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress ] { \"Hostname\": \"[YOUR_MACHINE_NAME]\", \"ProxyPort\": 22222, \"StartTime\": \"2016-01-29T16:25:54.9538838Z\", \"Status\": 3, \"SuspectingSilos\": [] } http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress]/IAmAlive \"2016-01-29T16:35:58.9193803Z\" å½“å®¢æˆ·ç«¯è¿æ¥æ—¶ï¼Œä»–ä»¬é€šè¿‡ä½¿ç”¨uriåœ¨ä¸€ä¸ªhttp getä¸­è¯»å–é›†ç¾¤ä¸­æ‰€æœ‰silosçš„kvs http://192.168.1.26:8500/v1/kv/orleans/myorleansdeployment/ï¼Ÿé€’å½’ æ˜¯çš„ã€‚ é™åˆ¶ Orleansæ‰©å±•æˆå‘˜åè®®(è¡¨ç‰ˆæœ¬å’ŒETag) consul kv currentlyç›®å‰ä¸æ”¯æŒåŸå­æ›´æ–°ã€‚å› æ­¤ï¼Œorleans consulæˆå‘˜èµ„æ ¼æä¾›è€…åªå®ç°äº†orleansåŸºæœ¬æˆå‘˜èµ„æ ¼åè®®ï¼Œå¦‚å‰æ‰€è¿° åœ¨è¿™é‡Œ ä¸æ”¯æŒæ‰©å±•æˆå‘˜èº«ä»½åè®®ã€‚è¿™ä¸ªæ‰©å±•çš„åè®®è¢«å¼•å…¥ä½œä¸ºä¸€ä¸ªé¢å¤–çš„ï¼Œä½†ä¸æ˜¯å¿…éœ€çš„ï¼Œsilosè¿é€šæ€§éªŒè¯å’Œä½œä¸ºå°šæœªå®ç°çš„åŠŸèƒ½çš„åŸºç¡€ã€‚å¦‚æœæ‚¨çš„åŸºç¡€è®¾æ–½é…ç½®æ­£ç¡®ï¼Œæ‚¨å°†ä¸ä¼šå› ç¼ºä¹æ”¯æŒè€Œå—åˆ°ä»»ä½•ä¸åˆ©å½±å“ã€‚ å¤šä¸ªæ•°æ®ä¸­å¿ƒ consunä¸­çš„é”®å€¼å¯¹å½“å‰æœªåœ¨consunæ•°æ®ä¸­å¿ƒä¹‹é—´å¤åˆ¶ã€‚æœ‰ä¸€ä¸ª å•ç‹¬é¡¹ç›® ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†å®ƒè¿˜æ²¡æœ‰è¢«è¯æ˜æ”¯æŒOrleansã€‚ åœ¨Windowsä¸Šè¿è¡Œæ—¶ å½“consulåœ¨windowsä¸Šå¯åŠ¨æ—¶ï¼Œå®ƒä¼šè®°å½•ä»¥ä¸‹æ¶ˆæ¯ï¼š ==> WARNING: Windows is not recommended as a Consul server. Do not use in production. è¿™ä»…ä»…æ˜¯å› ä¸ºåœ¨windowsç¯å¢ƒä¸­è¿è¡Œæ—¶ç¼ºä¹å¯¹æµ‹è¯•çš„å…³æ³¨ï¼Œè€Œä¸æ˜¯å› ä¸ºä»»ä½•å®é™…çš„å·²çŸ¥é—®é¢˜ã€‚é˜…è¯» æ­¤å¤„è®¨è®º åœ¨å†³å®šé¢†äº‹æ˜¯å¦é€‚åˆä½ ä¹‹å‰ã€‚ æœªæ¥çš„æ½œåœ¨å¢å¼º 1)è¯æ˜consun-kvå¤åˆ¶é¡¹ç›®èƒ½å¤Ÿåœ¨å¤šä¸ªconsunæ•°æ®ä¸­å¿ƒä¹‹é—´çš„å¹¿åŸŸç½‘ç¯å¢ƒä¸­æ”¯æŒä¸€ä¸ªorleansé›†ç¾¤ã€‚ 2)åœ¨é¢†äº‹é¦†æ‰§è¡Œæé†’è¡¨ã€‚ 3)å®ç°æ‰©å±•æˆå‘˜åè®®ã€‚consulèƒŒåçš„å›¢é˜Ÿç¡®å®è®¡åˆ’å®ç°åŸå­æ“ä½œï¼Œä¸€æ—¦æ­¤åŠŸèƒ½å¯ç”¨ï¼Œå°±å¯ä»¥æ¶ˆé™¤æä¾›è€…ä¸­çš„é™åˆ¶ã€‚"
  },
  "Documentation/index.html": {
    "href": "Documentation/index.html",
    "title": "Introduction | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæ˜¯ä¸€ä¸ªç”¨äºæ„å»ºå¥å£®ã€å¯ä¼¸ç¼©çš„åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„è·¨å¹³å°æ¡†æ¶ Orleanså»ºç«‹åœ¨.NETå¼€å‘äººå‘˜ç”Ÿäº§åŠ›çš„åŸºç¡€ä¸Šï¼Œå¹¶å°†å…¶å¸¦å…¥äº†åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„ä¸–ç•Œï¼Œä¾‹å¦‚äº‘æœåŠ¡ã€‚ Orleanså¯ä»å•ä¸ªæœ¬åœ°æœåŠ¡å™¨æ‰©å±•åˆ°äº‘ä¸­å…¨å±€åˆ†å¸ƒçš„é«˜å¯ç”¨æ€§åº”ç”¨ç¨‹åºã€‚ Orleansé‡‡ç”¨äº†å¯¹è±¡ï¼Œæ¥å£ï¼Œasync/awaitå’Œtry/catchç­‰ç†Ÿæ‚‰çš„æ¦‚å¿µï¼Œå¹¶å°†å…¶æ‰©å±•åˆ°å¤šæœåŠ¡å™¨ç¯å¢ƒã€‚è¿™æ ·ï¼Œå®ƒå¯ä»¥å¸®åŠ©å…·æœ‰å•æœåŠ¡å™¨åº”ç”¨ç¨‹åºç»éªŒçš„å¼€å‘äººå‘˜è¿‡æ¸¡åˆ°æ„å»ºå¼¹æ€§ï¼Œå¯æ‰©å±•çš„äº‘æœåŠ¡å’Œå…¶ä»–åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºã€‚å› æ­¤ï¼ŒOrleansé€šå¸¸è¢«ç§°ä¸ºâ€œåˆ†å¸ƒå¼.NETâ€ã€‚ å®ƒæ˜¯ç”± Microsoft Research åˆ›å»ºçš„ï¼Œå¹¶ä»‹ç»äº† Virtual Actor Model ä½œä¸ºä¸€ç§æ–°æ–¹æ³•æ¥æ„å»ºé¢å‘äº‘æ—¶ä»£çš„æ–°ä¸€ä»£åˆ†å¸ƒå¼ç³»ç»Ÿã€‚ Orleansçš„æ ¸å¿ƒè´¡çŒ®æ˜¯å®ƒçš„ç¼–ç¨‹æ¨¡å‹ï¼Œå®ƒåœ¨ä¸é™åˆ¶åŠŸèƒ½ï¼Œä»¥åŠå¯¹å¼€å‘äººå‘˜æ–½åŠ ç¹é‡çº¦æŸçš„æƒ…å†µä¸‹ï¼Œé™ä½äº†é«˜å¹¶å‘åˆ†å¸ƒå¼ç³»ç»Ÿå›ºæœ‰çš„å¤æ‚æ€§ã€‚ Grains ä»»ä½•Orleansåº”ç”¨ç¨‹åºçš„åŸºæœ¬æ„å»ºå—éƒ½æ˜¯ grain . grainsæ˜¯ç”±ç”¨æˆ·å®šä¹‰çš„èº«ä»½ã€è¡Œä¸ºå’ŒçŠ¶æ€ç»„æˆçš„å®ä½“ã€‚grainsæ ‡è¯†æ˜¯ç”¨æˆ·å®šä¹‰çš„é”®ï¼Œä½¿grainså§‹ç»ˆå¯ä¾›è°ƒç”¨ã€‚Grainså¯ä»¥é€šè¿‡å¼ºç±»å‹é€šä¿¡æ¥å£(contract)è¢«å…¶ä»–Grainsæˆ–Webå‰ç«¯ç­‰å¤–éƒ¨å®¢æˆ·ç«¯è°ƒç”¨ã€‚æ¯ä¸ªgrainséƒ½æ˜¯å®ç°ä¸€ä¸ªæˆ–å¤šä¸ªè¿™äº›æ¥å£çš„ç±»çš„ä¸€ä¸ªå®ä¾‹ã€‚ Grainså¯ä»¥å…·æœ‰æŒ¥å‘æ€§å’Œ/æˆ–æŒä¹…åŒ–çŠ¶æ€ï¼Œå¯ä»¥å­˜å‚¨åœ¨ä»»ä½•å­˜å‚¨ç³»ç»Ÿä¸­ã€‚å› æ­¤ï¼Œgrainséšå¼åœ°åˆ’åˆ†åº”ç”¨ç¨‹åºçŠ¶æ€ï¼Œä»è€Œå®ç°è‡ªåŠ¨å¯ä¼¸ç¼©æ€§å¹¶ç®€åŒ–æ•…éšœæ¢å¤ã€‚å½“Grainå¤„äºæ´»åŠ¨çŠ¶æ€æ—¶ï¼ŒGrainçŠ¶æ€è¢«ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œä»è€Œé™ä½äº†å»¶è¿Ÿå’Œæ•°æ®å­˜å‚¨çš„è´Ÿè½½ã€‚ grainsçš„å®ä¾‹åŒ–ç”±Orleansè¿è¡Œæ—¶æ ¹æ®éœ€è¦è‡ªåŠ¨æ‰§è¡Œã€‚æš‚æ—¶ä¸ä½¿ç”¨çš„grainsä¼šè‡ªåŠ¨ä»å†…å­˜ä¸­åˆ é™¤ä»¥é‡Šæ”¾èµ„æºã€‚è¿™æ˜¯æœ‰å¯èƒ½çš„ï¼Œå› ä¸ºå®ƒä»¬å…·æœ‰ç¨³å®šçš„èº«ä»½ï¼Œå…è®¸è°ƒç”¨grainsï¼Œä¸ç®¡å®ƒä»¬æ˜¯å¦å·²ç»åŠ è½½åˆ°å†…å­˜ä¸­ã€‚è¿™è¿˜å…è®¸é€æ˜åœ°ä»å¤±è´¥ä¸­æ¢å¤ï¼Œå› ä¸ºè°ƒç”¨æ–¹ä¸éœ€è¦çŸ¥é“åœ¨ä»»ä½•æ—¶é—´ç‚¹åœ¨å“ªä¸ªæœåŠ¡å™¨ä¸Šå®ä¾‹åŒ–äº†ä¸€ä¸ªgrainã€‚Grainsæœ‰ä¸€ä¸ªå—ç®¡ç†çš„ç”Ÿå‘½å‘¨æœŸï¼ŒOrleansè¿è¡Œæ—¶è´Ÿè´£æ¿€æ´»/åœç”¨Grainsï¼Œå¹¶æ ¹æ®éœ€è¦å­˜å‚¨/å®šä½Grainsã€‚è¿™å…è®¸å¼€å‘äººå‘˜ç¼–å†™ä»£ç ï¼Œå°±å¥½åƒæ‰€æœ‰çš„grainsæ€»æ˜¯åœ¨å†…å­˜ä¸­ä¸€æ ·ã€‚ æ€»çš„æ¥è¯´ï¼Œç¨³å®šçš„æ ‡è¯†ã€æœ‰çŠ¶æ€æ€§å’Œå¯ç®¡ç†çš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ„å»ºåœ¨Orleansä¹‹ä¸Šçš„ç³»ç»Ÿå¯ä¼¸ç¼©ã€é«˜æ€§èƒ½çš„æ ¸å¿ƒå› ç´ ï¼Œ&å¯é ï¼Œä¸å¿…å¼ºè¿«å¼€å‘äººå‘˜ç¼–å†™å¤æ‚çš„åˆ†å¸ƒå¼ç³»ç»Ÿä»£ç ã€‚ ç¤ºä¾‹ï¼šç‰©è”ç½‘äº‘åç«¯ è€ƒè™‘ä¸€ä¸ªäº‘åç«¯ ç‰©è”ç½‘ ç³»ç»Ÿã€‚æ­¤åº”ç”¨ç¨‹åºéœ€è¦å¤„ç†ä¼ å…¥çš„è®¾å¤‡æ•°æ®ã€ç­›é€‰ã€èšåˆå’Œå¤„ç†è¿™äº›ä¿¡æ¯ï¼Œå¹¶å…è®¸å‘è®¾å¤‡å‘é€å‘½ä»¤ã€‚åœ¨Orleansï¼Œäººä»¬å¾ˆè‡ªç„¶åœ°ç”¨ä¸€ç§Grainsæ¥æ¨¡æ‹Ÿæ¯ä¸€ç§è®¾å¤‡ï¼Œè¿™ç§Grainså˜æˆäº† æ•°ç åŒèƒèƒ å®ƒæ‰€å¯¹åº”çš„ç‰©ç†è®¾å¤‡ã€‚è¿™äº›grainså°†æœ€æ–°çš„è®¾å¤‡æ•°æ®ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥å¿«é€Ÿåœ°æŸ¥è¯¢å’Œå¤„ç†å®ƒä»¬ï¼Œè€Œä¸éœ€è¦ç›´æ¥ä¸ç‰©ç†è®¾å¤‡é€šä¿¡ã€‚é€šè¿‡è§‚å¯Ÿæ¥è‡ªè®¾å¤‡çš„æ—¶é—´åºåˆ—æ•°æ®æµï¼Œgrainså¯ä»¥æ£€æµ‹æ¡ä»¶çš„å˜åŒ–ï¼Œä¾‹å¦‚æµ‹é‡å€¼è¶…è¿‡é˜ˆå€¼ï¼Œå¹¶è§¦å‘ä¸€ä¸ªåŠ¨ä½œã€‚ ä¸€ä¸ªç®€å•çš„æ’æ¸©å™¨å¯ä»¥å»ºæ¨¡å¦‚ä¸‹ï¼š public interface IThermostat : IGrainWithStringKey { Task<List<Command>> OnUpdate(ThermostatStatus update); } ä»Webå‰ç«¯ä»æ’æ¸©å™¨åˆ°è¾¾çš„äº‹ä»¶å¯ä»¥é€šè¿‡è°ƒç”¨ OnUpdate æ–¹æ³•ï¼Œå®ƒå¯ä»¥é€‰æ‹©å°†å‘½ä»¤è¿”å›ç»™è®¾å¤‡ã€‚ var thermostat = client.GetGrain<IThermostat>(id); return await thermostat.OnUpdate(update); ç›¸åŒçš„æ’æ¸©å™¨grainså¯å®ç°å•ç‹¬çš„æ¥å£ï¼Œä»¥ä¾¿æ§åˆ¶ç³»ç»Ÿä¸ï¼š public interface IThermostatControl : IGrainWithStringKey { Task<ThermostatStatus> GetStatus(); Task UpdateConfiguration(ThermostatConfiguration config); } è¿™ä¸¤ä¸ªæ¥å£( IThermostat å’Œ IThermostatControl )ç”±å•ä¸ªå®ç°ç±»å®ç°ï¼š public class ThermostatGrain : Grain, IThermostat, IThermostatControl { private ThermostatStatus _status; private List<Command> _commands; public Task<List<Command>> OnUpdate(ThermostatStatus status) { _status = status; var result = _commands; _commands = new List<Command>(); return Task.FromResult(result); } public Task<ThermostatStatus> GetStatus() => Task.FromResult(_status); public Task UpdateConfiguration(ThermostatConfiguration config) { _commands.Add(new ConfigUpdateCommand(config)); return Task.CompletedTask; } } ä¸Šé¢çš„Grainsç±»ä¸ä¼šä¿æŒå…¶çŠ¶æ€ã€‚ æ–‡æ¡£ ä¸­æä¾›äº†æ¼”ç¤ºçŠ¶æ€æŒä¹…åŒ–çš„æ›´å½»åº•çš„ç¤ºä¾‹ã€‚ Orleansè¿è¡Œæ—¶ Orleansè¿è¡Œæ—¶ä¸ºåº”ç”¨ç¨‹åºè¿è¡Œæ—¶çš„ä¸»è¦ç»„ä»¶æ˜¯ silos ï¼Œè´Ÿè´£å¯„å­˜Grainsã€‚é€šå¸¸ï¼Œä¸€ç»„silosä½œä¸ºé›†ç¾¤è¿è¡Œï¼Œä»¥å®ç°å¯ä¼¸ç¼©æ€§å’Œå®¹é”™æ€§ã€‚å½“ä½œä¸ºé›†ç¾¤è¿è¡Œæ—¶ï¼Œsilosç›¸äº’åè°ƒä»¥åˆ†é…å·¥ä½œã€æ£€æµ‹å¹¶ä»æ•…éšœä¸­æ¢å¤ã€‚è¿è¡Œæ—¶ä½¿é›†ç¾¤ä¸­æ‰˜ç®¡çš„grainsèƒ½å¤Ÿåƒåœ¨å•ä¸ªè¿›ç¨‹ä¸­ä¸€æ ·ç›¸äº’é€šä¿¡ã€‚ é™¤äº†æ ¸å¿ƒç¼–ç¨‹æ¨¡å‹ä¹‹å¤–ï¼Œsilosè¿˜ä¸ºgrainsæä¾›äº†ä¸€ç»„è¿è¡Œæ—¶æœåŠ¡ï¼Œä¾‹å¦‚è®¡æ—¶å™¨ã€æé†’(persistent timers)ã€æŒä¹…åŒ–ã€äº‹åŠ¡ã€æµç­‰ã€‚è§ ç‰¹è‰²éƒ¨åˆ† ä¸‹é¢æ˜¯æ›´å¤šç»†èŠ‚ã€‚ Webå‰ç«¯å’Œå…¶ä»–å¤–éƒ¨å®¢æˆ·ç«¯ä½¿ç”¨å®¢æˆ·ç«¯åº“è°ƒç”¨é›†ç¾¤ä¸­çš„grainsï¼Œè¯¥åº“è‡ªåŠ¨ç®¡ç†ç½‘ç»œé€šä¿¡ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œå®¢æˆ·ç«¯ä¹Ÿå¯ä»¥ä¸silosåœ¨åŒä¸€è¿›ç¨‹ä¸­å…±åŒæ‰˜ç®¡ã€‚ Orleansä¸.NET Standard 2.0åŠæ›´é«˜ç‰ˆæœ¬å…¼å®¹ï¼Œè¿è¡Œåœ¨Windowsã€Linuxå’ŒmacOSä¸Šï¼Œé‡‡ç”¨å®Œæ•´çš„.NET Frameworkæˆ–.NETæ ¸å¿ƒã€‚ ç‰¹å¾ æŒä¹…åŒ– Orleansæä¾›äº†ä¸€ä¸ªç®€å•çš„æŒä¹…åŒ–æ¨¡å‹ï¼Œç¡®ä¿åœ¨å¤„ç†è¯·æ±‚ä¹‹å‰ï¼ŒçŠ¶æ€å¯¹grainæ˜¯å¯ç”¨çš„ï¼Œå¹¶ä¸”ä¿æŒä¸€è‡´æ€§ã€‚Grainså¯ä»¥æœ‰å¤šä¸ªå‘½åçš„æŒä¹…åŒ–æ•°æ®å¯¹è±¡ï¼Œä¾‹å¦‚ï¼Œä¸€ä¸ªåä¸ºâ€œprofileâ€çš„ç”¨æˆ·æ¦‚è¦æ–‡ä»¶ï¼Œä¸€ä¸ªåä¸ºâ€œinventoryâ€çš„å­˜å‚¨ã€‚æ­¤çŠ¶æ€å¯ä»¥å­˜å‚¨åœ¨ä»»ä½•å­˜å‚¨ç³»ç»Ÿä¸­ã€‚ä¾‹å¦‚ï¼Œé…ç½®æ–‡ä»¶æ•°æ®å¯ä»¥å­˜å‚¨åœ¨ä¸€ä¸ªæ•°æ®åº“ä¸­ï¼Œè€Œåº“å­˜å­˜å‚¨åœ¨å¦ä¸€ä¸ªæ•°æ®åº“ä¸­ã€‚å½“ä¸€ä¸ªgrainæ­£åœ¨è¿è¡Œæ—¶ï¼Œè¿™ä¸ªçŠ¶æ€è¢«ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ä¸è®¿é—®å­˜å‚¨å™¨çš„æƒ…å†µä¸‹å¤„ç†è¯»è¯·æ±‚ã€‚å½“grainsæ›´æ–°å…¶çŠ¶æ€æ—¶ state.WriteStateAsync() callç¡®ä¿å¤‡ä»½å­˜å‚¨çš„æŒä¹…åŒ–å’Œä¸€è‡´æ€§å¾—åˆ°æ›´æ–°ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ GrainsæŒä¹…åŒ– æ–‡æ¡£ã€‚ åˆ†å¸ƒå¼ACIDäº‹åŠ¡ é™¤äº†ä¸Šé¢æè¿°çš„ç®€å•æŒä¹…åŒ–æ¨¡å‹ä¹‹å¤–ï¼Œgrainsè¿˜å¯ä»¥ äº‹åŠ¡çŠ¶æ€ . å¤šä¸ªgrainså¯ä»¥å‚ä¸ é…¸æ€§ ä¸ç®¡äº‹åŠ¡çš„çŠ¶æ€æœ€ç»ˆå­˜å‚¨åœ¨ä½•å¤„ã€‚Orleansçš„äº‹åŠ¡æ˜¯åˆ†å¸ƒå¼å’Œåˆ†æ•£çš„(æ²¡æœ‰ä¸­å¤®äº‹åŠ¡ç®¡ç†å™¨æˆ–äº‹åŠ¡åè°ƒå™¨)ï¼Œå¹¶ä¸” å¯ä¸²è¡Œéš”ç¦» . æœ‰å…³Orleansäº¤æ˜“çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… æ–‡æ¡£ ä»¥åŠ å¾®è½¯ç ”ç©¶é™¢æŠ€æœ¯æŠ¥å‘Š . Streams æµå¸®åŠ©å¼€å‘äººå‘˜ä»¥è¿‘ä¹å®æ—¶çš„æ–¹å¼å¤„ç†ä¸€ç³»åˆ—æ•°æ®é¡¹ã€‚Orleansçš„Streams ç®¡ç† ï¼šåœ¨Grainæˆ–å®¢æˆ·ç«¯å‘å¸ƒåˆ°æµæˆ–è®¢é˜…æµä¹‹å‰ï¼Œä¸éœ€è¦åˆ›å»ºæˆ–æ³¨å†Œæµã€‚è¿™ä½¿å¾—æµç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´ä»¥åŠä¸åŸºç¡€è®¾æ–½ä¹‹é—´çš„æ›´å¤§ç¨‹åº¦çš„åˆ†ç¦»ã€‚æµå¤„ç†æ˜¯å¯é çš„ï¼šgrainså¯ä»¥å­˜å‚¨æ£€æŸ¥ç‚¹(æ¸¸æ ‡)ï¼Œå¹¶åœ¨æ¿€æ´»æœŸé—´æˆ–ä¹‹åçš„ä»»ä½•æ—¶é—´é‡ç½®ä¸ºå­˜å‚¨çš„æ£€æŸ¥ç‚¹ã€‚Streamsæ”¯æŒå‘ä½¿ç”¨è€…æ‰¹é‡ä¼ é€’æ¶ˆæ¯ï¼Œä»¥æé«˜æ•ˆç‡å’Œæ¢å¤æ€§èƒ½ã€‚æµç”±æ’é˜ŸæœåŠ¡æ”¯æŒï¼Œå¦‚Azureäº‹ä»¶ä¸­å¿ƒã€Amazon Kinesisç­‰ã€‚å¯ä»¥å°†ä»»æ„æ•°é‡çš„æµå¤šè·¯å¤ç”¨åˆ°è¾ƒå°æ•°é‡çš„é˜Ÿåˆ—ä¸Šï¼Œå¹¶ä¸”å¤„ç†è¿™äº›é˜Ÿåˆ—çš„è´£ä»»åœ¨é›†ç¾¤ä¸­å‡è¡¡ã€‚ è®¡æ—¶å™¨&æé†’ æé†’æ˜¯ä¸€ç§æŒä¹…çš„Grainsè°ƒåº¦æœºåˆ¶ã€‚å®ƒä»¬å¯ç”¨äºç¡®ä¿åœ¨å°†æ¥æŸä¸ªæ—¶é—´ç‚¹å®ŒæˆæŸäº›æ“ä½œï¼Œå³ä½¿æ­¤æ—¶grainså½“å‰æœªæ¿€æ´»ã€‚è®¡æ—¶å™¨æ˜¯éæŒä¹…åŒ–çš„æé†’ç‰©ï¼Œå¯ç”¨äºä¸éœ€è¦å¯é æ€§çš„é«˜é¢‘äº‹ä»¶ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ è®¡æ—¶å™¨å’Œæé†’ æ–‡æ¡£ã€‚ çµæ´»çš„Grainså­˜å‚¨ å½“ä¸€ä¸ªGrainsåœ¨Orleansè¢«æ¿€æ´»æ—¶ï¼Œè¿è¡Œæ—¶å†³å®šåœ¨å“ªä¸ªæœåŠ¡å™¨(silos)ä¸Šæ¿€æ´»è¯¥Grainsã€‚è¿™å°±æ˜¯æ‰€è°“çš„Grainså­˜å‚¨ã€‚Orleansçš„å¸ƒå±€è¿‡ç¨‹æ˜¯å®Œå…¨å¯é…ç½®çš„ï¼šå¼€å‘äººå‘˜å¯ä»¥ä»ä¸€ç»„ç°æˆçš„å¸ƒå±€ç­–ç•¥ä¸­è¿›è¡Œé€‰æ‹©ï¼Œä¾‹å¦‚éšæœºã€é¦–é€‰æœ¬åœ°å’ŒåŸºäºè´Ÿè½½çš„ï¼Œæˆ–è€…å¯ä»¥é…ç½®è‡ªå®šä¹‰é€»è¾‘ã€‚è¿™æ ·å°±å¯ä»¥å……åˆ†çµæ´»åœ°å†³å®šåœ¨å“ªé‡Œäº§ç”Ÿgrainsã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å°†Grainå­˜å‚¨åœ¨æœåŠ¡å™¨ä¸Šï¼Œé è¿‘å®ƒä»¬éœ€è¦æ“ä½œçš„èµ„æºæˆ–ä¸ä¹‹é€šä¿¡çš„å…¶ä»–Grainã€‚ Grainsç‰ˆæœ¬åŒ–&å¼‚æ„é›†ç¾¤ åº”ç”¨ç¨‹åºä»£ç ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œå‘å±•ï¼Œä»¥å®‰å…¨åœ°è§£é‡Šè¿™äº›æ›´æ”¹çš„æ–¹å¼å‡çº§å®æ—¶ç”Ÿäº§ç³»ç»Ÿå¯èƒ½æ˜¯ä¸€é¡¹æŒ‘æˆ˜ï¼Œå°¤å…¶æ˜¯åœ¨æœ‰çŠ¶æ€çš„ç³»ç»Ÿä¸­ã€‚Orleansçš„Grainsæ¥å£å¯ä»¥é€‰æ‹©æ€§åœ°è¿›è¡Œç‰ˆæœ¬æ§åˆ¶ã€‚é›†ç¾¤ç»´æŠ¤äº†ä¸€ä¸ªæ˜ å°„ï¼Œæ˜ å°„å‡ºé›†ç¾¤ä¸­çš„å“ªäº›ç«–äº•ä¸Šæœ‰å“ªäº›grainå®ç°ä»¥åŠè¿™äº›å®ç°çš„ç‰ˆæœ¬ã€‚è¿è¡Œæ—¶å°†æ­¤ç‰ˆæœ¬ä¿¡æ¯ä¸å­˜å‚¨ç­–ç•¥ç»“åˆä½¿ç”¨ï¼Œä»¥ä¾¿åœ¨å°†è°ƒç”¨è·¯ç”±åˆ°grainsæ—¶åšå‡ºå­˜å‚¨å†³ç­–ã€‚é™¤äº†å®‰å…¨åœ°æ›´æ–°ç‰ˆæœ¬åŒ–çš„grainsä¹‹å¤–ï¼Œè¿™è¿˜æ”¯æŒå¼‚æ„é›†ç¾¤ï¼Œå…¶ä¸­ä¸åŒçš„siloå…·æœ‰ä¸åŒçš„grainå®ç°é›†ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ Grainsç‰ˆæœ¬åŒ– æ–‡æ¡£ã€‚ å¼¹æ€§ä¼¸ç¼©æ€§&å®¹é”™ Orleansçš„è®¾è®¡æ˜¯å¼¹æ€§ä¼¸ç¼©çš„ã€‚å½“silosåŠ å…¥é›†ç¾¤æ—¶ï¼Œå®ƒèƒ½å¤Ÿæ¥å—æ–°çš„æ¿€æ´»ï¼Œå½“silosç¦»å¼€é›†ç¾¤æ—¶(ç”±äºè§„æ¨¡ç¼©å°æˆ–æœºå™¨æ•…éšœ)ï¼Œåœ¨è¯¥silosä¸Šæ¿€æ´»çš„Grainså°†æ ¹æ®éœ€è¦åœ¨å…¶ä½™silosä¸Šé‡æ–°æ¿€æ´»ã€‚ä¸€ä¸ªOrleansé›†ç¾¤å¯ä»¥ç¼©å°åˆ°ä¸€ä¸ªsilosã€‚æ”¯æŒå¼¹æ€§ä¼¸ç¼©æ€§çš„ç›¸åŒå±æ€§ä¹Ÿæ”¯æŒå®¹é”™ï¼šé›†ç¾¤è‡ªåŠ¨æ£€æµ‹å¹¶ä»æ•…éšœä¸­å¿«é€Ÿæ¢å¤ã€‚ è¿è¡Œåœ¨ä»»ä½•åœ°æ–¹ Orleansè¿è¡Œä»»ä½•æ”¯æŒ.NETCoreæˆ–.NETFrameworkçš„åœ°æ–¹ã€‚è¿™åŒ…æ‹¬åœ¨Linuxã€Windowså’ŒmacOSä¸Šæ‰˜ç®¡ï¼Œå¹¶éƒ¨ç½²åˆ°Kubernetesã€è™šæ‹Ÿæœºæˆ–ç‰©ç†æœºã€æœ¬åœ°æˆ–äº‘ä¸­ï¼Œä»¥åŠPaaSæœåŠ¡(å¦‚Azureäº‘æœåŠ¡)ã€‚ æ— çŠ¶æ€ Worker æ— çŠ¶æ€å·¥ä½œè€…æ˜¯ç‰¹æ®Šæ ‡è®°çš„grainsï¼Œæ²¡æœ‰ä»»ä½•å…³è”çŠ¶æ€ï¼Œå¯ä»¥åŒæ—¶åœ¨å¤šä¸ªsilosä¸Šæ¿€æ´»ã€‚è¿™æ ·å°±å¯ä»¥æé«˜æ— çŠ¶æ€å‡½æ•°çš„å¹¶è¡Œæ€§ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§ æ— çŠ¶æ€å·¥äººGrains æ–‡æ¡£ã€‚ Grainsæ‹¦æˆªå™¨ è®¸å¤šGrainsçš„å…±åŒé€»è¾‘å¯ä»¥è¡¨ç¤ºä¸º Grainsæ‹¦æˆªå™¨ . Orleansæ”¯æŒä¼ å…¥å’Œå‘¼å‡ºçš„è¿‡æ»¤å™¨ã€‚è¿‡æ»¤å™¨çš„ä¸€äº›å¸¸è§ç”¨ä¾‹æœ‰ï¼šæˆæƒã€æ—¥å¿—è®°å½•å’Œé¥æµ‹ä»¥åŠé”™è¯¯å¤„ç†ã€‚ è¯·æ±‚ä¸Šä¸‹æ–‡ å…ƒæ•°æ®å’Œå…¶ä»–ä¿¡æ¯å¯ä»¥é€šè¿‡ä½¿ç”¨ è¯·æ±‚ä¸Šä¸‹æ–‡ . è¯·æ±‚ä¸Šä¸‹æ–‡å¯ç”¨äºæ‰“å­”åˆ†å¸ƒå¼è·Ÿè¸ªä¿¡æ¯æˆ–ä»»ä½•å…¶ä»–ç”¨æˆ·å®šä¹‰çš„å€¼ã€‚ å…¥é—¨ è¯·çœ‹ å…¥é—¨æ•™ç¨‹ . æ„å»º åœ¨Windowsä¸Šï¼Œè¿è¡Œ build.cmd è„šæœ¬åœ¨æœ¬åœ°æ„å»ºNuGetåŒ…ï¼Œç„¶åä»ä¸­å¼•ç”¨æ‰€éœ€çš„NuGetåŒ… /Artifacts/Release/* . ä½ å¯ä»¥è·‘äº† Test.cmd è¿è¡Œæ‰€æœ‰BVTæµ‹è¯•ï¼Œä»¥åŠ TestAll.cmd åŒæ—¶è¿è¡ŒåŠŸèƒ½æµ‹è¯•ã€‚ åœ¨Linuxå’ŒmacOSä¸Šï¼Œè¿è¡Œ build.sh è„šæœ¬æˆ– dotnet build ./OrleansCrossPlatform.sln æ„å»ºOrleansã€‚ å®˜æ–¹æ„å»º æœ€æ–°çš„ç¨³å®šï¼Œç”Ÿäº§è´¨é‡å‘å¸ƒ åœ¨è¿™é‡Œ . å¤œé—´ç”Ÿæˆå‘å¸ƒåˆ° https://dotnet.myget.org/gallery/orleans-ci . è¿™äº›æ„å»ºé€šè¿‡äº†æ‰€æœ‰çš„åŠŸèƒ½æµ‹è¯•ï¼Œä½†æ˜¯æ²¡æœ‰åƒå‘å¸ƒåˆ°NuGetçš„ç¨³å®šç‰ˆæœ¬æˆ–é¢„å‘å¸ƒç‰ˆæœ¬é‚£æ ·è¿›è¡Œå½»åº•æµ‹è¯•ã€‚ åœ¨é¡¹ç›®ä¸­ä½¿ç”¨å¤œé—´æ„å»ºåŒ… è¦åœ¨é¡¹ç›®ä¸­ä½¿ç”¨å¤œé—´ç”Ÿæˆï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹ä»»ä¸€æ–¹æ³•æ·»åŠ MyGetæè¦ï¼š æ›´æ”¹.csprojæ–‡ä»¶ä»¥åŒ…å«æ­¤èŠ‚ï¼š <RestoreSources> $(RestoreSources); https://dotnet.myget.org/F/orleans-ci/api/v3/index.json; </RestoreSources> æˆ– åˆ›å»º NuGet.configæ–‡ä»¶ åŒ…å«ä»¥ä¸‹å†…å®¹çš„è§£å†³æ–¹æ¡ˆç›®å½•ä¸­çš„æ–‡ä»¶ï¼š <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <clear /> <add key=\"orleans-ci\" value=\"https://dotnet.myget.org/F/orleans-ci/api/v3/index.json\" /> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> </configuration> ç¤¾åŒº æé—®æ–¹å¼ åœ¨GitHubä¸Šæ‰“å¼€é—®é¢˜ æˆ–è€…åœ¨ å †æ ˆæº¢å‡º åœ¨Gitterä¸ŠèŠå¤© Orleansåšå®¢ è·Ÿéš @Orleanså°å§ Orleanså…¬å‘Šçš„Twitterå¸æˆ·ã€‚ OrleansContrib-é¢å‘Orleansç¤¾åŒºé™„åŠ ç»„ä»¶çš„GitHubç»„ç»‡ å„ç§ç¤¾åŒºé¡¹ç›®ï¼ŒåŒ…æ‹¬ç›‘è§†ã€è®¾è®¡æ¨¡å¼ã€å­˜å‚¨æä¾›ç¨‹åºç­‰ã€‚ å¼€å‘äººå‘˜å¸Œæœ› ä¸ºOrleansè´¡çŒ®ä»£ç æ›´æ”¹ . æˆ‘ä»¬è¿˜é¼“åŠ±æ‚¨æŠ¥å‘Šé”™è¯¯æˆ–é€šè¿‡å¯åŠ¨æ–°çš„ ä¼šè¯ åœ¨GitHubä¸Šã€‚ è®¸å¯è¯ æœ¬é¡¹ç›®æ ¹æ® MIT license . å¿«é€Ÿé“¾æ¥ Microsoftç ”ç©¶é¡¹ç›®ä¸»é¡µ æŠ€æœ¯æŠ¥å‘Šï¼š å¯ç¼–ç¨‹æ€§å’Œå¯æ‰©å±•æ€§çš„åˆ†å¸ƒå¼è™šæ‹Ÿå‚ä¸è€… Orleansæ–‡ä»¶ è´¡çŒ® Orleansçš„èµ·æº Orleansåˆ›å»ºäº å¾®è½¯ç ”ç©¶å¹¶è®¾è®¡ç”¨äºäº‘è®¡ç®— . è‡ª2011å¹´ä»¥æ¥ï¼Œå®ƒå·²è¢«å¤šå®¶å¾®è½¯äº§å“é›†å›¢å¹¿æ³›åº”ç”¨äºäº‘è®¡ç®—å’Œå†…éƒ¨éƒ¨ç½²ï¼Œå…¶ä¸­æœ€è‘—åçš„æ˜¯æ¸¸æˆå·¥ä½œå®¤ï¼Œå¦‚343 Industrieså’Œè”ç›Ÿä½œä¸ºHalo 4å’Œ5ã€Gears of War 4èƒŒåçš„äº‘æœåŠ¡å¹³å°ï¼Œä»¥åŠå…¶ä»–ä¸€äº›ã€‚ Orleansäº2015å¹´1æœˆå¼€æ”¾æºç ï¼Œå¸å¼•äº†è®¸å¤šå¼€å‘å•†æˆç«‹ æ˜¯.NETç”Ÿæ€ç³»ç»Ÿä¸­æœ€å…·æ´»åŠ›çš„å¼€æºç¤¾åŒºä¹‹ä¸€ . åœ¨å¼€å‘äººå‘˜ç¤¾åŒºå’Œå¾®è½¯Orleanså›¢é˜Ÿçš„ç§¯æåˆä½œä¸­ï¼Œæ¯å¤©éƒ½ä¼šæ·»åŠ å’Œæ”¹è¿›ç‰¹æ€§ã€‚å¾®è½¯ç ”ç©¶é™¢ç»§ç»­ä¸Orleanså›¢é˜Ÿåˆä½œï¼Œæ¨å‡ºæ–°çš„ä¸»è¦åŠŸèƒ½ï¼Œå¦‚ åœ°ç†åˆ†å¸ƒ , ç´¢å¼• ï¼Œå’Œ åˆ†å¸ƒå¼äº‹åŠ¡ ï¼Œæ¨åŠ¨äº†æœ€æ–°æŠ€æœ¯çš„å‘å±•ã€‚å¯¹äºè®¸å¤š.NETå¼€å‘äººå‘˜æ¥è¯´ï¼ŒOrleanså·²ç»æˆä¸ºæ„å»ºåˆ†å¸ƒå¼ç³»ç»Ÿå’Œäº‘æœåŠ¡çš„é¦–é€‰æ¡†æ¶ã€‚"
  },
  "1.5/Documentation/Grain-Versioning/Grain-versioning.html": {
    "href": "1.5/Documentation/Grain-Versioning/Grain-versioning.html",
    "title": "Grain versioning | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain versioning Warning This page describes how to use grain interface versioning. The versioning of Grain state is out of scope. Overview On a given cluster, silos can support different versions of a grain type. In this example the client and Silo{1,2,3} were compiled with grain interface A version 1. Silo 4 was compiled with A version 2. Limitations: No versioning on stateless worker Streaming interfaces are not versioned Enable versioning By default, grains are not versioned. You can version grain by using the VersionAttribute on the grain interface: [Version(X)] public interface IVersionUpgradeTestGrain : IGrainWithIntegerKey {} Where X is the version number of the grain interface, which is typically monotonically increasing. Grain version compatibility and placement When a call from a versioned grain arrive in a cluster: If no activation exists, a compatible activation will be created If an activation exists: If the current one is not compatible, it will be deactivated and new compatible will be created (see version selector strategy ) If the current one is compatible (see compatible grains ), the call will be handled normally. By default: All versioned grains are supposed to be backward-compatible only (see backward compatibility guidelines and compatible grains ). That means that a v1 grain can make calls to a v2 grain, but a v2 grain cannot call a v1. This default behavior can be changed with GlobalConfiguration.DefaultCompatibilityStrategy When multiple versions exist in the cluster, the new activation will be randomly placed on a compatible silo. This default behavior can be changed with GlobalConfiguration.DefaultVersionSelectorStrategy"
  },
  "1.5/Documentation/Grain-Versioning/Version-selector-strategy.html": {
    "href": "1.5/Documentation/Grain-Versioning/Version-selector-strategy.html",
    "title": "Version selector strategy | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Version selector strategy When several versions of the same grain interface exist in the cluster, and a new activation has to be created, a compatible version will be chosen according to the strategy defined in GlobalConfiguration.DefaultVersionSelectorStrategy . Orleans out of the box supports the following strategies: All compatible versions (default) Using this strategy, the version of the new activation will be chosen randomly across all compatible versions. For example if we have 2 versions of a given grain interface, V1 and V2: V2 is backward compatible with V1 In the cluster there are 2 silos that support V2, 8 support V1 The request was made from a V1 client/silo In this case, there is a 20% chance that the new activation will be a V2 and 80% chance that it will be a V1. Latest version Using this strategy, the version of the new activation will always be the latest compatible version. For example if we have 2 versions of a given grain interface, V1 and V2 (V2 is backward or fully compatible with V1) then all new activations will be V2. Minimum version Using this strategy, the version of the new activation will always be the requested or the minimum compatible version. For example if we have 2 versions of a given grain interface, V2, V3, all fully compatibles: If the request was made from a V1 client/silo, the new activation will be a V2 If the request was made from a V3 client/silo, the new activation will be a V2 too"
  },
  "1.5/Documentation/Grain-Versioning/Compatible-grains.html": {
    "href": "1.5/Documentation/Grain-Versioning/Compatible-grains.html",
    "title": "Compatible grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Compatible grains When an existing grain activation is about to process a request, the runtime will check if the version in the request and the actual version of the grain are compatible. Orleans does not infer at runtime which policy to use , The default behavior to determine if two versions are compatible is determined by GlobalConfiguration.CompatibilityStrategy Backward compatible (default) Definition A grain interface version Vn can be be backward compatible with Vm if: The name of the interface didn't change (or the overridden typecode) All public methods present in the Vm version are in the Vn version. It is important that the signatures of the methods inherited from Vm are not modified : since Orleans use an internal built-in serializer, modifying/renaming a field (even private) can make the serialization to break. Since Vn can have added methods compared to Vm, Vm is not compatible with Vn. Example If in the cluster we have two versions of a given interface, V1 and V2 and that V2 is backward compatible with V1: If the current activation is a V2 and the requested version is V1, the current activation will be able to process the request normally If the current activation is a V1 and the requested version is V2, the current activation will be deactivated and a new activation compatible with V2 will be created (see version selector strategy ). Fully compatible Definition A grain interface version Vn can be fully compatible with Vm if: Vn is backward compatible with Vm No public methods where added in the Vn version If Vn is fully compatible with Vm then Vm is also fully compatible with Vn. Example If in the cluster we have two versions of a given interface, V1 and V2 and that V2 is fully compatible with V1: If the current activation is a V2 and the requested version is V1, the current activation will be able to process the request normally If the current activation is a V2 and the requested version is V1, the current activation will also be able to process the request normally"
  },
  "1.5/Documentation/Grain-Versioning/Backward-compatibility-guidelines.html": {
    "href": "1.5/Documentation/Grain-Versioning/Backward-compatibility-guidelines.html",
    "title": "Backward compatibility guidelines | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Backward compatibility guidelines Writing backward compatible code can be hard and difficult to test. Never change the signature of existing methods Because of the way on how Orleans serializer work, you should never change the signature of existing methods. The following example is correct: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } This is not correct: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg, obj o); } NOTE : you should not do this change in your code, as it's an example of a bad practice that leads to very bad side-effects. This is an example of what can happen if you just rename the parameter names: let's say that we have the two following interface version deployed in the cluster: [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // return a - b Task<int> Substract(int a, int b); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // return y - x Task<int> Substract(int y, int x); } This methods seems identical. But if the client was called with V1, and the request is handled by a V2 activation: var grain = client.GetGrain<IMyGrain>(0); var result = await grain.Substract(5, 4); // Will return \"-1\" instead of expected \"1\" This is due to how the internal Orleans serializer works. Avoid changing existing method logic It can seems obvious, but you should be very careful when changing the body of an existing method. Unless you are fixing a bug, it is better to just add a new method if you need to modify the code. (see compatible grains ) Example: // V1 public interface MyGrain : IMyGrain { // First method Task MyMethod(int arg) { SomeSubRoutine(arg); } } // V2 public interface MyGrain : IMyGrain { // Method inherited from V1 // Do not change the body Task MyMethod(int arg) { SomeSubRoutine(arg); } // New method added in V2 Task MyNewMethod(int arg) { SomeSubRoutine(arg); NewRoutineAdded(arg); } } Do not remove methods from grain interfaces Unless you are sure that they are no longer used, you should not remove methods from the grain interface. If you want to remove methods, this should be done in 2 steps: Deploy V2 grains, with V1 method marked as Obsolete [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 [Obsolete] Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } When you are sure that no V1 calls are made (effectively V1 is no longer deployed in the running cluster), deploy V3 with V1 method removed [Version(3)] public interface IMyGrain : IGrainWithIntegerKey { // New method added in V2 Task MyNewMethod(int arg, obj o); }"
  },
  "1.5/Documentation/Grain-Versioning/Deployment.html": {
    "href": "1.5/Documentation/Grain-Versioning/Deployment.html",
    "title": "Deploy new version of grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Deploy new version of grains Rolling upgrade In this method you deploy newer silos directly on your environment. This is the simplest method, but it can be difficult to interrupt an ongoing deployment and to rollback. Recommended configuration: DefaultCompatibilityStrategy set to BackwardCompatible DefaultVersionSelectorStrategy set to AllCompatibleVersions When using this configuration, \"old\" clients will be able to talk to activations on both versions of silos. Newer clients and silos will only trigger new activations on newer silos. Using a staging environment In this method you will need a second environment (Staging environment), on which you will deploy newer silos before stopping the Production environment. The Production and the Staging silos and clients will be part of the same cluster . It is important that silos from both environment can talk to each other. Recommended configuration: DefaultCompatibilityStrategy set to BackwardCompatible DefaultVersionSelectorStrategy set to MinimumVersion Suggested deployment steps: \"V1\" silos and clients are deployed and are running in the Production slot. \"V2\" silos and clients begin to start in the Staging slot. They will join the same cluster as the Production slot. No \"V2\" activations will be created so far. Once the deployment in the Staging slot is finished, the developper can redirect some traffic on the V2 clients (smoke tests, targeted beta users, ect.). This will create V2 activations, but since Grains are backward compatibles and that all silos are in the same cluster, no duplicate activations will be created. If the validation is successful, proceed to VIP swap. If not, you can safely shutdown the Staging cluster: existing V2 activations will be destroyed and V1 activations will be created if needed. V1 activations will naturally \"migrate\" to V2 silos eventually. You can safely shutdown V1 silos. Warning Remember that stateless workers are not versioned and that streaming agents will also start in the staging environment."
  },
  "1.5/Documentation/Presentations/index.html": {
    "href": "1.5/Documentation/Presentations/index.html",
    "title": "Orleans Presentations | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleans Best Practices A collection of tips and trick to help design, build, and run an Orleans-based application. Orleans Presentation from the 28th International Symposium on Distributed Computing (DISC 2014) Orleans Presentation from the 15th International Workshop on High Performance Transaction Systems (HPTS 2013) [Balancing Techniques in Orleans]( http://dotnet.github.io/orleans/Presentations/Balancing Techniques in Orleans.pptx) [Uniform API is 42 - Virtual Meetup #3]( http://dotnet.github.io/orleans/Presentations/(VM03 ) Uniform Api is 42.pptx) [Orleans at FreeBay - Virtual Meetup #4]( http://dotnet.github.io/orleans/Presentations/VM-4 - Using Orleans at FreeBay.pptx) [Orleans Streaming - Virtual Meetup #5 - May 2015]( http://dotnet.github.io/orleans/Presentations/Orleans Streaming - Virtual meetup - 5-22-2015.pptx) [Geo Distributed Orleans - Virtual Meetup #6 - October 2015]( http://dotnet.github.io/orleans/Presentations/VM-6 - Orleans-Geo-Replication.pptx) [Orleankka Functional API for Orleans - Virtual Meetup #7]( http://dotnet.github.io/orleans/Presentations/(VM07 ) Orleankka Functional API for Orleans.pptx) [Orleans Roadmap - Virtual Meetup #8 - January 2016]( http://dotnet.github.io/orleans/Presentations/Orleans Roadmap 1-21-2016.pptx) [Orleans Networking discussion- Virtual Meetup #8.5 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-8.5 - Orleans Networking.pptx) [Orleans on Service Fabric - Virtual Meetup #9 Part 1 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-9 - Part.1 Orleans-on-Service-Fabric.pptx) [Orleans with YAMS - Virtual Meetup #9 Part 2 - February 2016]( http://dotnet.github.io/orleans/Presentations/VM-9 - Part.2 Orleans-with-YAMS.pptx) [Walk In Distributed Systems Park With Orleans]( http://dotnet.github.io/orleans/Presentations/(FWDAYSKIEV2016 ) Walk.In.Distributed.Systems.Park.With.Orleans.pptx)"
  },
  "1.5/Documentation/Introduction.html": {
    "href": "1.5/Documentation/Introduction.html",
    "title": "Introduction | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Introduction Orleans is a framework that provides a straightforward approach to building distributed high-scale computing applications, without the need to learn and apply complex concurrency or other scaling patterns. Background Cloud applications and services are inherently parallel and distributed. They are also interactive and dynamic; often requiring near real time direct interactions between cloud entities. Such applications are very difficult to build today. The development process demands expert level programmers and typically requires expensive iterations of the design and the architecture, as the workload grows. Most of todayâ€™s high scale properties are built as a composition of stateless n-tier services with most of application logic residing in the middle tier. While the model allows to scale out by adding more servers to the middle tier, it is constrained by the performance and scalability of the storage layer because most requests coming to the middle tier from the frontend web servers require one or more reads from storage, and updates are even more complicated and prone to concurrency issues and conflicts due to lack of coordination between the middle tier servers. It often requires caching in the stateless layer to get acceptable performance, adding complexity and introducing cache consistency issues. The other problem with the stateless n-tier model is that it doesn't support well horizontal communications between individual application entities exposed by the middle tier, which makes it hard to implement complex business logic with multiple entities performing individual operations as part of processing a request. Orleans as a Stateful Middle Tier Orleans provides an intuitive way of building a stateful middle tier, where various business logic entities appear as sea of isolated globally addressable .NET objects (grains) of different application defined types distributed across a cluster of servers (silos). A grain type is a simple .NET class that implements one or more application defined grain interfaces. Individual grains are instances of application defined grain classes that get automatically created by the Orleans runtime on servers on an as-needed basis to handle requests for those grains. Grains naturally map to most application entities, such as users, devices, sessions, inventories, orders, etc., which makes it very easy to build business logic that is object-oriented but scales transparently across a cluster of servers. Each grain has a stable logical identity (key) within its grain type chosen by the application logic, for example, user email or device ID or inventory SKU code. Orleans guarantees single-threaded execution of each individual grain, hence protecting the application logic from perils of concurrency and races. In the world of microservices, Orleans is used as a framework for implementing a microservice that can be deployed and managed by a microservices deployment/management solution of developer's choice. Grain Lifecycle Grain can have persistent state in storage or in-memory state or a combination of both. Any grain can be called by any other grain or by a frontend (client) by using the target grain's logical identity without the need to ever create or instantiate the target grain. The Orleans programming model makes grains appear as if they are in memory the whole time. In reality, a grain goes through the lifecycle from existing only as its persisted state in storage to being instantiated in memory to being removed from memory. The Orleans runtime behind the scene instantiates (activates) grains when there's work for them to do, and removes them from memory (deactivates) to reclaim hardware resources when they are idle for too long. This grain lifecycle management work of the runtime is transparent to the application code, and liberates it from the complicated task of distributed resource management. Application logic can be written with the whole \"address space\" of grains available to it without the need to have hardware resources to keep all grains in memory at the same time, conceptually similar to how virtual memory works in operating systems. In addition, the virtual nature of grains allows Orleans to handle server failures mostly transparently to the application logic because grains that were executing on a failed server get automatically re-instantiated on other servers in the cluster once the failure is detected. Virtual Actors Implementation of Orleans is based on the Actor Model that's been around since 1970s. However, unlike actors in more traditional actor systems such as Erlang or Akka, Orleans Grains are virtual actors. The biggest difference is that physical instantiations of grains are completely abstracted away and are automatically managed by the Orleans runtime. The Virtual Actor Model is much more suitable for high-scale dynamic workloads like cloud services and is the major innovation of Orleans. You can read more details in the Technical Report on Orleans. Origin of Orleans Orleans was created at Microsoft Research and designed for use in the cloud . Since 2011, it has been used extensively in the cloud and on premises by several Microsoft product groups, most notably by game studios, such as 343 Industries and The Coalition as a platform for cloud services behind Halo 4/5 and Gears of War 4, as well as by a number of other companies. Orleans was open-sourced in January 2015, and attracted many developers that formed one of the most vibrant open source communities in the .NET ecosystem . In an active collaboration between the developer community and the Orleans team at Microsoft, features are added and improved on a daily basis. Microsoft Research continues to partner with the Orleans team to bring new major features, such as geo-distribution , indexing , and distributed transactions , that are pushing the state of the art. Orleans has become the framework of choice for building distributed systems and cloud services for many .NET developers."
  },
  "blog/orleans-1.4-and-2.0-tech-preview-2-for-.net-core-released.html": {
    "href": "blog/orleans-1.4-and-2.0-tech-preview-2-for-.net-core-released.html",
    "title": "é¢å‘.NET Coreçš„Orleans 1.4å’Œ2.0 Tech Preview 2å‘å¸ƒ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é¢å‘.NET Coreçš„Orleans 1.4å’Œ2.0 Tech Preview 2å‘å¸ƒ æœ±åˆ©å®‰Â·å¤šæ˜æ ¼æ–¯(Julian Dominguez) 2017/3/2ä¸‹åˆ5:54:19 Orleans1.4.0 å‡ å‘¨å‰ï¼Œæˆ‘ä»¬å‘NuGet.orgå‘å¸ƒäº†Orleans 1.4.0ï¼Œå…¶ä¸­çš„ä¸»è¦æ–°ä¸»é¢˜æ˜¯ï¼š æ”¹è¿›äº†JournaledGrainï¼Œç”¨äºäº‹ä»¶æºï¼Œå¹¶æ”¯æŒåŸºäºåœ°ç†åˆ†å¸ƒçš„åŸºäºæ—¥å¿—çš„ä¸€è‡´æ€§æä¾›ç¨‹åºã€‚ å…·æœ‰å›ºå®šå­˜å‚¨çš„æ¯ä»“åº“åº”ç”¨ç¨‹åºç»„ä»¶çš„Grain Servicesçš„æŠ½è±¡ï¼Œå…¶å·¥ä½œè´Ÿè½½é€šè¿‡é›†ç¾¤ä¸€è‡´æ€§ç¯è¿›è¡Œåˆ†åŒºã€‚ æ”¯æŒä¸å‡åŒ€åˆ†å¸ƒçš„å¯ç”¨ç²®ä»“çš„å¼‚æ„silosã€‚ Service Fabricçš„ç¾¤é›†æˆå‘˜èµ„æ ¼æä¾›ç¨‹åºã€‚ å½“ç„¶ï¼Œè¿˜æœ‰è®¸å¤šå…¶ä»–æ”¹è¿›å’Œé”™è¯¯ä¿®å¤ï¼Œæ‚¨å¯ä»¥åœ¨æ­¤å¤„é˜…è¯»ï¼š Orleans v1.4.0å‘è¡Œè¯´æ˜ .NET Coreçš„Orleans 2.0 Tech Preview 2 é™¤äº†æˆ‘ä»¬çš„æ ‡å‡†ç‰ˆæœ¬å¤–ï¼Œæˆ‘ä»¬è¿˜åœ¨ä½¿ç”¨æ”¯æŒ.NET Standard(å’Œ.NET Coreä¸»æœº)çš„vNextåŠŸèƒ½ã€‚ä¸TP1ç›¸ä¼¼ï¼Œæ­¤æ–°é¢„è§ˆç‰ˆæœ¬ä¸Orleans 1.Xç‰ˆæœ¬å¹¶ä¸å®Œå…¨å®Œå…¨ç›¸åŒï¼Œä½†å·²ç»æ¥è¿‘ã€‚è‡ªä¸Šæ¬¡é¢„è§ˆä»¥æ¥ï¼Œæˆ‘ä»¬å·²å®Œæˆäº†è®¸å¤šé”™è¯¯ä¿®å¤ï¼Œå¹¶ä¸”è¯¥ç‰ˆæœ¬æ˜¯masteråˆ†æ”¯ä¸­çš„æœ€æ–°ç‰ˆæœ¬(æ¯”1.4.0æå‰äº†ä¸€ç‚¹)ã€‚ ä¸Orleans1.Xçš„å·®å¼‚ æ­¤é¢„å‘è¡Œç‰ˆæœ¬ä¸­çš„ä¸€äº›æ˜¾ç€å·®å¼‚æˆ–å¾…å¤„ç†äº‹é¡¹ï¼š Orleansä»£ç ç”Ÿæˆ ä»…å½“ä½¿ç”¨Visual Studio 2017æˆ–æœ€æ–°çš„dotnet CLIåœ¨Windowsä¸Šè¿›è¡Œæ„å»ºæ—¶ï¼Œæ„å»ºæ—¶é—´ä»£ç æº(Microsoft.Orleans.OrleansCodeGenerator.Build nugetç¨‹åºåŒ…)æ‰æœ‰æ•ˆã€‚ ä½†æ˜¯ï¼Œè¿è¡Œæ—¶ä»£ç ç”Ÿæˆæ˜¯è·¨å¹³å°å·¥ä½œçš„å¯è¡Œæ›¿ä»£æ–¹æ³•(é€šè¿‡å¼•ç”¨Siloå®¿ä¸»å’Œå®¢æˆ·ç«¯é¡¹ç›®ä¸­çš„Microsoft.Orleans.OrleansCodeGeneratorç¨‹åºåŒ…)ã€‚ .NET Standardä¸­å°šä¸æä¾›BinaryFormatter(å†…ç½®çš„.NETåºåˆ—åŒ–)ï¼Œå®ƒå·²åœ¨Orleansä¸­ç”¨ä½œé»˜è®¤çš„åå¤‡åºåˆ—åŒ–å™¨(é€šå¸¸åœ¨åºåˆ—åŒ–å¼‚å¸¸æ—¶ä½¿ç”¨)ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æœ‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„åŸºäºILçš„åå¤‡åºåˆ—åŒ–å™¨ï¼Œè¯¥åºåˆ—åŒ–å™¨åº”å¿«é€Ÿè€Œå¼ºå¤§ï¼Œä½†å¦‚æœæ‚¨ç°æœ‰çš„ä»£ç ä¾èµ–äºå®ƒï¼Œåˆ™å…¶è¡Œä¸ºå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒ [Serializable] ã€‚ .NETæ ‡å‡†ä¸­ä¸æ”¯æŒSystem.Diagnostic.Trace.CorrelationManager.ActivityIdã€‚å¦‚æœæ‚¨ä¾èµ–äºæ­¤æ¥å…³è”Grainsè°ƒç”¨ï¼Œè¯·è€ƒè™‘æ”¹ç”¨Orleans.Runtime.RequestContext.ActivityIdã€‚ Orleans2.0 TP2çš„ç”Ÿäº§å‡†å¤‡å°±ç»ªäº†å—ï¼Ÿ è¿˜æ²¡ã€‚å¤§å£°æ˜ï¼šæˆ‘ä»¬åœ¨.NETä¸­è¿›è¡ŒCIæµ‹è¯•(å› ä¸ºæˆ‘ä»¬çš„æµ‹è¯•ä¸¥é‡ä¾èµ–AppDomainsåˆ›å»ºå†…å­˜å­¤å²›ç¾¤é›†ï¼Œè€Œ.NET Coreä¸æ”¯æŒè¿™äº›å­¤å²›ï¼Œä½†æˆ‘ä»¬è®¡åˆ’å°½å¿«è§£å†³)ã€‚æˆ‘ä»¬å·²ç»åœ¨.NET Core(åŒ…æ‹¬Windowså’ŒLinux)ä¸­è¿›è¡Œäº†ä¸€äº›åŸºæœ¬çš„æ‰‹åŠ¨æµ‹è¯•ï¼Œå¹¶ä¸”æˆ‘ä»¬çš„ä¸€äº›è´¡çŒ®è€…æ­£åœ¨ä½¿ç”¨å®ƒå¼€å‘æ–°çš„æœåŠ¡ã€‚è·å¾—åé¦ˆ(å’ŒPRï¼)æ˜¯æ­¤ç‰ˆæœ¬çš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ï¼Œå°šæœªåœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ã€‚æ­¤å¤–ï¼Œå³ä½¿å¯¹äºå·²å®Œå…¨ç§»æ¤çš„åŠŸèƒ½ï¼Œä¹Ÿæ— æ³•ä¿è¯æ­¤æŠ€æœ¯é¢„è§ˆç‰ˆä¸Orleans 1.4å®Œå…¨å‘åå…¼å®¹ã€‚åœ¨æ¥è¿‘ç¨³å®šç‰ˆæœ¬ä¹‹åï¼Œæˆ‘ä»¬å°†åˆ—å‡ºæ‰€æœ‰å·²çŸ¥çš„é‡å¤§æ›´æ”¹ï¼Œä»¥é˜²æ‚¨æœ‰å…´è¶£å°†åº”ç”¨ç¨‹åºä»1.Xå‡çº§åˆ°2.0ã€‚ ä»å“ªé‡Œè·å¾— å› ä¸ºæ­¤æŠ€æœ¯é¢„è§ˆç‰ˆä¸å¦‚1.Xç‰ˆæœ¬å…·æœ‰å®Œæ•´åŠŸèƒ½æˆ–ç¨³å®šæ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨ä»…åœ¨MyGetä¸­å‘å¸ƒã€‚æ‚¨å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤åœ¨æ­¤å¤„é…ç½®Feedæ¥è·å–NuGetè½¯ä»¶åŒ…ï¼š https://dotnet.myget.org/gallery/orleans-ci HelloWorldç¤ºä¾‹ ç°åœ¨ï¼Œæˆ‘ä»¬çš„å­˜å‚¨åº“ä¸­æœ‰ä¸€ä¸ªéå¸¸ç®€å•çš„ç¤ºä¾‹ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å®ƒåœ¨.NET Core(æ— è®ºæ˜¯Windowsï¼ŒLinuxè¿˜æ˜¯MacOSä¸­)ä¸­è¯•ç”¨Orleansã€‚æ ·æœ¬ä½äº https://github.com/dotnet/orleans/tree/master/Samples/HelloWorld.NetCore ã€‚ äº«å—å®ƒï¼Œç©å¼„å®ƒï¼Œå¹¶è®©æˆ‘ä»¬çŸ¥é“æ‚¨çš„æƒ³æ³•ï¼Œæ— è®ºæ˜¯GitHubé—®é¢˜ï¼ŒPRè¿˜æ˜¯åªæ˜¯åœ¨æˆ‘ä»¬çš„Gitteré¢‘é“ä¸­é—²é€›ã€‚"
  },
  "blog/announcing-orleans-2.1.html": {
    "href": "blog/announcing-orleans-2.1.html",
    "title": "å®£å¸ƒOrleans2.1 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å®£å¸ƒOrleans2.1 é²æœ¬Â·é‚¦å¾· 2018/10/1ä¸‹åˆ7:17:59 ä»Šå¤©ï¼Œæˆ‘ä»¬å®£å¸ƒäº†Orleans2.1ã€‚æ­¤ç‰ˆæœ¬åŒ…æ‹¬å¯¹2.0çš„é‡å¤§æ€§èƒ½æ”¹è¿›ï¼Œå¯¹åˆ†å¸ƒå¼äº‹åŠ¡æ”¯æŒçš„é‡å¤§æ›´æ–°ï¼Œæ–°çš„ä»£ç ç”Ÿæˆå™¨ä»¥åŠç”¨äºå…±åŒæ‰˜ç®¡æ–¹æ¡ˆçš„æ–°åŠŸèƒ½ï¼Œä»¥åŠè¾ƒå°çš„ä¿®å¤å’Œæ”¹è¿›ã€‚é˜…è¯» åœ¨è¿™é‡Œå‘å¸ƒè¯´æ˜ ã€‚ æ–°è°ƒåº¦ç¨‹åº ä»Orleans2.1å¼€å§‹ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ª é‡å†™æ ¸å¿ƒè°ƒåº¦ç¨‹åº åˆ©ç”¨ .NET Coreçš„ThreadPoolçš„æ€§èƒ½æ”¹è¿› ã€‚æ–°çš„è°ƒåº¦ç¨‹åºä½¿ç”¨å…·æœ‰æœ¬åœ°é˜Ÿåˆ—ç›¸ä¼¼æ€§çš„å·¥ä½œçªƒå–é˜Ÿåˆ—æ¥å‡å°‘äº‰ç”¨å¹¶æé«˜ååé‡å’Œå»¶è¿Ÿã€‚è¿™äº›æ”¹è¿›é€‚ç”¨äºæ‰€æœ‰å¹³å°/æ¡†æ¶ã€‚ç¤¾åŒºæˆå‘˜æŠ¥å‘Šè¯´ä»–ä»¬çš„æœåŠ¡å…·æœ‰æ˜¾ç€çš„å“åº”èƒ½åŠ›å’Œååé‡æ”¹è¿›ï¼Œè€Œæˆ‘ä»¬çš„æµ‹è¯•è¡¨æ˜ååé‡æé«˜äº†30ï¼…ã€‚è¿™ç§æ–°çš„è°ƒåº¦ç¨‹åºåœ¨ä½è´Ÿè½½æœŸé—´çš„CPUä½¿ç”¨ç‡ä¹Ÿè¦ä½å¾—å¤šï¼Œè¿™æœ‰åˆ©äºå…±åŒæ‰˜ç®¡æ–¹æ¡ˆå¹¶æ”¹å–„CPUæ€§èƒ½åˆ†æä½“éªŒã€‚ç‰¹åˆ«æ„Ÿè°¢ å¾·ç±³ç‰¹ç½—Â·ç“¦åº“è¿ç§‘(Dmytro Vakulenko) ä»ç¤¾åŒºæ¨åŠ¨è¿™é¡¹å·¥ä½œä»ç†è®ºåˆ°å®éªŒå’Œå®Œæˆã€‚ åˆ†å¸ƒå¼äº¤æ˜“ Orleansèµ·æºäºMicrosoft Researchï¼Œæˆ‘ä»¬å°†ç»§ç»­ä¸MSRå’Œäº§å“å›¢é˜Ÿåˆä½œï¼Œå°†å¯æ‰©å±•çš„åˆ†å¸ƒå¼äº‹åŠ¡ç­‰åŠŸèƒ½å¼•å…¥ç”Ÿäº§ç¯å¢ƒã€‚åˆ†å¸ƒå¼äº‹åŠ¡æ”¯æŒæœ€åˆæ˜¯åœ¨Orleans2.0ä¸­ä½œä¸ºå®éªŒæ€§åŠŸèƒ½å¼•å…¥çš„ï¼Œè€Œåœ¨2.1ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ–°çš„å®Œå…¨åˆ†æ•£çš„äº‹åŠ¡ç®¡ç†å™¨æ¥åˆ·æ–°å‘è¡Œç‰ˆã€‚é™¤äº†å¯¹äº¤æ˜“ç®¡ç†å™¨è¿›è¡Œäº†æ”¹è¿›ä¹‹å¤–ï¼Œæ•´ä¸ªäº¤æ˜“ç³»ç»Ÿä»åœ¨ç»§ç»­è¿›è¡Œå¤§é‡æŠ•èµ„ï¼Œä»¥å‡†å¤‡ç”Ÿäº§ä»£ç å¹¶åœ¨Orleansçš„æœªæ¥ç‰ˆæœ¬ä¸­ç¨³å®šå‘å¸ƒã€‚æˆ‘ä»¬è®¤ä¸ºåˆ†å¸ƒå¼äº‹åŠ¡åœ¨2.1ä¸­å…·æœ‰â€œå€™é€‰å‘å¸ƒâ€è´¨é‡ã€‚ä»Sergeyçš„æ¼”è®²ä¸­äº†è§£Orleansçš„åˆ†å¸ƒå¼äº¤æ˜“ï¼Œ åˆ†å¸ƒå¼äº‹åŠ¡å·²æ­»ï¼Œåˆ†å¸ƒå¼äº‹åŠ¡ä¸‡å²ï¼æ¥è‡ªJ On the Beach 2018 ã€‚é˜…è¯»æœ‰å…³äº¤æ˜“ï¼Œé¢å‘å‚ä¸è€…çš„æ•°æ®åº“ç³»ç»Ÿä»¥åŠå…¶ä»–ä¸»é¢˜çš„ç ”ç©¶è®ºæ–‡ã€‚ OrleansMicrosoft Researchç½‘ç«™ ã€‚ ç›´æ¥å®¢æˆ· Orleans2.1å¼•å…¥äº†ä¸€ç§ä¸Grainsè¿›è¡Œäº¤äº’å¹¶ä¸ASP.NETæˆ–gRPCç­‰æ¡†æ¶è¿›è¡Œäº’æ“ä½œçš„æ–°æ–¹æ³•ã€‚è¯¥åŠŸèƒ½ç§°ä¸º ç›´æ¥å®¢æˆ· å¹¶ä¸”å®ƒå…è®¸ä»¥ä¸€ç§æ–¹å¼å…±åŒæ‰˜ç®¡å®¢æˆ·ç«¯å’Œå­¤å²›ï¼Œä»è€Œä½¿å®¢æˆ·ç«¯ä¸ä»…å¯ä»¥ä¸å…¶è¿æ¥çš„å­¤å²›ï¼Œè€Œä¸”å¯ä»¥ä¸æ•´ä¸ªé›†ç¾¤è¿›è¡Œæ›´æœ‰æ•ˆçš„é€šä¿¡ã€‚å¯ç”¨ç›´æ¥å®¢æˆ·ç«¯åï¼Œ IClusterå®¢æˆ·ç«¯ å’Œ IGrainå·¥å‚ å¯ä»¥ä»siloså®¹å™¨ä¸­è§£æå‡ºæ¥ï¼Œå¹¶ç”¨äºåˆ›å»ºå¯ä»¥è°ƒç”¨çš„Grainså¼•ç”¨ã€‚è¿™äº›è°ƒç”¨ä½¿ç”¨æœ¬åœ°siloså¯¹ç¾¤é›†å’Œgrainsä½ç½®çš„äº†è§£æ¥é¿å…ä¸å¿…è¦çš„å¤åˆ¶ï¼Œåºåˆ—åŒ–å’Œç½‘ç»œè·ƒç‚¹ã€‚å¦å¤–ï¼Œç”±äºæ­¤åŠŸèƒ½ä¸silosæœ¬èº«å…·æœ‰ç›¸åŒçš„å†…éƒ¨ç»“æ„ï¼Œå› æ­¤åœ¨çº¿ç¨‹é—´ä¼ é€’Grainså¼•ç”¨æ—¶ï¼Œå®ƒæä¾›äº†æ— ç¼çš„ä½“éªŒã€‚åœ¨Orleans2.1ä¸­ï¼Œæˆ‘ä»¬å°†ç›´æ¥å®¢æˆ·ä½œä¸ºé€‰æ‹©åŠ å…¥çš„åŠŸèƒ½ã€‚é€šè¿‡è°ƒç”¨å¯ç”¨å®ƒ ISiloHostBuilder.EnableDirectClient() åœ¨silosé…ç½®æœŸé—´ã€‚ æ–°ä»£ç ç”Ÿæˆå™¨ æ­¤ç‰ˆæœ¬åŒ…æ‹¬ä¸€ä¸ªæ–°çš„ä»£ç ç”ŸæˆåŒ…ï¼Œ Microsoft.Orleans.CodeGenerator.MSBuild ï¼Œæ˜¯ç°æœ‰è½¯ä»¶åŒ…çš„æ›¿ä»£å“ï¼Œ Microsoft.Orleans.OrleansCodeGenerator.Build ã€‚æ–°çš„ä»£ç ç”Ÿæˆå™¨åˆ©ç”¨Roslynè¿›è¡Œä»£ç åˆ†æï¼Œä»¥é¿å…åŠ è½½åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶ã€‚ç»“æœï¼Œå®ƒé¿å…äº†å› ç›¸äº’ä¾èµ–çš„ç‰ˆæœ¬å†²çªå’Œç›®æ ‡æ¡†æ¶ä¸åŒè€Œå¯¼è‡´çš„é—®é¢˜ã€‚å¦‚æœæ‚¨é‡åˆ°é—®é¢˜ï¼Œè¯·é€šè¿‡æ‰“å¼€ä¸€ä¸ªé—®é¢˜å‘ŠçŸ¥æˆ‘ä»¬ çš„GitHub ã€‚æ–°çš„ä»£ç ç”Ÿæˆå™¨è¿˜æ”¹å–„äº†å¯¹å¢é‡æ„å»ºçš„æ”¯æŒï¼Œè¿™å°†ç¼©çŸ­æ„å»ºæ—¶é—´ã€‚ å…¶ä»–æ”¹è¿› Grainsæ–¹æ³•å¯ä»¥è¿”å› ValueTask <T> - è°¢è°¢ @kutensky åˆ é™¤äº†æ¯æ¬¡è®¿é—®è®¡æ—¶å™¨åˆ†é… ï¼Œå‡å°‘.NET Timeré˜Ÿåˆ—äº‰ç”¨ ä¿®æ­£ å¯¹äº Siloå…³é—­è¡Œä¸º-è°¢è°¢ @yevhen ç”¨äºæŠ¥å‘Šå’Œ è°ƒæŸ¥ä¸­ é…ç½®Grainsæ”¶é›† ç©ºé—²æ—¶é—´ä½¿ç”¨ [CollectionAgeLimit(åˆ†é’Ÿ= x)] - è°¢è°¢ @aRajeshKumar .NET Core 2.1çš„å·²çŸ¥é—®é¢˜ ç”¨æˆ· å­™å¿ å³°æŠ¥å‘Šäº†é—®é¢˜ åœ¨å¯ç”¨TieredCompilationçš„.NET Core 2.1ä¸Šè¿è¡ŒOrleansã€‚æˆ‘ä»¬å°†æ­¤å½’ç»“ä¸º CoreCLRä¸­çš„JITé—®é¢˜ ï¼ŒCoreCLRå›¢é˜Ÿè¿…é€Ÿå¯¹å…¶è¿›è¡Œäº†è¯Šæ–­å’Œä¿®å¤ã€‚.NET Core 2.1é»˜è®¤æƒ…å†µä¸‹æœªå¯ç”¨TieredCompilationï¼Œå¹¶ä¸”æ­¤ä¿®å¤ç¨‹åºæ˜¯ é¢„è®¡ä¸ä¼šå‡ºç°åœ¨.NET Core 2.1ä¸­ï¼Œä½†å°†åŒ…å«åœ¨.NET Core 2.2ä¸­ ã€‚ å¦‚æœæ‚¨åœ¨.NET Core 2.1ä¸Šè¿è¡ŒOrleansï¼Œè¯·ä¸è¦å¯ç”¨TieredCompilationã€‚ æˆ‘ä»¬è¦æ„Ÿè°¢ç¤¾åŒºä¸­ä¸ºè¯¥ç‰ˆæœ¬åšå‡ºè´¡çŒ®å¹¶å¸®åŠ©æµ‹è¯•é¢„å‘è¡Œç‰ˆæœ¬çš„æ¯ä¸ªäººã€‚"
  },
  "blog/welcome-to-orleans-blog.html": {
    "href": "blog/welcome-to-orleans-blog.html",
    "title": "æ¬¢è¿æ¥åˆ°Orleansåšå®¢ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ¬¢è¿æ¥åˆ°Orleansåšå®¢ é˜¿ææ‹‰Â·å“ˆå‰å¾·é‡Œå…‹ã€‚ 2016å¹´12æœˆ1æ—¥ä¸‹åˆ2:15:01 è¿™ç¯‡æ–‡ç« æ˜¯è°¢å°”ç›–Â·æ‹œç§‘å¤«å†™çš„ã€‚ è¿Ÿåšæ€»æ¯”ä¸åšå¥½-æˆ‘ä»¬ç»ˆäºä¸ºOrleanså¼€äº†ä¸€ä¸ªåšå®¢ã€‚å…·æœ‰è®½åˆºæ„å‘³çš„æ˜¯ï¼Œè¿™ä¸ªé¡¹ç›®èµ·æºäºè¿‘ä¸¤å¹´å‰çš„2008å¹´ã€‚æˆ‘ä»¬å¸Œæœ›ç”¨ä¸€äº›é«˜è´¨é‡çš„å†…å®¹æ¥å¼¥è¡¥é”™è¿‡çš„æ—¶é—´ã€‚æˆ‘ä»¬è®¡åˆ’åˆ†äº«æˆ‘ä»¬çš„æƒ³æ³•ï¼Œè®¡åˆ’ï¼Œå­¦ä¹ ï¼ŒæŠ€å·§å’Œè¯€çªï¼Œå’Œæƒ³æ³•ï¼Œç–¯ç‹‚çš„å’Œå…¶ä»–çš„ï¼Œä¸å®¹æ˜“ç¬¦åˆæ–‡ä»¶æ ¼å¼ã€‚æˆ‘ä»¬ä¹Ÿå¸Œæœ›çœ‹åˆ°æ¥è‡ªç¤¾åŒºæˆå‘˜çš„å¸–å­ï¼Œåˆ†äº«ä»–ä»¬çš„ç»éªŒã€æƒ³æ³•å’Œæ™ºæ…§ã€‚æ‰€ä»¥ï¼Œæ¬¢è¿æ¥åˆ°Orleansåšå®¢ï¼Œæ— è®ºæ˜¯ä½œä¸ºä¸€ä¸ªè¯»è€…è¿˜æ˜¯ä½œä¸ºä¸€ä¸ªåšå®¢ä½œè€…ï¼"
  },
  "blog/orleans-2.0-tech-preview-supporting-.net-core.html": {
    "href": "blog/orleans-2.0-tech-preview-supporting-.net-core.html",
    "title": "æ”¯æŒ.NET Coreçš„Orleans 2.0 Tech Preview | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ”¯æŒ.NET Coreçš„Orleans 2.0 Tech Preview æœ±åˆ©å®‰Â·å¤šæ˜æ ¼æ–¯(Julian Dominguez) 2016/12/5ä¸Šåˆ11:52:59 ä½¿Orleansä¸.NET Standardå…¼å®¹å·²ç»æ˜¯ä¸€ä¸ªæ¼«é•¿çš„è¿‡ç¨‹ï¼Œä½†æ˜¯æˆ‘ä»¬ç»ˆäºæœ‰äº†ä¸€ä¸ªæœ€ä½é™åº¦çš„å¯è¡Œç‰ˆæœ¬ï¼Œå¯ä»¥å¼€å§‹åœ¨.NET Coreä¸­ç©äº†ï¼:) Orleans2.0æŠ€æœ¯é¢„è§ˆç‰ˆ1åˆšåˆšå‘å¸ƒåˆ°MyGetï¼š https://dotnet.myget.org/gallery/orleans-ci (è¦ä¹ˆ https://dotnet.myget.org/F/orleans-ci/api/v3/index.json åœ¨NuGetä¸­é…ç½®Feed) ä¸Orleans1.Xçš„å·®å¼‚ Orleans2.0æŠ€æœ¯é¢„è§ˆç‰ˆä¸å…·å¤‡Orleans1.Xçš„å…¨éƒ¨åŠŸèƒ½ï¼Œå› ä¸ºæˆ‘ä»¬ç§»æ¤äº†è·å¾—ä½“é¢ä½“éªŒæ‰€éœ€çš„æœ€ä½è¦æ±‚ï¼Œå¹¶ä¸”å¯ä»¥è¯´æ˜¯ç§»æ¤éš¾åº¦æœ€å¤§/é£é™©æœ€é«˜çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬å¸Œæœ›ä»ç°åœ¨å¼€å§‹ï¼Œå…¶ä½™æ‰©å±•çš„è¿ç§»é€Ÿåº¦ä¼šæ›´å¿«ã€‚ æ­¤é¢„å‘è¡Œç‰ˆæœ¬ä¸­çš„ä¸€äº›æ˜¾ç€å·®å¼‚æˆ–å¾…å¤„ç†äº‹é¡¹ï¼š Orleansä»£ç ç”Ÿæˆ åªæœ‰åœ¨å®‰è£…äº†.NET 4.6.2çš„Windowsä¸Šè¿›è¡Œæ„å»ºæ—¶ï¼Œæ„å»ºæ—¶é—´ä»£ç ç”Ÿæˆå™¨(Microsoft.Orleans.OrleansCodeGenerator.Build nugetç¨‹åºåŒ…)æ‰èµ·ä½œç”¨ã€‚å®ƒè¿˜éœ€è¦.NET Core Preview3å·¥å…·æˆ–æ›´é«˜ç‰ˆæœ¬(å¦‚æœæ˜¯åœ¨VSä¸­æ„å»ºï¼Œåˆ™ä¸ºVS2017 RC)ã€‚ ä½†æ˜¯ï¼Œè¿è¡Œæ—¶ä»£ç ç”Ÿæˆæ˜¯è·¨å¹³å°å·¥ä½œçš„å¯è¡Œæ›¿ä»£æ–¹æ³•(é€šè¿‡å¼•ç”¨Siloå®¿ä¸»å’Œå®¢æˆ·ç«¯é¡¹ç›®ä¸­çš„Microsoft.Orleans.OrleansCodeGeneratorç¨‹åºåŒ…)ã€‚ ä¸ºäº†è·å¾—å¯é çš„ç¾¤é›†æˆå‘˜èº«ä»½ï¼Œå­˜å‚¨å’Œæµï¼Œç›®å‰ä»…è¿ç§»äº†Azureå­˜å‚¨æä¾›ç¨‹åºã€‚å…¶ä½™çš„å³å°†æ¨å‡º(æˆ–éšæ—¶ä¸ºå®ƒä»¬è´¡çŒ®ä¸€ä¸ªç«¯å£)ã€‚ .NET Standardä¸­å°šä¸æä¾›BinaryFormatter(å†…ç½®çš„.NETåºåˆ—åŒ–)ï¼Œå®ƒå·²åœ¨Orleansä¸­ç”¨ä½œé»˜è®¤çš„åå¤‡åºåˆ—åŒ–å™¨(é€šå¸¸åœ¨åºåˆ—åŒ–å¼‚å¸¸æ—¶ä½¿ç”¨)ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æœ‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„åŸºäºILçš„åå¤‡åºåˆ—åŒ–å™¨ï¼Œè¯¥åºåˆ—åŒ–å™¨åº”å¿«é€Ÿè€Œå¼ºå¤§ï¼Œä½†å¦‚æœæ‚¨ç°æœ‰çš„ä»£ç ä¾èµ–äºå®ƒï¼Œåˆ™å…¶è¡Œä¸ºå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒ[Serializable]ã€‚ .NETæ ‡å‡†ä¸­ä¸æ”¯æŒSystem.Diagnostic.Trace.CorrelationManager.ActivityIdã€‚å¦‚æœæ‚¨ä¾èµ–äºæ­¤æ¥å…³è”Grainsè°ƒç”¨ï¼Œè¯·è€ƒè™‘æ”¹ç”¨Orleans.Runtime.RequestContext.ActivityIdã€‚ å‡†å¤‡ç”Ÿäº§äº†å—ï¼Ÿ æ²¡æœ‰ã€‚ å¤§å£°æ˜ï¼šæˆ‘ä»¬åœ¨.NETä¸­è¿›è¡ŒCIæµ‹è¯•(å› ä¸ºæˆ‘ä»¬çš„æµ‹è¯•ä¸¥é‡ä¾èµ–AppDomainsåˆ›å»ºå†…å­˜å­¤å²›ç¾¤é›†ï¼Œè€Œ.NET Coreä¸æ”¯æŒè¿™äº›å­¤å²›ï¼Œä½†æˆ‘ä»¬è®¡åˆ’å°½å¿«è§£å†³)ã€‚æˆ‘ä»¬å·²ç»åœ¨.NET Core(åŒ…æ‹¬Windowså’ŒLinux)ä¸­å®Œæˆäº†ä¸€äº›åŸºæœ¬çš„æ‰‹åŠ¨æµ‹è¯•ï¼Œä½†æ˜¯ä¼šé‡åˆ°ä¸€äº›é—®é¢˜ã€‚è·å¾—åé¦ˆ(å’ŒPRï¼)æ˜¯æ­¤ç‰ˆæœ¬çš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ï¼Œå°šæœªåœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ã€‚ æ­¤å¤–ï¼Œå³ä½¿å¯¹äºå·²å®Œå…¨ç§»æ¤çš„åŠŸèƒ½ï¼Œä¹Ÿæ— æ³•ä¿è¯æ­¤æŠ€æœ¯é¢„è§ˆç‰ˆä¸Orleans 1.3å®Œå…¨å‘åå…¼å®¹ã€‚ä¸€æ—¦æ¥è¿‘ç¨³å®šç‰ˆæœ¬ï¼Œæˆ‘ä»¬å°†åˆ—å‡ºæ‰€æœ‰å·²çŸ¥çš„é‡å¤§æ›´æ”¹ï¼Œä»¥é˜²æ‚¨æœ‰å…´è¶£å°†åº”ç”¨ç¨‹åºä»1.3å‡çº§åˆ°2.0ã€‚å› ä¸ºæ­¤æŠ€æœ¯é¢„è§ˆç‰ˆä¸å…·å¤‡1.Xå‘è¡Œç‰ˆçš„å…¨éƒ¨åŠŸèƒ½ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›®å‰ä»…åœ¨MyGetä¸­å‘è¡Œã€‚ è¿è¡Œæ ·æœ¬ æˆ‘åˆ›å»ºäº†ä¸€ä¸ªåœ¨.NET Coreä¸­è¿è¡Œçš„å°å‹Hello Worldç¤ºä¾‹åº”ç”¨ç¨‹åºï¼Œæ¬¢è¿æ‚¨ä½¿ç”¨å®ƒä½œä¸ºèµ·ç‚¹ã€‚ è¯¥ç¤ºä¾‹ä½äºæ­¤å¤„ï¼š https://github.com/jdom/OrleansHelloWorldSample.Core åœ¨Linuxä¸­è¿è¡ŒOrleansçš„ç¤ºä¾‹åº”ç”¨ç¨‹åº äº«å—å®ƒï¼Œç©å¼„å®ƒï¼Œå¹¶è®©æˆ‘ä»¬çŸ¥é“æ‚¨çš„æƒ³æ³•ï¼Œæ— è®ºæ˜¯GitHubé—®é¢˜ï¼ŒPRè¿˜æ˜¯åªæ˜¯åœ¨æˆ‘ä»¬çš„Gitteré¢‘é“ä¸­é—²é€›ã€‚"
  },
  "blog/latest-release-1.3.1.html": {
    "href": "blog/latest-release-1.3.1.html",
    "title": "æœ€æ–°ç‰ˆæœ¬-1.3.1 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æœ€æ–°ç‰ˆæœ¬-1.3.1 è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov) 2016/12/1ä¸‹åˆ5:48:39 11æœˆ15æ—¥ï¼Œæˆ‘ä»¬å‘å¸ƒäº†æˆ‘ä»¬çš„ æœ€æ–°ç‰ˆæœ¬-1.3.1 ã€‚æ­¤ä¿®è¡¥ç¨‹åºç‰ˆæœ¬è‡ª1.3.0èµ·å·²åˆå¹¶åˆ°masterä¸­ï¼Œå…¶ä¸­åŒ…å«è®¸å¤šé”™è¯¯ä¿®å¤å’Œæ”¹è¿›ã€‚1.3.1æœ‰ä¸¤ä¸ªä¸»è¦åŸå› ã€‚ 343 Industrieséœ€è¦ä¸€ä¸ªåœ¨æµä¼ è¾“æ–¹é¢è¿›è¡Œäº†ä¸€äº›æ”¹è¿›çš„ç‰ˆæœ¬ï¼Œä»¥åŠEventHubæµæä¾›ç¨‹åºï¼Œä»¥ç®€åŒ–ä»Halo 5å‘å¸ƒä¹‹å‰ä¸€ç›´åœ¨è¿è¡Œçš„æµå‘è¡Œå †æ ˆçš„é¢„å‘è¡Œç‰ˆæœ¬çš„è¿ç§»ã€‚ Orleanså¡ éœ€è¦ä¸€ä¸ªç›¸å½“é«˜çº§çš„åŠŸèƒ½ï¼Œä½¿ä»–ä»¬å¯ä»¥åœ¨æ¯ä¸ªæ¶ˆæ¯çš„åŸºç¡€ä¸Šæ§åˆ¶è¯·æ±‚çš„äº¤ç»‡ã€‚ @yevhen æäº¤äº†ä¸€ä»½å…¬å…³ ä¸ºæ­¤ï¼Œç»è¿‡å‡ æ¬¡è®¾è®¡å’Œå®ç°è¿­ä»£ã€‚ å› æ­¤ï¼Œ1.3.1ä¸æ˜¯çº¯è¡¥ä¸ç¨‹åºå‘è¡Œç‰ˆï¼Œå› ä¸ºå®ƒåŒ…å«ä¸€é¡¹æ–°åŠŸèƒ½ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™é‡Œè¿˜å¯ä»¥ï¼Œå› ä¸ºè¯¥åŠŸèƒ½å®é™…ä¸Šå¯¹å…¶ä»–äººæ²¡æœ‰å½±å“ã€‚ å¦‚æœè¦ä»1.2.xæˆ–æ›´æ—©çš„ç‰ˆæœ¬å‡çº§åˆ°1.3.1ï¼Œè¯·æ³¨æ„åœ¨1.3.0ä¸­æ‰€åšçš„ç»†å¾®æ›´æ”¹ã€‚çš„ 1.3.0å‘è¡Œè¯´æ˜ å–Šå‡ºæ¥ï¼š æ³¨æ„ï¼šæ­¤ç‰ˆæœ¬ä¸­æœ‰ä¸€ä¸ªå¾®å¦™çš„é‡å¤§æ›´æ”¹ï¼Œå¾ˆå®¹æ˜“é”™è¿‡ã€‚ å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ AzureSilo.Start(ClusterConfigurationé…ç½®ï¼Œå­—ç¬¦ä¸²DeploymentId) åœ¨æ‚¨çš„ä»£ç ä¸­ï¼Œè¯¥é‡è½½å·²è¢«åˆ é™¤ï¼Œä½†æ˜¯æ›¿æ¢å®ƒçš„æ–°é‡è½½å…·æœ‰ç›¸åŒçš„å‚æ•°ç­¾åï¼Œä½†å…·æœ‰ä¸åŒçš„ç¬¬äºŒä¸ªå‚æ•°ï¼š (ClusterConfigurationé…ç½®ï¼Œå­—ç¬¦ä¸²connectionString) ã€‚ç°åœ¨å¿…é¡»å°†éƒ¨ç½²IDä½œä¸ºconfigå‚æ•°çš„ä¸€éƒ¨åˆ†ä¼ é€’ï¼šconfig.Globals.DeploymentIdã€‚è¿™æ ·å°±æ¶ˆé™¤äº†ä¼ é€’ä¸¤ä¸ªä¸åŒçš„éƒ¨ç½²IDçš„ä¸ç¡®å®šæ€§ï¼Œä½†æ˜¯ä¸å¹¸çš„æ˜¯ï¼Œè¿™éœ€è¦ä»˜å‡ºç ´åæ€§çš„APIæ›´æ”¹çš„ä»£ä»·ã€‚ 1.3.0æ˜¯ä¸€ä¸ªç›¸å½“å¤§çš„ç‰ˆæœ¬ï¼Œå…·æœ‰è®¸å¤šæ”¹è¿›ï¼Œé”™è¯¯ä¿®å¤ä»¥åŠåœ°ç†åˆ†å¸ƒçš„å¤šé›†ç¾¤çš„ä¸»è¦æ–°åŠŸèƒ½ã€‚å®ƒçš„å¤§éƒ¨åˆ†å†…å®¹éƒ½åˆ—åœ¨ 1.3.0-beta2å‘è¡Œè¯´æ˜ ã€‚åœ°ç†åˆ†å¸ƒåŠŸèƒ½åœ¨ å¤šé›†ç¾¤æ”¯æŒéƒ¨åˆ† æ–‡æ¡£ã€‚"
  },
  "blog/solving-a-transactions-performance-mystery.html": {
    "href": "blog/solving-a-transactions-performance-mystery.html",
    "title": "è§£å†³äº¤æ˜“ç»©æ•ˆä¹‹è°œ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è§£å†³äº¤æ˜“ç»©æ•ˆä¹‹è°œ é²æœ¬Â·é‚¦å¾· 2018/12/7ä¸Šåˆ10:08:58 åˆ°è¾¾é›·å¾·è’™å¾·å¹¶å®Œæˆå¼ºåˆ¶æ€§çš„æ–°å‘˜å·¥å…¥èŒåŸ¹è®­åï¼Œæˆ‘åœ¨Orleanså›¢é˜Ÿçš„ç¬¬ä¸€é¡¹ä»»åŠ¡å°±æ˜¯ååŠ©è¿›è¡Œä¸€äº›æŒç»­çš„ç»©æ•ˆè°ƒæŸ¥ï¼Œä»¥ç¡®ä¿å†…éƒ¨äººå‘˜å¯ä»¥ä½¿ç”¨Orleansçš„äº¤æ˜“æ”¯æŒå¹¶å› æ­¤è€Œé‡Šæ”¾ã€‚ åœ¨é’ˆå¯¹æˆ‘ä»¬çš„æµ‹è¯•é›†ç¾¤çš„å‹åŠ›/è´Ÿè½½æµ‹è¯•ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸¥é‡çš„æ€§èƒ½é—®é¢˜å’Œå¤§é‡äº‹åŠ¡å¤±è´¥ã€‚å¾ˆå¤§ä¸€éƒ¨åˆ†äº‹åŠ¡ä¸€ç›´æš‚åœç›´åˆ°è¶…æ—¶ã€‚ æˆ‘ä»¬æœ€åˆçš„è°ƒæŸ¥é›†ä¸­åœ¨äº‹åŠ¡ç®¡ç†ä»£ç ä¸Šã€‚ä¹Ÿè®¸æŸä¸ªåœ°æ–¹é™·å…¥åƒµå±€ã€‚æˆ‘ä»¬é‡‡ç”¨äº†åˆ†è€Œæ²»ä¹‹çš„æ–¹æ³•ï¼Œå°†å†…éƒ¨äº¤æ˜“ç»„ä»¶æ›¿æ¢ä¸ºæ®‹å­˜çš„å˜ä½“ã€‚è¿™ä¸ªé—®é¢˜æˆ–å¤šæˆ–å°‘æ˜¯å­¤ç«‹çš„ ITransactionalState <T> å®æ–½å–å†³äºæ¯ä¸ªæ–¹é¢ã€‚äº‹åŠ¡çŠ¶æ€è´Ÿè´£åŠ è½½å’Œä¿®æ”¹GrainsçŠ¶æ€å¹¶å¤„ç†å„ç§äº‹åŠ¡é˜¶æ®µ(å¼€å§‹ï¼Œå‡†å¤‡ï¼Œä¸­æ­¢ï¼Œæäº¤ï¼Œç¡®è®¤)ï¼Œå¹¶ä½¿ç”¨è¯»å†™å™¨é”åœ¨éš”ç¦»ä¿è¯å†…ä¼˜åŒ–å¤šä¸ªé‡å äº‹åŠ¡ã€‚æ‚¨å¯ä»¥çœ‹åˆ°è¿™ä¸æ˜¯ä¸€ä¸ªå°æ•°ç›®çš„ä»£ç ï¼Œä½†æ˜¯äº‹å®è¯æ˜ï¼Œè¿›ä¸€æ­¥éš”ç¦»é—®é¢˜æ˜¯å›°éš¾çš„ï¼ŒåŸå› ä¸ä»…ä»…é™äºä»¥ä¸‹äº‹å®ï¼šå–å‡ºä»»ä½•ä¸€æ®µä»£ç éƒ½æ²¡æœ‰æ˜¾ç€æ”¹å–„ã€‚ åˆ†ææ•°æ®å¯¹äºæ€§èƒ½è°ƒæŸ¥è‡³å…³é‡è¦ï¼Œå› æ­¤ï¼Œåœ¨è¯·æ±‚è·å¾—ç›´æ¥è®¿é—®æˆ‘ä»¬æµ‹è¯•é›†ç¾¤ä¸­æœºå™¨çš„æƒé™ä¹‹åï¼Œæˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ”¶é›†äº†ETWæ—¥å¿—ï¼š PerfView ä½¿ç”¨ä¸æ­¤ç±»ä¼¼çš„å‘½ä»¤ï¼š PerfView.exe /acceptEULA /noGui /threadTime /zip /maxCollectSec:30 /dataFile:1.etl collect åˆ†æç»“æœ .etl æœ¬åœ°æ–‡ä»¶ï¼ŒæŸ¥çœ‹ ç«ç„°å›¾ å¯¹äºå †æ ˆè·Ÿè¸ªæ ·æœ¬ï¼Œé—®é¢˜ç«‹å³æ˜¾è€Œæ˜“è§ã€‚ PerfViewä½¿é—®é¢˜çš„åŸå› æ˜¾è€Œæ˜“è§ã€‚ è¯¦ç»†ä¿¡æ¯å¤ªå°è€Œæ— æ³•åœ¨è¯¥è§†å›¾ä¸Šé˜…è¯»ï¼Œä½†æ˜¯é€šè¿‡å°†é¼ æ ‡æ‚¬åœåœ¨æ¯ä¸ªå°èŠ‚ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å †æ ˆæ¡†æ¶ä»£è¡¨å“ªç§æ–¹æ³•ã€‚ç®­å¤´æŒ‡å‘CPUç­‰å¾…é”çš„å †æ ˆå¸§ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯¥é”ä½äºå…¨å±€.NET Timeré˜Ÿåˆ—ä¸­ã€‚å‘å³çš„å¹³ç¨³æœŸæ¥è‡ªäºä¸ºè®¡æ—¶å™¨é˜Ÿåˆ—æä¾›æœåŠ¡å¹¶è§¦å‘åˆ°æœŸçš„è®¡æ—¶å™¨çš„çº¿ç¨‹ï¼Œè¿™ä¹Ÿéœ€è¦è·å–é”å®šã€‚ æˆ‘ä»¬çš„è´Ÿè½½æµ‹è¯•åœ¨.NET Framework 4.6.2ä¸Šè¿è¡Œï¼Œå› æ­¤ System.Threading.Timer æ˜¯ä½¿ç”¨ è®¡æ—¶å™¨çš„å…¨å±€é˜Ÿåˆ—(é“¾æ¥åˆ—è¡¨) ç”±å•ä¸ªé”å®šå¯¹è±¡ä¿æŠ¤ã€‚æ­¤é˜Ÿåˆ—ä¸Šçš„ä»»ä½•æ“ä½œéƒ½å¿…é¡»è·å¾—è¯¥é”ã€‚è¿™æ˜¯æˆ‘ä»¬å·²ç»çŸ¥é“çš„ï¼ŒOrleans 2.1.0åŒ…å«ä¸€ä¸ª PRå‡è½»äº†æ­¤é˜Ÿåˆ—ä¸Šçš„æ½œåœ¨é”äº‰ç”¨ ç”¨äºæˆ‘ä»¬çš„ä¸»è¦è®¡æ—¶å™¨æ¥æº(å“åº”è¶…æ—¶è®¡æ—¶å™¨)ã€‚ äº¤æ˜“ä»£ç ä»ä¸ä½¿ç”¨ è®¡æ—¶å™¨ ï¼Œé‚£ä¸ºä»€ä¹ˆä¼šæœ‰é—®é¢˜å‘¢ï¼Ÿäº¤æ˜“åˆ©ç”¨ Task.Delay ç”¨äºå¤šç§ä»»åŠ¡ï¼Œå®ƒæ˜¾ç¤ºåœ¨å¤§å¤šæ•°ç»„ä»¶ä¸­ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸èƒ½å°†æ€§èƒ½é—®é¢˜ç¼©å°åˆ°ä¸€æ®µç‰¹å®šçš„ä»£ç çš„åŸå› ã€‚ Task.Delay ä½¿ç”¨ä¸€ä¸ª è®¡æ—¶å™¨ åœ¨å¼•æ“ç›–ä¸‹ï¼Œåˆ›å»ºä¸€ä¸ª è®¡æ—¶å™¨ å¯èƒ½ä¼šè§¦å‘ä¸€æ¬¡(å¦‚æœæœªå–æ¶ˆçš„è¯)ï¼Œå¹¶åœ¨ä¸å†éœ€è¦æ—¶æ³¨é”€å®ƒã€‚æˆ‘ä»¬çš„ä½¿ç”¨ Task.Delay åœ¨è´Ÿè½½ä¸‹å¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ .NET Core 3.0ç”¨æˆ·å¯èƒ½ä»æœªè§è¿‡è¿™æ ·çš„äº‰ç”¨ï¼Œå› ä¸º.NET Coreè¿›è¡Œäº†å¤§é‡å·¥ä½œä»¥è¿›è¡Œæ”¹è¿› è®¡æ—¶å™¨ å’Œ Task.Delay æ€§èƒ½ã€‚çœ‹åˆ° ï¼ƒ14527 å’Œ ï¼ƒ20302 ã€‚ æˆ‘ä»¬å¦‚ä½•è§£å†³è¿™ä¸€äº‰æ‰§ï¼Ÿåœ¨ç¡®è®¤è¿™é‡Œçš„ä¿®å¤ç¨‹åºå®é™…ä¸Šå¯ä»¥è§£å†³è¯¥é—®é¢˜(æˆåŠŸï¼)ä¹‹åï¼Œæˆ‘ç€æ‰‹å®æ–½ä¸€ä¸ªæœ‰å¸Œæœ›çš„ç®€å•æ›¿ä»£å“ Task.Delay ã€‚ç»“æœæ˜¯ åœ¨è¿™ä¸ªå…¬å…³ ã€‚å…¶å·¥ä½œåŸç†çš„è¦ç‚¹æ˜¯å®ƒä½¿ç”¨å•ä¸ª è®¡æ—¶å™¨ å®ä¾‹ä»¥æœåŠ¡çº¿ç¨‹æœ¬åœ°è®¡æ—¶å™¨é›†åˆã€‚è®¡æ—¶å™¨çš„ç‚¹ç«ä¸éœ€è¦ç²¾ç¡®ï¼Œå› æ­¤åœ¨è¿™äº›ç”¨é€”ä¸­ä¸å¿…æ‹…å¿ƒå»¶è¿Ÿç‚¹ç«ã€‚é€šè¿‡ä½¿ç”¨çº¿ç¨‹å±€éƒ¨æ•°æ®ç»“æ„å¯å¾ˆå¤§ç¨‹åº¦ä¸Šé¿å…é”äº‰ç”¨ï¼Œä½†é€šè¿‡ä½¿ç”¨è½»é‡çº§Reentrantå™¨å¯ä¿ç•™å®‰å…¨æ€§ äº’é”æ¯”è¾ƒäº¤æ¢ é”ã€‚çœ‹åˆ° å…¬å…³ æ›´å¤šç»†èŠ‚ã€‚ è¯¥å®æ–½åŸºäºä¹‹å‰çš„å·¥ä½œ @dVakulen åœ¨ ï¼ƒ2060å¹´ å¹¶å¯¼è‡´ååé‡æé«˜çº¦4å€ï¼Œè€Œæ•…éšœç‡é™è‡³é›¶ã€‚è°œå›¢å·²æ­å¼€ã€‚"
  },
  "blog/refresh-of-orleans-2.0-tech-preview-with-orleanssqlutils-added.html": {
    "href": "blog/refresh-of-orleans-2.0-tech-preview-with-orleanssqlutils-added.html",
    "title": "æ·»åŠ OrleansSQLUtilsåˆ·æ–°Orleans 2.0 Tech Preview | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ·»åŠ OrleansSQLUtilsåˆ·æ–°Orleans 2.0 Tech Preview è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov) 2016/12/15ä¸‹åˆ2:45:47 æˆ‘ä»¬å‘å¸ƒäº†2.0ç‰ˆæŠ€æœ¯é¢„è§ˆç‰ˆçš„æ›´æ–°ï¼Œå…¶ä¸­æ·»åŠ äº† Microsoft.Orleans.OrleansSqlUtils åŒ…ã€‚è¿™æ ·å¯ä»¥ä½¿ç”¨Microsoft SQL Serverï¼ŒMySQLï¼ŒPosgreSQLå’Œå…¶ä»–å…¼å®¹çš„SQL Serverè¿›è¡Œç¾¤é›†æˆå‘˜å­˜å‚¨å’ŒGrainçŠ¶æ€æŒä¹…åŒ–ã€‚éå¸¸æ„Ÿè°¢ Gutemberg Ribeiro ä¸ºå¸®åŠ©ï¼ æ‚¨å¯ä»¥ä»MyGetè·å–è½¯ä»¶åŒ…ï¼š https://dotnet.myget.org/gallery/orleans-ci (è¦ä¹ˆ https://dotnet.myget.org/F/orleans-ci/api/v3/index.json åœ¨NuGetä¸­é…ç½®Feed)ã€‚"
  },
  "blog/orleans-and-midori.html": {
    "href": "blog/orleans-and-midori.html",
    "title": "Orleanså’Œç±³å¤šé‡Œ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleanså’Œç±³å¤šé‡Œ è´ç§‘å¤« 2016å¹´12æœˆ11æ—¥ä¸‹åˆ10:56:13 è¯»ä¹”Â·è¾¾è²çš„å²è¯— å…±äº‹15å¹´ æ³¢æ–¯ç‰¹å¸¦æ¥äº†Orleansæ—©æœŸçš„ä¸€äº›å¾€äº‹ã€‚å®ƒç”šè‡³è¿«ä½¿æˆ‘æŒ–æ˜å¹¶å°è¯•ç¼–è¯‘2009å¹´çš„ä»£ç ã€‚è¿™æ˜¯ä¸€ä¸ªæœ‰è¶£çš„ç»ƒä¹ ã€‚ å½“æˆ‘ä»¬åˆšå¼€å§‹Orleansé¡¹ç›®æ—¶ï¼Œæˆ‘ä»¬ä¼šå®šæœŸä¸Midoriäººä¼šé¢å’Œäº¤è°ˆã€‚è¿™æ˜¯å¾ˆè‡ªç„¶çš„ï¼Œä¸ä»…æ˜¯å› ä¸ºé—®é¢˜ç©ºé—´æœ‰ä¸€äº›æ˜æ˜¾çš„é‡å ï¼Œè€Œä¸”å› ä¸ºå­•è‚²Orleansçš„å‰å§†Â·æ‹‰é²æ–¯æ˜¯ å¥‡ç‚¹ ç±³å¤šé‡Œçš„èµ·ç‚¹ã€‚æˆ‘ä»¬ç«‹å³å€Ÿç”¨äº†Midoriçš„promisesåº“ï¼Œå› ä¸ºæˆ‘ä»¬æƒ³ä½¿ç”¨åŸºäºpromiseçš„å¹¶å‘æ¥å®‰å…¨æ‰§è¡Œå’Œé«˜æ•ˆçš„RPCã€‚æˆ‘ä»¬æ²¡æœ‰è´¹å¿ƒå°è¯•é›†æˆä»£ç ï¼Œåªæ˜¯ç®€å•åœ°è·å–äº†äºŒè¿›åˆ¶æ–‡ä»¶å¹¶å°†å®ƒä»¬ç­¾å…¥åˆ°æˆ‘ä»¬çš„æºä»£ç æ ‘ä¸­ã€‚æˆ‘ä»¬å¤„äºæ—©æœŸåŸå‹é˜¶æ®µï¼Œè¿˜ä¸å¿…æ‹…å¿ƒé•¿æœŸæ€§ã€‚ å½“æ—¶ï¼Œgrainsæ¥å£æ˜¯è¿™æ ·çš„ï¼š [Eventual] public interface ISimpleGrain : IEventual { [Eventual] PVoid SetA(int a); [Eventual] PVoid SetB(int b); [Eventual] PInt32 GetAxB(); } PVoid å’Œ é’ˆè„š32 åœ¨é“å¾·ä¸Šç­‰åŒäº ä»»åŠ¡å’Œä»»åŠ¡\\<int>åœ¨ç¬¬ä¸‰æ–¹ç‰©æµ . ä¸Tasksä¸åŒï¼Œå®ƒä»¬æœ‰è®¸å¤šé™æ€æ–¹æ³•ï¼Œå…¶ä¸­ä¸€ä¸ªæ›´ç®€å•çš„é‡è½½ä½¿ç”¨ä¸¤ä¸ªlambdaï¼šä¸€ä¸ªç”¨äºæˆåŠŸæ¡ˆä¾‹ï¼Œå¦ä¸€ä¸ªç”¨äºå¤„ç†æŠ›å‡ºçš„å¼‚å¸¸ï¼š public static PVoid When(PVoid target, Action fn, Action<Exception> catchFn); ä¸€ä¸ªç®€å•çš„çº¹ç†æ–¹æ³•çœ‹èµ·æ¥åƒï¼š public PVoid SetA(int a) { this.a = a; return PVoid.DONE; } ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°ä»»åŠ¡å®Œæˆäº†ã€‚å®Œæˆäº†æ¥è‡ªã€‚ä¸€ä¸ªç®€å•çš„å•å…ƒæµ‹è¯•æ–¹æ³•çœ‹èµ·æ¥ç›¸å½“å¤æ‚ï¼š [TestMethod] public void SimpleGrainDataFlow() { result = new ResultHandle(); Runner.Enqueue(new SimpleTodo(() => { Promise<SimpleGrainReference> clientPromise = SimpleGrainReference.GetReference(\"foo\"); PVoid.When(clientPromise, reference => { grain = reference; Assert.IsNotNull(grain); PVoid setPromise = grain.SetA(3); PVoid.When(setPromise, () => { setPromise = grain.SetB(4); PVoid.When(setPromise, () => { PInt32 intPromise = grain.GetAxB(); PVoid.When<Int32>(intPromise, x => { result.Result = x; result.Done = true; }, exc => { Assert.Fail(\"Exception thrown by GetAxB: \" + exc.Message); return PVoid.DONE; }); }, exc => { Assert.Fail(\"Exception thrown by SetB: \" + exc.Message); return PVoid.DONE; }); }, exc => { Assert.Fail(\"Exception thrown by SetA: \" + exc.Message); return PVoid.DONE; }); }, exc => { result.Exception = exc; result.Done = true; return PVoid.DONE; }); })); Assert.IsTrue(result.WaitForFinished(timeout)); Assert.IsNotNull(result.Result); Assert.AreEqual(12, result.Result); } åµŒå¥—whenæ˜¯ç»„ç»‡æ•°æ®æµæ‰§è¡Œç®¡é“æ‰€å¿…éœ€çš„ã€‚ è·‘æ­¥è€… æ˜¯ å¤–å›½æŠ•èµ„è€… ï¼Œè¿™æ˜¯æ³¨å…¥å¼‚æ­¥ä»»åŠ¡çš„æ–¹æ³•ä¹‹ä¸€( æ‰˜å¤š s) å˜æˆä¸€ä¸ª æ‰˜å¤šç»ç† . æ‰˜å¤šç»ç† æ˜¯ä¸€ä¸ªå•çº¿ç¨‹æ‰§è¡Œç®¡ç†å™¨ï¼Œä¹Ÿå«å¢å€¼ç¨ï¼Œ æ¥è‡ªEè¯­è¨€çš„æ¦‚å¿µ . å¢å€¼ç¨æ‰§è¡Œç³»ç»Ÿçš„åˆå§‹åŒ–æ˜¯å‡ è¡Œä»£ç ï¼š todoManager = new TodoManager(); Thread t = new Thread(todoManager.Run); t.Name = \"Unit test TodoManager\"; t.Start(); runner = new ForeignTodoRunner(todoManager); åœ¨ä¸€ä¸ªsilosä¸­ï¼Œæˆ‘ä»¬è¿˜ä½¿ç”¨vatsæ¥ç®¡ç†Grainsè½¬å‘çš„å•çº¿ç¨‹æ‰§è¡Œã€‚ä½œä¸ºsiloså¯åŠ¨çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å…¶ä¸­çš„Nä¸ªè®¾ç½®ä¸ºä¸å¯ç”¨CPUæ ¸å¿ƒçš„æ•°é‡ç›¸åŒ¹é…ï¼š for (int i = 0; i < nTodoManagers; i++) { todoManagers[i] = new TodoManager(); for (int j = 0; j < runnerFactor; j++) todoRunners[i \\* runnerFactor + j] = new ForeignTodoRunner(todoManagers[i]); Thread t = new Thread(todoManagers[i].Run); t.Name = String.Format(\"TodoManager: {0}\", i); t.Start(); } å½“æ—¶æˆ‘ä»¬å’Œè¿ªæ©Â·ç‰¹é‡Œå¸ƒå°”äº‰è®ºè¯´ï¼Œåœ¨æˆ‘ä»¬çœ‹æ¥ï¼Œåœ¨æ‰¿è¯ºä¸Šä½¿ç”¨é™æ€æ–¹æ³•å¯¹å¤§å¤šæ•°å¼€å‘äººå‘˜æ¥è¯´å¤ªä¸æ–¹ä¾¿äº†ã€‚æˆ‘ä»¬å¸Œæœ›å®ƒä»¬æˆä¸ºå®ä¾‹æ–¹æ³•ã€‚å‡ ä¸ªæœˆåï¼Œæˆ‘ä»¬æ¨å‡ºäº†è‡ªå·±çš„æ‰¿è¯ºAsyncCompletionå’ŒAsyncValue . ä»–ä»¬æ˜¯ä»»åŠ¡å’Œä»»åŠ¡çš„åŒ…è£… å’Œhadå®ä¾‹æ–¹æ³•ã€‚è¿™å°†ä»£ç å‹ç¼©äº†ä¸å°‘ï¼š [TestMethod] public void SimpleGrainDataFlow() { ResultHandle result = new ResultHandle(); SimpleGrainReference grain = SimpleGrainReference.GetReference(\"foo\"); AsyncCompletion setPromise = grain.SetA(3); setPromise.ContinueWith(() => { setPromise = grain.SetB(4); setPromise.ContinueWith( () => { AsyncValue<int> intPromise = grain.GetAxB(); intPromise.ContinueWith( x => { result.Result = x; result.Done = true; }); }); }); Assert.IsTrue(result.WaitForFinished(timeout)); Assert.IsNotNull(result.Result); Assert.AreEqual(12, result.Result); } æœ€åˆï¼Œæˆ‘ä»¬å…è®¸grainæ–¹æ³•æ˜¯åŒæ­¥çš„ï¼Œå¹¶å°†grainå¼•ç”¨ä½œä¸ºå®ƒä»¬çš„å¼‚æ­¥ä»£ç†ã€‚ public class SimpleGrain : GrainBase { public void SetA(int a) public void SetB(int b) public int GetAxB() } public class SimpleGrainReference : GrainReference { public AsyncCompletion SetA(int a) public AsyncCompletion SetB(int b) public AsyncValue<int> GetAxB() } æˆ‘ä»¬å¾ˆå¿«æ„è¯†åˆ°è¿™æ˜¯ä¸ªåä¸»æ„ï¼Œäºæ˜¯æ”¹ç”¨Grainsçš„æ–¹æ³•é€€è´§ å¼‚æ­¥å®Œæˆ / å¼‚æ­¥å€¼<T> . æˆ‘ä»¬åå¤è€ƒè™‘ï¼Œæœ€ç»ˆæ”¾å¼ƒäº†ä¸€äº›å…¶ä»–çš„åä¸»æ„ã€‚æˆ‘ä»¬æ”¯æŒGrainsç±»çš„å±æ€§ã€‚å¼‚æ­¥è®¾ç½®å™¨æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå¼‚æ­¥å±æ€§å…·æœ‰ç›¸å½“çš„è¯¯å¯¼æ€§ï¼Œä¸æ˜¾å¼getteræ–¹æ³•ç›¸æ¯”æ²¡æœ‰ä»»ä½•å¥½å¤„ã€‚æˆ‘ä»¬æœ€åˆæ”¯æŒGrainsä¸Šçš„.NETäº‹ä»¶ã€‚ç”±äº.NETä¸­+=å’Œ-=æ“ä½œåŸºæœ¬ä¸Šæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥ä¸å¾—ä¸åºŸå¼ƒå®ƒä»¬ã€‚ ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸ç®€å•åœ°ä½¿ç”¨ Task / Task<T> è€Œä¸æ˜¯ å¼‚æ­¥å®Œæˆ / å¼‚æ­¥å€¼<T> ? ä¸ºäº†ä¿è¯å•çº¿ç¨‹æ‰§è¡Œï¼Œæˆ‘ä»¬éœ€è¦æ‹¦æˆªæ¯ä¸ªè°ƒåº¦å’Œè¿ç»­è°ƒç”¨ã€‚ Task æ˜¯ä¸€ä¸ªå¯†å°ç±»ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å°†å…¶å­ç±»åŒ–ä»¥é‡å†™æ‰€éœ€çš„é”®æ–¹æ³•ã€‚æˆ‘ä»¬ä¹Ÿæ²¡æœ‰ä¸€ä¸ªå®šåˆ¶çš„TPLè°ƒåº¦ç¨‹åºã€‚ åœ¨æˆ‘ä»¬è½¬è€Œä½¿ç”¨æˆ‘ä»¬è‡ªå·±çš„æ‰¿è¯ºä¹‹åï¼Œæˆ‘ä»¬å¤±å»äº†ä½¿ç”¨Midoriçš„ä¸€äº›é«˜çº§åŠŸèƒ½çš„æœºä¼šã€‚ä¾‹å¦‚ï¼Œä»–ä»¬æ”¯æŒä¸‰æ–¹æ‰¿è¯ºåˆ‡æ¢åè®®ã€‚å¦‚æœèŠ‚ç‚¹Aè°ƒç”¨äº†èŠ‚ç‚¹Bå¹¶æŒæœ‰è¯¥è°ƒç”¨çš„å…è¯ºï¼Œä½†ä½œä¸ºå¤„ç†è¯·æ±‚çš„ä¸€éƒ¨åˆ†ï¼ŒBå‘Cå‘å‡ºäº†å¯¹æœ€ç»ˆå€¼çš„è°ƒç”¨ï¼Œåˆ™Bå¯ä»¥ä¼ é€’å¯¹AæŒæœ‰çš„å…è¯ºçš„å¼•ç”¨ï¼Œè¿™æ ·Cå°±å¯ä»¥ç›´æ¥å“åº”Aï¼Œè€Œä¸æ˜¯é¢å¤–è·³å›Bã€‚åœ¨æ€§èƒ½å’Œå¤æ‚æ€§ä¹‹é—´çš„æŠ˜è¡·ä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©ä¼˜å…ˆè€ƒè™‘ç®€å•æ€§ã€‚ æˆ‘ä»¬ä»ä¸Midoriäººäº¤è°ˆä¸­å¾—åˆ°çš„å¦ä¸€ä¸ªæ•™è®­æ˜¯ï¼Œåœ¨ä»–ä»¬çš„ä»£ç åº“ä¸­ï¼Œä¸€äº›æœ€éš¾è·Ÿè¸ªçš„bugçš„æ¥æºæ˜¯äº¤é”™æ‰§è¡Œã€‚å°½ç®¡vatåªæœ‰ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œæ‰€æœ‰çš„turns(åœ¨å±ˆæœç‚¹ä¹‹é—´åŒæ­¥çš„ä»£ç æ®µ)ï¼Œä½†å®ƒä»¥ä»»æ„é¡ºåºæ‰§è¡Œå±äºä¸åŒè¯·æ±‚çš„turnsæ˜¯å®Œå…¨åˆæ³•çš„ã€‚ å‡è®¾æ‚¨çš„ç»„ä»¶æ­£åœ¨å¤„ç†ä¸€ä¸ªè¯·æ±‚ï¼Œå¹¶ä¸”éœ€è¦è°ƒç”¨å¦ä¸€ä¸ªç»„ä»¶ï¼Œä¾‹å¦‚ï¼Œåœ¨å…¶ä¸­è¿›è¡ŒIOè°ƒç”¨ã€‚æ‚¨å‘å‡ºé‚£ä¸ªIOè°ƒç”¨ï¼Œæ”¶åˆ°å®Œæˆæˆ–è¿”å›å€¼çš„æ‰¿è¯ºï¼Œå¹¶ä½¿ç”¨ ä»€ä¹ˆæ—¶å€™ï¼Ÿ æˆ– ç»§ç»­ è°ƒç”¨ã€‚è¿™é‡Œçš„é™·é˜±æ˜¯ï¼Œå½“IOè°ƒç”¨å®Œæˆå¹¶ä¸”è®¡åˆ’çš„å»¶ç»­å¼€å§‹æ‰§è¡Œæ—¶ï¼Œå¾ˆå®¹æ˜“å‡è®¾ç»„ä»¶çš„çŠ¶æ€è‡ªå‘å‡ºIOè°ƒç”¨ä»¥æ¥æ²¡æœ‰æ”¹å˜ã€‚äº‹å®ä¸Šï¼Œç»„ä»¶å¯èƒ½åœ¨å¼‚æ­¥ç­‰å¾…IOè°ƒç”¨æ—¶æ¥æ”¶å¹¶å¤„ç†äº†è®¸å¤šå…¶ä»–è¯·æ±‚ï¼Œè€Œå¤„ç†è¿™äº›è¯·æ±‚å¯èƒ½ä¼šä»¥ä¸æ˜æ˜¾çš„æ–¹å¼æ”¹å˜ç»„ä»¶çš„çŠ¶æ€ã€‚Midoriå›¢é˜Ÿéå¸¸èµ„æ·±ã€‚å½“æ—¶ï¼Œä»–ä»¬ä¸­çš„å¤§å¤šæ•°æ˜¯æ ¡é•¿å’Œåˆä¼™äººçº§åˆ«çš„å·¥ç¨‹å¸ˆå’Œå»ºç­‘å¸ˆã€‚æˆ‘ä»¬æƒ³çŸ¥é“ï¼Œå¦‚æœç©¿æ’å¯¹è¿™ç§æ‰å¹²å’Œç»éªŒçš„äººæ¥è¯´æ˜¯å¦‚æ­¤çš„å±é™©ï¼Œé‚£å¯¹æˆ‘ä»¬è¿™æ ·çš„å‡¡äººæ¥è¯´è‚¯å®šæ›´ç³Ÿã€‚è¿™å¯¼è‡´åæ¥å†³å®šè®©Orleansçš„Grainsåœ¨é»˜è®¤æƒ…å†µä¸‹ä¸å¯å†å…¥ã€‚ å¤§çº¦åœ¨åŒä¸€æ—¶é—´ï¼ŒNiklas Gustafssonå‚ä¸äº†è¿™ä¸ªé¡¹ç›® å¤§å¸ˆ åæ¥æ”¹åä¸º é˜¿å…‹è‹å§† . æˆ‘ä»¬åœ¨Axumä¸Šæœ‰ä¸€ä¸ªå®ä¹ ç”ŸåŸå‹(æ—©æœŸçš„Orleansåº”ç”¨ç¨‹åºä¹‹ä¸€)æ¥æ¯”è¾ƒç¼–ç¨‹ä½“éªŒå’Œ2009å¹´æ˜¥å­£åŸºäºpromiseçš„åº”ç”¨ç¨‹åºã€‚æˆ‘ä»¬å¾—å‡ºçš„ç»“è®ºæ˜¯ï¼Œå¯¹äºå¼€å‘äººå‘˜æ¥è¯´ï¼Œpromisesæ¨¡å‹æ›´å®¹æ˜“å®ç°ã€‚ä¸æ­¤åŒæ—¶ï¼Œå°¼æ ¼æ‹‰æ–¯æå‡ºäº†ä¸€ä¸ªå»ºè®®å’Œä¸€ä¸ªåŸå‹ï¼Œåœ¨ä»–è¯´æœäº†å®‰å¾·æ–¯Â·èµ«å…¹ä¼¯æ ¼å’Œå…¶ä»–äººä¹‹åï¼Œæœ€ç»ˆæˆä¸ºäº† å¼‚æ­¥ /awaitCä¸­çš„å…³é”®å­—#. åˆ°ç°åœ¨ï¼Œå®ƒä¼ æ’­åˆ°äº†æ›´å¤šçš„è¯­è¨€ã€‚ åœ¨å‘å¸ƒäº†å¸¦æœ‰asyncå’Œawaitçš„.net4.5ä¹‹åï¼Œæˆ‘ä»¬æœ€ç»ˆæ”¾å¼ƒäº† å¼‚æ­¥å®Œæˆ / å¼‚æ­¥å€¼<T> èµæˆ Task / Task<T> åˆ©ç”¨ç­‰å¾…çš„åŠ›é‡ã€‚è¿™æ˜¯å¦ä¸€ä¸ªæŠ˜è¡·æ–¹æ¡ˆï¼Œå®ƒè®©æˆ‘ä»¬é‡å†™äº†å‡ æ¬¡è°ƒåº¦ç¨‹åº(ä¸æ˜¯ä¸€ä¸ªå°ä»»åŠ¡)ï¼Œå¹¶æ”¾å¼ƒäº†æˆ‘ä»¬æ‰¿è¯ºä¸­çš„ä¸€äº›å¥½ç‰¹æ€§ã€‚ä¾‹å¦‚ï¼Œåœ¨æˆ‘ä»¬å¯ä»¥è½»æ¾æ£€æµ‹åˆ°grainä»£ç æ˜¯å¦è¯•å›¾é€šè¿‡è°ƒç”¨ ç»“æœ æˆ– ç­‰ç­‰() åœ¨ä¸€ä¸ªæœªè§£å†³çš„æ‰¿è¯ºä¸Š InvalidOperationExceptionå¼‚å¸¸ è¡¨ç¤ºåœ¨silosçš„åä½œå¤šä»»åŠ¡ç¯å¢ƒä¸­ä¸å…è®¸è¿™æ ·åšã€‚æˆ‘ä»¬ä¸èƒ½å†è¿™æ ·äº†ã€‚ä½†æˆ‘ä»¬è·å¾—äº†ä»Šå¤©æ›´å¹²å‡€çš„ç¼–ç¨‹æ¨¡å‹ï¼š public interface ISimpleGrain : IGrainWithIntegerKey { Task SetA(int a); Task SetB(int b); Task<int> GetAxB(); } [Fact, TestCategory(\"BVT\"), TestCategory(\"Functional\")] public async Task SimpleGrainDataFlow() { var grain = GrainFactory.GetGrain<ISimpleGrain>(GetRandomGrainId()); Task setAPromise = grain.SetA(3); Task setBPromise = grain.SetB(4); await Task.WhenAll(setAPromise, setBPromise); var x = await grain.GetAxB(); Assert.Equal(12, x); } Midoriæ˜¯ä¸€ä¸ªéå¸¸æœ‰æ„ä¹‰çš„æœ‰è¶£å®éªŒï¼Œè¯•å›¾æ„å»ºä¸€ä¸ªå…·æœ‰å¼‚æ­¥æ€§å’Œè‡ªä¸Šè€Œä¸‹éš”ç¦»çš„â€œå®‰å…¨æ„å»ºâ€æ“ä½œç³»ç»Ÿã€‚ä»æˆåŠŸã€å¤±è´¥å’Œé”™å¤±çš„æœºä¼šæ¥åˆ¤æ–­è¿™äº›åŠªåŠ›æ€»æ˜¯å¾ˆå›°éš¾çš„ã€‚æœ‰ä¸€ç‚¹å¾ˆæ¸…æ¥šï¼ŒMidoriç¡®å®å½±å“äº†Orleanså…³äºå¼‚æ­¥å’Œå¹¶å‘çš„æ—©æœŸæ€è€ƒå’Œè®¾è®¡ï¼Œå¹¶å¸®åŠ©å¼•å¯¼äº†å®ƒçš„åˆå§‹åŸå‹ã€‚"
  },
  "blog/de-inventing-the-wheel.html": {
    "href": "blog/de-inventing-the-wheel.html",
    "title": "å‘æ˜è½®å­ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å‘æ˜è½®å­ æœ±åˆ©å®‰Â·å¤šæ˜æ ¼æ–¯ 2017å¹´4æœˆ12æ—¥ä¸‹åˆ2:49:11 å¾®è½¯Orleansé¡¹ç›®å¼€å§‹äºè®¸å¤šå¹´å‰çš„å¾®è½¯ç ”ç©¶ï¼Œå½“æ—¶è¿ä»»åŠ¡ç±»éƒ½ä¸å­˜åœ¨ã€‚éšç€é¡¹ç›®çš„æˆç†Ÿï¼Œéœ€è¦è®¸å¤šéæ ¸å¿ƒæŠ½è±¡å’ŒåŠŸèƒ½æ¥æ”¯æŒå…¶å¢é•¿ã€‚è¿™äº›æŠ½è±¡åœ¨.NETä¸­å¹¶ä¸ä½œä¸ºæ ‡å‡†å­˜åœ¨ï¼Œ.NETOSSè¿˜å¤„äºåˆçº§é˜¶æ®µã€‚è¿™äº›æ–¹é¢çš„ä¾‹å­åŒ…æ‹¬æ¨ªåˆ‡å…³æ³¨ç‚¹ï¼Œå¦‚æ—¥å¿—è®°å½•ã€é…ç½®å’Œä¾èµ–æ³¨å…¥ã€‚ éšç€æ—¶é—´çš„æ¨ç§»ï¼Œå‡ºç°äº†ä¸€äº›å¸¸è§çš„æŠ½è±¡å’Œæ¨¡å¼ï¼Œå¹¶ä¸”è¾¾åˆ°äº†åªé‡‡ç”¨å®ƒä»¬å°±æœ‰æ„ä¹‰çš„ç¨‹åº¦ã€‚åŸå› æœ‰å¾ˆå¤šï¼š å¼€å‘äººå‘˜å·²ç»ä¹ æƒ¯äº†æ ‡å‡†çš„æ¨¡å¼å’ŒæŠ½è±¡ï¼Œæ‰€ä»¥æ–°æ‰‹ä¸éœ€è¦ä¸ºäº†ä½¿ç”¨Orleansè€Œå­¦ä¹ è¿™äº›éæ ¸å¿ƒæŠ½è±¡ã€‚ æ ‡å‡†æŠ½è±¡çš„é‡‡ç”¨ç¨‹åº¦éå¸¸é«˜ï¼Œå‡ ä¹æ¯ä¸€ä¸ªç¬¬ä¸‰æ–¹ç»„ä»¶éƒ½ä¸è¯¥æŠ½è±¡ç›¸å…³ã€‚å¦ä¸€æ–¹é¢ï¼Œä»Šå¤©å®ƒè¦æ±‚Orleansç¤¾åŒºä¸ºè®¸å¤šç¬¬ä¸‰æ–¹ç»„ä»¶æ„å»ºé›†æˆåŒ…(å³ï¼šä½¿ç”¨Serilogã€log4netæˆ–push events to ETW)ï¼Œå› ä¸ºè¿™äº›ç»„ä»¶çš„æ‰€æœ‰è€…åªä¼šä¸ºå…¬å…±æŠ½è±¡åˆ›å»ºé›†æˆåŒ…ï¼Œè€Œä¸æ˜¯ä¸ºOrleansæˆ–ä»»ä½•å…¶ä»–éæ ‡å‡†æŠ½è±¡åˆ›å»ºé›†æˆåŒ…ã€‚ æˆ‘ä»¬åˆ›å»ºäº†å®šåˆ¶çš„æŠ½è±¡æ¥å®Œæˆè¿™é¡¹å·¥ä½œï¼Œä½†æ˜¯åœ¨è¿™ä¹‹åæˆ‘ä»¬å¹¶æ²¡æœ‰è¿‡å¤šåœ°å…³æ³¨å¯ç”¨æ€§ï¼Œå› ä¸ºå®ƒåªæ˜¯è¿›å…¥äº†ç»´æŠ¤æ¨¡å¼ã€‚æœ‰æ—¶æˆ‘ä»¬å‘ç°è¿™äº›æŠ½è±¡ä¸å¤Ÿå¥½ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»åšå‡ºçªç ´æ€§çš„æ”¹å˜(ä¾‹å¦‚ï¼Œæˆ‘ä»¬å‘éé™æ€å®¢æˆ·ç«¯å’Œsilosçš„è¿ç§»éœ€è¦éé™æ€æ—¥å¿—æŠ½è±¡)ã€‚ è¿™äº›æ ‡å‡†çš„æŠ½è±¡æ˜¯ç»è¿‡æ·±æ€ç†Ÿè™‘æ¥å®Œæˆç‰¹å®šå·¥ä½œçš„ï¼Œé€šå¸¸éå¸¸çµæ´»ï¼Œä½¿ç”¨ç®€å•ï¼Œå¹¶ä¸”æœ‰å¾ˆå¤šæ–‡æ¡£ã€‚æˆ‘ä»¬åªæ˜¯ç«™åœ¨ä»–ä»¬çš„è‚©è†€ä¸Šã€‚ åˆ é™¤å¯¹Orleansæ ¸å¿ƒåŠŸèƒ½ä¸é‡è¦çš„ä»£ç æ€»æ˜¯å¾ˆå¥½çš„ã€‚ æˆ‘ä»¬å·²ç»å¼€å§‹ä½¿ç”¨ Microsoft.Extensions.DependencyInjection æ”¯æŒDIçš„æŠ½è±¡ï¼Œåœ¨å¾ˆå¤šåœ°æ–¹æˆ‘ä»¬ä¸å†ä½¿ç”¨ç©·äººçš„å¯¹è±¡æ¿€æ´»(å’Œä¸¤æ­¥åˆå§‹åŒ–)æ–¹æ³•ã€‚ éšç€æˆ‘ä»¬çš„è¿›ä¸€æ­¥å‘å±•ï¼Œæˆ‘ä»¬è®¡åˆ’å¯¹ä¸€äº›å®šåˆ¶æŠ½è±¡è¿›è¡ŒæŠ¨å‡»ï¼Œè½¬è€Œä½¿ç”¨æ ‡å‡†æŠ½è±¡ã€‚ç‰¹åˆ«æ˜¯æˆ‘ä»¬å·²ç»åœ¨è€ƒè™‘ä¸¤ä¸ªå³å°†åˆ°æ¥çš„å˜åŒ–ï¼š å°†æ—¥å¿—æŠ½è±¡è¿ç§»åˆ° Microsoft.Extensions.Logging . ä¿®æ”¹æˆ‘ä»¬çš„é…ç½®å’Œå¯åŠ¨æ¨¡å¼ï¼Œä½¿ä¹‹ä¸ASP.NETæ ¸å¿ƒçš„ã€‚çœ‹ dotnet/Orleans#2936 å¯¹äºè¿™ä¸ªåŠ¨ä½œçš„åˆæ­¥è®¾è®¡ã€‚ å’Œå¾€å¸¸ä¸€æ ·ï¼Œæˆ‘ä»¬ä¼šå°½é‡å°†ç ´åæ€§æ›´æ”¹ä¿æŒåœ¨æœ€ä½é™åº¦ï¼Œä½†æˆ‘ä»¬ä¸ä¼šä¸¥æ ¼é˜²æ­¢ç ´åæ›´æ”¹ã€‚æœ‰æ—¶ï¼Œæˆ‘ä»¬ä½¿æˆ‘ä»¬çš„æ–°ç‰ˆæœ¬ä¸æºä»£ç å…¼å®¹(è¿™æ„å‘³ç€å¼€å‘äººå‘˜ä¸èƒ½ç®€å•åœ°åœ¨Orleansç¨‹åºé›†ä¸Šä½¿ç”¨ç»‘å®šé‡å®šå‘ï¼Œä½†æ˜¯é‡æ–°æ„å»ºä»–ä»¬çš„ä»£ç å¯èƒ½ä»ç„¶å¯ä»¥ç¼–è¯‘)ï¼Œæˆ–è€…éœ€è¦ä¸€äº›æœ€å°çš„ä¿®å¤ã€‚æœ‰æ—¶ï¼Œçªç ´æ€§çš„æ”¹å˜*æ›´å¤§çš„*å¦‚æœå®ƒä»¬åªä¼šå½±å“åˆ°ä¸€ä¸ªå°ç‰¹æ€§æˆ–ä¸€äº›é€šå¸¸ä¸ä¼šåœ¨ç”¨æˆ·çš„æ•´ä¸ªä»£ç åº“ä¸­æ‰©å±•çš„ä¸œè¥¿(ä¾‹å¦‚ä¸å½±å“Grainä»£ç çš„æ‰©å±•ç‚¹)ã€‚ è€Œä¸”ï¼Œç°åœ¨ä¼¼ä¹æ˜¯ä¸€ä¸ªä»¥å…¨æ–°çš„æ€ç»´çœ‹å¾…è¿™äº›æŠ½è±¡çš„æ°å½“æ—¶æœºï¼Œå› ä¸ºè¿™æ­£æ˜¯.NETç¤¾åŒºåœ¨å±•æœ›ä»¥ä¸‹äº‹æƒ…æ—¶æ‰€åšçš„ASP.NETå’Œ.NETæ ¸å¿ƒã€‚"
  },
  "blog/announcing-orleans-2.0-tech-preview-3.html": {
    "href": "blog/announcing-orleans-2.0-tech-preview-3.html",
    "title": "å®£å¸ƒOrleans2.0æŠ€æœ¯é¢„è§ˆç‰ˆ3 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å®£å¸ƒOrleans2.0æŠ€æœ¯é¢„è§ˆç‰ˆ3 æœ±åˆ©å®‰Â·å¤šæ˜æ ¼æ–¯(Julian Dominguez) 2017/9/13ä¸‹åˆ1:17:21 æˆ‘ä»¬åˆšåˆšå‘å¸ƒäº†Orleans2.0æŠ€æœ¯é¢„è§ˆç‰ˆç«è½¦çš„é‡å¤§æ›´æ–°ã€‚æ–°çš„äºŒè¿›åˆ¶æ–‡ä»¶ç°åœ¨é¢å‘.NET Standard 2.0ï¼Œå› æ­¤å®ƒä»¬ä¸Orleansçš„.NETç‰ˆæœ¬å‡ ä¹å®Œå…¨ç›¸åŒã€‚è¿™æ„å‘³ç€å½“å‰çŠ¶æ€ä¸ä»…å¯¹ä½¿ç”¨.NET Coreç¼–å†™æ–°åº”ç”¨ç¨‹åºçš„äººèµ·ä½œç”¨ï¼Œè€Œä¸”å¯¹äºå…·æœ‰å·²åœ¨.NET Frameworkä¸­è¿è¡Œçš„åº”ç”¨ç¨‹åºçš„äººæ¥è¯´ï¼Œä¹Ÿæ˜¯ä¸€ç§å‡çº§é€”å¾„ã€‚ æˆ‘ä»¬å®Œæˆäº†å—ï¼Ÿ å¯¹äºæˆ‘ä»¬å›¢é˜Ÿæ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªæ¿€åŠ¨äººå¿ƒçš„é‡Œç¨‹ç¢‘ï¼Œå› ä¸ºå®ƒä½¿2.0ç‰ˆæœ¬æ›´åŠ æ¥è¿‘ã€‚åœ¨å‘å¸ƒä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸ºæ­¤ç‰ˆæœ¬åšä¸€äº›å‰©ä½™çš„äº‹æƒ…ï¼Œä¾‹å¦‚ï¼š ä¸º.NET Coreåº”ç”¨å¯ç”¨ç”Ÿæˆæ—¶ä»£ç ç”Ÿæˆå™¨(.NET Coreä»ç„¶ä»…æ”¯æŒè¿è¡Œæ—¶ä»£ç ç”Ÿæˆå™¨) è¿ç§»åˆ° Microsoft.Extensions.Logging å¯¹äºæˆ‘ä»¬æ‰€æœ‰çš„æ—¥å¿—è®°å½• å……å®silosç”Ÿæˆå™¨API é€šè¿‡ä»…æ‰«ææœ€ç»ˆç”¨æˆ·å®šä¹‰çš„ç¨‹åºé›†æ¥æ”¹å–„å¯åŠ¨ é‡ç»„ æˆ‘ä»¬çš„æŸäº›ç±»å‹å…·æœ‰ä¸€ä¸ªæˆ‘ä»¬ä¸ç»å¸¸ç‰ˆæœ¬åŒ–çš„Abstractionsé¡¹ç›® æ‹¥æœ‰äº¤æ˜“åŠŸèƒ½çš„åˆå§‹ç‰ˆæœ¬ ä¸ºé€šå¸¸åºåˆ—åŒ–å¹¶æŒä¹…å­˜å‚¨çš„ç±»å‹æä¾›ä¸€å®šç¨‹åº¦çš„å‘åå…¼å®¹æ€§ å’Œå…¶ä»–ä¸€äº›å°äº‹ æˆ‘è¯¥å¦‚ä½•å°è¯•ï¼Ÿ æˆ‘ä»¬åˆšåˆšå°†è½¯ä»¶åŒ…å‘å¸ƒåˆ°MyGetï¼š https://dotnet.myget.org/gallery/orleans-ci è¯·æŒ‰ç…§é“¾æ¥è·å–æœ‰å…³å¦‚ä½•é…ç½®NuGetä»¥ä¾¿ä»è¯¥ä¾›ç¨¿ä¸‹è½½ç¨‹åºåŒ…çš„è¯´æ˜ã€‚ è¯·å¸®åŠ©æˆ‘ä»¬ æˆ‘ä»¬è®¡åˆ’å¼€å§‹æ›´é¢‘ç¹åœ°å¼€å§‹å‘MyGetæè¦å‘å¸ƒæ›´æ–°çš„è½¯ä»¶åŒ…ï¼Œå› æ­¤è¯·å°è¯•é¢„è§ˆï¼Œå¦‚æœæœ‰é—®é¢˜ï¼Œè¯·å‘ŠçŸ¥æˆ‘ä»¬ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œä¿®å¤å¹¶åœ¨ä¸ä¹…åä»¥æ‚¨çš„æ–¹å¼å‘é€æ›´æ–°ã€‚ Orleans2.0 TP3çš„ç”Ÿäº§å‡†å¤‡å°±ç»ªäº†å—ï¼Ÿ è¿˜æ²¡ã€‚å¤§å£°æ˜ï¼šæˆ‘ä»¬åœ¨.NETä¸­è¿›è¡ŒCIæµ‹è¯•(å› ä¸ºæˆ‘ä»¬çš„æµ‹è¯•ä¸¥é‡ä¾èµ–AppDomainsåˆ›å»ºå†…å­˜å­¤å²›ç¾¤é›†ï¼Œè€Œ.NET Coreä¸æ”¯æŒè¿™äº›å­¤å²›ï¼Œä½†æˆ‘ä»¬è®¡åˆ’å°½å¿«è§£å†³)ã€‚æˆ‘ä»¬å·²ç»åœ¨.NET Core(åŒ…æ‹¬Windowså’ŒLinux)ä¸­è¿›è¡Œäº†ä¸€äº›åŸºæœ¬çš„æ‰‹åŠ¨æµ‹è¯•ï¼Œå¹¶ä¸”æˆ‘ä»¬çš„ä¸€äº›è´¡çŒ®è€…æ­£åœ¨ä½¿ç”¨å®ƒå¼€å‘æ–°çš„æœåŠ¡ã€‚è·å¾—åé¦ˆ(å’ŒPRï¼)æ˜¯æ­¤ç‰ˆæœ¬çš„ä¸»è¦ç›®æ ‡ä¹‹ä¸€ï¼Œå°šæœªåœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ã€‚æ­¤å¤–ï¼Œå³ä½¿å¯¹äºå·²å®Œå…¨ç§»æ¤çš„åŠŸèƒ½ï¼Œä¹Ÿæ— æ³•ä¿è¯æ­¤æŠ€æœ¯é¢„è§ˆç‰ˆä¸Orleans 1.5å®Œå…¨å‘åå…¼å®¹ã€‚åœ¨æ¥è¿‘ç¨³å®šç‰ˆæœ¬ä¹‹åï¼Œæˆ‘ä»¬å°†åˆ—å‡ºæ‰€æœ‰å·²çŸ¥çš„é‡å¤§æ›´æ”¹ï¼Œä»¥é˜²æ‚¨æœ‰å…´è¶£å°†åº”ç”¨ç¨‹åºä»1.Xå‡çº§åˆ°2.0ã€‚ ç¬”è®° å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯è¾ƒæ—©çš„æŠ€æœ¯é¢„è§ˆï¼Œè¯·æ³¨æ„ç¨‹åºé›†åŠ è½½å‘ç”Ÿäº†ä¸€äº›å˜åŒ–ï¼Œæˆ‘ä»¬å¸Œæœ›ç»§ç»­è¿›è¡Œæ›´æ”¹ã€‚åŒæ—¶ï¼Œè¯·æ³¨æ„ï¼Œåœ¨.NET Coreä¸­ï¼Œå¯èƒ½éœ€è¦å‘å¸ƒåº”ç”¨ç¨‹åºï¼Œä»¥ä¾¿æ‰€æœ‰è¦æ‰«æçš„ç¨‹åºé›†éƒ½åœ¨åŒä¸€æ–‡ä»¶å¤¹ä¸­(æ‚¨å¯ä»¥é€šè¿‡è°ƒç”¨` dotnetå‘å¸ƒ `åœ¨æ‚¨çš„silosä¸»æœºä¸Š)ã€‚"
  },
  "Tutorials/index.zh.html": {
    "href": "Tutorials/index.zh.html",
    "title": "Step by Step Tutorials | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è¿™äº›æ•™ç¨‹é€‚ç”¨äº2.0ç‰ˆæœ¬ Orleans2.0æ˜¯ä»1.xç‰ˆæœ¬å¼€å§‹çš„é‡å¤§æ”¹è¿›ã€‚"
  },
  "Documentation/grains/grain_identity.html": {
    "href": "Documentation/grains/grain_identity.html",
    "title": "Grain Identity | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Grainsèº«ä»½ åœ¨é¢å‘å¯¹è±¡çš„ç¯å¢ƒä¸­ï¼Œå¾ˆéš¾å°†å¯¹è±¡çš„æ ‡è¯†ä¸å¯¹å…¶çš„å¼•ç”¨åŒºåˆ†å¼€ã€‚å› æ­¤ï¼Œå½“ä½¿ç”¨newåˆ›å»ºå¯¹è±¡æ—¶ï¼Œæ‚¨è·å¾—çš„å¼•ç”¨ä»£è¡¨å…¶èº«ä»½çš„æ‰€æœ‰æ–¹é¢ï¼Œé™¤äº†é‚£äº›å°†å¯¹è±¡æ˜ å°„åˆ°å…¶æ‰€ä»£è¡¨çš„å¤–éƒ¨å®ä½“çš„æ–¹é¢ã€‚ åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå¯¹è±¡å¼•ç”¨ä¸èƒ½è¡¨ç¤ºå®ä¾‹èº«ä»½ï¼Œå› ä¸ºå¼•ç”¨é€šå¸¸é™äºå•ä¸ªåœ°å€ç©ºé—´ã€‚.NETå¼•ç”¨è‚¯å®šæ˜¯è¿™ç§æƒ…å†µã€‚æ­¤å¤–ï¼Œæ— è®ºGrainsæ˜¯å¦å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œå®ƒéƒ½å¿…é¡»å…·æœ‰èº«ä»½ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥æŒ‰éœ€æ¿€æ´»å®ƒã€‚å› æ­¤ï¼ŒGrainså…·æœ‰ä¸»é”®ã€‚ä¸»é”®å¯ä»¥æ˜¯å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦(GUID)ï¼Œé•¿æ•´æ•°æˆ–å­—ç¬¦ä¸²ã€‚ Grainçš„ä¸»é”®åœ¨å…¶ç±»å‹ä¸­å®šä¹‰ã€‚å› æ­¤ï¼ŒGrainçš„å®Œæ•´æ ‡è¯†ç”±Grainçš„ç±»å‹åŠå…¶é”®ç»„æˆã€‚ Grainsçš„è°ƒç”¨è€…å†³å®šåº”ä½¿ç”¨å“ªç§æ–¹æ¡ˆã€‚é€‰é¡¹åŒ…æ‹¬ï¼š long GUID string GUID + string long + string å› ä¸ºåŸºç¡€æ•°æ®æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥è¿™äº›æ–¹æ¡ˆå¯ä»¥äº’æ¢ä½¿ç”¨ã€‚å½“ä½¿ç”¨é•¿æ•´æ•°æ—¶ï¼Œå®é™…ä¸Šä¼šåˆ›å»ºä¸€ä¸ªGUIDå¹¶ç”¨é›¶å¡«å……ã€‚ éœ€è¦ä½¿ç”¨å•ä¾‹Grainså®ä¾‹çš„æƒ…å†µ(ä¾‹å¦‚å­—å…¸æˆ–æ³¨å†Œè¡¨)å¯ä»ä½¿ç”¨ä¸­å—ç›Š Guid.Empty ä½œä¸ºå…¶å…³é”®ã€‚è¿™ä»…ä»…æ˜¯ä¸€ä¸ªçº¦å®šï¼Œä½†æ˜¯é€šè¿‡åšæŒï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªæ•™ç¨‹ä¸­æ‰€çœ‹åˆ°çš„ï¼Œåœ¨è°ƒç”¨ç«™ç‚¹å¤„ï¼Œäº‹æƒ…å·²ç»å¾ˆæ¸…æ¥šäº†ã€‚ ä½¿ç”¨GUID å½“æœ‰å¤šä¸ªè¿›ç¨‹å¯èƒ½éœ€è¦è¯·æ±‚grainæ—¶ï¼Œä¾‹å¦‚Webåœºä¸­çš„è®¸å¤šWebæœåŠ¡å™¨ï¼ŒGUIDå¾ˆæœ‰ç”¨ã€‚æ‚¨ä¸éœ€è¦åè°ƒä¸»é”®çš„åˆ†é…ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ç³»ç»Ÿå‡ºç°å•ç‚¹æ•…éšœï¼Œä¹Ÿå¯èƒ½ä¸éœ€è¦å¯¹èµ„æºè¿›è¡Œç³»ç»Ÿä¾§é”å®šå°±å¯èƒ½é€ æˆç“¶é¢ˆã€‚GUIDå‘ç”Ÿç¢°æ’çš„å¯èƒ½æ€§å¾ˆå°ï¼Œå› æ­¤åœ¨æ„å»ºOrleansç³»ç»Ÿæ—¶ï¼Œå®ƒä»¬å¯èƒ½æ˜¯é»˜è®¤é€‰æ‹©ã€‚ åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­é€šè¿‡GUIDå¼•ç”¨Grainsï¼š var grain = grainFactory.GetGrain<IExample>(Guid.NewGuid()); ä»Grainsä»£ç ä¸­æ£€ç´¢ä¸»é”®ï¼š public override Task OnActivateAsync() { Guid primaryKey = this.GetPrimaryKey(); return base.OnActivateAsync(); } ä½¿ç”¨Longs ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªé•¿æ•´æ•°ï¼Œå¦‚æœå°†GrainsæŒä¹…ä¿å­˜åˆ°å…³ç³»æ•°æ®åº“ä¸­(åœ¨è¯¥æ•°æ®åº“ä¸­æ•°å­—ç´¢å¼•ä¼˜å…ˆäºGUID)ï¼Œè¿™å°†æ˜¯æœ‰æ„ä¹‰çš„ã€‚ åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­é€šè¿‡é•¿æ•´æ•°å¼•ç”¨Grainsï¼š var grain = grainFactory.GetGrain<IExample>(1); æ£€ç´¢ä¸»é”®å½¢å¼çš„Grainä»£ç ï¼š public override Task OnActivateAsync() { long primaryKey = this.GetPrimaryKeyLong(); return base.OnActivateAsync(); } ä½¿ç”¨å­—ç¬¦ä¸² å­—ç¬¦ä¸²ä¹Ÿæ˜¯å¯ç”¨çš„ã€‚ åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­æŒ‰å­—ç¬¦ä¸²å¼•ç”¨Grainsï¼š var grain = grainFactory.GetGrain<IExample>(\"myGrainKey\"); æ£€ç´¢ä¸»é”®å½¢å¼çš„Grainä»£ç ï¼š public override Task OnActivateAsync() { string primaryKey = this.GetPrimaryKeyString(); return base.OnActivateAsync(); } ä½¿ç”¨å¤åˆä¸»é”® å¦‚æœæ‚¨çš„ç³»ç»Ÿä¸GUIDæˆ–longå‡ä¸åˆé€‚ï¼Œåˆ™å¯ä»¥é€‰æ‹©å¤åˆä¸»é”®ï¼Œè¯¥ä¸»é”®å…è®¸æ‚¨ä½¿ç”¨GUIDæˆ–longä¸å­—ç¬¦ä¸²çš„ç»„åˆæ¥å¼•ç”¨Grainsã€‚ æ‚¨å¯ä»¥ä» IGrainWithGuidCompoundKey æˆ– IGrainWithIntegerCompoundKey æ¥å£ç»§æ‰¿æ¥å£ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š public interface IExampleGrain : Orleans.IGrainWithIntegerCompoundKey { Task Hello(); } åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­ï¼Œè¿™ä¼šå‘ GetGrain ç²®å‚çš„æ–¹æ³•ã€‚ var grain = grainFactory.GetGrain<IExample>(0, \"a string!\", null); è¦è®¿é—®Grainsä¸­çš„å¤åˆé”®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ GetPrimaryKey æ–¹æ³•ï¼š public class ExampleGrain : Orleans.Grain, IExampleGrain { public Task Hello() { string keyExtension; long primaryKey = this.GetPrimaryKeyLong(out keyExtension); Console.WriteLine(\"Hello from \" + keyExtension); Task.CompletedTask; } }"
  },
  "Documentation/grains/grain_lifecycle.html": {
    "href": "Documentation/grains/grain_lifecycle.html",
    "title": "Grain Lifecycle | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Grainsç”Ÿå‘½å‘¨æœŸ æ€»è§ˆ OrleansGrainsä½¿ç”¨å¯è§‚å¯Ÿåˆ°çš„ç”Ÿå‘½å‘¨æœŸ(è¯·å‚è§ Orleansç”Ÿå‘½å‘¨æœŸ )è¿›è¡Œæœ‰åºçš„æ¿€æ´»å’Œåœç”¨ã€‚è¿™å…è®¸åœ¨Grainsæ¿€æ´»å’Œæ”¶é›†æœŸé—´ä»¥æœ‰åºçš„æ–¹å¼å¯åŠ¨å’Œåœæ­¢Grainsé€»è¾‘ï¼Œç³»ç»Ÿç»„ä»¶å’Œåº”ç”¨ç¨‹åºé€»è¾‘ã€‚ é˜¶æ®µ é¢„å®šçš„Grainsç”Ÿå‘½å‘¨æœŸé˜¶æ®µå¦‚ä¸‹ã€‚ public static class GrainLifecycleStage { public const int First = int.MinValue; public const int SetupState = 1000; public const int Activate = 2000; public const int Last = int.MaxValue; } First -Grainsç”Ÿå‘½å‘¨æœŸçš„ç¬¬ä¸€é˜¶æ®µ SetupState â€“åœ¨æ¿€æ´»ä¹‹å‰è®¾ç½®grainsçŠ¶æ€ã€‚å¯¹äºæœ‰çŠ¶æ€çš„Grainsï¼Œè¿™æ˜¯ä»å­˜å‚¨ä¸­åŠ è½½çŠ¶æ€çš„é˜¶æ®µã€‚ Activate â€“ OnActivateAsync å’Œ OnDeactivateAsync é˜¶æ®µ Last -Grainsç”Ÿå‘½å‘¨æœŸçš„æœ€åé˜¶æ®µ å°½ç®¡å°†åœ¨Grainsæ¿€æ´»æœŸé—´ä½¿ç”¨Grainsç”Ÿå‘½å‘¨æœŸï¼Œä½†ç”±äºåœ¨æŸäº›é”™è¯¯æƒ…å†µä¸‹(ä¾‹å¦‚Siloå´©æºƒ)å¹¶éæ€»æ˜¯åœç”¨Grainsï¼Œå› æ­¤åº”ç”¨ç¨‹åºä¸åº”ä¾èµ–äºåœ¨Grainsåœç”¨è¿‡ç¨‹ä¸­å§‹ç»ˆæ‰§è¡Œçš„Grainsç”Ÿå‘½å‘¨æœŸã€‚ grainç”Ÿå‘½å‘¨æœŸå‚ä¸ åº”ç”¨ç¨‹åºé€»è¾‘å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼å‚ä¸Grainsçš„ç”Ÿå‘½å‘¨æœŸï¼šGrainså¯ä»¥å‚ä¸å…¶ç”Ÿå‘½å‘¨æœŸï¼Œå’Œ/æˆ–ç»„ä»¶å¯ä»¥é€šè¿‡Grainsæ¿€æ´»ä¸Šä¸‹æ–‡è®¿é—®ç”Ÿå‘½å‘¨æœŸ(è¯·å‚é˜…IGrainActivationContext.ObservableLifecycle)ã€‚ Grainså§‹ç»ˆå‚ä¸å…¶è‡ªèº«çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤å¯ä»¥é€šè¿‡è¦†ç›–å‚ä¸æ–¹æ³•æ¥å¼•å…¥åº”ç”¨ç¨‹åºé€»è¾‘ã€‚ ç¤ºä¾‹ public override void Participate(IGrainLifecycle lifecycle) { base.Participate(lifecycle); lifecycle.Subscribe(this.GetType().FullName, GrainLifecycleStage.SetupState, OnSetupState); } åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œ grains<T> è¦†ç›– å‚åŠ  å‘Šè¯‰ç”Ÿå‘½å‘¨æœŸçš„æ–¹æ³•åœ¨ç”Ÿå‘½å‘¨æœŸçš„SetupStateé˜¶æ®µè°ƒç”¨å…¶OnSetupStateæ–¹æ³•ã€‚ åœ¨Grainsçš„æ„é€ è¿‡ç¨‹ä¸­åˆ›å»ºçš„ç»„ä»¶ä¹Ÿå¯ä»¥å‚ä¸ç”Ÿå‘½å‘¨æœŸï¼Œè€Œæ— éœ€æ·»åŠ ä»»ä½•ç‰¹æ®Šçš„Grainsé€»è¾‘ã€‚ç”±äºGrainsçš„æ¿€æ´»ç¯å¢ƒ( IGrainActivationContext )ï¼ŒåŒ…æ‹¬Grainsçš„ç”Ÿå‘½å‘¨æœŸ( IGrainActivationContext.ObservableLifecycle )æ˜¯åœ¨åˆ›å»ºGrainsä¹‹å‰åˆ›å»ºçš„ï¼Œå®¹å™¨æ³¨å…¥Grainsä¸­çš„ä»»ä½•æˆåˆ†éƒ½å¯ä»¥å‚ä¸Grainsçš„ç”Ÿå‘½å‘¨æœŸã€‚ ç¤ºä¾‹ ä½¿ç”¨å·¥å‚æ–¹æ³• Create(..) åˆ›å»ºæ—¶ï¼Œä»¥ä¸‹ç»„ä»¶ä¼šå‚ä¸Grainsçš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™ç§é€»è¾‘å¯èƒ½å­˜åœ¨äºç»„ä»¶çš„æ„é€ å‡½æ•°ä¸­ï¼Œä½†æ˜¯è¿™ä¼šå†’ç€é£é™©åœ¨ç»„ä»¶å®Œå…¨æ„å»ºä¹‹å‰å°†å…¶æ·»åŠ åˆ°ç”Ÿå‘½å‘¨æœŸä¸­çš„é£é™©ï¼Œè¿™å¯èƒ½å¹¶ä¸å®‰å…¨ã€‚ public class MyComponent : ILifecycleParticipant<IGrainLifecycle> { public static MyComponent Create(IGrainActivationContext context) { var component = new MyComponent(); component.Participate(context.ObservableLifecycle); return component; } public void Participate(IGrainLifecycle lifecycle) { lifecycle.Subscribe<MyComponent>(GrainLifecycleStage.Activate, OnActivate); } private Task OnActivate(CancellationToken ct) { // Do stuff } } é€šè¿‡å·¥å‚æ–¹æ³• Create(..) æ³¨å†Œä¸Šè¿°ç»„ä»¶åˆ°æœåŠ¡å®¹å™¨ä¸­ï¼Œä»»ä½•å°†ç»„ä»¶ä½œä¸ºä¾èµ–é¡¹æ„é€ çš„grainå°†ä½¿ç»„ä»¶å‚ä¸å…¶ç”Ÿå‘½å‘¨æœŸï¼Œè€Œgrainä¸­æ²¡æœ‰ä»»ä½•ç‰¹æ®Šé€»è¾‘ã€‚ åœ¨å®¹å™¨ä¸­æ³¨å†Œç»„ä»¶ services.AddTransient<MyComponent>(sp => MyComponent.Create(sp.GetRequiredService<IGrainActivationContext>()); Grainsä»¥æˆåˆ†ä¸ºä¾å­˜å…³ç³» public class MyGrain : Grain, IMyGrain { private readonly MyComponent component; public MyGrain(MyComponent component) { this.component = component; } }"
  },
  "Documentation/grains/request_context.html": {
    "href": "Documentation/grains/request_context.html",
    "title": "Request Context | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è¯·æ±‚ä¸Šä¸‹æ–‡ RequestContextæ˜¯ä¸€ä¸ªOrleansç‰¹æ€§ï¼Œå®ƒå…è®¸åº”ç”¨ç¨‹åºå…ƒæ•°æ®(å¦‚è·Ÿè¸ªID)ä¸è¯·æ±‚ä¸€èµ·æµåŠ¨ã€‚åº”ç”¨ç¨‹åºå…ƒæ•°æ®å¯ä»¥æ·»åŠ åˆ°å®¢æˆ·ç«¯ä¸Šï¼›å®ƒå°†ä¸Orleansè¯·æ±‚ä¸€èµ·æµå‘æ¥æ”¶Grainã€‚ è¯¥ç‰¹æ€§ç”±Orleansåç§°ç©ºé—´ä¸­çš„ä¸€ä¸ªå…¬å…±é™æ€ç±»RequestContextå®ç°ã€‚æ­¤ç±»å…¬å¼€äº†ä¸¤ä¸ªç®€å•æ–¹æ³•ï¼š void Set(string key, object value) ç”¨äºåœ¨è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­å­˜å‚¨å€¼ã€‚è¯¥å€¼å¯ä»¥æ˜¯ä»»ä½•å¯åºåˆ—åŒ–ç±»å‹ã€‚ Object Get(string key) ç”¨äºä»å½“å‰è¯·æ±‚ä¸Šä¸‹æ–‡ä¸­æ£€ç´¢å€¼ã€‚ RequestContextçš„åå°å­˜å‚¨æ˜¯çº¿ç¨‹é™æ€çš„ã€‚å½“ä¸€ä¸ªçº¿ç¨‹(æ— è®ºæ˜¯å®¢æˆ·ç«¯è¿˜æ˜¯åœ¨Orleanså†…)å‘é€è¯·æ±‚æ—¶ï¼Œå‘é€çº¿ç¨‹çš„RequestContextçš„å†…å®¹éƒ½åŒ…å«åœ¨è¯·æ±‚çš„Orleansæ¶ˆæ¯ä¸­ï¼›å½“grainä»£ç æ¥æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œå¯ä»¥ä»æœ¬åœ°RequestContextè®¿é—®è¯¥å…ƒæ•°æ®ã€‚å¦‚æœgrainä»£ç æ²¡æœ‰ä¿®æ”¹RequestContextï¼Œé‚£ä¹ˆå®ƒè¯·æ±‚çš„ä»»ä½•grainéƒ½å°†æ¥æ”¶ç›¸åŒçš„å…ƒæ•°æ®ï¼Œä¾æ­¤ç±»æ¨ã€‚ å½“æ‚¨ä½¿ç”¨StartNewæˆ–ContinueWithè®¡åˆ’æœªæ¥çš„è®¡ç®—æ—¶ï¼Œä¹Ÿä¼šç»´æŠ¤åº”ç”¨ç¨‹åºå…ƒæ•°æ®ï¼›åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œåç»­çš„ä»»åŠ¡å°†ä½¿ç”¨ä¸è°ƒåº¦ä»£ç åœ¨è°ƒåº¦è®¡ç®—æ—¶æ‰€å…·æœ‰çš„ç›¸åŒå…ƒæ•°æ®æ‰§è¡Œ(å³ï¼Œç³»ç»Ÿå¤åˆ¶å½“å‰å…ƒæ•°æ®å¹¶å°†å…¶ä¼ é€’ç»™åç»­ä»»åŠ¡ï¼Œå› æ­¤ï¼Œè°ƒç”¨StartNewæˆ–ContinueWithä¹‹åçš„æ›´æ”¹å°†ä¸ä¼šè¢«åç»­ä»»åŠ¡çœ‹åˆ°)ã€‚ è¯·æ³¨æ„ï¼Œåº”ç”¨ç¨‹åºå…ƒæ•°æ®ä¸ä¼šéšå“åº”è¿”å›ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œç”±äºæ¥æ”¶åˆ°å“åº”è€Œè¿è¡Œçš„ä»£ç ï¼Œæ— è®ºæ˜¯åœ¨ContinueWith åç»­ä»»åŠ¡ä¸­ï¼Œè¿˜æ˜¯åœ¨è°ƒç”¨Waitæˆ–GetValueä¹‹åï¼Œä»å°†åœ¨åŸå§‹è¯·æ±‚è®¾ç½®çš„å½“å‰ä¸Šä¸‹æ–‡ä¸­è¿è¡Œã€‚ ä¾‹å¦‚ï¼Œè¦å°†å®¢æˆ·ç«¯ä¸­çš„è·Ÿè¸ªIDè®¾ç½®ä¸ºæ–°çš„GUIDï¼Œåªéœ€è°ƒç”¨ï¼š RequestContext.Set(\"TraceId\", new Guid()); åœ¨grainä»£ç (æˆ–åœ¨Orleanså†…è¿è¡Œçš„è°ƒåº¦ç¨‹åºçº¿ç¨‹ä¸Šçš„å…¶ä»–ä»£ç )ä¸­ï¼Œå¯ä»¥ä½¿ç”¨åŸå§‹å®¢æˆ·ç«¯è¯·æ±‚çš„è·Ÿè¸ªIDï¼Œä¾‹å¦‚ï¼Œåœ¨ç¼–å†™æ—¥å¿—æ—¶ï¼š Logger.Info(\"Currently processing external request {0}\", RequestContext.Get(\"TraceId\")); è™½ç„¶ä»»ä½•å¯åºåˆ—åŒ–çš„å¯¹è±¡éƒ½å¯ä»¥ä½œä¸ºåº”ç”¨ç¨‹åºå…ƒæ•°æ®å‘é€ï¼Œä½†å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¤§å‹æˆ–å¤æ‚çš„å¯¹è±¡å¯èƒ½ä¼šç»™æ¶ˆæ¯åºåˆ—åŒ–æ—¶é—´å¢åŠ æ˜¾è‘—çš„å¼€é”€ã€‚å› æ­¤ï¼Œå»ºè®®ä½¿ç”¨ç®€å•ç±»å‹(å­—ç¬¦ä¸²ã€guidæˆ–æ•°å­—ç±»å‹)ã€‚"
  },
  "Documentation/grains/external_tasks_and_grains.html": {
    "href": "Documentation/grains/external_tasks_and_grains.html",
    "title": "External Tasks and Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤–éƒ¨ä»»åŠ¡å’Œgrain æ ¹æ®è®¾è®¡ï¼Œä»»ä½•ä»å­çº§ä»£ç ä¸­äº§ç”Ÿçš„å­ä»»åŠ¡(ä¾‹å¦‚ï¼Œé€šè¿‡ä½¿ç”¨awaitè¦ä¹ˆ ç»§ç»­ è¦ä¹ˆ Task.Factory.StartNew )å°†åœ¨æ¯æ¬¡æ¿€æ´»æ—¶åˆ†æ´¾ TPLä»»åŠ¡è®¡åˆ’ç¨‹åº ä½œä¸ºçˆ¶ä»»åŠ¡ï¼Œå› æ­¤ç»§æ‰¿äº†ä¸å…¶ä½™Grainsä»£ç ç›¸åŒçš„å•çº¿ç¨‹æ‰§è¡Œæ¨¡å‹ã€‚è¿™æ˜¯å•çº¿ç¨‹æ‰§è¡Œçš„ä¸»è¦è¦ç‚¹ åŸºäºGrainsè½¬å‘çš„å¹¶å‘ ã€‚ åœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒGrainsä»£ç å¯èƒ½éœ€è¦â€œçªç ´â€Orleansä»»åŠ¡è°ƒåº¦æ¨¡å‹å¹¶â€œåšä¸€äº›ç‰¹åˆ«çš„äº‹æƒ…â€ï¼Œä¾‹å¦‚æ˜ç¡®æŒ‡å‘ Task åˆ°å…¶ä»–ä»»åŠ¡è®¡åˆ’ç¨‹åºæˆ–ä½¿ç”¨.NETçº¿ç¨‹æ± ã€‚è¿™ç§æƒ…å†µçš„ä¸€ä¸ªä¾‹å­æ˜¯å½“Grainsä»£ç å¿…é¡»æ‰§è¡ŒåŒæ­¥çš„è¿œç¨‹é˜»å¡è°ƒç”¨(ä¾‹å¦‚è¿œç¨‹IO)æ—¶ã€‚åœ¨Grainsç¯å¢ƒä¸­æ‰§è¡Œæ­¤æ“ä½œå°†é˜»å¡Grainsä»¥åŠOrleansçº¿ç¨‹ä¹‹ä¸€ï¼Œå› æ­¤æ°¸è¿œä¸åº”è¯¥è¿™æ ·åšã€‚ç›¸åï¼Œgrainä»£ç å¯ä»¥åœ¨çº¿ç¨‹æ± çº¿ç¨‹ä¸Šæ‰§è¡Œè¿™æ®µé˜»å¡ä»£ç å¹¶åŠ å…¥(await)è¯¥æ‰§è¡Œçš„å®Œæˆï¼Œå¹¶æ ¹æ®å…·ä½“æƒ…å†µè¿›è¡Œã€‚æˆ‘ä»¬å¸Œæœ›ï¼Œä»â€œOrleansâ€è°ƒåº¦ç¨‹åºä¸­è½¬ä¹‰å°†æ˜¯éå¸¸é«˜çº§ä¸”å¾ˆå°‘éœ€è¦çš„ä½¿ç”¨åœºæ™¯ï¼Œè¶…å‡ºäº†â€œæ­£å¸¸â€ä½¿ç”¨æ¨¡å¼ã€‚ åŸºäºä»»åŠ¡çš„APIï¼š 1)awaitï¼Œ Task.Factory.StartNew (è§ä¸‹æ–‡)ï¼Œ Task.ContinuewWith ï¼Œ Task.WhenAny ï¼Œ Task.WhenAll ï¼Œ Task.Delay éƒ½å°Šé‡å½“å‰çš„ä»»åŠ¡è®¡åˆ’ç¨‹åºã€‚è¿™æ„å‘³ç€ä»¥é»˜è®¤æ–¹å¼ä½¿ç”¨å®ƒä»¬è€Œä¸ä¼ é€’å…¶ä»–TaskSchedulerä¼šä½¿å®ƒä»¬åœ¨Grainsä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œã€‚ 2)ä¸¤è€…Task.Run å’Œ endMethod çš„ä»£è¡¨ Task.Factory.FromAsync ä¸è¦å°Šé‡å½“å‰çš„ä»»åŠ¡è®¡åˆ’ç¨‹åºã€‚ä»–ä»¬éƒ½ä½¿ç”¨ TaskScheduler.Default Schedulerï¼Œå®ƒæ˜¯.NETçº¿ç¨‹æ± ä»»åŠ¡Schedulerã€‚å› æ­¤ï¼Œé‡Œé¢çš„ä»£ç Task.Run å’Œ endMethod å°†å§‹ç»ˆåœ¨OrleansGrainsçš„å•çº¿ç¨‹æ‰§è¡Œæ¨¡å‹ä¹‹å¤–çš„.NETçº¿ç¨‹æ± ä¸Šè¿è¡Œï¼Œ å¦‚è¿™é‡Œè¯¦ç»† ã€‚ä½†æ˜¯ï¼Œ ç­‰å¾…Task.Run è¦ä¹ˆ ç­‰å¾…Task.Factory.FromAsync å°†åœ¨åˆ›å»ºä»»åŠ¡æ—¶åœ¨è°ƒåº¦ç¨‹åºä¸‹è¿è¡Œï¼Œè¿™å°±æ˜¯Grainsè°ƒåº¦ç¨‹åºã€‚ 3) configureAwait(false) æ˜¯ç”¨äºé€ƒé¿å½“å‰ä»»åŠ¡è®¡åˆ’ç¨‹åºçš„æ˜¾å¼APIã€‚è¿™å°†å¯¼è‡´åœ¨ç­‰å¾…çš„ä»»åŠ¡ä¹‹ååœ¨ TaskScheduler.Default è°ƒåº¦ç¨‹åºï¼Œå®ƒæ˜¯.NETçº¿ç¨‹æ± ï¼Œå› æ­¤å°†ä¸­æ–­Orleans grainçš„å•çº¿ç¨‹æ‰§è¡Œã€‚ä½ ä¸€èˆ¬åº”è¯¥ æ°¸è¿œä¸è¦ä½¿ç”¨ ConfigureAwait(false) ç›´æ¥åœ¨Grainsä»£ç ä¸­ã€‚ 4)å¸¦ç­¾åçš„æ–¹æ³• å¼‚æ­¥æ— æ•ˆ ä¸åº”ä¸Grainsä¸€èµ·ä½¿ç”¨ã€‚å®ƒä»¬æ—¨åœ¨ç”¨äºå›¾å½¢ç”¨æˆ·æ¥å£äº‹ä»¶å¤„ç†ç¨‹åºã€‚ Task.Factory.StartNewå’Œå¼‚æ­¥å§”æ‰˜ åœ¨ä»»ä½•Cï¼ƒç¨‹åºä¸­è°ƒåº¦ä»»åŠ¡çš„é€šå¸¸å»ºè®®æ˜¯ä½¿ç”¨Task.Run æœ‰åˆ©äº Task.Factory.StartNew ã€‚å®é™…ä¸Šï¼Œè°·æ­Œå¿«é€Ÿæœç´¢ä½¿ç”¨ Task.Factory.StartNew() ä¼šå»ºè®®[é‚£æ˜¯å±é™©çš„](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html)å’Œ[é‚£åº”è¯¥æ°¸è¿œå–œæ¬¢Task.Run ]( https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ä¿ç•™åœ¨Orleanså•çº¿ç¨‹æ‰§è¡Œæ¨¡å‹ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨å®ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ­£ç¡®åœ°æ‰§è¡Œå®ƒå‘¢ï¼Ÿä½¿ç”¨æ—¶çš„â€œå±é™©â€`Task.Factory.StartNew()`æ˜¯å®ƒæœ¬èº«ä¸æ”¯æŒå¼‚æ­¥å§”æ‰˜ã€‚è¿™æ„å‘³ç€è¿™å¯èƒ½æ˜¯ä¸€ä¸ªé”™è¯¯ï¼š`var notIntendedTask = Task.Factory.StartNew(SomeDelegateAsync) ã€‚ notIntendedTask æ˜¯*ä¸*åœ¨ä»¥ä¸‹æ—¶é—´å®Œæˆçš„ä»»åŠ¡ SomeDelegateAsync åšã€‚ç›¸åï¼Œåº”è¯¥*æ€»æ˜¯*è§£å¼€è¿”å›çš„ä»»åŠ¡ï¼š var task = Task.Factory.StartNew(SomeDelegateAsync).Unwrap()`ã€‚ ä¾‹ï¼š ä»¥ä¸‹æ˜¯ç¤ºä¾‹ä»£ç ï¼Œæ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ TaskScheduler.Current ï¼ŒTask.Run`ä»¥åŠä¸€ä¸ªç‰¹æ®Šçš„è‡ªå®šä¹‰è°ƒåº¦ç¨‹åºï¼Œå¯ä»OrleanGrainsä¸Šä¸‹æ–‡ä»¥åŠå¦‚ä½•è¿”å›åˆ°è¯¥ä¸Šä¸‹æ–‡ä¸­é€ƒè„±ã€‚ public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; await TaskDelay(10000); // Current task scheduler did not change, the code after await is still running in the same task scheduler. Assert.AreEqual(orleansTs, TaskScheduler.Current); Task t1 = Task.Run( () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(TaskScheduler.Default, TaskScheduler.Current); } ); await t1; // We are back to the Orleans task scheduler. // Since await was executed in Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); // Example of using ask.Factory.StartNew with a custom scheduler to escape from the Orleans scheduler Task t2 = Task.Factory.StartNew(() => { // This code runs on the MyCustomSchedulerThatIWroteMyself scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); Assert.AreEqual(MyCustomSchedulerThatIWroteMyself, TaskScheduler.Current); }, CancellationToken.None, TaskCreationOptions.None, scheduler: MyCustomSchedulerThatIWroteMyself); await t2; // We are back to Orleans task scheduler. Assert.AreEqual(orleansTS, TaskScheduler.Current); } é«˜çº§ç¤ºä¾‹-ä»è¿è¡Œåœ¨çº¿ç¨‹æ± ä¸Šçš„ä»£ç è¿›è¡ŒGrainè°ƒç”¨ ç”šè‡³æ›´é«˜çº§çš„æ–¹æ¡ˆæ˜¯ä¸€æ®µGrainsä»£ç ï¼Œéœ€è¦â€œçªç ´â€Orleansä»»åŠ¡è°ƒåº¦æ¨¡å‹å¹¶åœ¨çº¿ç¨‹æ± (æˆ–å…¶ä»–éOrleansä¸Šä¸‹æ–‡)ä¸Šè¿è¡Œï¼Œä½†ä»éœ€è¦è°ƒç”¨å¦ä¸€ä¸ªGrainsã€‚å¦‚æœæ‚¨å°è¯•è¿›è¡Œä¸€æ¬¡Grainsè°ƒç”¨ä½†ä¸åœ¨Orleansä¸Šä¸‹æ–‡ä¸­ï¼Œåˆ™ä¼šæ”¶åˆ°ä¸€ä¸ªå¼‚å¸¸ï¼ŒæŒ‡å‡ºæ‚¨æ­£åœ¨â€œå°è¯•ä»silosè€Œä¸æ˜¯ä»Grainså†…éƒ¨è€Œä¸æ˜¯ç³»ç»Ÿç›®æ ‡å†…éƒ¨å‘é€æ¶ˆæ¯(RuntimeContextä¸æ˜¯ è®¾ç½®ä¸ºSchedulingContext)â€ã€‚ public async Task MyGrainMethod() { // Grab the Orleans task scheduler var orleansTs = TaskScheduler.Current; Task<int> t1 = Task.Run(async () => { // This code runs on the thread pool scheduler, not on Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); // You can do whatever you need to do here. Now let's say you need to make a grain call. Task<Task<int>> t2 = Task.Factory.StartNew(() => { // This code runs on the Orleans task scheduler since we specified the scheduler: orleansTs. Assert.AreEqual(orleansTS, TaskScheduler.Current); return GrainFactory.GetGrain<IFooGrain>(0).MakeGrainCall(); }, CancellationToken.None, TaskCreationOptions.None, scheduler: orleansTs); int res = await (await t2); // double await, unrelated to Orleans, just part of TPL APIs. // This code runs back on the thread pool scheduler, not on the Orleans task scheduler Assert.AreNotEqual(orleansTS, TaskScheduler.Current); return res; } ); int result = await t1; // We are back to the Orleans task scheduler. // Since await was executed in the Orleans task scheduler context, we are now back to that context. Assert.AreEqual(orleansTS, TaskScheduler.Current); } ä¸‹é¢çš„ä»£ç æ¼”ç¤ºäº†å¦‚ä½•ä»åœ¨Grainså†…éƒ¨ä½†ä¸åœ¨Grainsä¸Šä¸‹æ–‡ä¸­è¿è¡Œçš„ä¸€æ®µä»£ç è¿›è¡ŒGrainsè°ƒç”¨ã€‚ ä¸å›¾ä¹¦é¦†æ‰“äº¤é“ æ‚¨çš„ä»£ç æ­£åœ¨ä½¿ç”¨çš„æŸäº›å¤–éƒ¨åº“å¯èƒ½æ­£åœ¨ä½¿ç”¨ ConfigureAwait(false)å†…éƒ¨ã€‚ å®é™…ä¸Šï¼Œåœ¨.NETä¸­ä½¿ç”¨å®ƒæ˜¯ä¸€ç§æ­£ç¡®çš„å¥½ä¹ æƒ¯ ConfigureAwait(false) åœ¨å®ç°é€šç”¨åº“æ—¶ã€‚åœ¨Orleansï¼Œè¿™ä¸æ˜¯é—®é¢˜ã€‚ åªè¦è°ƒç”¨åº“æ–¹æ³•çš„grainä¸­çš„ä»£ç æ­£åœ¨ç­‰å¾…å¸¸è§„çš„åº“è°ƒç”¨ ç­‰å¾…ï¼Œç²’ç æ­£ç¡®ã€‚ ç»“æœå°†å®Œå…¨ç¬¦åˆè¦æ±‚-åº“ä»£ç å°†åœ¨Default Schedulerä¸Šç»§ç»­è¿è¡Œ(ç¢°å·§æ˜¯ ThreadPoolTaskâ€‹â€‹Scheduler ä½†è¿™ä¸èƒ½ä¿è¯ç»§ç»­æ“ä½œä¸€å®šä¼šåœ¨ThreadPoolçº¿ç¨‹ä¸Šè¿è¡Œï¼Œå› ä¸ºç»§ç»­æ“ä½œé€šå¸¸åœ¨ä¸Šä¸€ä¸ªçº¿ç¨‹ä¸­å†…è”)ï¼Œè€Œgrainä»£ç å°†åœ¨Orleansè°ƒåº¦ç¨‹åºä¸Šè¿è¡Œã€‚ å¦ä¸€ä¸ªç»å¸¸é—®åˆ°çš„é—®é¢˜æ˜¯ï¼Œæ˜¯å¦éœ€è¦ä½¿ç”¨Task.Run -ä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯å¦éœ€è¦å°†åº“ä»£ç æ˜¾å¼å¸è½½åˆ°ThreadPool(ç”¨äºGrainsä»£ç ) Task.Run(()=> myLibrary.FooAsync()))ã€‚ç­”æ¡ˆæ˜¯å¦å®šçš„ã€‚é™¤äº†åº“ä»£ç è¿›è¡Œé˜»å¡åŒæ­¥è°ƒç”¨çš„æƒ…å†µå¤–ï¼Œæ— éœ€å°†ä»»ä½•ä»£ç å¸è½½åˆ°ThreadPoolã€‚é€šå¸¸ï¼Œä»»ä½•ç¼–å†™æ­£ç¡®ä¸”æ­£ç¡®çš„.NETå¼‚æ­¥åº“(è¿”å›çš„æ–¹æ³• Task å¹¶ä»¥ å¼‚æ­¥`åç¼€)è¯·å‹¿æ‹¨è°ƒç”¨ã€‚å› æ­¤ï¼Œé™¤éæ‚¨æ€€ç–‘å¼‚æ­¥åº“æœ‰æ•…éšœæˆ–æ•…æ„ä½¿ç”¨åŒæ­¥é˜»å¡åº“ï¼Œå¦åˆ™æ— éœ€å°†ä»»ä½•å†…å®¹å¸è½½åˆ°ThreadPoolã€‚ æ‘˜è¦ ä½ æƒ³åšä»€ä¹ˆï¼Ÿ æ€ä¹ˆåš åœ¨.NETçº¿ç¨‹æ± çº¿ç¨‹ä¸Šè¿è¡Œåå°å·¥ä½œã€‚ä¸å…è®¸ä½¿ç”¨ä»»ä½•Grainsä»£ç æˆ–Grainsè°ƒç”¨ã€‚ Task.Run` grainsæ¥å£è°ƒç”¨ æ–¹æ³•è¿”å›ç±»å‹= Task æˆ– Task<T> ä½¿ç”¨åŸºäºOrleanså›åˆçš„å¹¶å‘ä¿è¯( å¾€ä¸Šçœ‹ )ã€‚ Task.Factory.StartNew(WorkerAsync).Unwrap() ä½¿ç”¨åŸºäºOrleanså›åˆçš„å¹¶å‘ä¿è¯ï¼Œå¯ä»¥ä»Grainsä»£ç è¿è¡ŒåŒæ­¥å·¥ä½œè€…ä»»åŠ¡ã€‚ Task.Factory.StartNew(WorkerSync) æ‰§è¡Œå·¥ä½œé¡¹çš„è¶…æ—¶ Task.Delay + Task.WhenAny ç”¨äºasync/await æ™®é€šçš„.NET Task-Asyncç¼–ç¨‹æ¨¡å‹ã€‚æ”¯æŒå’Œæ¨è ConfigureAwait(false) è¯·å‹¿ä½¿ç”¨å†…éƒ¨Grainsä»£ç ã€‚ä»…åœ¨åº“å†…éƒ¨å…è®¸ã€‚ è°ƒç”¨å¼‚æ­¥åº“ awaitå›¾ä¹¦é¦†è°ƒç”¨"
  },
  "Documentation/grains/transactions.html": {
    "href": "Documentation/grains/transactions.html",
    "title": "æ ‡é¢˜ï¼šOrleans2.0ä¸­çš„äº¤æ˜“ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¸ƒå±€ï¼šé¡µé¢ æ ‡é¢˜ï¼šOrleans2.0ä¸­çš„äº¤æ˜“ Orleansäº¤æ˜“ Orleansæ”¯æŒé’ˆå¯¹æŒä¹…GrainsçŠ¶æ€çš„åˆ†å¸ƒå¼ACIDäº¤æ˜“ã€‚ å»ºç«‹ Orleansé€‰æ‹©åŠ å…¥äº¤æ˜“ã€‚å¿…é¡»å°†silosé…ç½®ä¸ºä½¿ç”¨äº‹åŠ¡ã€‚å¦‚æœä¸æ˜¯ï¼Œå¯¹Grainsä¸Šçš„äº‹åŠ¡æ–¹æ³•çš„ä»»ä½•è°ƒç”¨éƒ½å°†æ”¶åˆ°ä¸€ä¸ª OrleansTransactionsDisabledException ã€‚è¦åœ¨silosä¸Šå¯ç”¨äº¤æ˜“ï¼Œè¯·è°ƒç”¨ UseTransactions() åœ¨silosä¸»æœºæ„å»ºå™¨ä¸Šã€‚ var builder = new SiloHostBuilder().UseTransactions(); äº¤æ˜“çŠ¶æ€å­˜å‚¨ è¦ä½¿ç”¨äº‹åŠ¡ï¼Œç”¨æˆ·éœ€è¦é…ç½®æ•°æ®å­˜å‚¨ã€‚ä¸ºäº†æ”¯æŒå¸¦æœ‰äº‹åŠ¡çš„å„ç§æ•°æ®å­˜å‚¨ï¼Œå­˜å‚¨æŠ½è±¡ ITransactionalStateStorage å·²ç»ä»‹ç»äº†ã€‚è¿™ç§æŠ½è±¡æ˜¯ç‰¹å®šäºäº¤æ˜“éœ€æ±‚çš„ï¼Œä¸æ™®é€šçš„Grainså­˜å‚¨ä¸åŒ( IGrainå­˜å‚¨ )ã€‚è¦ä½¿ç”¨ç‰¹å®šäºäº‹åŠ¡çš„å­˜å‚¨ï¼Œç”¨æˆ·å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»»ä½•å®ç°æ¥é…ç½®å…¶silos ITransactionalStateStorage ï¼Œä¾‹å¦‚Azure( AddAzureTableTransactionalStateStorage )ã€‚ ä¾‹ï¼š var builder = new SiloHostBuilder() .AddAzureTableTransactionalStateStorage(\"TransactionStore\", options => { options.ConnectionString = â€YOUR_STORAGE_CONNECTION_STRINGâ€); }) .UseTransactions(); å‡ºäºå¼€å‘ç›®çš„ï¼Œå¦‚æœç‰¹å®šäº‹åŠ¡çš„å­˜å‚¨ä¸é€‚ç”¨äºæ‚¨éœ€è¦çš„æ•°æ®å­˜å‚¨ï¼Œåˆ™ IGrainå­˜å‚¨ å®ç°å¯ä»¥ä»£æ›¿ä½¿ç”¨ã€‚å¯¹äºä»»ä½•æœªä¸ºå…¶é…ç½®å­˜å‚¨çš„äº‹åŠ¡çŠ¶æ€ï¼Œäº‹åŠ¡å°†å°è¯•ä½¿ç”¨ç½‘æ¡¥æ•…éšœè½¬ç§»åˆ°Grainså­˜å‚¨ã€‚é€šè¿‡é€šå¾€Grainså­˜å‚¨çš„æ¡¥æ¢è®¿é—®äº¤æ˜“çŠ¶æ€å°†æ•ˆç‡è¾ƒä½ï¼Œå¹¶ä¸”ä¸æ˜¯æˆ‘ä»¬æ‰“ç®—é•¿æœŸæ”¯æŒçš„æ¨¡å¼ï¼Œå› æ­¤å»ºè®®å°†å…¶ä»…ç”¨äºå¼€å‘ç›®çš„ã€‚ ç¨‹å¼è®¾è®¡æ¨¡å‹ grainsæ¥å£ ä¸ºäº†ä½¿Grainsæ”¯æŒäº¤æ˜“ï¼Œå¿…é¡»ä½¿ç”¨â€œäº¤æ˜“â€å±æ€§å°†Grainsæ¥å£ä¸Šçš„äº¤æ˜“æ–¹æ³•æ ‡è®°ä¸ºäº¤æ˜“çš„ä¸€éƒ¨åˆ†ã€‚è¯¥å±æ€§éœ€æ±‚é€šè¿‡ä¸‹é¢çš„äº‹åŠ¡é€‰é¡¹æŒ‡ç¤ºåœ¨è°ƒç”¨ç¯å¢ƒä¸­grainè°ƒç”¨çš„è¡Œä¸ºï¼š TransactionOption.Create -è°ƒç”¨æ˜¯äº‹åŠ¡æ€§çš„ï¼Œå³ä½¿åœ¨ç°æœ‰äº‹åŠ¡ä¸Šä¸‹æ–‡ä¸­è¢«è°ƒç”¨ï¼Œä¹Ÿæ€»æ˜¯ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡ä¸Šä¸‹æ–‡(å³å®ƒå°†å¯åŠ¨ä¸€ä¸ªæ–°äº‹åŠ¡)ã€‚ TransactionOption.Join -è°ƒç”¨æ˜¯äº‹åŠ¡æ€§çš„ï¼Œä½†åªèƒ½åœ¨ç°æœ‰äº‹åŠ¡çš„ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚ TransactionOption.CreateOrJoin -é€šè¯å…·æœ‰äº¤æ˜“æ€§ã€‚å¦‚æœåœ¨äº‹åŠ¡ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ï¼Œå®ƒå°†ä½¿ç”¨è¯¥ä¸Šä¸‹æ–‡ï¼Œå¦åˆ™å®ƒå°†åˆ›å»ºä¸€ä¸ªæ–°çš„ä¸Šä¸‹æ–‡ã€‚ TransactionOption.Suppress -è°ƒç”¨ä¸æ˜¯äº‹åŠ¡æ€§çš„ï¼Œä½†å¯ä»¥ä»äº‹åŠ¡ä¸­è°ƒç”¨ã€‚å¦‚æœåœ¨äº‹åŠ¡ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ï¼Œåˆ™ä¸Šä¸‹æ–‡å°†ä¸ä¼šä¼ é€’ç»™è°ƒç”¨ã€‚ TransactionOption.Supported -é€šè¯ä¸æ˜¯äº¤æ˜“æ€§çš„ï¼Œä½†æ”¯æŒäº¤æ˜“ã€‚å¦‚æœåœ¨äº‹åŠ¡ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ï¼Œåˆ™ä¸Šä¸‹æ–‡å°†ä¼ é€’ç»™è°ƒç”¨ã€‚ TransactionOption.NotAllowed -è®¿é—®ä¸æ˜¯äº‹åŠ¡æ€§çš„ï¼Œä¸èƒ½ä»äº‹åŠ¡ä¸­è¿›è¡Œè®¿é—®ã€‚å¦‚æœåœ¨äº¤æ˜“ç¯å¢ƒä¸­è°ƒç”¨ï¼Œå®ƒå°†æŠ›å‡ºä¸€ä¸ª NotSupportedException ã€‚ å¯ä»¥å°†è®¿é—®æ ‡è®°ä¸ºâ€œåˆ›å»ºâ€ï¼Œè¿™æ„å‘³ç€è®¿é—®å°†å§‹ç»ˆå¯åŠ¨è‡ªå·±çš„äº‹åŠ¡ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ATMä¸­çš„â€œè½¬å¸â€æ“ä½œå°†å§‹ç»ˆå¯åŠ¨ä¸€ä¸ªæ¶‰åŠä¸¤ä¸ªå¼•ç”¨å¸æˆ·çš„æ–°äº¤æ˜“ã€‚ public interface IATMGrain : IGrainWithIntegerKey { [Transaction(TransactionOption.Create)] Task Transfer(Guid fromAccount, Guid toAccount, uint amountToTransfer); } å¸æˆ·ä¸Šçš„ææ¬¾å’Œå­˜æ¬¾äº¤æ˜“æ“ä½œæ ‡è®°ä¸ºâ€œåŠ å…¥â€ï¼Œè¡¨ç¤ºåªèƒ½åœ¨ç°æœ‰äº¤æ˜“çš„ä¸Šä¸‹æ–‡ä¸­è°ƒç”¨å®ƒä»¬ï¼Œå¦‚æœåœ¨ IATMGrain.Transfer(â€¦) ã€‚çš„ å–å¾—å¹³è¡¡ é€šè¯è¢«æ ‡è®° åˆ›å»ºæˆ–åŠ å…¥ å› æ­¤å¯ä»¥åœ¨ç°æœ‰äº¤æ˜“ä¸­è°ƒç”¨å®ƒï¼Œä¾‹å¦‚é€šè¿‡ IATMGrain.Transfer(â€¦) ï¼Œæˆ–å•ç‹¬ä½¿ç”¨ã€‚ public interface IAccountGrain : IGrainWithGuidKey { [Transaction(TransactionOption.Join)] Task Withdraw(uint amount); [Transaction(TransactionOption.Join)] Task Deposit(uint amount); [Transaction(TransactionOption.CreateOrJoin)] Task<uint> GetBalance(); } grainå®æ–½ grainå®æ–½éœ€è¦ä½¿ç”¨ ITransactionalState facet(è¯·å‚é˜…Facet System)ä»¥é€šè¿‡ACIDäº‹åŠ¡ç®¡ç†grainsçŠ¶æ€ã€‚ public interface ITransactionalState<TState> where TState : class, new() { Task<TResult> PerformRead<TResult>(Func<TState, TResult> readFunction); Task<TResult> PerformUpdate<TResult>(Func<TState, TResult> updateFunction); } å¿…é¡»é€šè¿‡ä¼ é€’ç»™äº‹åŠ¡çŠ¶æ€æ–¹é¢çš„åŒæ­¥åŠŸèƒ½æ¥æ‰§è¡Œå¯¹æŒä¹…çŠ¶æ€çš„æ‰€æœ‰è¯»å–æˆ–å†™å…¥è®¿é—®ã€‚è¿™å…è®¸äº¤æ˜“ç³»ç»Ÿä»¥äº¤æ˜“æ–¹å¼æ‰§è¡Œæˆ–å–æ¶ˆè¿™äº›æ“ä½œã€‚è¦åœ¨Grainsä¸­ä½¿ç”¨äº‹åŠ¡çŠ¶æ€ï¼Œåªéœ€è¦å®šä¹‰ä¸€ä¸ªå¯åºåˆ—åŒ–çš„çŠ¶æ€ç±»å³å¯ä¿ç•™ï¼Œå¹¶åœ¨Grainsçš„æ„é€ å‡½æ•°ä¸­ä½¿ç”¨ äº¤æ˜“çŠ¶æ€ å±æ€§ã€‚åè€…å£°æ˜çŠ¶æ€åç§°å’Œ(å¯é€‰)ä½¿ç”¨å“ªä¸ªäº‹åŠ¡çŠ¶æ€å­˜å‚¨(è¯·å‚é˜…å®‰è£…ç¨‹åº)ã€‚ [AttributeUsage(AttributeTargets.Parameter)] public class TransactionalStateAttribute : Attribute { public TransactionalStateAttribute(string stateName, string storageName = null) { â€¦ } } ä¾‹ï¼š public class AccountGrain : Grain, IAccountGrain { private readonly ITransactionalState<Balance> balance; public AccountGrain( [TransactionalState(\"balance\", \"TransactionStore\")] ITransactionalState<Balance> balance) { this.balance = balance ?? throw new ArgumentNullException(nameof(balance)); } Task IAccountGrain.Deposit(uint amount) { return this.balance.PerformUpdate(x => x.Value += amount); } Task IAccountGrain.Withdrawal(uint amount) { return this.balance.PerformUpdate(x => x.Value -= amount); } Task<uint> IAccountGrain.GetBalance() { return this.balance.PerformRead(x => x.Value); } } åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œå±æ€§ äº¤æ˜“çŠ¶æ€ ç”¨äºå£°æ˜â€œ balanceâ€æ„é€ å‡½æ•°å‚æ•°åº”ä¸åä¸ºâ€œ balanceâ€çš„äº¤æ˜“çŠ¶æ€ç›¸å…³è”ã€‚é€šè¿‡æ­¤å£°æ˜ï¼ŒOrleanså°†æ³¨å…¥ ITransactionalState ä»åä¸ºâ€œ TransactionStoreâ€çš„äº‹åŠ¡çŠ¶æ€å­˜å‚¨ä¸­åŠ è½½çŠ¶æ€çš„å®ä¾‹(è¯·å‚é˜…å®‰è£…ç¨‹åº)ã€‚å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¿®æ”¹çŠ¶æ€ æ‰§è¡Œæ›´æ–° æˆ–é€šè¿‡é˜…è¯» PerformRead ã€‚äº¤æ˜“åŸºç¡€æ¶æ„å°†ç¡®ä¿ä½œä¸ºäº¤æ˜“ä¸€éƒ¨åˆ†è¿›è¡Œçš„ä»»ä½•æ­¤ç±»æ›´æ”¹ï¼Œå³ä½¿æ˜¯åœ¨åˆ†å¸ƒäºOrleansé›†ç¾¤ä¸­çš„å¤šä¸ªGrainsä¹‹é—´ï¼Œä¹Ÿå°†åœ¨åˆ›å»ºäº¤æ˜“çš„Grainsè°ƒç”¨å®Œæˆåå…¨éƒ¨æäº¤æˆ–å…¨éƒ¨æ’¤æ¶ˆ( IATMGrain.Transfer åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­)ã€‚ è®¿é—®äº¤æ˜“ å¦‚åŒå…¶ä»–ä»»ä½•Grainsè°ƒç”¨ä¸€æ ·ï¼Œè°ƒç”¨Grainsæ¥å£ä¸Šçš„äº‹åŠ¡æ–¹æ³•ã€‚ IATMGrain atm = client.GetGrain<IATMGrain>(0); Guid from = Guid.NewGuid(); Guid to = Guid.NewGuid(); await atm.Transfer(from, to, 100); uint fromBalance = await client.GetGrain<IAccountGrain>(from).GetBalance(); uint toBalance = await client.GetGrain<IAccountGrain>(to).GetBalance(); åœ¨ä¸Šè¿°è®¿é—®ä¸­ï¼Œä½¿ç”¨ATMGrainså°†100ä¸ªå•ä½çš„è´§å¸ä»ä¸€ä¸ªå¸æˆ·è½¬ç§»åˆ°å¦ä¸€ä¸ªå¸æˆ·ã€‚è½¬å¸å®Œæˆåï¼Œå°†æŸ¥è¯¢ä¸¤ä¸ªå¸æˆ·ä»¥è·å–å…¶å½“å‰ä½™é¢ã€‚è´§å¸è½¬å¸ä»¥åŠä¸¤ä¸ªå¸æˆ·æŸ¥è¯¢å‡ä½œä¸ºACIDäº‹åŠ¡æ‰§è¡Œã€‚ å¦‚ä¸Šä¾‹æ‰€ç¤ºï¼Œäº‹åŠ¡å¯ä»¥åƒå…¶ä»–grainè°ƒç”¨ä¸€æ ·è¿”å›ä»»åŠ¡ä¸­çš„å€¼ï¼Œä½†æ˜¯åœ¨è°ƒç”¨å¤±è´¥æ—¶ï¼Œå®ƒä»¬ä¸ä¼šå¼•å‘åº”ç”¨ç¨‹åºå¼‚å¸¸ï¼Œè€Œæ˜¯ OrleansTransactionException è¦ä¹ˆ TimeoutException ã€‚å¦‚æœåº”ç”¨ç¨‹åºåœ¨äº‹åŠ¡æœŸé—´å¼•å‘å¼‚å¸¸ï¼Œå¹¶ä¸”è¯¥å¼‚å¸¸å¯¼è‡´äº‹åŠ¡å¤±è´¥(ä¸å…¶ä»–ç³»ç»Ÿæ•…éšœå¯¼è‡´çš„å¤±è´¥ç›¸å)ï¼Œåˆ™åº”ç”¨ç¨‹åºå¼‚å¸¸å°†æ˜¯äº‹åŠ¡çš„å†…éƒ¨å¼‚å¸¸ã€‚ OrleansTransactionException ã€‚å¦‚æœæŠ›å‡ºç±»å‹çš„äº¤æ˜“å¼‚å¸¸ OrleansTransactionAbortedException ï¼Œäº¤æ˜“å¤±è´¥ï¼Œå¯ä»¥é‡è¯•ã€‚å¼•å‘çš„ä»»ä½•å…¶ä»–å¼‚å¸¸éƒ½è¡¨ç¤ºäº‹åŠ¡ä»¥æœªçŸ¥çŠ¶æ€ç»ˆæ­¢ã€‚ç”±äºäº‹åŠ¡æ˜¯åˆ†å¸ƒå¼æ“ä½œï¼Œå› æ­¤å¤„äºæœªçŸ¥çŠ¶æ€çš„äº‹åŠ¡å¯èƒ½å·²ç»æˆåŠŸï¼Œå¤±è´¥æˆ–ä»åœ¨è¿›è¡Œä¸­ã€‚å› æ­¤ï¼Œå»ºè®®è®¾ç½®é€šè¯è¶…æ—¶æ—¶é—´( SiloMessagingOptions.ResponseTimeout )ä¼ é€’ï¼Œä»¥é¿å…çº§è”ä¸­æ­¢ï¼Œç„¶åå†éªŒè¯çŠ¶æ€æˆ–é‡è¯•æ“ä½œã€‚"
  },
  "Documentation/grains/interceptors.html": {
    "href": "Documentation/grains/interceptors.html",
    "title": "Grain Call Filters | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Grainsè®¿é—®è¿‡æ»¤å™¨ Grainsè°ƒç”¨è¿‡æ»¤å™¨æä¾›äº†ä¸€ç§æ‹¦æˆªGrainsè°ƒç”¨çš„æ–¹æ³•ã€‚ç­›é€‰å™¨å¯ä»¥åœ¨Grainsè°ƒç”¨ä¹‹å‰å’Œä¹‹åæ‰§è¡Œä»£ç ã€‚å¯ä»¥åŒæ—¶å®‰è£…å¤šä¸ªè¿‡æ»¤å™¨ã€‚è¿‡æ»¤å™¨æ˜¯å¼‚æ­¥çš„ï¼Œå¯ä»¥ä¿®æ”¹ RequestContext ï¼Œå‚æ•°å’Œè¢«è°ƒç”¨æ–¹æ³•çš„è¿”å›å€¼ã€‚è¿‡æ»¤å™¨è¿˜å¯ä»¥æ£€æŸ¥ æ–¹æ³•ä¿¡æ¯ å¯ä»¥åœ¨Grainç±»ä¸Šè°ƒç”¨çš„æ–¹æ³•ï¼Œå¯ç”¨äºå¼•å‘æˆ–å¤„ç†å¼‚å¸¸ã€‚ Grainè°ƒç”¨è¿‡æ»¤å™¨çš„ä¸€äº›ç¤ºä¾‹ç”¨æ³•æ˜¯ï¼š æˆæƒï¼šè¿‡æ»¤å™¨å¯ä»¥æ£€æŸ¥æ­£åœ¨è°ƒç”¨çš„æ–¹æ³•ä»¥åŠå…¶ä¸­çš„å‚æ•°æˆ–æŸäº›æˆæƒä¿¡æ¯ RequestContext ç¡®å®šæ˜¯å¦å…è®¸å‘¼å«ç»§ç»­è¿›è¡Œã€‚ è®°å½•/é¥æµ‹ï¼šè¿‡æ»¤å™¨å¯ä»¥è®°å½•ä¿¡æ¯å¹¶æ•è·è®¡æ—¶æ•°æ®å’Œæœ‰å…³æ–¹æ³•è°ƒç”¨çš„å…¶ä»–ç»Ÿè®¡ä¿¡æ¯ã€‚ é”™è¯¯å¤„ç†ï¼šè¿‡æ»¤å™¨å¯ä»¥æ‹¦æˆªæ–¹æ³•è°ƒç”¨å¼•å‘çš„å¼‚å¸¸ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºå¦ä¸€ä¸ªå¼‚å¸¸ï¼Œæˆ–è€…åœ¨é€šè¿‡è¿‡æ»¤å™¨æ—¶å¤„ç†è¯¥å¼‚å¸¸ã€‚ è¿‡æ»¤å™¨æœ‰ä¸¤ç§å£å‘³ï¼š è®¿é—®è¿‡æ»¤ å‘¼å‡ºè°ƒç”¨è¿‡æ»¤å™¨ æ”¶åˆ°å‘¼å«æ—¶ï¼Œå°†æ‰§è¡Œä¼ å…¥å‘¼å«è¿‡æ»¤å™¨ã€‚æ‹¨è°ƒç”¨æ—¶æ‰§è¡Œå‘¼å‡ºè°ƒç”¨è¿‡æ»¤å™¨ã€‚ è®¿é—®è¿‡æ»¤ ä¼ å…¥çš„Grainè°ƒç”¨è¿‡æ»¤å™¨å®ç°äº† IIncomingGrainCallFilter æ¥å£ï¼Œå®ƒå…·æœ‰ä¸€ç§æ–¹æ³•ï¼š public interface IIncomingGrainCallFilter { Task Invoke(IIncomingGrainCallContext context); } çš„ IIncomingGrainCallContext å‚æ•°ä¼ é€’ç»™ Invoke æ–¹æ³•å…·æœ‰ä»¥ä¸‹å½¢çŠ¶ï¼š public interface IIncomingGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the interface method being invoked. /// </summary> MethodInfo InterfaceMethod { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the implementation method being invoked. /// </summary> MethodInfo ImplementationMethod { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } çš„ IIncomingGrainCallFilter.Invoke(IIncomingGrainCallContext) æ–¹æ³•å¿…é¡»ç­‰å¾…æˆ–è¿”å›çš„ç»“æœ IIncomingGrainCallContext.Invoke() æ‰§è¡Œä¸‹ä¸€ä¸ªé…ç½®çš„è¿‡æ»¤å™¨ï¼Œæœ€ç»ˆæ‰§è¡Œgrainæ–¹æ³•æœ¬èº«ã€‚çš„ Result å¯ä»¥åœ¨ç­‰å¾… Invoke() æ–¹æ³•ã€‚ ImplementationMethod å±æ€§è¿”å› MethodInfo å®ç°ç±»ã€‚è·å– MethodInfo å¯ä»¥ä½¿ç”¨ InterfaceMethod å±æ€§ã€‚å¯¹äºæ‰€æœ‰å¯¹Grainsçš„æ–¹æ³•è°ƒç”¨ï¼Œéƒ½ä¼šè°ƒç”¨Grainsè°ƒç”¨è¿‡æ»¤å™¨ï¼Œå…¶ä¸­åŒ…æ‹¬å¯¹Grainsæ‰©å±•çš„è°ƒç”¨( IGrainæ‰©å±• )å®‰è£…åœ¨Grainsä¸­ã€‚ä¾‹å¦‚ï¼Œgrainsæ‰©å±•ç”¨äºå®ç°æµå’Œå–æ¶ˆä»¤ç‰Œã€‚å› æ­¤ï¼Œåº”è¯¥æœŸæœ› ImplementationMethod åœ¨Grainsç±»æœ¬èº«ä¸­å¹¶ä¸æ€»æ˜¯ä¸€ç§æ–¹æ³•ã€‚ é…ç½®ä¼ å…¥å‘¼å«è¿‡æ»¤å™¨ çš„å®ç° IIncomingGrainCallFilter å¯ä»¥é€šè¿‡Dependency Injectionæ³¨å†Œä¸ºsilosçº§è¿‡æ»¤å™¨ï¼Œä¹Ÿå¯ä»¥é€šè¿‡Grainså®ç°å°†å…¶æ³¨å†Œä¸ºgrainsçº§è¿‡æ»¤å™¨ IIncomingGrainCallFilter ç›´ã€‚ silosèŒƒå›´å†…çš„æ‰€æœ‰è®¿é—®è¿‡æ»¤å™¨ å¯ä»¥ä½¿ç”¨Dependency Injectionå°†å§”æ‰˜æ³¨å†Œä¸ºsilosçº§çš„Grainè°ƒç”¨è¿‡æ»¤å™¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š siloHostBuilder.AddIncomingGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.InterfaceMethod.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); åŒæ ·ï¼Œå¯ä»¥ä½¿ç”¨ AddIncomingGrainCallFilter è¾…åŠ©æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªgrainè°ƒç”¨è¿‡æ»¤å™¨çš„ç¤ºä¾‹ï¼Œå®ƒè®°å½•æ¯ä¸ªgrainæ–¹æ³•çš„ç»“æœï¼š public class LoggingCallFilter : IIncomingGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IIncomingGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } ç„¶åå¯ä»¥ä½¿ç”¨ AddIncomingGrainCallFilter æ‰©å±•æ–¹æ³•ï¼š siloHostBuilder.AddIncomingGrainCallFilter<LoggingCallFilter>(); æˆ–è€…ï¼Œå¯ä»¥åœ¨ä¸ä½¿ç”¨æ‰©å±•æ–¹æ³•çš„æƒ…å†µä¸‹æ³¨å†Œè¿‡æ»¤å™¨ï¼š siloHostBuilder.ConfigureServices( services => services.AddSingleton<IIncomingGrainCallFilter, LoggingCallFilter>()); æ¯ç²’Grainsè°ƒç”¨è¿‡æ»¤å™¨ Grainsç±»å¯ä»¥å°†è‡ªå·±æ³¨å†Œä¸ºGrainsè°ƒç”¨è¿‡æ»¤å™¨ï¼Œå¹¶å¯ä»¥é€šè¿‡å®ç°å¯¹å®ƒçš„æ‰€æœ‰è°ƒç”¨è¿›è¡Œè¿‡æ»¤ IIncomingGrainCallFilter åƒè¿™æ ·ï¼š public class MyFilteredGrain : Grain, IMyFilteredGrain, IIncomingGrainCallFilter { public async Task Invoke(IIncomingGrainCallContext context) { await context.Invoke(); // Change the result of the call from 7 to 38. if (string.Equals(context.InterfaceMethod.Name, nameof(this.GetFavoriteNumber))) { context.Result = 38; } } public Task<int> GetFavoriteNumber() => Task.FromResult(7); } åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œå¯¹ GetFavoriteNumber æ–¹æ³•å°†è¿”å› 38 ä»£æ›¿ 7 ï¼Œå› ä¸ºè¿”å›å€¼å·²è¢«è¿‡æ»¤å™¨æ›´æ”¹ã€‚ è¿‡æ»¤å™¨çš„å¦ä¸€ä¸ªç”¨ä¾‹æ˜¯åœ¨è®¿é—®æ§åˆ¶ä¸­ï¼Œå¦‚ä»¥ä¸‹ç¤ºä¾‹æ‰€ç¤ºï¼š [AttributeUsage(AttributeTargets.Method)] public class AdminOnlyAttribute : Attribute { } public class MyAccessControlledGrain : Grain, IMyFilteredGrain, IIncomingGrainCallFilter { public Task Invoke(IIncomingGrainCallContext context) { // Check access conditions. var isAdminMethod = context.ImplementationMethod.GetCustomAttribute<AdminOnlyAttribute>(); if (isAdminMethod && !(bool) RequestContext.Get(\"isAdmin\")) { throw new AccessDeniedException($\"Only admins can access {context.ImplementationMethod.Name}!\"); } return context.Invoke(); } [AdminOnly] public Task<int> SpecialAdminOnlyOperation() => Task.FromResult(7); } åœ¨ä»¥ä¸Šç¤ºä¾‹ä¸­ï¼Œ SpecialAdminOnlyOperation è¯¥æ–¹æ³•åªèƒ½åœ¨ä»¥ä¸‹æƒ…å†µä¸‹è°ƒç”¨ â€œ isAdminâ€ è®¾å®šä¸º çœŸæ­£ åœ¨é‡Œé¢ RequestContext ã€‚è¿™æ ·ï¼Œå¯ä»¥å°†Grainsè°ƒç”¨è¿‡æ»¤å™¨ç”¨äºæˆæƒã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œå‘¼å«è€…æœ‰è´£ä»»ç¡®ä¿ â€œ isAdminâ€ å€¼è®¾ç½®æ­£ç¡®ï¼Œå¹¶ä¸”éªŒè¯æ­£ç¡®æ‰§è¡Œã€‚è¯·æ³¨æ„ [ä»…ç®¡ç†å‘˜] å±æ€§æ˜¯åœ¨Grainsç±»æ–¹æ³•ä¸ŠæŒ‡å®šçš„ã€‚è¿™æ˜¯å› ä¸º å®ç°æ–¹æ³• å±æ€§è¿”å› æ–¹æ³•ä¿¡æ¯ çš„å®ç°ï¼Œè€Œä¸æ˜¯æ¥å£ã€‚è¿‡æ»¤å™¨è¿˜å¯ä»¥æ£€æŸ¥ æ¥å£æ–¹æ³• å±æ€§ã€‚ grainså‘¼å«è¿‡æ»¤å™¨çš„è®¢è´­ Grainsè°ƒç”¨è¿‡æ»¤å™¨éµå¾ªå®šä¹‰çš„é¡ºåºï¼š IIncomingGrainCallFilter åœ¨ä¾èµ–é¡¹æ³¨å…¥å®¹å™¨ä¸­é…ç½®çš„å®ç°(æŒ‰æ³¨å†Œé¡ºåº)ã€‚ Grainsçº§è¿‡æ»¤å™¨(å¦‚æœä½¿ç”¨Grains) IIncomingGrainCallFilter ã€‚ grainæ–¹æ³•å®æ–½æˆ–grainæ‰©å±•æ–¹æ³•å®æ–½ã€‚ æ¯æ¬¡è°ƒç”¨ IIncomingGrainCallContext.Invoke() å°è£…ä¸‹ä¸€ä¸ªå®šä¹‰çš„è¿‡æ»¤å™¨ï¼Œä»¥ä¾¿æ¯ä¸ªè¿‡æ»¤å™¨éƒ½æœ‰æœºä¼šåœ¨é“¾ä¸­ä¸‹ä¸€ä¸ªè¿‡æ»¤å™¨ä¹‹å‰å’Œä¹‹åæ‰§è¡Œä»£ç ï¼Œå¹¶æœ€ç»ˆæ‰§è¡Œgrainæ–¹æ³•æœ¬èº«ã€‚ å‘¼å‡ºè°ƒç”¨è¿‡æ»¤å™¨ ä¼ å‡ºGrainsè°ƒç”¨è¿‡æ»¤å™¨ç±»ä¼¼äºä¼ å…¥Grainsè°ƒç”¨è¿‡æ»¤å™¨ï¼Œä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬æ˜¯åœ¨è°ƒç”¨è€…(å®¢æˆ·ç«¯)è€Œä¸æ˜¯è¢«è°ƒç”¨è€…(grains)ä¸Šè°ƒç”¨çš„ã€‚ ä¼ å‡ºå‘¼å«è¿‡æ»¤å™¨å®ç°äº† IOutgoingGrainCallFilter æ¥å£ï¼Œå®ƒå…·æœ‰ä¸€ç§æ–¹æ³•ï¼š public interface IOutgoingGrainCallFilter { Task Invoke(IOutgoingGrainCallContext context); } çš„ IOutgoingGrainCallContext å‚æ•°ä¼ é€’ç»™ Invoke æ–¹æ³•å…·æœ‰ä»¥ä¸‹å½¢çŠ¶ï¼š public interface IOutgoingGrainCallContext { /// <summary> /// Gets the grain being invoked. /// </summary> IAddressable Grain { get; } /// <summary> /// Gets the <see cref=\"MethodInfo\"/> for the interface method being invoked. /// </summary> MethodInfo InterfaceMethod { get; } /// <summary> /// Gets the arguments for this method invocation. /// </summary> object[] Arguments { get; } /// <summary> /// Invokes the request. /// </summary> Task Invoke(); /// <summary> /// Gets or sets the result. /// </summary> object Result { get; set; } } çš„ IOutgoingGrainCallFilter.Invoke(IOutgoingGrainCallContext) æ–¹æ³•å¿…é¡»ç­‰å¾…æˆ–è¿”å›çš„ç»“æœ IOutgoingGrainCallContext.Invoke() æ‰§è¡Œä¸‹ä¸€ä¸ªé…ç½®çš„è¿‡æ»¤å™¨ï¼Œæœ€ç»ˆæ‰§è¡Œgrainæ–¹æ³•æœ¬èº«ã€‚çš„ ç»“æœ å¯ä»¥åœ¨ç­‰å¾… è°ƒç”¨() æ–¹æ³•ã€‚çš„ æ–¹æ³•ä¿¡æ¯ å¯ä»¥ä½¿ç”¨ æ¥å£æ–¹æ³• å±æ€§ã€‚ä¼ å‡ºçš„Grainsè°ƒç”¨è¿‡æ»¤å™¨ä¼šé’ˆå¯¹æ‰€æœ‰å¯¹Grainsçš„æ–¹æ³•è°ƒç”¨è¿›è¡Œè°ƒç”¨ï¼Œå…¶ä¸­åŒ…æ‹¬å¯¹Orleansè¿›è¡Œçš„ç³»ç»Ÿæ–¹æ³•çš„è°ƒç”¨ã€‚ é…ç½®å»ç”µå‘¼å«è¿‡æ»¤å™¨ çš„å®ç° IOutgoingGrainCallFilter å¯ä»¥ä½¿ç”¨ä¾èµ–æ³¨å…¥åœ¨siloså’Œå®¢æˆ·ç«¯ä¸Šæ³¨å†Œã€‚ å¯ä»¥å°†å§”æ‰˜æ³¨å†Œä¸ºå‘¼å«è¿‡æ»¤å™¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š builder.AddOutgoingGrainCallFilter(async context => { // If the method being called is 'MyInterceptedMethod', then set a value // on the RequestContext which can then be read by other filters or the grain. if (string.Equals(context.InterfaceMethod.Name, nameof(IMyGrain.MyInterceptedMethod))) { RequestContext.Set(\"intercepted value\", \"this value was added by the filter\"); } await context.Invoke(); // If the grain method returned an int, set the result to double that value. if (context.Result is int resultValue) context.Result = resultValue * 2; }); åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œ å»ºé€ è€… å¯èƒ½æ˜¯ ISiloHostBuilder è¦ä¹ˆ IClientBuilder ã€‚ åŒæ ·ï¼Œå¯ä»¥å°†ä¸€ä¸ªç±»æ³¨å†Œä¸ºä¼ å‡ºçš„Grainè°ƒç”¨è¿‡æ»¤å™¨ã€‚è¿™æ˜¯ä¸€ä¸ªgrainè°ƒç”¨è¿‡æ»¤å™¨çš„ç¤ºä¾‹ï¼Œå®ƒè®°å½•æ¯ä¸ªgrainæ–¹æ³•çš„ç»“æœï¼š public class LoggingCallFilter : IOutgoingGrainCallFilter { private readonly Logger log; public LoggingCallFilter(Factory<string, Logger> loggerFactory) { this.log = loggerFactory(nameof(LoggingCallFilter)); } public async Task Invoke(IOutgoingGrainCallContext context) { try { await context.Invoke(); var msg = string.Format( \"{0}.{1}({2}) returned value {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), context.Result); this.log.Info(msg); } catch (Exception exception) { var msg = string.Format( \"{0}.{1}({2}) threw an exception: {3}\", context.Grain.GetType(), context.InterfaceMethod.Name, string.Join(\", \", context.Arguments), exception); this.log.Info(msg); // If this exception is not re-thrown, it is considered to be // handled by this filter. throw; } } } ç„¶åå¯ä»¥ä½¿ç”¨ AddOutgoingGrainCallFilter æ‰©å±•æ–¹æ³•ï¼š builder.AddOutgoingGrainCallFilter<LoggingCallFilter>(); æˆ–è€…ï¼Œå¯ä»¥åœ¨ä¸ä½¿ç”¨æ‰©å±•æ–¹æ³•çš„æƒ…å†µä¸‹æ³¨å†Œè¿‡æ»¤å™¨ï¼š builder.ConfigureServices( services => services.AddSingleton<IOutgoingGrainCallFilter, LoggingCallFilter>()); ä¸å§”æ‰˜è°ƒç”¨è¿‡æ»¤å™¨ç¤ºä¾‹ä¸€æ ·ï¼Œ å»ºé€ è€… å¯èƒ½æ˜¯ä»¥ä¸‹ä»»ä½•ä¸€ä¸ªçš„å®ä¾‹ ISiloHostBuiler è¦ä¹ˆ IClientBuilder ã€‚ ç”¨ä¾‹ å¼‚å¸¸è½¬æ¢ å½“ä»æœåŠ¡å™¨å¼•å‘çš„å¼‚å¸¸åœ¨å®¢æˆ·ç«¯ä¸Šååºåˆ—åŒ–æ—¶ï¼Œæœ‰æ—¶å¯èƒ½ä¼šæ”¶åˆ°ä»¥ä¸‹å¼‚å¸¸ï¼Œè€Œä¸æ˜¯å®é™…çš„å¼‚å¸¸ï¼š TypeLoadExceptionï¼šæ‰¾ä¸åˆ°Whatever.dllã€‚ å¦‚æœåŒ…å«å¼‚å¸¸çš„ç¨‹åºé›†å¯¹å®¢æˆ·ç«¯ä¸å¯ç”¨ï¼Œåˆ™ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚ä¾‹å¦‚ï¼Œå‡è®¾æ‚¨åœ¨grainå®ç°ä¸­ä½¿ç”¨å®ä½“æ¡†æ¶ï¼›é‚£ä¹ˆæœ‰å¯èƒ½ EntityException è¢«æŠ›å‡ºã€‚å¦ä¸€æ–¹é¢ï¼Œå®¢æˆ·ç«¯ä¸(ä¹Ÿä¸åº”è¯¥)å¼•ç”¨ EntityFramework.dll å› ä¸ºå®ƒä¸äº†è§£åŸºç¡€æ•°æ®è®¿é—®å±‚ã€‚ å½“å®¢æˆ·ç«¯å°è¯•ååºåˆ—åŒ– EntityException ï¼Œå®ƒå°†å› ç¼ºå°‘DLLè€Œå¤±è´¥ï¼›ç»“æœæ˜¯ TypeLoadExceptionç±»å‹åŠ è½½å¼‚å¸¸ æŠŠåŸæ¥çš„ä¸œè¥¿è—èµ·æ¥äº† å®ä½“å¼‚å¸¸ . æœ‰äººå¯èƒ½ä¼šè¯´è¿™å¾ˆå¥½ï¼Œå› ä¸ºå®¢æˆ·æ°¸è¿œä¸ä¼šå¤„ç† å®ä½“å¼‚å¸¸ å¦åˆ™å°±å¾—å‚è€ƒ EntityFramework.dll . ä½†æ˜¯å¦‚æœå®¢æˆ·ç«¯å¸Œæœ›è‡³å°‘è®°å½•å¼‚å¸¸å‘¢ï¼Ÿé—®é¢˜æ˜¯åŸæ¥çš„é”™è¯¯æ¶ˆæ¯ä¸¢å¤±äº†ã€‚è§£å†³æ­¤é—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯æˆªè·æœåŠ¡å™¨ç«¯å¼‚å¸¸å¹¶ç”¨ç±»å‹çš„çº¯å¼‚å¸¸æ›¿æ¢å®ƒä»¬ ä¾‹å¤– å¦‚æœå¼‚å¸¸ç±»å‹å¯èƒ½åœ¨å®¢æˆ·ç«¯æœªçŸ¥ã€‚ ç„¶è€Œï¼Œæœ‰ä¸€ä»¶é‡è¦çš„äº‹æˆ‘ä»¬å¿…é¡»ç‰¢è®°ï¼šæˆ‘ä»¬åªæƒ³æ›¿æ¢ä¸€ä¸ªä¾‹å¤– å¦‚æœè°ƒç”¨è€…æ˜¯Grainså®¢æˆ· . å¦‚æœè°ƒç”¨è€…æ˜¯å¦ä¸€ä¸ªgrain(æˆ–è€…æ­£åœ¨è¿›è¡Œgrainè°ƒç”¨çš„OrleansåŸºç¡€è®¾æ–½ï¼›ä¾‹å¦‚ GrainBasedReminderTable Grains)ã€‚ åœ¨æœåŠ¡å™¨ç«¯ï¼Œè¿™å¯ä»¥é€šè¿‡silosçº§åˆ«çš„æ‹¦æˆªå™¨æ¥å®ç°ï¼š public class ExceptionConversionFilter : IIncomingGrainCallFilter { private static readonly HashSet<string> KnownExceptionTypeAssemblyNames = new HashSet<string> { typeof(string).Assembly.GetName().Name, \"System\", \"System.ComponentModel.Composition\", \"System.ComponentModel.DataAnnotations\", \"System.Configuration\", \"System.Core\", \"System.Data\", \"System.Data.DataSetExtensions\", \"System.Net.Http\", \"System.Numerics\", \"System.Runtime.Serialization\", \"System.Security\", \"System.Xml\", \"System.Xml.Linq\", \"MyCompany.Microservices.DataTransfer\", \"MyCompany.Microservices.Interfaces\", \"MyCompany.Microservices.ServiceLayer\" }; public async Task Invoke(IIncomingGrainCallContext context) { var isConversionEnabled = RequestContext.Get(\"IsExceptionConversionEnabled\") as bool? == true; if (!isConversionEnabled) { // If exception conversion is not enabled, execute the call without interference. await context.Invoke(); return; } RequestContext.Remove(\"IsExceptionConversionEnabled\"); try { await context.Invoke(); } catch (Exception exc) { var type = exc.GetType(); if (KnownExceptionTypeAssemblyNames.Contains(type.Assembly.GetName().Name)) { throw; } // Throw a base exception containing some exception details. throw new Exception( string.Format( \"Exception of non-public type '{0}' has been wrapped.\" + \" Original message: <<<<----{1}{2}{3}---->>>>\", type.FullName, Environment.NewLine, exc, Environment.NewLine)); } } } ç„¶åå¯ä»¥åœ¨silosä¸Šæ³¨å†Œæ­¤ç­›é€‰å™¨ï¼š siloHostBuilder.AddIncomingGrainCallFilter<ExceptionConversionFilter>(); é€šè¿‡æ·»åŠ ä¼ å‡ºå‘¼å«ç­›é€‰å™¨ï¼Œä¸ºå®¢æˆ·ç«¯å‘å‡ºçš„å‘¼å«å¯ç”¨ç­›é€‰å™¨ï¼š clientBuilder.AddOutgoingGrainCallFilter(context => { RequestContext.Set(\"IsExceptionConversionEnabled\", true); return context.Invoke(); }); è¿™æ ·ï¼Œå®¢æˆ·ç«¯å°±å‘Šè¯‰æœåŠ¡å™¨å®ƒè¦ä½¿ç”¨å¼‚å¸¸è½¬æ¢ã€‚ ä»æ‹¦æˆªå™¨å‘¼å«Grains é€šè¿‡æ³¨å…¥ï¼Œå¯ä»¥ä»æ‹¦æˆªå™¨å‘å‡ºgrainè°ƒç”¨ IGRå·¥å‚ è¿›å…¥æ‹¦æˆªå™¨ç±»ï¼š private readonly IGrainFactory grainFactory; public CustomCallFilter(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Invoke(IIncomingGrainCallContext context) { // Hook calls to any grain other than ICustomFilterGrain implementations. // This avoids potential infinite recursion when calling OnReceivedCall() below. if (!(context.Grain is ICustomFilterGrain)) { var filterGrain = this.grainFactory.GetGrain<ICustomFilterGrain>(context.Grain.GetPrimaryKeyLong()); // Perform some grain call here. await filterGrain.OnReceivedCall(); } // Continue invoking the call on the target grain. await context.Invoke(); }"
  },
  "Documentation/grains/index.html": {
    "href": "Documentation/grains/index.html",
    "title": "Developing a Grain | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å‡†å¤‡ åœ¨ç¼–å†™ä»£ç ä»¥å®ç°Grainsç±»ä¹‹å‰ï¼Œè¯·åˆ›å»ºä¸€ä¸ªé’ˆå¯¹.NET Standardï¼ˆé¦–é€‰ï¼‰æˆ–.NET Framework 4.6.1æˆ–æ›´é«˜ç‰ˆæœ¬çš„æ–°ç±»åº“é¡¹ç›®ï¼ˆå¦‚æœç”±äºä¾èµ–æ€§è€Œæ— æ³•ä½¿ç”¨.NET Standardï¼‰ã€‚å¯ä»¥åœ¨åŒä¸€ä¸ªâ€œç±»åº“â€é¡¹ç›®ä¸­æˆ–åœ¨ä¸¤ä¸ªä¸åŒçš„é¡¹ç›®ä¸­å®šä¹‰grainsæ¥å£å’Œgrainsç±»ï¼Œä»¥æ›´å¥½åœ°å°†æ¥å£ä¸å®ç°åˆ†å¼€ã€‚æ— è®ºå“ªç§æƒ…å†µï¼Œé¡¹ç›®éƒ½éœ€è¦å‚è€ƒ Microsoft.Orleans.Core.Abstractions å’Œ Microsoft.Orleans.CodeGenerator.MSBuild NuGetè½¯ä»¶åŒ…ã€‚ æœ‰å…³æ›´è¯¦å°½çš„è¯´æ˜ï¼Œè¯·å‚è§ é¡¹ç›®è®¾ç½® çš„éƒ¨åˆ† æ•™ç¨‹ä¸€â€“OrleansåŸºç¡€ ã€‚ Grainsæ¥å£å’Œç±» Grainsé€šè¿‡ä»å¤–éƒ¨è°ƒç”¨å„ä¸ªGrainsæ¥å£ç”³æ˜çš„æ–¹æ³•è¿›è¡Œç›¸äº’äº¤äº’ã€‚Grainsç±»å®ç°ä¸€ä¸ªæˆ–å¤šä¸ªå…ˆå‰å£°æ˜çš„Grainsæ¥å£ã€‚Grainæ¥å£çš„æ‰€æœ‰æ–¹æ³•éƒ½å¿…é¡»è¿”å› Task ï¼ˆå¯¹äº virtual æ–¹æ³•ï¼‰ï¼Œä¸€ä¸ª Task<T> æˆ–ä¸€ä¸ª ValueTask <T> ï¼ˆå¯¹äºè¿”å›ç±»å‹ä¸ºå€¼çš„æ–¹æ³• T ï¼‰ã€‚ ä»¥ä¸‹æ˜¯Orleans 1.5 Presence Serviceç¤ºä¾‹çš„æ‘˜å½•ï¼š //an example of a Grain Interface public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } //an example of a Grain class implementing a Grain Interface public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGame() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGame(IGameGrain game) { currentGame = game; Console.WriteLine( \"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGame(IGameGrain game) { currentGame = null; Console.WriteLine( \"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return Task.CompletedTask; } } Grainsæ–¹æ³•çš„è¿”å›å€¼ è¿”å› T ç±»å‹å€¼çš„grainæ–¹æ³•åœ¨grainæ¥å£ä¸­å®šä¹‰ä¸ºè¿”å› Task<T> ã€‚å¯¹äºæœªæ ‡æœ‰asyncå…³é”®å­—ï¼Œå½“è¿”å›å€¼å¯ç”¨æ—¶ï¼Œé€šå¸¸é€šè¿‡ä»¥ä¸‹è¯­å¥è¿”å›ï¼š public Task<SomeType> GrainMethod1() { ... return Task.FromResult(<variable or constant with result>); } æ²¡æœ‰è¿”å›å€¼çš„grainæ–¹æ³•ï¼ˆå®é™…ä¸Šæ˜¯voidæ–¹æ³•ï¼‰åœ¨grainæ¥å£ä¸­å®šä¹‰ä¸ºè¿”å› Task ã€‚è¿”å›çš„ Task æŒ‡ç¤ºæ–¹æ³•çš„å¼‚æ­¥æ‰§è¡Œå’Œå®Œæˆã€‚å¯¹äºæœªæ ‡æœ‰asyncå…³é”®å­—ï¼Œå½“ void æ–¹æ³•å®Œæˆæ‰§è¡Œæ—¶ï¼Œéœ€è¦è¿”å›çš„ç‰¹æ®Šå€¼ Task.CompletedTask ï¼š public Task GrainMethod2() { ... return Task.CompletedTask; } æ ‡è®°ä¸ºasyncç›´æ¥è¿”å›å€¼ï¼š public async Task<SomeType> GrainMethod3() { ... return <variable or constant with result>; } ä¸€ç§ void çš„Grainsæ–¹æ³•æ ‡è®°ä¸ºasyncä¸è¿”å›å€¼çš„ä»£ç åªæ˜¯åœ¨æ‰§è¡Œç»“æŸæ—¶è¿”å›ï¼š public async Task GrainMethod4() { ... return; } å¦‚æœgrainæ–¹æ³•ä»å¦ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•è°ƒç”¨æ¥æ”¶åˆ°çš„è¿”å›å€¼ï¼ˆæ˜¯å¦è¿”å›grainï¼‰ï¼Œå¹¶ä¸”ä¸éœ€è¦å¯¹è¯¥è°ƒç”¨æ‰§è¡Œé”™è¯¯å¤„ç†ï¼Œåˆ™åªéœ€è¿”å› Task å®ƒä»è¯¥å¼‚æ­¥è°ƒç”¨æ¥æ”¶ä½œä¸ºå…¶è¿”å›å€¼ï¼š public Task<SomeType> GrainMethod5() { ... Task<SomeType> task = CallToAnotherGrain(); return task; } åŒæ ·ï¼Œ void Grainæ–¹æ³•å¯ä»¥è¿”å› Task é€šè¿‡å¦ä¸€ä¸ªè°ƒç”¨è¿”å›ç»™å®ƒï¼Œè€Œä¸æ˜¯ç­‰å¾…å®ƒã€‚ public Task GrainMethod6() { ... Task task = CallToAsyncAPI(); return task; } ValueTask <T> å¯ä»¥ä»£æ›¿ Task<T> Grainså¼•ç”¨ Grainså¼•ç”¨æ˜¯å®ç°ä¸ç›¸åº”Grainsç±»ç›¸åŒçš„Grainsæ¥å£çš„ä»£ç†å¯¹è±¡ã€‚å®ƒå°è£…äº†ç›®æ ‡Grainçš„é€»è¾‘æ ‡è¯†ï¼ˆç±»å‹å’Œå”¯ä¸€é”®ï¼‰ã€‚Grainså¼•ç”¨æ˜¯ç”¨äºè°ƒç”¨ç›®æ ‡Grainsçš„å·¥å…·ã€‚æ¯ä¸ªGrainså¼•ç”¨éƒ½é’ˆå¯¹å•ä¸ªGrainsï¼ˆGrainsç±»çš„å•ä¸ªå®ä¾‹ï¼‰ï¼Œä½†æ˜¯å¯ä»¥ä¸ºåŒä¸€ä¸ªGrainsåˆ›å»ºå¤šä¸ªç‹¬ç«‹çš„å¼•ç”¨ã€‚ ç”±äºGrainså¼•ç”¨ä»£è¡¨ç›®æ ‡Grainsçš„é€»è¾‘æ ‡è¯†ï¼Œå› æ­¤å®ƒä¸Grainsçš„ç‰©ç†ä½ç½®æ— å…³ï¼Œå³ä½¿åœ¨ç³»ç»Ÿå®Œå…¨é‡å¯åä¹Ÿä»ç„¶æœ‰æ•ˆã€‚å¼€å‘äººå‘˜å¯ä»¥åƒå…¶ä»–ä»»ä½•.NETå¯¹è±¡ä¸€æ ·ä½¿ç”¨Grainså¼•ç”¨ã€‚å®ƒå¯ä»¥ä¼ é€’ç»™æ–¹æ³•ï¼Œç”¨ä½œæ–¹æ³•çš„è¿”å›å€¼ç­‰ï¼Œç”šè‡³å¯ä»¥ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨ä¸­ã€‚ å¯ä»¥é€šè¿‡å°†Grainsçš„èº«ä»½ä¼ é€’ç»™ GrainFactory.GetGrain <T>(key) æ–¹æ³•ï¼Œåœ¨å“ªé‡Œ T æ˜¯Grainsæ¥å£ï¼Œ key æ˜¯è¯¥ç±»å‹ä¸­çº¹ç†çš„å”¯ä¸€é”®ã€‚ ä»¥ä¸‹æ˜¯å¦‚ä½•è·å– IPlayerGrain ä¸Šé¢å®šä¹‰çš„æ¥å£ã€‚ ä»Grainsç±»å†…éƒ¨ï¼š //construct the grain reference of a specific player IPlayerGrain player = GrainFactory.GetGrain<IPlayerGrain>(playerId); æ¥è‡ªOrleanså®¢æˆ·ä»£ç ã€‚ IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Grainæ–¹æ³•è°ƒç”¨ Orleansç¼–ç¨‹æ¨¡å‹åŸºäº å¼‚æ­¥ç¼–ç¨‹ ã€‚ ä½¿ç”¨ä¸Šä¸€ä¸ªç¤ºä¾‹ä¸­çš„grainå¼•ç”¨ï¼Œè¿™é‡Œæ˜¯æ‰§è¡Œgrainæ–¹æ³•è°ƒç”¨çš„æ–¹æ³•ï¼š //Invoking a grain method asynchronously Task joinGameTask = player.JoinGame(this); //The await keyword effectively makes the remainder of the method execute asynchronously at a later point (upon completion of the Task being awaited) without blocking the thread. await joinGameTask; //The next line will execute later, after joinGameTask is completed. players.Add(playerId); å¯ä»¥åŠ å…¥ä¸¤ä¸ªæˆ–å¤šä¸ª Task ;è”æ¥æ“ä½œåˆ›å»ºä¸€ä¸ªæ–°çš„ Task å½“æ‰€æœ‰ç»„æˆéƒ¨åˆ†éƒ½è§£å†³æ—¶ Task så®Œæˆã€‚å½“Grainséœ€è¦å¯åŠ¨å¤šä¸ªè®¡ç®—å¹¶ç­‰å¾…æ‰€æœ‰è®¡ç®—å®Œæˆåå†ç»§ç»­æ“ä½œæ—¶ï¼Œè¿™æ˜¯ä¸€ç§æœ‰ç”¨çš„æ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œç”Ÿæˆç”±è®¸å¤šéƒ¨åˆ†ç»„æˆçš„ç½‘é¡µçš„å‰ç«¯çº¹ç†å¯èƒ½ä¼šè¿›è¡Œå¤šä¸ªåç«¯è°ƒç”¨ï¼Œæ¯ä¸ªéƒ¨åˆ†ä¸€ä¸ªï¼Œå¹¶æ¥æ”¶ä¸€ä¸ª Task å¯¹äºæ¯ä¸ªç»“æœã€‚ç„¶åGrainså°†ç­‰å¾…æ‰€æœ‰è¿™äº›çš„åŠ å…¥ Task ;å½“åŠ å…¥ Task è§£å†³äº†ï¼Œä¸ªäºº Task å·²å®Œæˆï¼Œå¹¶ä¸”å·²æ”¶åˆ°æ ¼å¼åŒ–ç½‘é¡µæ‰€éœ€çš„æ‰€æœ‰æ•°æ®ã€‚ ä¾‹ï¼š List<Task> tasks = new List<Task>(); Message notification = CreateNewMessage(text); foreach (ISubscriber subscriber in subscribers) { tasks.Add(subscriber.Notify(notification)); } // WhenAll joins a collection of tasks, and returns a joined Task that will be resolved when all of the individual notification Tasks are resolved. Task joinedTask = Task.WhenAll(tasks); await joinedTask; // Execution of the rest of the method will continue asynchronously after joinedTask is resolve. è™šæ–¹æ³• Grainsç±»å¯ä»¥é€‰æ‹©è¦†ç›– OnActivateAsync å’Œ OnDeactivateAsync åœ¨æ¿€æ´»å’Œåœç”¨ç±»çš„æ¯ä¸ªGrainæ—¶ï¼Œç”±Orleansè¿è¡Œæ—¶è°ƒç”¨çš„è™šæ‹Ÿæ–¹æ³•ã€‚è¿™ä½¿Grainsä»£ç æœ‰æœºä¼šæ‰§è¡Œå…¶ä»–åˆå§‹åŒ–å’Œæ¸…ç†æ“ä½œã€‚å¼•å‘çš„å¼‚å¸¸ OnActivateAsync æ— æ³•æ¿€æ´»è¿‡ç¨‹ã€‚è€Œ OnActivateAsync ï¼Œå¦‚æœè¢«è¦†ç›–ï¼Œåˆ™å§‹ç»ˆè¢«ç§°ä¸ºGrainsæ¿€æ´»è¿‡ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œ OnDeactivateAsync ä¸èƒ½ä¿è¯åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚åœ¨æœåŠ¡å™¨æ•…éšœæˆ–å…¶ä»–å¼‚å¸¸äº‹ä»¶çš„æƒ…å†µä¸‹ï¼‰éƒ½ä¼šè¢«è°ƒç”¨ã€‚å› æ­¤ï¼Œåº”ç”¨ç¨‹åºä¸åº”ä¾èµ– OnDeactivateAsync ç”¨äºæ‰§è¡Œå…³é”®æ“ä½œï¼Œä¾‹å¦‚çŠ¶æ€å˜åŒ–çš„æŒä¹…åŒ–ã€‚ä»–ä»¬åº”ä»…å°†å…¶ç”¨äºå°½åŠ›è€Œä¸ºçš„æ“ä½œã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/serialization.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/serialization.html",
    "title": "Serialization and Writing Custom Serializers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "åºåˆ—åŒ–å’Œç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åº Orleansæœ‰ä¸€ä¸ªé«˜çº§å’Œå¯æ‰©å±•çš„åºåˆ—åŒ–æ¡†æ¶ã€‚orleansåºåˆ—åŒ–åœ¨grainè¯·æ±‚å’Œå“åº”æ¶ˆæ¯ä»¥åŠgrainæŒä¹…çŠ¶æ€å¯¹è±¡ä¸­ä¼ é€’çš„æ•°æ®ç±»å‹ã€‚ä½œä¸ºè¿™ä¸ªæ¡†æ¶çš„ä¸€éƒ¨åˆ†ï¼Œorleansè‡ªåŠ¨ä¸ºè¿™äº›æ•°æ®ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ä»£ç ã€‚é™¤äº†ä¸ºå·²å¯.NETåºåˆ—åŒ–çš„ç±»å‹ç”Ÿæˆæ›´æœ‰æ•ˆçš„åºåˆ—åŒ–/ååºåˆ—åŒ–ä¹‹å¤–ï¼ŒOrleansè¿˜å°è¯•ä¸ºä¸å¯.NETåºåˆ—åŒ–çš„Grainæ¥å£ä¸­ä½¿ç”¨çš„ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ç¨‹åºã€‚è¯¥æ¡†æ¶è¿˜åŒ…æ‹¬ä¸€ç»„ç”¨äºå¸¸ç”¨ç±»å‹(åˆ—è¡¨ã€å­—å…¸ã€å­—ç¬¦ä¸²ã€åŸè¯­ã€æ•°ç»„ç­‰)çš„é«˜æ•ˆå†…ç½®åºåˆ—åŒ–ç¨‹åºã€‚ Orleansçš„åºåˆ—åŒ–ç¨‹åºæœ‰ä¸¤ä¸ªé‡è¦çš„ç‰¹æ€§ï¼Œä½¿å®ƒä¸è®¸å¤šå…¶ä»–ç¬¬ä¸‰æ–¹åºåˆ—åŒ–æ¡†æ¶ä¸åŒï¼šåŠ¨æ€ç±»å‹/ä»»æ„å¤šæ€æ€§å’Œå¯¹è±¡æ ‡è¯†ã€‚ åŠ¨æ€ç±»å‹ä¸ä»»æ„å¤šæ€æ€§ -orleanså¯¹å¯ä»¥åœ¨grainè°ƒç”¨ä¸­ä¼ é€’çš„ç±»å‹æ²¡æœ‰ä»»ä½•é™åˆ¶ï¼Œå¹¶ä¿æŒäº†å®é™…æ•°æ®ç±»å‹çš„åŠ¨æ€ç‰¹æ€§ã€‚ä¾‹å¦‚ï¼Œè¿™æ„å‘³ç€å¦‚æœgrainæ¥å£ä¸­çš„æ–¹æ³•è¢«å£°æ˜ä¸ºæ¥å— è¯å…¸ ä½†åœ¨è¿è¡Œæ—¶å‘é€è€…é€šè¿‡ åˆ†ç±»è¯å…¸ ï¼Œæ¥æ”¶å™¨ç¡®å®ä¼š åˆ†ç±»è¯å…¸ (å°½ç®¡â€œstatic contract/grainâ€æ¥å£æ²¡æœ‰æŒ‡å®šæ­¤è¡Œä¸º)ã€‚ ç»´æŠ¤å¯¹è±¡æ ‡è¯† -å¦‚æœåŒä¸€ä¸ªå¯¹è±¡åœ¨ä¸€ä¸ªgrainè°ƒç”¨çš„å‚æ•°ä¸­ä¼ é€’äº†å¤šä¸ªç±»å‹ï¼Œæˆ–è€…ä»å‚æ•°ä¸­é—´æ¥æŒ‡å‘äº†å¤šä¸ªç±»å‹ï¼Œé‚£ä¹ˆorleanså°†åªåºåˆ—åŒ–å®ƒä¸€æ¬¡ã€‚åœ¨æ¥æ”¶ç«¯ï¼Œorleanså°†æ­£ç¡®åœ°æ¢å¤æ‰€æœ‰å¼•ç”¨ï¼Œä»¥ä¾¿ååºåˆ—åŒ–åæŒ‡å‘åŒä¸€å¯¹è±¡çš„ä¸¤ä¸ªæŒ‡é’ˆä»ç„¶æŒ‡å‘åŒä¸€å¯¹è±¡ã€‚åœ¨å¦‚ä¸‹åœºæ™¯ä¸­ï¼Œå¯¹è±¡æ ‡è¯†æ˜¯å¾ˆé‡è¦çš„ã€‚å‡è®¾actor aæ­£åœ¨å‘actor bå‘é€ä¸€ä¸ªåŒ…å«100ä¸ªæ¡ç›®çš„å­—å…¸ï¼Œå¹¶ä¸”å­—å…¸ä¸­çš„10ä¸ªé”®æŒ‡å‘aä¸€ä¾§çš„åŒä¸€ä¸ªå¯¹è±¡objã€‚åœ¨ä¸ä¿ç•™å¯¹è±¡æ ‡è¯†çš„æƒ…å†µä¸‹ï¼Œbå°†æ”¶åˆ°ä¸€ä¸ªåŒ…å«100ä¸ªæ¡ç›®çš„å­—å…¸ï¼Œå…¶ä¸­10ä¸ªé”®æŒ‡å‘10ä¸ªä¸åŒçš„objå…‹éš†ã€‚åœ¨ä¿ç•™å¯¹è±¡æ ‡è¯†çš„æƒ…å†µä¸‹ï¼ŒBä¾§çš„å­—å…¸ä¸Aä¾§çš„å­—å…¸å®Œå…¨ç›¸åŒï¼Œ10ä¸ªé”®æŒ‡å‘ä¸€ä¸ªå¯¹è±¡objã€‚ ä»¥ä¸Šä¸¤ä¸ªè¡Œä¸ºæ˜¯ç”±æ ‡å‡†çš„.NETäºŒè¿›åˆ¶åºåˆ—åŒ–ç¨‹åºæä¾›çš„ï¼Œå› æ­¤ï¼Œæ”¯æŒè¿™ä¸€æ ‡å‡†ä»¥åŠOrleanså¸¸è§çš„è¡Œä¸ºå¯¹æˆ‘ä»¬æ¥è¯´ä¹Ÿå¾ˆé‡è¦ã€‚ ç”Ÿæˆçš„åºåˆ—åŒ–ç¨‹åº Orleansä½¿ç”¨ä»¥ä¸‹è§„åˆ™æ¥å†³å®šè¦ç”Ÿæˆå“ªäº›åºåˆ—åŒ–ç¨‹åºã€‚è§„åˆ™æ˜¯ï¼š 1)æ‰«ææ‰€æœ‰å¼•ç”¨Core Orleansåº“çš„ç¨‹åºé›†ä¸­çš„æ‰€æœ‰ç±»å‹ã€‚ 2)åœ¨è¿™äº›ç¨‹åºé›†ä¸­ï¼šä¸ºç›´æ¥åœ¨grain interfacesæ–¹æ³•ç­¾åæˆ–çŠ¶æ€ç±»ç­¾åä¸­å¼•ç”¨çš„ç±»å‹æˆ–ä»»ä½•æ ‡è®°ä¸º [Serializable] å±æ€§ã€‚ 3)æ­¤å¤–ï¼Œgrainæ¥å£æˆ–å®ç°é¡¹ç›®å¯ä»¥é€šè¿‡æ·»åŠ  [çŸ¥è¯†] æˆ– [çŸ¥è¯†è£…é…] ç¨‹åºé›†çº§å±æ€§ï¼ŒæŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨ä¸ºç¨‹åºé›†ä¸­çš„ç‰¹å®šç±»å‹æˆ–æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ç¨‹åºã€‚ åºåˆ—åŒ–æä¾›ç¨‹åº Orleansæ”¯æŒä½¿ç”¨æä¾›ç¨‹åºæ¨¡å‹ä¸ç¬¬ä¸‰æ–¹åºåˆ—åŒ–ç¨‹åºé›†æˆã€‚è¿™éœ€è¦å®ç° IExternalSerializer åœ¨æ­¤æ–‡æ¡£çš„è‡ªå®šä¹‰åºåˆ—åŒ–éƒ¨åˆ†ä¸­æè¿°çš„ç±»å‹ã€‚ä¸€äº›å¸¸è§åºåˆ—åŒ–ç¨‹åºçš„é›†æˆä¸Orleansä¸€èµ·ç»´æŠ¤ï¼Œä¾‹å¦‚ï¼š åè®®ç¼“å†²åŒº ä»¥ä¸‹å†…å®¹ï¼š Orleans.Serialization.ProtobufSerializer ä» Microsoft.Orleans.OrleansGoogleå®ç”¨ç¨‹åº NugetåŒ…ã€‚ å€ºåˆ¸ ä»¥ä¸‹å†…å®¹ï¼š orleans.serialization.bondsserializer ä» Microsoft.Orleans.Serialization.bond NugetåŒ…ã€‚ newtonsoft.jsonåˆåjson.net ä»¥ä¸‹å†…å®¹ï¼š orleans.serialization.orleansjssonåºåˆ—åŒ–ç¨‹åº ä»Orleansæ ¸å¿ƒå›¾ä¹¦é¦†ã€‚ è‡ªå®šä¹‰å®ç° IExternalSerializer åœ¨ä¸‹é¢çš„ç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºéƒ¨åˆ†ä¸­è¿›è¡Œäº†æè¿°ã€‚ é…ç½® ç¡®ä¿åºåˆ—åŒ–é…ç½®åœ¨æ‰€æœ‰å®¢æˆ·ç«¯å’Œsilosä¸Šéƒ½æ˜¯ç›¸åŒçš„ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚å¦‚æœé…ç½®ä¸ä¸€è‡´ï¼Œåˆ™å¯èƒ½å‘ç”Ÿåºåˆ—åŒ–é”™è¯¯ã€‚ åºåˆ—åŒ–æä¾›ç¨‹åºï¼Œå®ƒå®ç° IExternalSerializer ï¼Œå¯ä»¥ä½¿ç”¨ åºåˆ—åŒ–æä¾›ç¨‹åº å±æ€§ å®¢æˆ·ç«¯é…ç½® å’Œ å…¨çƒé…ç½® ä»£ç ä¸­ï¼š var cfg = new ClientConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); var cfg = new GlobalConfiguration(); cfg.SerializationProviders.Add(typeof(FantasticSerializer).GetTypeInfo()); æˆ–è€…ï¼Œå¯ä»¥åœ¨ <serializationproviders/> å±æ€§ <ä¿¡æ¯> ä»¥ä¸‹å†…å®¹ï¼š <Messaging> <SerializationProviders> <Provider type=\"GreatCompany.FantasticSerializer, GreatCompany.SerializerAssembly\"/> </SerializationProviders> </Messaging> åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œéƒ½å¯ä»¥é…ç½®å¤šä¸ªæä¾›ç¨‹åºã€‚é›†åˆæ˜¯æœ‰åºçš„ï¼Œè¿™æ„å‘³ç€å¦‚æœå¯ä»¥åºåˆ—åŒ–ç±»å‹çš„æä¾›ç¨‹åº ä¸€ä¸ª å’Œ ä¹™ åœ¨åªèƒ½åºåˆ—åŒ–ç±»å‹çš„æä¾›ç¨‹åºä¹‹å‰æŒ‡å®š ä¹™ ï¼Œåˆ™ä¸ä¼šä½¿ç”¨åä¸€ä¸ªæä¾›ç¨‹åºã€‚ ç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åº é™¤äº†è‡ªåŠ¨åºåˆ—åŒ–ç”Ÿæˆä¹‹å¤–ï¼Œåº”ç”¨ç¨‹åºä»£ç è¿˜å¯ä»¥ä¸ºå…¶é€‰æ‹©çš„ç±»å‹æä¾›è‡ªå®šä¹‰åºåˆ—åŒ–ã€‚Orleanså»ºè®®å¯¹å¤§å¤šæ•°åº”ç”¨ç¨‹åºç±»å‹ä½¿ç”¨è‡ªåŠ¨åºåˆ—åŒ–ç”Ÿæˆï¼Œåªæœ‰åœ¨å°‘æ•°æƒ…å†µä¸‹ï¼Œå½“æ‚¨è®¤ä¸ºå¯ä»¥é€šè¿‡æ‰‹åŠ¨ç¼–å†™åºåˆ—åŒ–ç¨‹åºæ¥æé«˜æ€§èƒ½æ—¶ï¼Œæ‰ç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºã€‚æœ¬è¯´æ˜æè¿°äº†å¦‚ä½•è¿™æ ·åšï¼Œå¹¶ç¡®å®šäº†ä¸€äº›å¯èƒ½æœ‰ç”¨çš„ç‰¹å®šæƒ…å†µã€‚ åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ä¸‰ç§æ–¹å¼è‡ªå®šä¹‰åºåˆ—åŒ–ï¼š å‘ç±»å‹ä¸­æ·»åŠ åºåˆ—åŒ–æ–¹æ³•å¹¶ç”¨é€‚å½“çš„å±æ€§æ ‡è®°å®ƒä»¬( å¤å°æœº ï¼Œ åºåˆ—åŒ–æ–¹æ³• ï¼Œ ååºåˆ—åŒ–æ–¹æ³• )ä¸­ã€‚å¯¹äºåº”ç”¨ç¨‹åºæ‹¥æœ‰çš„ç±»å‹(å³å¯ä»¥å‘å…¶æ·»åŠ æ–°æ–¹æ³•çš„ç±»å‹)ï¼Œæ­¤æ–¹æ³•æ›´å¯å–ã€‚ å®æ–½ IExternalSerializer å¹¶åœ¨é…ç½®æœŸé—´æ³¨å†Œå®ƒã€‚æ­¤æ–¹æ³•å¯¹äºé›†æˆå¤–éƒ¨åºåˆ—åŒ–åº“éå¸¸æœ‰ç”¨ã€‚ ç¼–å†™ä¸€ä¸ªå•ç‹¬çš„é™æ€ç±»ï¼Œç”¨ [åºåˆ—åŒ–ç¨‹åº(typeof(yourtype))] å…¶ä¸­åŒ…å«3ä¸ªåºåˆ—åŒ–æ–¹æ³•å’Œä¸ä¸Šé¢ç›¸åŒçš„å±æ€§ã€‚æ­¤æ–¹æ³•å¯¹äºåº”ç”¨ç¨‹åºä¸æ‹¥æœ‰çš„ç±»å‹éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚ï¼Œåœ¨åº”ç”¨ç¨‹åºæ— æ³•æ§åˆ¶çš„å…¶ä»–åº“ä¸­å®šä¹‰çš„ç±»å‹ã€‚ ä»¥ä¸‹å„èŠ‚è¯¦ç»†ä»‹ç»äº†æ¯ç§æ–¹æ³•ã€‚ ä»‹ç» Orleansåºåˆ—åŒ–åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼šå¯¹è±¡ç«‹å³è¢«æ·±åº¦å¤åˆ¶ä»¥ç¡®ä¿éš”ç¦»ï¼›åœ¨è¿æ¥ä¹‹å‰ï¼›å¯¹è±¡è¢«åºåˆ—åŒ–ä¸ºæ¶ˆæ¯å­—èŠ‚æµï¼›å½“ä¼ é€’åˆ°ç›®æ ‡æ¿€æ´»æ—¶ï¼Œå¯¹è±¡ä»æ¥æ”¶çš„å­—èŠ‚æµé‡æ–°åˆ›å»º(ååºåˆ—åŒ–)ã€‚å¯ä»¥åœ¨æ¶ˆæ¯ä¸­å‘é€çš„æ•°æ®ç±»å‹(å³å¯ä»¥ä½œä¸ºæ–¹æ³•å‚æ•°æˆ–è¿”å›å€¼ä¼ é€’çš„ç±»å‹)å¿…é¡»å…·æœ‰æ‰§è¡Œè¿™ä¸‰ä¸ªæ­¥éª¤çš„å…³è”ä¾‹ç¨‹ã€‚æˆ‘ä»¬å°†è¿™äº›ä¾‹ç¨‹ç»Ÿç§°ä¸ºæ•°æ®ç±»å‹çš„åºåˆ—åŒ–ç¨‹åºã€‚ ç±»å‹çš„å¤å°æœºæ˜¯ç‹¬ç«‹çš„ï¼Œè€Œåºåˆ—åŒ–å™¨å’Œååºåˆ—åŒ–å™¨æ˜¯ä¸€èµ·å·¥ä½œçš„ä¸€å¯¹ã€‚æ‚¨å¯ä»¥åªæä¾›ä¸€ä¸ªè‡ªå®šä¹‰å¤å°æœºï¼Œæˆ–è€…åªæä¾›ä¸€ä¸ªè‡ªå®šä¹‰åºåˆ—åŒ–å™¨å’Œä¸€ä¸ªè‡ªå®šä¹‰ååºåˆ—åŒ–å™¨ï¼Œä¹Ÿå¯ä»¥æä¾›è¿™ä¸‰ä¸ªçš„è‡ªå®šä¹‰å®ç°ã€‚ åºåˆ—åŒ–ç¨‹åºåœ¨siloså¯åŠ¨æ—¶ä»¥åŠåŠ è½½ç¨‹åºé›†æ—¶ä¸ºæ¯ä¸ªå—æ”¯æŒçš„æ•°æ®ç±»å‹æ³¨å†Œã€‚å¯¹äºè¦ä½¿ç”¨çš„ç±»å‹ï¼Œè‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºä¾‹ç¨‹éœ€è¦æ³¨å†Œã€‚åºåˆ—åŒ–ç¨‹åºé€‰æ‹©åŸºäºè¦å¤åˆ¶æˆ–åºåˆ—åŒ–çš„å¯¹è±¡çš„åŠ¨æ€ç±»å‹ã€‚å› æ­¤ï¼Œä¸éœ€è¦ä¸ºæŠ½è±¡ç±»æˆ–æ¥å£åˆ›å»ºåºåˆ—åŒ–ç¨‹åºï¼Œå› ä¸ºå®ƒä»¬æ°¸è¿œä¸ä¼šè¢«ä½¿ç”¨ã€‚ ä½•æ—¶è€ƒè™‘ç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åº æ‰‹å·¥ç¼–åˆ¶çš„åºåˆ—åŒ–ç¨‹åºä¾‹ç¨‹å¾ˆå°‘ä¼šæ¯”ç”Ÿæˆçš„ç‰ˆæœ¬æ‰§è¡Œå¾—æ›´å¥½ã€‚å¦‚æœæ‚¨æƒ³è¿™æ ·åšï¼Œæ‚¨åº”è¯¥é¦–å…ˆè€ƒè™‘ä»¥ä¸‹é€‰é¡¹ï¼š å¦‚æœæ•°æ®ç±»å‹ä¸­æœ‰ä¸éœ€è¦åºåˆ—åŒ–æˆ–å¤åˆ¶çš„å­—æ®µæˆ–å±æ€§ï¼Œå¯ä»¥ä½¿ç”¨ éåºåˆ—åŒ– å±æ€§ã€‚è¿™å°†å¯¼è‡´ç”Ÿæˆçš„ä»£ç åœ¨å¤åˆ¶å’Œåºåˆ—åŒ–æ—¶è·³è¿‡è¿™äº›å­—æ®µã€‚ä½¿ç”¨ ä¸å¯å˜<t> & [ä¸å˜] å°½å¯èƒ½é¿å…å¤åˆ¶ä¸å¯å˜æ•°æ®ã€‚å…³äº ä¼˜åŒ–æ‹·è´ è¯¦æƒ…è§ä¸‹æ–‡ã€‚å¦‚æœè¦é¿å…ä½¿ç”¨æ ‡å‡†æ³›å‹é›†åˆç±»å‹ï¼Œè¯·ä¸è¦ä½¿ç”¨ã€‚Orleansè¿è¡Œæ—¶åŒ…å«æ³›å‹é›†åˆçš„è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºï¼Œè¿™äº›æ³›å‹é›†åˆä½¿ç”¨é›†åˆçš„è¯­ä¹‰æ¥ä¼˜åŒ–å¤åˆ¶ã€åºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚è¿™äº›é›†åˆåœ¨åºåˆ—åŒ–å­—èŠ‚æµä¸­è¿˜å…·æœ‰ç‰¹æ®Šçš„â€œç¼©å†™â€è¡¨ç¤ºå½¢å¼ï¼Œä»è€Œå¸¦æ¥æ›´å¤§çš„æ€§èƒ½ä¼˜åŠ¿ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ª å­—å…¸<stringï¼Œstring> ä¼šæ¯” list<tuple<stringï¼Œstring>> æ˜¯çš„ã€‚ è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºå¯ä»¥æä¾›æ˜¾è‘—æ€§èƒ½æé«˜çš„æœ€å¸¸è§æƒ…å†µæ˜¯ï¼Œæ•°æ®ç±»å‹ä¸­ç¼–ç äº†é‡è¦çš„è¯­ä¹‰ä¿¡æ¯ï¼Œè€Œè¿™äº›ä¿¡æ¯ä»…é€šè¿‡å¤åˆ¶å­—æ®µå€¼æ˜¯ä¸å¯ç”¨çš„ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡å°†æ•°ç»„è§†ä¸ºç´¢å¼•/å€¼å¯¹çš„é›†åˆï¼Œå³ä½¿åº”ç”¨ç¨‹åºä¸ºäº†æé«˜æ“ä½œé€Ÿåº¦è€Œå°†æ•°æ®ä¿æŒä¸ºå®Œå…¨å®ç°çš„æ•°ç»„ï¼Œå¡«å……è¾ƒå°‘çš„æ•°ç»„é€šå¸¸ä¹Ÿå¯ä»¥æ›´æœ‰æ•ˆåœ°åºåˆ—åŒ–ã€‚ åœ¨ç¼–å†™è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºä¹‹å‰ï¼Œè¦åšçš„ä¸€ä¸ªå…³é”®äº‹æƒ…æ˜¯ç¡®ä¿ç”Ÿæˆçš„åºåˆ—åŒ–ç¨‹åºç¡®å®ä¼šæŸå®³æ‚¨çš„æ€§èƒ½ã€‚åˆ†æåœ¨è¿™æ–¹é¢æœ‰ç‚¹å¸®åŠ©ï¼Œä½†æ›´é‡è¦çš„æ˜¯ä½¿ç”¨ä¸åŒçš„åºåˆ—åŒ–è´Ÿè½½è¿è¡Œåº”ç”¨ç¨‹åºçš„ç«¯åˆ°ç«¯å‹åŠ›æµ‹è¯•ï¼Œä»¥è¯„ä¼°ç³»ç»Ÿçº§åˆ«çš„å½±å“ï¼Œè€Œä¸æ˜¯åºåˆ—åŒ–çš„å¾®è§‚å½±å“ã€‚ä¾‹å¦‚ï¼Œæ„å»ºä¸€ä¸ªä¸å‘grainæ–¹æ³•ä¼ é€’å‚æ•°æˆ–ç»“æœçš„æµ‹è¯•ç‰ˆæœ¬ï¼Œåªéœ€åœ¨ä¸¤ç«¯ä½¿ç”¨å›ºå®šå€¼ï¼Œå°±å¯ä»¥æ”¾å¤§åºåˆ—åŒ–å’Œå¤åˆ¶å¯¹ç³»ç»Ÿæ€§èƒ½çš„å½±å“ã€‚ æ–¹æ³•1:å‘ç±»å‹æ·»åŠ åºåˆ—åŒ–æ–¹æ³• æ‰€æœ‰åºåˆ—åŒ–ç¨‹åºä¾‹ç¨‹éƒ½åº”å®ç°ä¸ºå®ƒä»¬æ‰€æ“ä½œçš„ç±»æˆ–ç»“æ„çš„é™æ€æˆå‘˜ã€‚è¿™é‡Œæ˜¾ç¤ºçš„åç§°ä¸æ˜¯å¿…éœ€çš„ï¼›æ³¨å†ŒåŸºäºå„ä¸ªå±æ€§çš„å­˜åœ¨ï¼Œè€Œä¸æ˜¯æ–¹æ³•åã€‚è¯·æ³¨æ„ï¼Œåºåˆ—åŒ–ç¨‹åºæ–¹æ³•ä¸å¿…æ˜¯å…¬å…±çš„ã€‚ é™¤éå®ç°æ‰€æœ‰ä¸‰ä¸ªåºåˆ—åŒ–ä¾‹ç¨‹ï¼Œå¦åˆ™åº”ä½¿ç”¨ å¯ä¸²è¡ŒåŒ– å±æ€§ï¼Œä»¥ä¾¿ä¸ºæ‚¨ç”Ÿæˆç¼ºå°‘çš„æ–¹æ³•ã€‚ å¤å°æœº å¤å°æœºæ–¹æ³•ç”¨ Orleanså¤å°æœº å±æ€§ï¼š [CopierMethod] static private object Copy(object input, ICopyContext context) { ... } å¤å°æœºé€šå¸¸æ˜¯æœ€ç®€å•çš„åºåˆ—åŒ–ç¨‹åºç¼–å†™ã€‚å®ƒä»¬æ¥å—ä¸€ä¸ªå¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„ç±»å‹ä¿è¯ä¸å¤å°æœºå®šä¹‰çš„ç±»å‹ç›¸åŒï¼Œå¹¶ä¸”å¿…é¡»è¿”å›è¯¥å¯¹è±¡åœ¨è¯­ä¹‰ä¸Šç­‰æ•ˆçš„å‰¯æœ¬ã€‚ å¦‚æœä½œä¸ºå¤åˆ¶å¯¹è±¡çš„ä¸€éƒ¨åˆ†ï¼Œéœ€è¦å¤åˆ¶å­å¯¹è±¡ï¼Œåˆ™æœ€å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨serializationmanagerçš„deepcopyinnerä¾‹ç¨‹ï¼š var fooCopy = SerializationManager.DeepCopyInner(foo, context); ä¸ºäº†ç»´æŠ¤å®Œæ•´å¤åˆ¶æ“ä½œçš„å¯¹è±¡æ ‡è¯†ä¸Šä¸‹æ–‡ï¼Œä½¿ç”¨deepcopyinnerè€Œä¸æ˜¯deepcopyéå¸¸é‡è¦ã€‚ ç»´æŠ¤å¯¹è±¡æ ‡è¯† å¤åˆ¶ä¾‹ç¨‹çš„ä¸€ä¸ªé‡è¦èŒè´£æ˜¯ç»´æŠ¤å¯¹è±¡æ ‡è¯†ã€‚orleansè¿è¡Œæ—¶ä¸ºæ­¤æä¾›äº†ä¸€ä¸ªhelperç±»ã€‚åœ¨â€œæ‰‹åŠ¨â€å¤åˆ¶å­å¯¹è±¡(å³ï¼Œä¸æ˜¯é€šè¿‡è°ƒç”¨deepcopyiner)ä¹‹å‰ï¼Œè¯·æ£€æŸ¥æ˜¯å¦å·²æŒ‰å¦‚ä¸‹æ–¹å¼å¼•ç”¨å®ƒï¼š var fooCopy = context.CheckObjectWhileCopying(foo); if (fooCopy == null) { // Actually make a copy of foo context.RecordObject(foo, fooCopy); } æœ€åä¸€è¡Œï¼Œæ‰“ç»™ è®°å½•å¯¹è±¡ æ˜¯å¿…éœ€çš„ï¼Œä»¥ä¾¿å°†æ¥å¯ä»¥é€šè¿‡ æ£€æŸ¥å¯¹è±¡é€‰æ‹© æ˜¯å•Šã€‚ è¯·æ³¨æ„ï¼Œè¿™åªåº”é’ˆå¯¹ç±»å®ä¾‹ï¼Œè€Œä¸æ˜¯ç»“æ„å®ä¾‹æˆ–.NETåŸè¯­(å­—ç¬¦ä¸²ã€uriã€æšä¸¾)ã€‚ å¦‚æœä½ ä½¿ç”¨ æ·±å¤åˆ¶å†…éƒ¨ è‹¥è¦å¤åˆ¶å­å¯¹è±¡ï¼Œåˆ™ä¼šä¸ºæ‚¨å¤„ç†å¯¹è±¡æ ‡è¯†ã€‚ åºåˆ—åŒ–ç¨‹åº åºåˆ—åŒ–æ–¹æ³•æ ‡è®°ä¸º åºåˆ—åŒ–æ–¹æ³• å±æ€§ï¼š [SerializerMethod] static private void Serialize(object input, ISerializationContext context, Type expected) { ... } ä¸copiersä¸€æ ·ï¼Œä¼ é€’ç»™åºåˆ—åŒ–ç¨‹åºçš„â€œinputâ€å¯¹è±¡ä¿è¯æ˜¯å®šä¹‰ç±»å‹çš„å®ä¾‹ã€‚å¯ä»¥å¿½ç•¥â€œé¢„æœŸâ€ç±»å‹ï¼›å®ƒåŸºäºæœ‰å…³æ•°æ®é¡¹çš„ç¼–è¯‘æ—¶ç±»å‹ä¿¡æ¯ï¼Œå¹¶åœ¨è¾ƒé«˜çº§åˆ«ä¸Šç”¨äºåœ¨å­—èŠ‚æµä¸­å½¢æˆç±»å‹å‰ç¼€ã€‚ è‹¥è¦åºåˆ—åŒ–å­å¯¹è±¡ï¼Œè¯·ä½¿ç”¨ åºåˆ—åŒ–ç®¡ç†å™¨ çš„ åºåˆ—åŒ–å†…éƒ¨ ä¾‹è¡Œç¨‹åºï¼š SerializationManager.SerializeInner(foo, context, typeof(FooType)); å¦‚æœfooæ²¡æœ‰ç‰¹å®šçš„é¢„æœŸç±»å‹ï¼Œé‚£ä¹ˆå¯ä»¥ä¸ºé¢„æœŸç±»å‹ä¼ é€’nullã€‚ è¿™ä¸ª äºŒè¿›åˆ¶ä»¤ç‰Œæµç¼–å†™å™¨ ç±»æä¾›äº†å¤šç§å°†æ•°æ®å†™å…¥å­—èŠ‚æµçš„æ–¹æ³•ã€‚ç±»çš„å®ä¾‹å¯ä»¥é€šè¿‡ ä¸Šä¸‹æ–‡.streamwriter å±æ€§ã€‚æœ‰å…³æ–‡æ¡£ï¼Œè¯·å‚è§ç±»ã€‚ ååºåˆ—åŒ–ç¨‹åº ååºåˆ—åŒ–æ–¹æ³•æ ‡è®°ä¸º ååºåˆ—åŒ–æ–¹æ³• å±æ€§ï¼š [DeserializerMethod] static private object Deserialize(Type expected, IDeserializationContext context) { ... } å¯ä»¥å¿½ç•¥â€œé¢„æœŸâ€ç±»å‹ï¼›å®ƒåŸºäºæœ‰å…³æ•°æ®é¡¹çš„ç¼–è¯‘æ—¶ç±»å‹ä¿¡æ¯ï¼Œå¹¶åœ¨è¾ƒé«˜çº§åˆ«ä¸Šç”¨äºåœ¨å­—èŠ‚æµä¸­å½¢æˆç±»å‹å‰ç¼€ã€‚è¦åˆ›å»ºçš„å¯¹è±¡çš„å®é™…ç±»å‹å°†å§‹ç»ˆæ˜¯å®šä¹‰ååºåˆ—åŒ–ç¨‹åºçš„ç±»çš„ç±»å‹ã€‚ è‹¥è¦ååºåˆ—åŒ–å­å¯¹è±¡ï¼Œè¯·ä½¿ç”¨ åºåˆ—åŒ–ç®¡ç†å™¨ çš„ ååºåˆ—åŒ–å†…éƒ¨ ä¾‹è¡Œç¨‹åºï¼š var foo = SerializationManager.DeserializeInner(typeof(FooType), context); æˆ–è€…ï¼š var foo = SerializationManager.DeserializeInner<FooType>(context); å¦‚æœfooæ²¡æœ‰ç‰¹å®šçš„é¢„æœŸç±»å‹ï¼Œè¯·ä½¿ç”¨éæ³›å‹ ååºåˆ—åŒ–å†…éƒ¨ å˜å‹å¹¶é€šè¿‡ æ— æ•ˆçš„ å¯¹äºæ‰€éœ€çš„ç±»å‹ã€‚ è¿™ä¸ª äºŒè¿›åˆ¶ä»¤ç‰Œæµè¯»å–å™¨ ç±»æä¾›äº†ä»å­—èŠ‚æµè¯»å–æ•°æ®çš„å„ç§æ–¹æ³•ã€‚ç±»çš„å®ä¾‹å¯ä»¥é€šè¿‡ ä¸Šä¸‹æ–‡.streamreader å±æ€§ã€‚æœ‰å…³æ–‡æ¡£ï¼Œè¯·å‚è§ç±»ã€‚ æ–¹æ³•2:ç¼–å†™åºåˆ—åŒ–ç¨‹åºæä¾›ç¨‹åº åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæ‚¨å¯ä»¥å®ç° Orleans.serialization.iexternalserializer å¹¶å°†å…¶æ·»åŠ åˆ° åºåˆ—åŒ–æä¾›ç¨‹åº ä¸¤è€…çš„å±æ€§ å®¢æˆ·ç«¯é…ç½® åœ¨å®¢æˆ·å’Œ å…¨çƒé…ç½® åœ¨silosé‡Œã€‚é…ç½®åœ¨ä¸Šé¢çš„åºåˆ—åŒ–æä¾›ç¨‹åºéƒ¨åˆ†æœ‰è¯¦ç»†è¯´æ˜ã€‚ å®æ–½ IExternalSerializer éµå¾ªä»¥ä¸‹ä¸ºåºåˆ—åŒ–æ–¹æ³•æè¿°çš„æ¨¡å¼ æ–¹æ³•1 ä¸Šé¢æ·»åŠ äº† åˆå§‹åŒ– æ–¹æ³•å’Œ å‘å¸ƒæ”¯æŒç±»å‹ Orleansç”¨æ¥ç¡®å®šåºåˆ—åŒ–ç¨‹åºæ˜¯å¦æ”¯æŒç»™å®šç±»å‹çš„æ–¹æ³•ã€‚è¿™æ˜¯æ¥å£å®šä¹‰ï¼š public interface IExternalSerializer { /// <summary> /// Initializes the external serializer. Called once when the serialization manager creates /// an instance of this type /// </summary> void Initialize(Logger logger); /// <summary> /// Informs the serialization manager whether this serializer supports the type for serialization. /// </summary> /// <param name=\"itemType\">The type of the item to be serialized</param> /// <returns>A value indicating whether the item can be serialized.</returns> bool IsSupportedType(Type itemType); /// <summary> /// Tries to create a copy of source. /// </summary> /// <param name=\"source\">The item to create a copy of</param> /// <param name=\"context\">The context in which the object is being copied.</param> /// <returns>The copy</returns> object DeepCopy(object source, ICopyContext context); /// <summary> /// Tries to serialize an item. /// </summary> /// <param name=\"item\">The instance of the object being serialized</param> /// <param name=\"context\">The context in which the object is being serialized.</param> /// <param name=\"expectedType\">The type that the deserializer will expect</param> void Serialize(object item, ISerializationContext context, Type expectedType); /// <summary> /// Tries to deserialize an item. /// </summary> /// <param name=\"context\">The context in which the object is being deserialized.</param> /// <param name=\"expectedType\">The type that should be deserialized</param> /// <returns>The deserialized object</returns> object Deserialize(Type expectedType, IDeserializationContext context); } æ–¹æ³•3:ä¸ºå•ä¸ªç±»å‹ç¼–å†™åºåˆ—åŒ–ç¨‹åº åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæ‚¨å¯ä»¥ç¼–å†™ä¸€ä¸ªæ–°çš„ç±»ï¼Œå¹¶ç”¨ä¸€ä¸ªå±æ€§è¿›è¡Œæ³¨é‡Š [åºåˆ—åŒ–å±æ€§(typeof(targettype))] ï¼Œå…¶ä¸­ ç›®æ ‡ç±»å‹ æ­£åœ¨åºåˆ—åŒ–çš„ç±»å‹ï¼Œå¹¶å®ç°3ä¸ªåºåˆ—åŒ–ä¾‹ç¨‹ã€‚å¦‚ä½•ç¼–å†™è¿™äº›ä¾‹ç¨‹çš„è§„åˆ™ä¸æ–¹æ³•1ç›¸åŒã€‚Orleansä½¿ç”¨ [åºåˆ—åŒ–å±æ€§(typeof(targettype))] ç¡®å®šè¯¥ç±»æ˜¯ ç›®æ ‡ç±»å‹ å¦‚æœè¿™ä¸ªå±æ€§èƒ½å¤Ÿåºåˆ—åŒ–å¤šä¸ªç±»å‹ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨åŒä¸€ä¸ªç±»ä¸Šå¤šæ¬¡æŒ‡å®šå®ƒã€‚ä¸‹é¢æ˜¯è¿™æ ·ä¸€ä¸ªç±»çš„ç¤ºä¾‹ï¼š public class User { public User BestFriend { get; set; } public string NickName { get; set; } public int FavoriteNumber { get; set; } public DateTimeOffset BirthDate { get; set; } } [Orleans.CodeGeneration.SerializerAttribute(typeof(User))] internal class UserSerializer { [CopierMethod] public static object DeepCopier(object original, ICopyContext context) { var input = (User) original; var result = new User(); // Record 'result' as a copy of 'input'. Doing this immediately after construction allows for // data structures which have cyclic references or duplicate references. // For example, imagine that 'input.BestFriend' is set to 'input'. In that case, failing to record // the copy before trying to copy the 'BestFriend' field would result in infinite recursion. context.RecordCopy(original, result); // Deep-copy each of the fields. result.BestFriend = (User)context.SerializationManager.DeepCopy(input.BestFriend); result.NickName = input.NickName; // strings in .NET are immutable, so they can be shallow-copied. result.FavoriteNumber = input.FavoriteNumber; // ints are primitive value types, so they can be shallow-copied. result.BirthDate = (DateTimeOffset)context.SerializationManager.DeepCopy(input.BirthDate); return result; } [SerializerMethod] public static void Serializer(object untypedInput, ISerializationContext context, Type expected) { var input = (User) untypedInput; // Serialize each field. SerializationManager.SerializeInner(input.BestFriend, context); SerializationManager.SerializeInner(input.NickName, context); SerializationManager.SerializeInner(input.FavoriteNumber, context); SerializationManager.SerializeInner(input.BirthDate, context); } [DeserializerMethod] public static object Deserializer(Type expected, IDeserializationContext context) { var result = new User(); // Record 'result' immediately after constructing it. As with with the deep copier, this // allows for cyclic references and de-duplication. context.RecordObject(result); // Deserialize each field in the order that they were serialized. result.BestFriend = SerializationManager.DeserializeInner<User>(context); result.NickName = SerializationManager.DeserializeInner<string>(context); result.FavoriteNumber = SerializationManager.DeserializeInner<int>(context); result.BirthDate = SerializationManager.DeserializeInner<DateTimeOffset>(context); return result; } } åºåˆ—åŒ–æ³›å‹ç±»å‹ è¿™ä¸ª ç›®æ ‡ç±»å‹ å‚æ•° [åºåˆ—åŒ–ç¨‹åº(typeof(targettype))] å¯ä»¥æ˜¯å¼€æ”¾æ³›å‹ç±»å‹ï¼Œä¾‹å¦‚ï¼Œ MyGenericType<> æ˜¯çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåºåˆ—åŒ–ç¨‹åºç±»å¿…é¡»å…·æœ‰ä¸ç›®æ ‡ç±»å‹ç›¸åŒçš„æ³›å‹å‚æ•°ã€‚Orleanså°†åœ¨è¿è¡Œæ—¶ä¸ºæ¯ä¸ªå…·ä½“å¯¹è±¡åˆ›å»ºåºåˆ—åŒ–ç¨‹åºçš„å…·ä½“ç‰ˆæœ¬ MyGenericType<T> åºåˆ—åŒ–çš„ç±»å‹ï¼Œä¾‹å¦‚ï¼Œæ¯ä¸ª MyGenericType<int> å’Œ MyGenericType<string> æ˜¯çš„ã€‚ ç¼–å†™åºåˆ—åŒ–ç¨‹åºå’Œååºåˆ—åŒ–ç¨‹åºçš„æç¤º é€šå¸¸ï¼Œç¼–å†™åºåˆ—åŒ–å™¨/ååºåˆ—åŒ–å™¨å¯¹çš„æœ€ç®€å•æ–¹æ³•æ˜¯é€šè¿‡æ„é€ å­—èŠ‚æ•°ç»„å¹¶å°†æ•°ç»„é•¿åº¦å†™å…¥æµï¼Œç„¶åæ˜¯æ•°ç»„æœ¬èº«ï¼Œç„¶åé€šè¿‡åè½¬è¿‡ç¨‹è¿›è¡Œååºåˆ—åŒ–ã€‚å¦‚æœæ•°ç»„æ˜¯å›ºå®šé•¿åº¦çš„ï¼Œåˆ™å¯ä»¥ä»æµä¸­å¿½ç•¥å®ƒã€‚å¦‚æœæ•°æ®ç±»å‹å¯ä»¥ç®€æ´åœ°è¡¨ç¤ºï¼Œå¹¶ä¸”æ²¡æœ‰å¯èƒ½é‡å¤çš„å­å¯¹è±¡(å› æ­¤ä¸å¿…æ‹…å¿ƒå¯¹è±¡æ ‡è¯†)ï¼Œé‚£ä¹ˆè¿™ç§æ–¹æ³•å¾ˆå¥½åœ°å·¥ä½œã€‚ å¦ä¸€ç§æ–¹æ³•ï¼Œå³Orleansè¿è¡Œæ—¶å¯¹å­—å…¸ç­‰é›†åˆæ‰€é‡‡ç”¨çš„æ–¹æ³•ï¼Œé€‚ç”¨äºå…·æœ‰é‡è¦è€Œå¤æ‚çš„å†…éƒ¨ç»“æ„çš„ç±»ï¼šä½¿ç”¨å®ä¾‹æ–¹æ³•è®¿é—®å¯¹è±¡çš„è¯­ä¹‰å†…å®¹ï¼Œåºåˆ—åŒ–è¯¥å†…å®¹ï¼Œå¹¶é€šè¿‡è®¾ç½®è¯­ä¹‰å†…å®¹è€Œä¸æ˜¯å¤æ‚çš„å†…éƒ¨å†…å®¹ååºåˆ—åŒ–ã€‚å›½å®¶ã€‚åœ¨è¿™ç§æ–¹æ³•ä¸­ï¼Œä½¿ç”¨serializeinnerç¼–å†™å†…éƒ¨å¯¹è±¡ï¼Œä½¿ç”¨deserializeinnerè¯»å–å†…éƒ¨å¯¹è±¡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–å†™è‡ªå®šä¹‰å¤å°æœºä¹Ÿå¾ˆå¸¸è§ã€‚ å¦‚æœæ‚¨ç¼–å†™ä¸€ä¸ªè‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºï¼Œå¹¶ä¸”å®ƒæœ€ç»ˆçœ‹èµ·æ¥åƒç±»ä¸­æ¯ä¸ªå­—æ®µçš„åºåˆ—åŒ–å†…éƒ¨è°ƒç”¨åºåˆ—ï¼Œåˆ™ä¸éœ€è¦è¯¥ç±»çš„è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºã€‚ å›é€€åºåˆ—åŒ– Orleansæ”¯æŒåœ¨è¿è¡Œæ—¶ä¼ è¾“ä»»æ„ç±»å‹ï¼Œå› æ­¤å†…ç½®ä»£ç ç”Ÿæˆå™¨æ— æ³•ç¡®å®šå°†æå‰ä¼ è¾“çš„æ•´ä¸ªç±»å‹é›†ã€‚æ­¤å¤–ï¼ŒæŸäº›ç±»å‹ä¸èƒ½ä¸ºå…¶ç”Ÿæˆåºåˆ—åŒ–ç¨‹åºï¼Œå› ä¸ºå®ƒä»¬ä¸å¯è®¿é—®(ä¾‹å¦‚ï¼Œ ç§æœ‰çš„ )æˆ–è€…æœ‰ä¸å¯è®¿é—®çš„å­—æ®µ(ä¾‹å¦‚ï¼Œ åªè¯» )ä¸­ã€‚å› æ­¤ï¼Œéœ€è¦å¯¹æ„å¤–æˆ–æ— æ³•æå‰ç”Ÿæˆåºåˆ—åŒ–ç¨‹åºçš„ç±»å‹è¿›è¡ŒåŠæ—¶åºåˆ—åŒ–ã€‚è´Ÿè´£è¿™äº›ç±»å‹çš„åºåˆ—åŒ–ç¨‹åºç§°ä¸º å›é€€åºåˆ—åŒ–ç¨‹åº æ˜¯çš„ã€‚Orleansæä¾›äº†ä¸¤ä¸ªå›é€€åºåˆ—åŒ–ç¨‹åºï¼š Orleans.Serialization.BinaryFormatterSerializer ä½¿ç”¨.netçš„ äºŒè¿›åˆ¶æ ¼å¼ ï¼›å’Œ Orleans.Serialization.ILBasedSerializer å‘å‡º CIL åœ¨è¿è¡Œæ—¶åˆ›å»ºåºåˆ—åŒ–ç¨‹åºçš„æŒ‡ä»¤ï¼Œè¯¥åºåˆ—åŒ–ç¨‹åºåˆ©ç”¨Orleansçš„åºåˆ—åŒ–æ¡†æ¶å¯¹æ¯ä¸ªå­—æ®µè¿›è¡Œåºåˆ—åŒ–ã€‚è¿™æ„å‘³ç€å¦‚æœä¸€ä¸ªä¸å¯è®¿é—®çš„ç±»å‹ æˆ‘çš„ç§æ å‹ åŒ…å«å­—æ®µ æˆ‘çš„ç±»å‹ å®ƒæœ‰ä¸€ä¸ªè‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºï¼Œè¯¥è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºå°†ç”¨äºåºåˆ—åŒ–å®ƒã€‚ å¯ä»¥ä½¿ç”¨ FallbackSerializationProvider ä¸¤è€…çš„å±æ€§ å®¢æˆ·ç«¯é…ç½® åœ¨å®¢æˆ·å’Œ å…¨çƒé…ç½® åœ¨silosé‡Œã€‚ var cfg = new ClientConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); var cfg = new GlobalConfiguration(); cfg.FallbackSerializationProvider = typeof(FantasticSerializer).GetTypeInfo(); æˆ–è€…ï¼Œå¯ä»¥åœ¨XMLé…ç½®ä¸­æŒ‡å®šå›é€€åºåˆ—åŒ–æä¾›ç¨‹åºï¼š <Messaging> <FallbackSerializationProvider type=\"GreatCompany.FantasticFallbackSerializer, GreatCompany.SerializerAssembly\"/> </Messaging> äºŒè¿›åˆ¶æ ¼å¼åºåˆ—åŒ–ç¨‹åº æ˜¯é»˜è®¤çš„å›é€€åºåˆ—åŒ–ç¨‹åºã€‚ å¼‚å¸¸åºåˆ—åŒ– ä½¿ç”¨ å›é€€åºåˆ—åŒ–ç¨‹åº æ˜¯çš„ã€‚ä½¿ç”¨é»˜è®¤é…ç½®ï¼Œ äºŒè¿›åˆ¶æ ¼å¼åºåˆ—åŒ–ç¨‹åº æ˜¯å›é€€åºåˆ—åŒ–ç¨‹åºï¼Œå› æ­¤ ISerializableæ¨¡å¼ å¿…é¡»ç´§è·Ÿå…¶åæ‰èƒ½ç¡®ä¿å¼‚å¸¸ç±»å‹ä¸­æ‰€æœ‰å±æ€§çš„æ­£ç¡®åºåˆ—åŒ–ã€‚ ä»¥ä¸‹æ˜¯å…·æœ‰æ­£ç¡®å®ç°çš„åºåˆ—åŒ–çš„å¼‚å¸¸ç±»å‹çš„ç¤ºä¾‹ï¼š [Serializable] public class MyCustomException : Exception { public string MyProperty { get; } public MyCustomException(string myProperty, string message) : base(message) { this.MyProperty = myProperty; } public MyCustomException(string transactionId, string message, Exception innerException) : base(message, innerException) { this.MyProperty = transactionId; } // Note: This is the constructor called by BinaryFormatter during deserialization public MyCustomException(SerializationInfo info, StreamingContext context) : base(info, context) { this.MyProperty = info.GetString(nameof(this.MyProperty)); } // Note: This method is called by BinaryFormatter during serialization public override void GetObjectData(SerializationInfo info, StreamingContext context) { base.GetObjectData(info, context); info.AddValue(nameof(this.MyProperty), this.MyProperty); } } ä½¿ç”¨ä¸å¯å˜ç±»å‹ä¼˜åŒ–å¤åˆ¶ Orleansæœ‰ä¸€ä¸ªç‰¹æ€§ï¼Œå¯ä»¥ç”¨æ¥é¿å…ä¸€äº›ä¸åºåˆ—åŒ–åŒ…å«ä¸å¯å˜ç±»å‹çš„æ¶ˆæ¯ç›¸å…³çš„å¼€é”€ã€‚æœ¬èŠ‚ä»ä¸Šä¸‹æ–‡å¼€å§‹ä»‹ç»ç‰¹æ€§åŠå…¶åº”ç”¨ç¨‹åºã€‚ Orleansçš„åºåˆ—åŒ– å½“ä¸€ä¸ªgrainæ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œorleansè¿è¡Œæ—¶ä¼šå¯¹æ–¹æ³•å‚æ•°è¿›è¡Œä¸€ä¸ªæ·±åº¦æ‹·è´ï¼Œå¹¶ä»æ‹·è´ä¸­å½¢æˆè¯·æ±‚ã€‚è¿™å¯ä»¥é˜²æ­¢è°ƒç”¨ä»£ç åœ¨æ•°æ®ä¼ é€’ç»™è¢«è°ƒç”¨çš„Grainä¹‹å‰ä¿®æ”¹å‚æ•°å¯¹è±¡ã€‚ å¦‚æœè¢«è°ƒç”¨çš„Grainåœ¨ä¸åŒçš„silosä¸Šï¼Œé‚£ä¹ˆæ‹·è´æœ€ç»ˆè¢«åºåˆ—åŒ–ä¸ºå­—èŠ‚æµï¼Œå¹¶é€šè¿‡ç½‘ç»œå‘é€åˆ°ç›®æ ‡silosï¼Œåœ¨é‚£é‡Œå®ƒä»¬è¢«ååºåˆ—åŒ–ä¸ºå¯¹è±¡ã€‚å¦‚æœè¢«è°ƒç”¨çš„grainä½äºåŒä¸€ä¸ªsilosä¸Šï¼Œé‚£ä¹ˆå‰¯æœ¬å°†ç›´æ¥ä¼ é€’ç»™è¢«è°ƒç”¨çš„æ–¹æ³•ã€‚ è¿”å›å€¼çš„å¤„ç†æ–¹å¼ç›¸åŒï¼šé¦–å…ˆå¤åˆ¶ï¼Œç„¶åå¯èƒ½åºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ è¯·æ³¨æ„ï¼Œæ‰€æœ‰3ä¸ªè¿›ç¨‹(å¤åˆ¶ã€åºåˆ—åŒ–å’Œååºåˆ—åŒ–)éƒ½å°Šé‡å¯¹è±¡æ ‡è¯†ã€‚æ¢è¨€ä¹‹ï¼Œå¦‚æœæ‚¨ä¼ é€’ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ªç›¸åŒçš„å¯¹è±¡ï¼Œé‚£ä¹ˆåœ¨æ¥æ”¶ç«¯ï¼Œæ‚¨å°†å¾—åˆ°ä¸€ä¸ªåˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ªç›¸åŒçš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯åŒ…å«ä¸¤ä¸ªå…·æœ‰ç›¸åŒå€¼çš„å¯¹è±¡ã€‚ ä¼˜åŒ–æ‹·è´ åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œæ·±åº¦å¤åˆ¶æ˜¯ä¸å¿…è¦çš„ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå¯èƒ½çš„åœºæ™¯æ˜¯ä¸€ä¸ªwebå‰ç«¯ï¼Œå®ƒä»å®¢æˆ·ç«¯æ¥æ”¶ä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œå¹¶å°†è¯¥è¯·æ±‚(åŒ…æ‹¬å­—èŠ‚æ•°ç»„)ä¼ é€’åˆ°ä¸€ä¸ªgrainè¿›è¡Œå¤„ç†ã€‚å‰ç«¯è¿›ç¨‹ä¸€æ—¦å°†æ•°ç»„ä¼ é€’ç»™grainï¼Œå°±ä¸ä¼šå¯¹å®ƒåšä»»ä½•äº‹æƒ…ï¼›ç‰¹åˆ«æ˜¯ï¼Œå®ƒä¸ä¼šé‡ç”¨æ•°ç»„æ¥æ¥æ”¶å°†æ¥çš„è¯·æ±‚ã€‚åœ¨Grainså†…éƒ¨ï¼Œå­—èŠ‚æ•°ç»„è¢«è§£æä»¥è·å–è¾“å…¥æ•°æ®ï¼Œä½†æœªè¢«ä¿®æ”¹ã€‚grainè¿”å›å®ƒåˆ›å»ºçš„å¦ä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œå¹¶å°†å…¶ä¼ é€’å›webå®¢æˆ·ç«¯ï¼›ä¸€æ—¦è¿”å›è¯¥æ•°ç»„ï¼Œå®ƒå°†ç«‹å³ä¸¢å¼ƒè¯¥æ•°ç»„ã€‚webå‰ç«¯å°†ç»“æœå­—èŠ‚æ•°ç»„ä¼ é€’å›å…¶å®¢æˆ·ç«¯ï¼Œè€Œæ— éœ€ä¿®æ”¹ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸éœ€è¦å¤åˆ¶è¯·æ±‚æˆ–å“åº”å­—èŠ‚æ•°ç»„ã€‚ä¸å¹¸çš„æ˜¯ï¼Œorleansè¿è¡Œæ—¶æ— æ³•è‡ªå·±è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºå®ƒæ— æ³•åˆ¤æ–­æ•°ç»„æ˜¯ç”±webå‰ç«¯ä¿®æ”¹çš„è¿˜æ˜¯ç”±grainä¿®æ”¹çš„ã€‚åœ¨æœ€å¥½çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¼šæœ‰æŸç§.NETæœºåˆ¶æ¥æŒ‡ç¤ºæŸä¸ªå€¼ä¸å†è¢«ä¿®æ”¹ï¼›å¦‚æœæ²¡æœ‰è¿™ç§æœºåˆ¶ï¼Œæˆ‘ä»¬ä¼šä¸ºæ­¤æ·»åŠ ç‰¹å®šäºOrleansçš„æœºåˆ¶ï¼š ä¸å¯å˜<t> åŒ…è£…ç±»å’Œ [ä¸å˜] å±æ€§ã€‚ ä½¿ç”¨ ä¸å¯å˜<t> è¿™ä¸ª Orleans.Concurrency.Immutable<T> wrapperç±»ç”¨äºæŒ‡ç¤ºä¸€ä¸ªå€¼å¯èƒ½è¢«è®¤ä¸ºæ˜¯ä¸å¯å˜çš„ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œåº•å±‚å€¼ä¸ä¼šè¢«ä¿®æ”¹ï¼Œå› æ­¤å®‰å…¨å…±äº«ä¸éœ€è¦å¤åˆ¶ã€‚æ³¨æ„ä½¿ç”¨ ä¸å¯å˜<t> æ„å‘³ç€æ— è®ºæ˜¯ä»·å€¼çš„æä¾›è€…è¿˜æ˜¯ä»·å€¼çš„æ¥å—è€…éƒ½ä¸ä¼šåœ¨æœªæ¥å¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼›å®ƒä¸æ˜¯å•æ–¹é¢çš„æ‰¿è¯ºï¼Œè€Œæ˜¯ç›¸äº’çš„åŒè¾¹æ‰¿è¯ºã€‚ ä½¿ç”¨ ä¸å¯å˜<t> å¾ˆç®€å•ï¼šåœ¨grainæ¥å£ä¸­ï¼Œè€Œä¸æ˜¯ä¼ é€’ Tå‹ ï¼Œé€šè¿‡ ä¸å¯å˜<t> æ˜¯çš„ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸Šè¿°åœºæ™¯ä¸­ï¼Œgrainæ–¹æ³•æ˜¯ï¼š Task<byte[]> ProcessRequest(byte[] request); å˜æˆï¼š Task<Immutable<byte[]>> ProcessRequest(Immutable<byte[]> request); åˆ›å»º ä¸å¯å˜<t> ï¼Œåªéœ€ä½¿ç”¨æ„é€ å‡½æ•°ï¼š Immutable<byte[]> immutable = new Immutable<byte[]>(buffer); è‹¥è¦è·å–ä¸å¯å˜çš„å†…éƒ¨å€¼ï¼Œè¯·ä½¿ç”¨ .ä»·å€¼ å±æ€§ï¼š byte[] buffer = immutable.Value; ä½¿ç”¨ [ä¸å˜] å¯¹äºç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼Œ [Orleans.å¹¶å‘æ€§.ä¸å¯å˜] å±æ€§å¯ä»¥æ·»åŠ åˆ°ç±»å‹ã€‚è¿™æŒ‡ç¤ºOrleansçš„åºåˆ—åŒ–ç¨‹åºé¿å…å¤åˆ¶æ­¤ç±»å‹çš„å®ä¾‹ã€‚ä¸‹é¢çš„ä»£ç ç‰‡æ®µæ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ [ä¸å˜] è¡¨ç¤ºä¸å¯å˜ç±»å‹ã€‚åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¸ä¼šå¤åˆ¶æ­¤ç±»å‹ã€‚ [Immutable] public class MyImmutableType { public MyImmutableType(int value) { this.MyValue = value; } public int MyValue { get; } } Orleansçš„ä¸å˜æ€§ å¯¹äºorleansæ¥è¯´ï¼Œä¸å˜æ€§æ˜¯ä¸€ä¸ªç›¸å½“ä¸¥æ ¼çš„å£°æ˜ï¼šæ•°æ®é¡¹çš„å†…å®¹ä¸ä¼šä»¥ä»»ä½•å¯èƒ½æ”¹å˜å…¶è¯­ä¹‰çš„æ–¹å¼è¿›è¡Œä¿®æ”¹ï¼Œä¹Ÿä¸ä¼šå¹²æ‰°å¦ä¸€ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®è¯¥é¡¹ã€‚ç¡®ä¿è¿™ä¸€ç‚¹çš„æœ€å®‰å…¨æ–¹æ³•æ˜¯æ ¹æœ¬ä¸ä¿®æ”¹é¡¹ï¼šæŒ‰ä½ä¸å˜ï¼Œè€Œä¸æ˜¯é€»è¾‘ä¸å˜ã€‚ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå°†å…¶æ”¾å®½åˆ°é€»è¾‘ä¸å˜æ€§æ˜¯å®‰å…¨çš„ï¼Œä½†æ˜¯å¿…é¡»æ³¨æ„ç¡®ä¿å˜å¼‚ä»£ç æ˜¯æ­£ç¡®çš„çº¿ç¨‹å®‰å…¨çš„ï¼›å› ä¸ºå¤„ç†å¤šçº¿ç¨‹æ˜¯å¤æ‚çš„ï¼Œå¹¶ä¸”åœ¨Orleansä¸Šä¸‹æ–‡ä¸­æ˜¯ä¸å¸¸è§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¼ºçƒˆå»ºè®®ä¸è¦ä½¿ç”¨è¿™ç§æ–¹æ³•ï¼Œå¹¶å»ºè®®åšæŒæŒ‰ä½ä¸å˜æ€§ã€‚ åºåˆ—åŒ–æœ€ä½³å®è·µ åºåˆ—åŒ–åœ¨Orleansæœ‰ä¸¤ä¸ªä¸»è¦ç›®çš„ï¼š ä½œä¸ºåœ¨è¿è¡Œæ—¶åœ¨Grainså’Œå®¢æˆ·ç«¯ä¹‹é—´ä¼ è¾“æ•°æ®çš„æœ‰çº¿æ ¼å¼ã€‚ ä½œä¸ºä¸€ç§å­˜å‚¨æ ¼å¼ï¼Œç”¨äºä¿å­˜é•¿æœŸæ•°æ®ä»¥ä¾›ä»¥åæ£€ç´¢ã€‚ Orleansäº§ç”Ÿçš„ä¸²è¡Œå™¨ç”±äºå…¶çµæ´»æ€§ã€æ€§èƒ½å’Œé€šç”¨æ€§è€Œé€‚åˆäºç¬¬ä¸€ç›®çš„ã€‚å®ƒä»¬ä¸å¤ªé€‚åˆç”¨äºç¬¬äºŒä¸ªç›®çš„ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰æ˜¾å¼çš„ç‰ˆæœ¬å®¹å¿ã€‚å»ºè®®ç”¨æˆ·é…ç½®ä¸€ä¸ªç‰ˆæœ¬å®¹å¿åºåˆ—åŒ–ç¨‹åºï¼Œå¦‚ åè®®ç¼“å†²åŒº å¯¹äºæŒä¹…æ•°æ®ã€‚åè®®ç¼“å†²åŒºé€šè¿‡ Orleans.Serialization.ProtobufSerializer ä» Microsoft.Orleans.OrleansGoogleå®ç”¨ç¨‹åº NugetåŒ…ã€‚åº”ä½¿ç”¨æ‰€é€‰ç‰¹å®šåºåˆ—åŒ–ç¨‹åºçš„æœ€ä½³å®è·µï¼Œä»¥ç¡®ä¿ç‰ˆæœ¬å…¬å·®ã€‚å¯ä»¥ä½¿ç”¨ åºåˆ—åŒ–æä¾›ç¨‹åº å¦‚ä¸Šæ‰€è¿°çš„é…ç½®å±æ€§ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/client_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/client_configuration.html",
    "title": "Client Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "[å•Šï¼æ³¨æ„!]å¦‚æœåªæƒ³å¯åŠ¨æœ¬åœ°siloså’Œæœ¬åœ°å®¢æˆ·ç«¯è¿›è¡Œå¼€å‘ï¼Œè¯·æŸ¥çœ‹æœ¬åœ°å¼€å‘é…ç½®é¡µã€‚ å®¢æˆ·ç«¯é…ç½® è¿æ¥åˆ°silosé›†ç¾¤å¹¶å‘Grainså‘é€è¯·æ±‚çš„å®¢æˆ·ç«¯æ˜¯é€šè¿‡ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ ä»¥åŠä¸€äº›è¡¥å……é€‰é¡¹ç±»ã€‚ä¸æ€æ´›é€‰é¡¹ä¸€æ ·ï¼Œå®¢æˆ·ç«¯é€‰é¡¹ç±»éµå¾ª ASP.NETé€‰é¡¹ æ˜¯çš„ã€‚ å®¢æˆ·ç«¯é…ç½®æœ‰å‡ ä¸ªå…³é”®æ–¹é¢ï¼š Orleansèšç±»ä¿¡æ¯ ç¾¤é›†æä¾›ç¨‹åº åº”ç”¨ç¨‹åºéƒ¨ä»¶ å®¢æˆ·ç«¯é…ç½®ç¤ºä¾‹ï¼š var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); è®©æˆ‘ä»¬åˆ†è§£æ­¤ç¤ºä¾‹ä¸­ä½¿ç”¨çš„æ­¥éª¤ï¼š Orleansèšç±»ä¿¡æ¯ [...] // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"orleans-docker\"; options.ServiceId = \"AspNetSampleApp\"; }) [...] è¿™é‡Œæˆ‘ä»¬è®¾å®šäº†ä¸¤ä»¶äº‹ï¼š è¿™ä¸ª æ£’çŠ¶çš„ åˆ° â€œæˆ‘çš„ç¬¬ä¸€ä¸ªç¾¤é›†â€ ï¼šè¿™æ˜¯Orleansé›†ç¾¤çš„å”¯ä¸€IDã€‚ä½¿ç”¨æ­¤IDçš„æ‰€æœ‰å®¢æˆ·ç«¯å’Œsiloså°†èƒ½å¤Ÿç›´æ¥ç›¸äº’é€šä¿¡ã€‚æœ‰äº›äººä¼šé€‰æ‹©ä½¿ç”¨ä¸åŒçš„ æ£’çŠ¶çš„ ä¾‹å¦‚ï¼Œå¯¹äºæ¯ä¸ªéƒ¨ç½²ã€‚ è¿™ä¸ª æœåŠ¡ID åˆ° â€œaspnetsampleapâ€ ï¼šè¿™æ˜¯åº”ç”¨ç¨‹åºçš„å”¯ä¸€IDï¼ŒæŸäº›æä¾›ç¨‹åº(ä¾‹å¦‚ï¼ŒæŒä¹…åŒ–æä¾›ç¨‹åº)å°†ä½¿ç”¨å®ƒã€‚ æ­¤IDåœ¨éƒ¨ç½²æœŸé—´åº”è¯¥æ˜¯ç¨³å®šçš„(è€Œä¸æ˜¯æ›´æ”¹çš„) æ˜¯çš„ã€‚ ç¾¤é›†æä¾›ç¨‹åº [...] // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) [...] å®¢æˆ·ç«¯å°†ä½¿ç”¨æ­¤æä¾›ç¨‹åºå‘ç°ç¾¤é›†ä¸­å¯ç”¨çš„æ‰€æœ‰ç½‘å…³ã€‚æœ‰å‡ ä¸ªæä¾›ç¨‹åºå¯ç”¨ï¼Œåœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨azureè¡¨æä¾›ç¨‹åºã€‚ è¦è·å¾—æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹æœåŠ¡å™¨é…ç½®é¡µä¸­çš„åŒ¹é…éƒ¨åˆ†ã€‚ åº”ç”¨ç¨‹åºéƒ¨ä»¶ [...] // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)).WithReferences()) [...]; è¦è·å¾—æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹æœåŠ¡å™¨é…ç½®é¡µä¸­çš„åŒ¹é…éƒ¨åˆ†ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/server_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/server_configuration.html",
    "title": "Server Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "[å•Šï¼æ³¨æ„!]å¦‚æœè¦å¯åŠ¨æœ¬åœ°siloså’Œæœ¬åœ°å®¢æˆ·ç«¯è¿›è¡Œå¼€å‘ï¼Œè¯·æŸ¥çœ‹ æœ¬åœ°å¼€å‘é…ç½®é¡µ æœåŠ¡å™¨é…ç½® silosé€šè¿‡ç¼–ç¨‹æ–¹å¼é…ç½® silohostbuilderè½¯ä»¶ ä»¥åŠä¸€äº›è¡¥å……é€‰é¡¹ç±»ã€‚Orleansçš„é€‰é¡¹ç±»éµå¾ª ASP.NETé€‰é¡¹ æ¨¡å¼ï¼Œå¯ä»¥é€šè¿‡æ–‡ä»¶ã€ç¯å¢ƒå˜é‡ç­‰åŠ è½½ã€‚ silosé…ç½®æœ‰å‡ ä¸ªå…³é”®æ–¹é¢ï¼š Orleansèšç±»ä¿¡æ¯ ç¾¤é›†æä¾›ç¨‹åº ç”¨äºsilosåˆ°siloså’Œå®¢æˆ·ç«¯åˆ°silosé€šä¿¡çš„ç»ˆç»“ç‚¹ åº”ç”¨ç¨‹åºéƒ¨ä»¶ è¿™æ˜¯ä¸€ä¸ªsilosé…ç½®çš„ç¤ºä¾‹ï¼Œå®ƒå®šä¹‰ç¾¤é›†ä¿¡æ¯ã€ä½¿ç”¨azureç¾¤é›†å¹¶é…ç½®åº”ç”¨ç¨‹åºéƒ¨åˆ†ï¼š var silo = new SiloHostBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"AspNetSampleApp\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Endpoints .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) // Application parts: just reference one of the grain implementations that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(ValueGrain).Assembly).WithReferences()) // Now create the silo! .Build(); è®©æˆ‘ä»¬åˆ†è§£æ­¤ç¤ºä¾‹ä¸­ä½¿ç”¨çš„æ­¥éª¤ï¼š Orleansèšç±»ä¿¡æ¯ [...] // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"AspNetSampleApp\"; }) [...] è¿™é‡Œæˆ‘ä»¬åšä¸¤ä»¶äº‹ï¼š è®¾ç½® æ£’çŠ¶çš„ åˆ° â€œæˆ‘çš„ç¬¬ä¸€ä¸ªç¾¤é›†â€ ï¼šè¿™æ˜¯Orleansé›†ç¾¤çš„å”¯ä¸€IDã€‚ä½¿ç”¨æ­¤IDçš„æ‰€æœ‰å®¢æˆ·ç«¯å’Œsiloséƒ½å¯ä»¥ç›´æ¥ç›¸äº’é€šä¿¡ã€‚ä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨ä¸åŒçš„ æ£’çŠ¶çš„ ä¸è¿‡ï¼Œå¯¹äºä¸åŒçš„éƒ¨ç½²ã€‚ è®¾ç½® æœåŠ¡ID åˆ° â€œaspnetsampleapâ€ ï¼šè¿™æ˜¯åº”ç”¨ç¨‹åºçš„å”¯ä¸€IDï¼ŒæŸäº›æä¾›ç¨‹åº(å¦‚æŒä¹…åŒ–æä¾›ç¨‹åº)å°†ä½¿ç”¨å®ƒã€‚ æ­¤IDåº”ä¿æŒç¨³å®šï¼Œå¹¶ä¸”åœ¨éƒ¨ç½²æœŸé—´ä¸ä¼šæ›´æ”¹ æ˜¯çš„ã€‚ ç¾¤é›†æä¾›ç¨‹åº [...] // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) [...] é€šå¸¸ï¼Œåœ¨orleansä¸Šæ„å»ºçš„æœåŠ¡éƒ¨ç½²åœ¨èŠ‚ç‚¹é›†ç¾¤ä¸Šï¼Œæˆ–è€…éƒ¨ç½²åœ¨ä¸“ç”¨ç¡¬ä»¶ä¸Šï¼Œæˆ–è€…éƒ¨ç½²åœ¨azureä¸­ã€‚ä¸ºäº†è¿›è¡Œå¼€å‘å’ŒåŸºæœ¬æµ‹è¯•ï¼Œå¯ä»¥åœ¨å•èŠ‚ç‚¹é…ç½®ä¸­éƒ¨ç½²Orleansã€‚å½“éƒ¨ç½²åˆ°ä¸€ä¸ªèŠ‚ç‚¹é›†ç¾¤æ—¶ï¼Œorleansåœ¨å†…éƒ¨å®ç°äº†ä¸€ç»„åè®®æ¥å‘ç°å’Œç»´æŠ¤é›†ç¾¤ä¸­orleans siloçš„æˆå‘˜å…³ç³»ï¼ŒåŒ…æ‹¬æ£€æµ‹èŠ‚ç‚¹æ•…éšœå’Œè‡ªåŠ¨é‡æ–°é…ç½®ã€‚ ä¸ºäº†å¯é åœ°ç®¡ç†é›†ç¾¤æˆå‘˜å…³ç³»ï¼Œorleansä½¿ç”¨azureè¡¨ã€sql serveræˆ–apache zookeeperæ¥åŒæ­¥èŠ‚ç‚¹ã€‚ åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨azureè¡¨ä½œä¸ºæˆå‘˜èµ„æ ¼æä¾›ç¨‹åºã€‚ ç«¯ç‚¹ var silo = new SiloHostBuilder() [...] // Endpoints .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) [...] Orleanssilosæœ‰ä¸¤ç§å…¸å‹çš„ç«¯ç‚¹é…ç½®ï¼š silosåˆ°silosç«¯ç‚¹ï¼Œç”¨äºåŒä¸€é›†ç¾¤ä¸­silosä¹‹é—´çš„é€šä¿¡ å®¢æˆ·ç«¯åˆ°silosç«¯ç‚¹(æˆ–ç½‘å…³)ï¼Œç”¨äºåœ¨åŒä¸€é›†ç¾¤ä¸­çš„å®¢æˆ·ç«¯å’Œsilosä¹‹é—´è¿›è¡Œé€šä¿¡ åœ¨ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨helperæ–¹æ³• .é…ç½®ç»ˆç»“ç‚¹(siloport:11111ï¼Œgatewayport:30000) å®ƒå°†ç”¨äºsilosåˆ°silosé€šä¿¡çš„ç«¯å£è®¾ç½®ä¸º 11111ä¸ª å’Œç½‘å…³çš„ç«¯å£ 30000ä¸ª æ˜¯çš„ã€‚æ­¤æ–¹æ³•å°†æ£€æµ‹è¦ä¾¦å¬çš„æ¥å£ã€‚ è¿™ç§æ–¹æ³•åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹åº”è¯¥è¶³å¤Ÿäº†ï¼Œä½†æ˜¯å¦‚æœéœ€è¦çš„è¯ï¼Œå¯ä»¥è¿›ä¸€æ­¥è‡ªå®šä¹‰å®ƒã€‚ä¸‹é¢æ˜¯å¦‚ä½•å°†å¤–éƒ¨IPåœ°å€ä¸æŸäº›ç«¯å£è½¬å‘ä¸€èµ·ä½¿ç”¨çš„ç¤ºä¾‹ï¼š [...] .Configure<EndpointOptions>(options => { // Port to use for Silo-to-Silo options.SiloPort = 11111; // Port to use for the gateway options.GatewayPort = 30000; // IP Address to advertise in the cluster options.AdvertisedIPAddress = IPAddress.Parse(\"172.16.0.42\"); // The socket used for silo-to-silo will bind to this endpoint options.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any, 40000); // The socket used by the gateway will bind to this endpoint options.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any, 50000); }) [...] åœ¨å†…éƒ¨ï¼Œsilosä¼šç›‘å¬ 0.0.0.0:40000ä¸ª å’Œ 0.0.0.0:50000 ï¼Œä½†åœ¨æˆå‘˜èµ„æ ¼æä¾›ç¨‹åºä¸­å‘å¸ƒçš„å€¼å°†æ˜¯ 172.16.0.42:11111 å’Œ 172.16.0.42:30000 æ˜¯çš„ã€‚ åº”ç”¨ç¨‹åºéƒ¨ä»¶ [...] // Application parts: just reference one of the grain implementations that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(ValueGrain).Assembly).WithReferences()) [...]; è™½ç„¶æŠ€æœ¯ä¸Šä¸éœ€è¦æ­¤æ­¥éª¤(å¦‚æœæœªé…ç½®ï¼ŒOrleanså°†æ‰«æå½“å‰æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰ç¨‹åºé›†)ï¼Œä½†é¼“åŠ±å¼€å‘äººå‘˜å¯¹æ­¤è¿›è¡Œé…ç½®ã€‚æ­¤æ­¥éª¤å°†å¸®åŠ©OrleansåŠ è½½ç”¨æˆ·ç¨‹åºé›†å’Œç±»å‹ã€‚è¿™äº›ç»„ä»¶ç§°ä¸ºåº”ç”¨ç¨‹åºéƒ¨ä»¶ã€‚æ‰€æœ‰Grainã€Grainæ¥å£å’Œåºåˆ—åŒ–å™¨éƒ½æ˜¯ä½¿ç”¨åº”ç”¨ç¨‹åºéƒ¨ä»¶å‘ç°çš„ã€‚ åº”ç”¨ç¨‹åºéƒ¨ä»¶çš„é…ç½®ä½¿ç”¨ IApplicationPartsManageråº”ç”¨ç¨‹åºéƒ¨ä»¶ç®¡ç†å™¨ ï¼Œå¯ä»¥ä½¿ç”¨ é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ ä¸Šçš„æ‰©å±•æ–¹æ³• IClientBuilder å’Œ IsiloHostBuilder æ˜¯çš„ã€‚è¿™ä¸ª é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ æ–¹æ³•æ¥å—å§”æ‰˜ï¼Œ æ“ä½œ<iapplicationpartmanager> æ˜¯çš„ã€‚ ä¸Šçš„ä»¥ä¸‹æ‰©å±•æ–¹æ³• IApplicationPartManager æ”¯æŒå¸¸è§ç”¨é€”ï¼š addapplicationpart(ç¨‹åºé›†) ä½¿ç”¨æ­¤æ‰©å±•æ–¹æ³•å¯ä»¥æ·»åŠ å•ä¸ªç¨‹åºé›†ã€‚ AddFromAppdomain() æ·»åŠ å½“å‰åŠ è½½åœ¨ åº”ç”¨ç¨‹åºåŸŸ æ˜¯çš„ã€‚ AddFromApplicationBaseDirectory() åŠ è½½å¹¶æ·»åŠ å½“å‰åŸºè·¯å¾„ä¸­çš„æ‰€æœ‰ç¨‹åºé›†(è¯·å‚è§ appdomain.basedirectoryç›®å½• )ä¸­ã€‚ é€šè¿‡ä¸Šè¿°æ–¹æ³•æ·»åŠ çš„ç¨‹åºé›†å¯ä»¥åœ¨å…¶è¿”å›ç±»å‹ä¸Šä½¿ç”¨ä»¥ä¸‹æ‰©å±•æ–¹æ³•è¿›è¡Œè¡¥å……ï¼Œ å¸¦ç¨‹åºé›†çš„IApplicationPartManager ï¼š å¼•ç”¨() ä»æ·»åŠ çš„é›¶ä»¶æ·»åŠ æ‰€æœ‰å¼•ç”¨çš„éƒ¨ä»¶ã€‚è¿™å°†ç«‹å³åŠ è½½ä»»ä½•å¯ä¼ é€’å¼•ç”¨çš„ç¨‹åºé›†ã€‚å¿½ç•¥ç¨‹åºé›†åŠ è½½é”™è¯¯ã€‚ ä½¿ç”¨ä»£ç ç”Ÿæˆ() ä¸ºæ·»åŠ çš„éƒ¨ä»¶ç”Ÿæˆæ”¯æŒä»£ç å¹¶å°†å…¶æ·»åŠ åˆ°éƒ¨ä»¶ç®¡ç†å™¨ä¸­ã€‚æ³¨æ„ï¼Œè¿™éœ€è¦ Microsoft.Orleans.Orleanscodegenerator è¦å®‰è£…çš„åŒ…ï¼Œé€šå¸¸ç§°ä¸ºè¿è¡Œæ—¶ä»£ç ç”Ÿæˆã€‚ ç±»å‹å‘ç°è¦æ±‚æä¾›çš„åº”ç”¨ç¨‹åºéƒ¨åˆ†åŒ…å«ç‰¹å®šå±æ€§ã€‚æ·»åŠ ç”Ÿæˆæ—¶ä»£ç ç”ŸæˆåŒ…( Microsoft.Orleans.CodeGenerator.MSBuild æˆ– Microsoft.Orleans.OrleansCodeGenerator.Build )å¯¹äºåŒ…å«Grainã€Grainæ¥å£æˆ–åºåˆ—åŒ–ç¨‹åºçš„æ¯ä¸ªé¡¹ç›®ï¼Œå»ºè®®ä½¿ç”¨ç¡®ä¿è¿™äº›å±æ€§å­˜åœ¨çš„æ–¹æ³•ã€‚ç”Ÿæˆç”Ÿæˆæ—¶ä»£ç åªæ”¯æŒCã€‚å¯¹äºFã€Visual Basicå’Œå…¶ä»–.NETè¯­è¨€ï¼Œå¯ä»¥åœ¨é…ç½®æœŸé—´é€šè¿‡ ä½¿ç”¨ä»£ç ç”Ÿæˆ() ä¸Šè¿°æ–¹æ³•ã€‚æœ‰å…³ä»£ç ç”Ÿæˆçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ ç›¸åº”éƒ¨åˆ† æ˜¯çš„ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html",
    "title": "Configuring ADO.NET Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é…ç½®ADO.NETæä¾›ç¨‹åº ä»»ä½•å¯é çš„Orleanséƒ¨ç½²éƒ½éœ€è¦ä½¿ç”¨æŒä¹…å­˜å‚¨æ¥ä¿æŒç³»ç»ŸçŠ¶æ€ï¼Œç‰¹åˆ«æ˜¯Orleansé›†ç¾¤æˆå‘˜è¡¨å’Œæé†’ã€‚å¯ç”¨çš„é€‰é¡¹ä¹‹ä¸€æ˜¯é€šè¿‡ADO.NETæä¾›ç¨‹åºä½¿ç”¨SQLæ•°æ®åº“ã€‚ ä¸ºäº†ä½¿ç”¨ado.netè¿›è¡ŒæŒä¹…åŒ–ã€é›†ç¾¤æˆ–æé†’ï¼Œéœ€è¦å°†ado.netæä¾›ç¨‹åºé…ç½®ä¸ºsilosé…ç½®çš„ä¸€éƒ¨åˆ†ï¼Œå¦‚æœæ˜¯é›†ç¾¤ï¼Œåˆ™è¿˜éœ€è¦é…ç½®ä¸ºå®¢æˆ·ç«¯é…ç½®çš„ä¸€éƒ¨åˆ†ã€‚ silosé…ç½®ä»£ç åº”å¦‚ä¸‹æ‰€ç¤ºï¼š var siloHostBuilder = new SiloHostBuilder(); var invariant = \"System.Data.SqlClient\"; // for Microsoft SQL Server var connectionString = \"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; //use AdoNet for clustering siloHostBuilder.UseAdoNetClustering(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); //use AdoNet for reminder service siloHostBuilder.UseAdoNetReminderService(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); //use AdoNet for Persistence siloHostBuilder.AddAdoNetGrainStorage(\"GrainStorageForTest\", options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); å®¢æˆ·ç«¯é…ç½®ä»£ç åº”å¦‚ä¸‹æ‰€ç¤ºï¼š var siloHostBuilder = new SiloHostBuilder(); var invariant = \"System.Data.SqlClient\"; var connectionString = \"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True\"; //use AdoNet for clustering siloHostBuilder.UseAdoNetClustering(options => { options.Invariant = invariant; options.ConnectionString = connectionString; }); å…¶ä¸­ è¿æ¥ä¸² è®¾ç½®ä¸ºæœ‰æ•ˆçš„ADONETæœåŠ¡å™¨è¿æ¥å­—ç¬¦ä¸²ã€‚ ä¸ºäº†ä½¿ç”¨ado.netæä¾›ç¨‹åºè¿›è¡ŒæŒä¹…åŒ–ã€æé†’æˆ–é›†ç¾¤ï¼Œæœ‰ç”¨äºåˆ›å»ºæ•°æ®åº“å·¥ä»¶çš„è„šæœ¬ï¼Œæ‰€æœ‰å°†æ‰˜ç®¡Orleanssilosçš„æœåŠ¡å™¨éƒ½éœ€è¦è®¿é—®è¿™äº›è„šæœ¬ã€‚ç¼ºä¹å¯¹ç›®æ ‡æ•°æ®åº“çš„è®¿é—®æ˜¯æˆ‘ä»¬çœ‹åˆ°çš„å¼€å‘äººå‘˜æ‰€çŠ¯çš„ä¸€ä¸ªå…¸å‹é”™è¯¯ã€‚ åœ¨ADONETæ‰©å±•åNUGETSä¸Šå®‰è£…æˆ–æ‰§è¡ŒNUGETè¿˜åŸåï¼Œè„šæœ¬å°†å¤åˆ¶åˆ°é¡¹ç›®ç›®å½•æˆ–leansADONETcontentï¼Œå…¶ä¸­æ¯ä¸ªå—æ”¯æŒçš„ADO.NETæ‰©å±•åéƒ½æœ‰è‡ªå·±çš„ç›®å½•ã€‚æˆ‘ä»¬å°†adonet nugetåˆ†ä¸ºæ¯ä¸ªåŠŸèƒ½nugetï¼š Microsoft.Orleans.Clustering.adonet å¯¹äºé›†ç¾¤ï¼Œ Microsoft.Orleans.Persistence.adonet ä¸ºäº†åšæŒå’Œ Microsoft.Orleans.Reminders.adonet ä½œä¸ºæé†’ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/configuring_.NET_garbage_collection.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/configuring_.NET_garbage_collection.html",
    "title": "Configuring .NET Garbage Collection | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é…ç½®.NETåƒåœ¾å›æ”¶ ä¸ºäº†è·å¾—è‰¯å¥½çš„æ€§èƒ½ï¼Œå¿…é¡»ä»¥æ­£ç¡®çš„æ–¹å¼ä¸ºsilosè¿›ç¨‹é…ç½®.NETåƒåœ¾å›æ”¶ã€‚æˆ‘ä»¬æ‰¾åˆ°çš„æœ€ä½³è®¾ç½®ç»„åˆæ˜¯è®¾ç½®gcserver=trueå’Œgcconcurrent=trueã€‚è¿™äº›å¾ˆå®¹æ˜“é€šè¿‡åº”ç”¨ç¨‹åºcsprojæ–‡ä»¶è®¾ç½®ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š .NETæ¡†æ¶å’Œ.NETæ ¸å¿ƒ // .csproj <PropertyGroup> <ServerGarbageCollection>true</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> å…·æœ‰æ—§.csprojé¡¹ç›®æ ¼å¼çš„.NETæ¡†æ¶ // App.config <configuration> <runtime> <gcServer enabled=\"true\"/> <gcConcurrent enabled=\"true\"/> </runtime> </configuration> ä½†æ˜¯ï¼Œå¦‚æœsilosä½œä¸ºazureå·¥ä½œå™¨è§’è‰²çš„ä¸€éƒ¨åˆ†è¿è¡Œ(é»˜è®¤æƒ…å†µä¸‹é…ç½®ä¸ºä½¿ç”¨å·¥ä½œç«™gc)ï¼Œè¿™å°±ä¸é‚£ä¹ˆå®¹æ˜“äº†ã€‚è¿™ç¯‡åšå®¢æ–‡ç« å±•ç¤ºäº†å¦‚ä½•ä¸ºazureå·¥ä½œè€…è§’è‰²è®¾ç½®ç›¸åŒçš„é…ç½®- https://blogs.msdn.microsoft.com/cclayton/2014/06/05/server-garbage-collection-mode-in-microsoft-azure/ [å•Šï¼æ³¨æ„] server garbage collection is available only on multiprocessor computers ä¸­ã€‚å› æ­¤ï¼Œå³ä½¿æ‚¨é€šè¿‡åº”ç”¨ç¨‹åºcsprojæ–‡ä»¶æˆ–é€šè¿‡å¼•ç”¨çš„åšå®¢æ–‡ç« ä¸Šçš„è„šæœ¬é…ç½®åƒåœ¾å›æ”¶ï¼Œå¦‚æœsilosè¿è¡Œåœ¨å…·æœ‰å•ä¸ªæ ¸å¿ƒçš„(è™šæ‹Ÿ)è®¡ç®—æœºä¸Šï¼Œæ‚¨ä¹Ÿä¸ä¼šä» gcserver=çœŸ æ˜¯çš„ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html",
    "title": "Shutting down Orleans | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æœ¬æ–‡æ¡£è§£é‡Šäº†å¦‚ä½•åœ¨åº”ç”¨ç¨‹åºå‡ºå£ä¹‹å‰ä¼˜é›…åœ°å…³é—­Orleanssilosï¼Œé¦–å…ˆæ˜¯ä½œä¸ºæ§åˆ¶å°åº”ç”¨ç¨‹åºï¼Œç„¶åä½œä¸ºä¸€ä¸ªåç¼–è¯‘å®¹å™¨åº”ç”¨ç¨‹åºã€‚ æ­£å¸¸å…³æœº-æ§åˆ¶å°åº”ç”¨ç¨‹åº ä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†å¦‚ä½•åœ¨ç”¨æˆ·æŒ‰ä¸‹ctrl+cæ—¶ä¼˜é›…åœ°å…³é—­Orleansæ€æ´›æ§åˆ¶å°åº”ç”¨ç¨‹åºï¼Œè¿™å°†ç”Ÿæˆ æ§åˆ¶å°å–æ¶ˆæŒ‰é”® äº‹ä»¶ é€šå¸¸ï¼Œå½“äº‹ä»¶å¤„ç†ç¨‹åºè¿”å›æ—¶ï¼Œåº”ç”¨ç¨‹åºå°†ç«‹å³é€€å‡ºï¼Œå¯¼è‡´ç¾éš¾æ€§çš„Orleanssiloså´©æºƒå’Œå†…å­˜çŠ¶æ€ä¸¢å¤±ã€‚ä½†æ˜¯åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä»£ç ä¸­ï¼Œæˆ‘ä»¬è®¾ç½® a.å–æ¶ˆ=çœŸï¼› ä»¥é˜²æ­¢åº”ç”¨ç¨‹åºåœ¨Orleanssiloså®Œæˆæ­£å¸¸å…³é—­ä¹‹å‰å…³é—­ã€‚ using Microsoft.Extensions.Logging; using Orleans.Configuration; using Orleans.Hosting; using System; using System.Net; using System.Threading; using System.Threading.Tasks; namespace MySiloHost { class Program { static readonly ManualResetEvent _siloStopped = new ManualResetEvent(false); static ISiloHost silo; static bool siloStopping = false; static readonly object syncLock = new object(); static void Main(string[] args) { SetupApplicationShutdown(); silo = CreateSilo(); silo.StartAsync().Wait(); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); } static void SetupApplicationShutdown() { /// Capture the user pressing Ctrl+C Console.CancelKeyPress += (s, a) => { /// Prevent the application from crashing ungracefully. a.Cancel = true; /// Don't allow the following code to repeat if the user presses Ctrl+C repeatedly. lock (syncLock) { if (!siloStopping) { siloStopping = true; Task.Run(StopSilo).Ignore(); } } /// Event handler execution exits immediately, leaving the silo shutdown running on a background thread, /// but the app doesn't crash because a.Cancel has been set = true }; } static ISiloHost CreateSilo() { return new SiloHostBuilder() .Configure(options => options.ClusterId = \"MyTestCluster\") /// Prevent the silo from automatically stopping itself when the cancel key is pressed. .Configure<ProcessExitHandlingOptions>(options => options.FastKillOnProcessExit = false) .UseDevelopmentClustering(options => options.PrimarySiloEndpoint = new IPEndPoint(IPAddress.Loopback, 11111)) .ConfigureLogging(b => b.SetMinimumLevel(LogLevel.Debug).AddConsole()) .Build(); } static async Task StopSilo() { await silo.StopAsync(); _siloStopped.Set(); } } } å½“ç„¶ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–æ–¹æ³•å¯ä»¥è¾¾åˆ°åŒæ ·çš„ç›®æ ‡ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ–¹å¼ï¼Œæµè¡Œçš„åœ¨çº¿ï¼Œè¯¯å¯¼ï¼Œè¿™æ˜¯ä¸æ­£å¸¸çš„å·¥ä½œã€‚å®ƒä¸èµ·ä½œç”¨ï¼Œå› ä¸ºå®ƒåœ¨è¯•å›¾é€€å‡ºçš„ä¸¤ç§æ–¹æ³•ä¹‹é—´è®¾ç½®ä¸€ä¸ªç«äº‰æ¡ä»¶ï¼š æ§åˆ¶å°å–æ¶ˆæŒ‰é”® äº‹ä»¶å¤„ç†ç¨‹åºæ–¹æ³•ï¼Œä»¥åŠ é™æ€void main(å­—ç¬¦ä¸²[]å‚æ•°) æ–¹æ³•ã€‚å½“äº‹ä»¶å¤„ç†æ–¹æ³•é¦–å…ˆå®Œæˆæ—¶ï¼Œè‡³å°‘å‘ç”Ÿä¸€åŠçš„æ—¶é—´ï¼Œåº”ç”¨ç¨‹åºå°†æŒ‚èµ·è€Œä¸æ˜¯é¡ºåˆ©é€€å‡ºã€‚ class Program { static readonly ManualResetEvent _siloStopped = new ManualResetEvent(false); static ISiloHost silo; static bool siloStopping = false; static readonly object syncLock = new object(); static void Main(string[] args) { Console.CancelKeyPress += (s, a) => { Task.Run(StopSilo); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); /// Now race to finish ... who will finish first? /// If I finish first, the application will hang! :( }; silo = CreateSilo(); silo.StartAsync().Wait(); /// Wait for the silo to completely shutdown before exiting. _siloStopped.WaitOne(); /// Now race to finish ... who will finish first? } static async Task StopSilo() { await silo.StopAsync(); _siloStopped.Set(); } } æ­£å¸¸å…³æœº-Dockeråº”ç”¨ç¨‹åº å¾…å®Œæˆã€‚"
  },
  "Documentation/grains/grain_versioning/backward_compatibility_guidelines.html": {
    "href": "Documentation/grains/grain_versioning/backward_compatibility_guidelines.html",
    "title": "å‘åå…¼å®¹å‡†åˆ™ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å‘åå…¼å®¹å‡†åˆ™ ç¼–å†™å‘åå…¼å®¹çš„ä»£ç å¯èƒ½å¾ˆéš¾æµ‹è¯•ã€‚ æ°¸è¿œä¸è¦æ›´æ”¹ç°æœ‰æ–¹æ³•çš„ç­¾å ç”±äºOrleansåºåˆ—åŒ–ç¨‹åºçš„å·¥ä½œæ–¹å¼ï¼Œæ‚¨æ°¸è¿œä¸åº”è¯¥æ›´æ”¹ç°æœ‰æ–¹æ³•çš„ç­¾åã€‚ ä»¥ä¸‹ç¤ºä¾‹æ˜¯æ­£ç¡®çš„ï¼š [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } è¿™æ˜¯ä¸æ­£ç¡®çš„ï¼š [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 Task MyMethod(int arg, obj o); } æ³¨æ„ ï¼šæ‚¨ä¸åº”åœ¨ä»£ç ä¸­è¿›è¡Œæ­¤æ›´æ”¹ï¼Œå› ä¸ºè¿™æ˜¯å¯¼è‡´éå¸¸ç³Ÿç³•çš„å‰¯ä½œç”¨çš„ä¸è‰¯å®è·µçš„ç¤ºä¾‹ã€‚è¿™æ˜¯ä¸€ä¸ªå¦‚æœæ‚¨åªé‡å‘½åå‚æ•°åä¼šå‘ç”Ÿä»€ä¹ˆçš„ç¤ºä¾‹ï¼šå‡è®¾æˆ‘ä»¬åœ¨é›†ç¾¤ä¸­éƒ¨ç½²äº†ä»¥ä¸‹ä¸¤ä¸ªæ¥å£ç‰ˆæœ¬ï¼š [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // return a - b Task<int> Substract(int a, int b); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // return y - x Task<int> Substract(int y, int x); } è¿™ç§æ–¹æ³•ä¼¼ä¹æ˜¯ç›¸åŒçš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½¿ç”¨V1è°ƒç”¨å®¢æˆ·ç«¯ï¼Œå¹¶ä¸”è¯·æ±‚ç”±V2æ¿€æ´»å¤„ç†ï¼š var grain = client.GetGrain<IMyGrain>(0); var result = await grain.Substract(5, 4); // Will return \"-1\" instead of expected \"1\" è¿™æ˜¯ç”±äºå†…éƒ¨Orleansåºåˆ—åŒ–ç¨‹åºæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ é¿å…æ”¹å˜ç°æœ‰çš„æ–¹æ³•é€»è¾‘ è¿™çœ‹èµ·æ¥å¾ˆæ˜æ˜¾ï¼Œä½†æ˜¯åœ¨æ›´æ”¹ç°æœ‰æ–¹æ³•çš„ä¸»ä½“æ—¶åº”è¯¥éå¸¸å°å¿ƒã€‚é™¤éæ‚¨æ­£åœ¨ä¿®å¤ä¸€ä¸ªbugï¼Œå¦åˆ™å¦‚æœæ‚¨éœ€è¦ä¿®æ”¹ä»£ç ï¼Œæœ€å¥½åªæ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³•ã€‚ ä¾‹å­ï¼š // V1 public interface MyGrain : IMyGrain { // First method Task MyMethod(int arg) { SomeSubRoutine(arg); } } // V2 public interface MyGrain : IMyGrain { // Method inherited from V1 // Do not change the body Task MyMethod(int arg) { SomeSubRoutine(arg); } // New method added in V2 Task MyNewMethod(int arg) { SomeSubRoutine(arg); NewRoutineAdded(arg); } } ä¸è¦ä»grainæ¥å£åˆ é™¤æ–¹æ³• é™¤éç¡®å®šä¸å†ä½¿ç”¨è¿™äº›æ–¹æ³•ï¼Œå¦åˆ™ä¸åº”ä»grainæ¥å£ä¸­åˆ é™¤æ–¹æ³•ã€‚å¦‚æœè¦åˆ é™¤æ–¹æ³•ï¼Œåº”è¯¥åˆ†ä¸¤æ­¥å®Œæˆï¼š1ã€‚éƒ¨ç½²V2grainsï¼ŒV1æ–¹æ³•æ ‡è®°ä¸º è¿‡æ—¶çš„ [Version(1)] public interface IMyGrain : IGrainWithIntegerKey { // First method Task MyMethod(int arg); } [Version(2)] public interface IMyGrain : IGrainWithIntegerKey { // Method inherited from V1 [Obsolete] Task MyMethod(int arg); // New method added in V2 Task MyNewMethod(int arg, obj o); } å½“æ‚¨ç¡®å®šæ²¡æœ‰è¿›è¡ŒV1è°ƒç”¨æ—¶(å®é™…ä¸ŠV1ä¸å†éƒ¨ç½²åœ¨æ­£åœ¨è¿è¡Œçš„é›†ç¾¤ä¸­)ï¼Œåˆ™åœ¨éƒ¨ç½²V3æ—¶åˆ é™¤V1æ–¹æ³• cs [Version(3)] public interface IMyGrain : IGrainWithIntegerKey { // New method added in V2 Task MyNewMethod(int arg, obj o); }"
  },
  "Documentation/grains/grain_versioning/compatible_grains.html": {
    "href": "Documentation/grains/grain_versioning/compatible_grains.html",
    "title": "å…¼å®¹Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å…¼å®¹Grains å½“ç°æœ‰çš„Grainsæ¿€æ´»å°†è¦å¤„ç†è¯·æ±‚æ—¶ï¼Œè¿è¡Œæ—¶å°†æ£€æŸ¥è¯·æ±‚ä¸­çš„ç‰ˆæœ¬ä¸Grainsçš„å®é™…ç‰ˆæœ¬æ˜¯å¦å…¼å®¹ã€‚ Orleansä¸ä¼šåœ¨è¿è¡Œæ—¶æ¨æ–­è¦ä½¿ç”¨å“ªä¸ªç­–ç•¥ ï¼Œç¡®å®šä¸¤ä¸ªç‰ˆæœ¬æ˜¯å¦å…¼å®¹çš„é»˜è®¤è¡Œä¸ºç”± GrainVersioningOptions.CompatibilityStrategy å‘åå…¼å®¹(é»˜è®¤) å®šä¹‰ å¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œåˆ™Grainæ¥å£ç‰ˆæœ¬Vnå¯ä»¥ä¸Vmå‘åå…¼å®¹ï¼š æ¥å£åç§°æœªæ›´æ”¹(æˆ–è¦†ç›–çš„ç±»å‹ä»£ç ) Vmç‰ˆæœ¬ä¸­å­˜åœ¨çš„æ‰€æœ‰å…¬å…±æ–¹æ³•éƒ½åœ¨Vnç‰ˆæœ¬ä¸­ã€‚ é‡è¦çš„æ˜¯ï¼Œä¸è¦ä¿®æ”¹ä»Vmç»§æ‰¿çš„æ–¹æ³•çš„ç­¾åã€‚ ï¼šç”±äºOrleansä½¿ç”¨å†…éƒ¨å†…ç½®çš„åºåˆ—åŒ–ç¨‹åºï¼Œå› æ­¤ä¿®æ”¹/é‡å‘½åå­—æ®µ(ç”šè‡³ç§æœ‰)å¯èƒ½ä¼šä½¿åºåˆ—åŒ–ä¸­æ–­ã€‚ ç”±äºVnä¸Vmç›¸æ¯”å¯ä»¥å¢åŠ å…¶ä»–æ–¹æ³•ï¼Œå› æ­¤Vmä¸Vnä¸å…¼å®¹ã€‚ ä¾‹ å¦‚æœåœ¨é›†ç¾¤ä¸­ï¼Œç»™å®šæ¥å£æœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå³V1å’ŒV2ï¼Œå¹¶ä¸”è¯¥V2å‘åå…¼å®¹V1ï¼š å¦‚æœå½“å‰æ¿€æ´»ä¸ºV2ï¼Œè€Œè¯·æ±‚çš„ç‰ˆæœ¬ä¸ºV1ï¼Œåˆ™å½“å‰æ¿€æ´»å°†èƒ½å¤Ÿæ­£å¸¸å¤„ç†è¯·æ±‚ å¦‚æœå½“å‰æ¿€æ´»ä¸ºV1ï¼Œè€Œè¯·æ±‚çš„ç‰ˆæœ¬ä¸ºV2ï¼Œåˆ™å°†å–æ¶ˆæ¿€æ´»å½“å‰æ¿€æ´»ï¼Œå¹¶åˆ›å»ºä¸V2å…¼å®¹çš„æ–°æ¿€æ´»(è¯·å‚è§ ç‰ˆæœ¬é€‰æ‹©å™¨ç­–ç•¥ )ã€‚ å®Œå…¨å…¼å®¹ å®šä¹‰ å¦‚æœæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œåˆ™Grainsæ¥å£ç‰ˆæœ¬Vnå¯ä»¥ä¸Vmå®Œå…¨å…¼å®¹ï¼š Vnä¸Vmå‘åå…¼å®¹ åœ¨Vnç‰ˆæœ¬ä¸­æœªæ·»åŠ ä»»ä½•å…¬å…±æ–¹æ³• å¦‚æœVnä¸Vmå®Œå…¨å…¼å®¹ï¼Œåˆ™Vmä¹Ÿä¸Vnå®Œå…¨å…¼å®¹ã€‚ ä¾‹ å¦‚æœåœ¨é›†ç¾¤ä¸­ï¼Œç»™å®šæ¥å£æœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå³V1å’ŒV2ï¼Œå¹¶ä¸”è¯¥V2ä¸V1å®Œå…¨å…¼å®¹ï¼š å¦‚æœå½“å‰æ¿€æ´»ä¸ºV2ï¼Œè€Œè¯·æ±‚çš„ç‰ˆæœ¬ä¸ºV1ï¼Œåˆ™å½“å‰æ¿€æ´»å°†èƒ½å¤Ÿæ­£å¸¸å¤„ç†è¯·æ±‚ å¦‚æœå½“å‰æ¿€æ´»ä¸ºV1ï¼Œè€Œè¯·æ±‚çš„ç‰ˆæœ¬ä¸ºV2ï¼Œåˆ™å½“å‰æ¿€æ´»ä¹Ÿå°†èƒ½å¤Ÿæ­£å¸¸å¤„ç†è¯·æ±‚"
  },
  "Documentation/grains/grain_versioning/deploying_new_versions_of_grains.html": {
    "href": "Documentation/grains/grain_versioning/deploying_new_versions_of_grains.html",
    "title": "éƒ¨ç½²æ–°ç‰ˆæœ¬çš„Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "éƒ¨ç½²æ–°ç‰ˆæœ¬çš„Grains æ»šåŠ¨å‡çº§ é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæ‚¨å¯ä»¥ç›´æ¥åœ¨ç¯å¢ƒä¸­éƒ¨ç½²è¾ƒæ–°çš„Siloã€‚è¿™æ˜¯æœ€ç®€å•çš„æ–¹æ³•ï¼Œä½†æ˜¯å¯èƒ½å¾ˆéš¾ä¸­æ–­æ­£åœ¨è¿›è¡Œçš„éƒ¨ç½²å¹¶å›æ»šã€‚ æ¨èé…ç½®ï¼š DefaultCompatibilityStrategy è°ƒæˆ BackwardCompatible DefaultVersionSelectorStrategy è°ƒæˆ AllCompatibleVersions var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(AllCompatibleVersions); }) [...] ä½¿ç”¨æ­¤é…ç½®æ—¶ï¼Œâ€œæ—§â€å®¢æˆ·ç«¯å°†èƒ½å¤Ÿä¸ä¸¤ä¸ªç‰ˆæœ¬çš„silosä¸Šçš„æ¿€æ´»è¿›è¡Œå¯¹è¯ã€‚è¾ƒæ–°çš„å®¢æˆ·ç«¯å’Œsilosåªä¼šåœ¨è¾ƒæ–°çš„silosä¸Šè§¦å‘æ–°çš„æ¿€æ´»ã€‚ ä½¿ç”¨é¢„ç”Ÿäº§ç¯å¢ƒ åœ¨è¿™ç§æ–¹æ³•ä¸­ï¼Œæ‚¨å°†éœ€è¦ç¬¬äºŒä¸ªç¯å¢ƒ(é¢„ç”Ÿäº§ç¯å¢ƒ)ï¼Œåœ¨è¯¥ç¯å¢ƒä¸­æ‚¨å°†åœ¨åœæ­¢ç”Ÿäº§ç¯å¢ƒä¹‹å‰éƒ¨ç½²è¾ƒæ–°çš„Siloã€‚ç”Ÿäº§å’Œé¢„ç”Ÿäº§Siloså’Œå®¢æˆ·ç«¯å°†ä½œä¸º åŒä¸€é›†ç¾¤çš„ä¸€éƒ¨åˆ† ã€‚ä¸¤ä¸ªç¯å¢ƒä¸­çš„siloså¯ä»¥ç›¸äº’é€šä¿¡ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚ æ¨èé…ç½®ï¼š DefaultCompatibilityStrategy è°ƒæˆ BackwardCompatible DefaultVersionSelectorStrategy è°ƒæˆ MinimumVersion var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(MinimumVersion); }) [...] å»ºè®®çš„éƒ¨ç½²æ­¥éª¤ï¼š â€œV1â€ siloså’Œå®¢æˆ·ç«¯å·²éƒ¨ç½²å¹¶æ­£åœ¨ç”Ÿäº§æ’æ§½ä¸­è¿è¡Œã€‚ â€œV2â€ siloså’Œå®¢æˆ·ç«¯å¼€å§‹åœ¨é¢„ç”Ÿäº§æ’æ§½ä¸­å¯åŠ¨ã€‚ä»–ä»¬å°†ä¸ç”Ÿâ€‹â€‹äº§å¹¿å‘Šä½åŠ å…¥åŒä¸€é›†ç¾¤ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå°†ä¸ä¼šåˆ›å»ºâ€œV2â€æ¿€æ´»ã€‚ åœ¨é¢„ç”Ÿäº§æ’æ§½ä¸­çš„éƒ¨ç½²å®Œæˆåï¼Œå¼€å‘äººå‘˜å¯ä»¥é‡å®šå‘V2å®¢æˆ·ç«¯ä¸Šçš„æŸäº›æµé‡(çƒŸé›¾æµ‹è¯•ï¼Œç›®æ ‡Betaç”¨æˆ·ç­‰)ã€‚è¿™å°†åˆ›å»ºV2æ¿€æ´»ï¼Œä½†æ˜¯ç”±äºGrainsæ˜¯å‘åå…¼å®¹çš„ï¼Œå¹¶ä¸”æ‰€æœ‰Siloéƒ½åœ¨åŒä¸€é›†ç¾¤ä¸­ï¼Œå› æ­¤ä¸ä¼šåˆ›å»ºé‡å¤çš„æ¿€æ´»ã€‚ å¦‚æœéªŒè¯æˆåŠŸï¼Œè¯·ç»§ç»­è¿›è¡ŒVIPäº¤æ¢ã€‚å¦‚æœæ²¡æœ‰ï¼Œæ‚¨å¯ä»¥å®‰å…¨åœ°å…³é—­é¢„ç”Ÿäº§ç¾¤é›†ï¼šå¦‚æœéœ€è¦ï¼Œç°æœ‰çš„V2æ¿€æ´»å°†è¢«é”€æ¯ï¼Œè€ŒV1æ¿€æ´»å°†è¢«åˆ›å»ºã€‚ V1æ¿€æ´»è‡ªç„¶ä¼šæœ€ç»ˆâ€œè¿ç§»â€åˆ°V2 Siloã€‚æ‚¨å¯ä»¥å®‰å…¨åœ°å…³é—­V1 silosã€‚ [ï¼è­¦å‘Š!]è¯·è®°ä½ï¼Œæ— çŠ¶æ€å·¥ä½œå™¨æ²¡æœ‰ç‰ˆæœ¬æ§åˆ¶ï¼Œæµä»£ç†ä¹Ÿå°†åœ¨é¢„ç”Ÿäº§ç¯å¢ƒä¸­å¯åŠ¨ã€‚"
  },
  "Documentation/grains/grain_persistence/azure_storage.html": {
    "href": "Documentation/grains/grain_persistence/azure_storage.html",
    "title": "Azure Storage Grain Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Azureå­˜å‚¨GrainæŒä¹…åŒ– Azureå­˜å‚¨GrainæŒä¹…åŒ–æä¾›ç¨‹åºåŒæ—¶æ”¯æŒ Azure Blobå­˜å‚¨ å’Œ Azureè¡¨å­˜å‚¨ ã€‚ å®‰è£… å®‰è£… Microsoft.Orleans.Persistence.AzureStorage NuGetçš„è½¯ä»¶åŒ…ã€‚ ç»„æ€ Azureè¡¨å­˜å‚¨ Azureè¡¨å­˜å‚¨æä¾›ç¨‹åºå°†çŠ¶æ€å­˜å‚¨åœ¨è¡¨è¡Œä¸­ï¼Œå¦‚æœè¶…å‡ºå•ä¸ªåˆ—çš„é™åˆ¶ï¼Œåˆ™å°†çŠ¶æ€åˆ†ä¸ºå¤šä¸ªåˆ—ã€‚æ¯è¡Œçš„æœ€å¤§é•¿åº¦ä¸ºä¸€å…†å­—èŠ‚ï¼Œä¾‹å¦‚ æ‰©å±•Azureè¡¨å­˜å‚¨ ã€‚ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤é…ç½®Azureè¡¨å­˜å‚¨GrainæŒä¹…åŒ–æä¾›ç¨‹åº ISiloBuilder.AddAzureTableGrainStorage æ‰©å±•æ–¹æ³•ã€‚ siloBuilder.AddAzureTableGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; }); Azure Blobå­˜å‚¨ Azure Blobå­˜å‚¨æä¾›ç¨‹åºå°†çŠ¶æ€å­˜å‚¨åœ¨Blobä¸­ã€‚ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤é…ç½®Azure Blobå­˜å‚¨GrainæŒä¹…åŒ–æä¾›ç¨‹åº ISiloBuilder.AddAzureBlobGrainStorage æ‰©å±•æ–¹æ³•ã€‚ siloBuilder.AddAzureBlobGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; });"
  },
  "Documentation/grains/grain_persistence/dynamodb_storage.html": {
    "href": "Documentation/grains/grain_persistence/dynamodb_storage.html",
    "title": "Amazon DynamoDB Grain Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Amazon DynamoDBGrainæŒä¹…åŒ– å®‰è£… å®‰è£… Microsoft.Orleans.Persistence.DynamoDB NuGetçš„è½¯ä»¶åŒ…ã€‚ ç»„æ€ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤é…ç½®Dynamo DB Grain Persistenceæä¾›ç¨‹åº ISiloBuilder.AddDynamoDBGrainStorage æ‰©å±•æ–¹æ³•ã€‚ siloBuilder.AddDynamoDBGrainStorage( name: \"profileStore\", configureOptions: options => { options.UseJson = true; options.AccessKey = /* Dynamo DB access key */; options.SecretKey = /* Dynamo DB secret key */; options.Service = /* Dynamo DB service name */; });"
  },
  "Documentation/grains/grain_persistence/index.html": {
    "href": "Documentation/grains/grain_persistence/index.html",
    "title": "Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æŒä¹…åŒ– Grainså¯ä»¥å…·æœ‰å¤šä¸ªä¸ä¹‹å…³è”çš„å‘½åæŒä¹…æ•°æ®å¯¹è±¡ã€‚åœ¨æ¿€æ´»GrainsæœŸé—´ä¼šä»å­˜å‚¨ä¸­åŠ è½½æ­¤çŠ¶æ€ï¼Œä»¥ä¾¿åœ¨è¯·æ±‚æœŸé—´å¯ä»¥ä½¿ç”¨å®ƒä»¬ã€‚GrainæŒä¹…åŒ–ä½¿ç”¨å¯æ‰©å±•çš„æ’ä»¶æ¨¡å‹ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ä»»ä½•æ•°æ®åº“çš„å­˜å‚¨æä¾›ç¨‹åºã€‚æ­¤æŒä¹…åŒ–æ¨¡å‹ä»…å‡ºäºç®€åŒ–ç›®çš„è€Œè®¾è®¡ï¼Œå¹¶ä¸æ—¨åœ¨æ¶µç›–æ‰€æœ‰æ•°æ®è®¿é—®æ¨¡å¼ã€‚Grainsè¿˜å¯ä»¥ç›´æ¥è®¿é—®æ•°æ®åº“ï¼Œè€Œæ— éœ€ä½¿ç”¨GrainsæŒä¹…åŒ–æ¨¡å‹ã€‚ åœ¨ä¸Šå›¾ä¸­ï¼ŒUserGrainæœ‰ä¸€ä¸ª Profile çŠ¶æ€å’Œ Cart çŠ¶æ€ï¼Œæ¯ä¸ªçŠ¶æ€éƒ½å­˜å‚¨åœ¨å•ç‹¬çš„å­˜å‚¨ç³»ç»Ÿä¸­ã€‚ ç›®æ ‡ æ¯ä¸ªGrainsæœ‰å¤šä¸ªå‘½åçš„æŒä¹…æ•°æ®å¯¹è±¡ã€‚ å¤šä¸ªé…ç½®çš„å­˜å‚¨æä¾›ç¨‹åºï¼Œæ¯ä¸ªå­˜å‚¨æä¾›ç¨‹åºå¯ä»¥å…·æœ‰ä¸åŒçš„é…ç½®å¹¶ç”±ä¸åŒçš„å­˜å‚¨ç³»ç»Ÿæ”¯æŒã€‚ å­˜å‚¨æä¾›å•†å¯ä»¥ç”±ç¤¾åŒºå¼€å‘å’Œå‘å¸ƒã€‚ å­˜å‚¨æä¾›è€…å¯ä»¥å®Œå…¨æ§åˆ¶ä»–ä»¬å¦‚ä½•åœ¨æŒä¹…åŒ–åå¤‡å­˜å‚¨ä¸­å­˜å‚¨GrainsçŠ¶æ€æ•°æ®ã€‚ç»“è®ºï¼šOrleansæ²¡æœ‰æä¾›å…¨é¢çš„ORMå­˜å‚¨è§£å†³æ–¹æ¡ˆï¼Œä½†å…è®¸è‡ªå®šä¹‰å­˜å‚¨æä¾›å•†åœ¨éœ€è¦æ—¶æ”¯æŒç‰¹å®šçš„ORMè¦æ±‚ã€‚ é…å¥— å¯ä»¥åœ¨ä»¥ä¸‹ä½ç½®æ‰¾åˆ°OrleansGrainså­˜å‚¨æä¾›å•† NuGet ã€‚å®˜æ–¹ç»´æŠ¤çš„è½¯ä»¶åŒ…åŒ…æ‹¬ï¼š Microsoft.Orleans.Persistence.AdoNet é€‚ç”¨äºADO.NETæ”¯æŒçš„SQLæ•°æ®åº“å’Œå…¶ä»–å­˜å‚¨ç³»ç»Ÿã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ ADO.NETGrainæŒä¹…åŒ– ã€‚ Microsoft.Orleans.Persistence.AzureStorage é€šè¿‡Azure Table Storage APIè®¿é—®Azureå­˜å‚¨ï¼ŒåŒ…æ‹¬Azure Blobå­˜å‚¨ï¼ŒAzureè¡¨å­˜å‚¨å’ŒAzure CosmosDBã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ Azureå­˜å‚¨GrainæŒä¹…åŒ– ã€‚ Microsoft.Orleans.Persistence.DynamoDB é€‚ç”¨äºAmazon DynamoDBã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ Amazon DynamoDBGrainæŒä¹…åŒ– ã€‚ API Grainsä¸å®ƒä»¬çš„æŒä¹…çŠ¶æ€ç›¸äº’ä½œç”¨ IPersistentState <TState> å“ªé‡Œ State æ˜¯å¯åºåˆ—åŒ–çŠ¶æ€ç±»å‹ï¼š Grainsé€šè¿‡ IPersistentState<TState> ï¼ˆå…¶ä¸­ <TState> ä¸ºå…¶å¯åºåˆ—åŒ–çŠ¶æ€ç±»å‹ï¼‰ä¸å®ƒä»¬çš„æŒä¹…åŒ–çŠ¶æ€äº¤äº’ã€‚ public interface IPersistentState<TState> where TState : new() { TState State { get; set; } string Etag { get; } Task ClearStateAsync(); Task WriteStateAsync(); Task ReadStateAsync(); } IPersistentState <TState> çš„å®ä¾‹ä½œä¸ºæ„é€ å‡½æ•°å‚æ•°æ³¨å…¥åˆ°Grainsä¸­ã€‚è¿™äº›å‚æ•°å¯ä»¥ç”¨ [PersistentState(stateNameï¼ŒstorageName)] å±æ€§æ¥æ ‡è¯†è¦æ³¨å…¥çš„çŠ¶æ€çš„åç§°ä»¥åŠæä¾›çŠ¶æ€å­˜å‚¨æä¾›ç¨‹åºçš„åç§°ã€‚ä»¥ä¸‹ç¤ºä¾‹é€šè¿‡å°†ä¸¤ä¸ªå‘½åçŠ¶æ€æ³¨å…¥åˆ° UserGrain æ„é€ å‡½æ•°ï¼š public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; private readonly IPersistentState<CartState> _cart; public UserGrain( [PersistentState(\"profile\", \"myGrainStorage\")] IPersistentState<ProfileState> profile, [PersistentState(\"cart\", \"cartStorage\")] IPersistentState<CartState> cart, ) { _profile = profile; _cart = cart; } } å³ä½¿å®ƒä»¬æ˜¯åŒä¸€ç±»å‹ï¼Œä¸åŒçš„Grainç±»å‹ä¹Ÿå¯ä»¥ä½¿ç”¨ä¸åŒçš„é…ç½®å­˜å‚¨æä¾›ç¨‹åºï¼šä¾‹å¦‚ï¼Œä¸¤ä¸ªä¸åŒçš„Azure Table Storageæä¾›ç¨‹åºå®ä¾‹è¿æ¥åˆ°ä¸åŒçš„Azureå­˜å‚¨å¸æˆ·ã€‚ è¯»å–çŠ¶æ€ å½“æ¿€æ´»grainsæ—¶ï¼Œå°†è‡ªåŠ¨è¯»å–grainsçŠ¶æ€ï¼Œä½†æ˜¯grainsè´Ÿè´£åœ¨å¿…è¦æ—¶æ˜¾å¼è§¦å‘ä»»ä½•æ›´æ”¹çš„grainsçŠ¶æ€çš„å†™å…¥ã€‚ å¦‚æœæŸä¸ªGrainså¸Œæœ›ä»åå¤‡å­˜å‚¨ä¸­æ˜ç¡®é‡æ–°è¯»å–è¯¥Grainsçš„æœ€æ–°çŠ¶æ€ï¼Œåˆ™è¯¥Grainsåº”è°ƒç”¨ ReadStateAsync() æ–¹æ³•ã€‚ è¿™å°†é€šè¿‡å­˜å‚¨æä¾›ç¨‹åºä»æŒä¹…å­˜å‚¨é‡æ–°åŠ è½½GrainçŠ¶æ€ï¼Œå¹¶ä¸”å½“ ReadStateAsync() ä»»åŠ¡å®Œæˆæ—¶ï¼Œå°†è¦†ç›–å’Œæ›¿æ¢ä¹‹å‰çš„å†…å­˜çŠ¶æ€å‰¯æœ¬ã€‚ ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è®¿é—®çŠ¶æ€å€¼ State å±æ€§ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ–¹æ³•è®¿é—®ä¸Šé¢çš„ä»£ç ä¸­å£°æ˜çš„é…ç½®æ–‡ä»¶çŠ¶æ€ï¼š public Task<string> GetNameAsync() => Task.FromResult(_profile.State.Name); æ— éœ€è°ƒç”¨ ReadStateAsync() åœ¨æ­£å¸¸æ“ä½œæœŸé—´ï¼šåœ¨æ¿€æ´»æœŸé—´è‡ªåŠ¨åŠ è½½çŠ¶æ€ã€‚ç„¶è€Œï¼Œ ReadStateAsync() å¯ä»¥ç”¨æ¥åˆ·æ–°å¤–éƒ¨ä¿®æ”¹çš„çŠ¶æ€ã€‚ è§ å¤±è´¥æ¨¡å¼ ä»¥ä¸‹éƒ¨åˆ†æä¾›äº†æœ‰å…³é”™è¯¯å¤„ç†æœºåˆ¶çš„è¯¦ç»†ä¿¡æ¯ã€‚ å†™å…¥çŠ¶æ€ çŠ¶æ€å¯ä»¥é€šè¿‡ State å±æ€§ã€‚ä¿®æ”¹åçš„çŠ¶æ€ä¸ä¼šè‡ªåŠ¨ä¿æŒã€‚ç›¸åï¼Œå¼€å‘äººå‘˜é€šè¿‡è°ƒç”¨ WriteStateAsync() æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ–¹æ³•æ›´æ–°ä¸€ä¸ªå±æ€§ State å¹¶ä¿æŒæ›´æ–°çŠ¶æ€ï¼š public async Task SetNameAsync(string name) { _profile.State.Name = name; await _profile.WriteStateAsync(); } ä»æ¦‚å¿µä¸Šè®²ï¼ŒOrleansè¿è¡Œæ—¶å°†åœ¨ä»»ä½•å†™å…¥æ“ä½œæœŸé—´è·å–GrainsçŠ¶æ€æ•°æ®å¯¹è±¡çš„æ·±å±‚å‰¯æœ¬ä»¥ä¾›å…¶è‡ªå·±ä½¿ç”¨ã€‚åœ¨å¹•åï¼Œè¿è¡Œæ—¶ å¯èƒ½ åœ¨ä¿ç•™é¢„æœŸçš„é€»è¾‘éš”ç¦»è¯­ä¹‰çš„å‰æä¸‹ï¼Œä½¿ç”¨ä¼˜åŒ–è§„åˆ™å’Œè¯•æ¢æ³•é¿å…åœ¨æŸäº›æƒ…å†µä¸‹æ‰§è¡Œéƒ¨åˆ†æˆ–å…¨éƒ¨æ·±åº¦å¤åˆ¶ã€‚ è§ å¤±è´¥æ¨¡å¼ ä»¥ä¸‹éƒ¨åˆ†æä¾›äº†æœ‰å…³é”™è¯¯å¤„ç†æœºåˆ¶çš„è¯¦ç»†ä¿¡æ¯ã€‚ çŠ¶æ€æ¸…ç† ClearStateAsync() æ–¹æ³•æ¸…é™¤å­˜å‚¨ä¸­çš„GrainsçŠ¶æ€ã€‚æ ¹æ®æä¾›è€…ï¼Œæ­¤æ“ä½œå¯ä»¥é€‰æ‹©å®Œå…¨åˆ é™¤grainsçŠ¶æ€ã€‚ å…¥é—¨ åœ¨Grainså¯ä»¥ä½¿ç”¨æŒä¹…åŒ–ä¹‹å‰ï¼Œå¿…é¡»åœ¨silosä¸Šé…ç½®å­˜å‚¨æä¾›ç¨‹åºã€‚ é¦–å…ˆï¼Œé…ç½®å­˜å‚¨æä¾›ç¨‹åºï¼š var host = new HostBuilder() .UseOrleans(siloBuilder => { // Configure Azure Table storage using the name \"profileStore\" siloBuilder.AddAzureTableGrainStorage( name: \"profileStore\", configureOptions: options => { // Use JSON for serializing the state in storage options.UseJson = true; // Configure the storage connection key options.ConnectionString = \"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\"; }); // -- other options }) .Build(); ç°åœ¨ï¼Œå·²ç»ä½¿ç”¨åç§°é…ç½®äº†å­˜å‚¨æä¾›ç¨‹åº â€œ profileStoreâ€ ï¼Œæˆ‘ä»¬å¯ä»¥ä»Grainsè®¿é—®æ­¤æä¾›ç¨‹åºã€‚ æŒä¹…çŠ¶æ€å¯ä»¥é€šè¿‡ä¸¤ç§ä¸»è¦æ–¹å¼æ·»åŠ åˆ°Grainsä¸­ï¼š é€šè¿‡æ³¨å…¥ IPersistentState <TState> è¿›å…¥Grainsçš„æ„é€ å‡½æ•° é€šè¿‡ç»§æ‰¿ Grain<TState> æ¨èçš„æ·»åŠ Grainså­˜å‚¨æ–¹å¼çš„æ–¹æ³•æ˜¯é€šè¿‡æ³¨å…¥ IPersistentState<TState> å¹¶å…³è” [PersistentState(\"stateName\",\" providerName\")] å±æ€§åˆ°Grainsçš„æ„é€ å‡½æ•°ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ GrainsTState> ï¼Œ è§ä¸‹æ–‡ ã€‚ä»æ”¯æŒæ­¤åŠŸèƒ½ï¼Œä½†è¢«è®¤ä¸ºæ˜¯æ—§ç‰ˆã€‚ å£°æ˜ä¸€ä¸ªç±»æ¥ä¿æŒæˆ‘ä»¬çš„GrainsçŠ¶æ€ï¼š [Serializable] public class ProfileState { public string Name { get; set; } public Date DateOfBirth } æ³¨å…¥ IPersistentState <é…ç½®æ–‡ä»¶çŠ¶æ€> åˆ°Grainsçš„æ„é€ å‡½æ•°ä¸­ï¼š public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; public UserGrain([PersistentState(\"profile\", \"profileStore\")] IPersistentState<ProfileState> profile) { _profile = profile; } } æ³¨æ„ï¼šé…ç½®æ–‡ä»¶çŠ¶æ€åœ¨æ³¨å…¥åˆ°æ„é€ å‡½æ•°ä¸­æ—¶ä¸ä¼šè¢«åŠ è½½ï¼Œå› æ­¤é‚£æ—¶è®¿é—®å®ƒæ˜¯æ— æ•ˆçš„ã€‚è¯¥çŠ¶æ€å°†åœ¨ OnActivateAsync è°ƒç”¨ã€‚ ç°åœ¨ï¼Œgrainå…·æœ‰æŒä¹…çŠ¶æ€ï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ è¯»å–å’Œå†™å…¥çŠ¶æ€çš„æ–¹æ³•ï¼š public class UserGrain : Grain, IUserGrain { private readonly IPersistentState<ProfileState> _profile; public UserGrain([PersistentState(\"profile\", \"profileStore\")] IPersistentState<ProfileState> profile) { _profile = profile; } public Task<string> GetNameAsync() => Task.FromResult(_profile.State.Name); public async Task SetNameAsync(string name) { _profile.State.Name = name; await _profile.WriteStateAsync(); } } æŒä¹…åŒ–æ“ä½œçš„å¤±è´¥æ¨¡å¼ è¯»å–æ“ä½œçš„å¤±è´¥æ¨¡å¼ å­˜å‚¨æä¾›ç¨‹åºåœ¨åˆå§‹è¯»å–è¯¥ç‰¹å®šGrainçš„çŠ¶æ€æ•°æ®æœŸé—´è¿”å›çš„æ•…éšœå°†å¯¼è‡´Grainçš„æ¿€æ´»æ“ä½œå¤±è´¥;åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°†ä¸è°ƒç”¨è¯¥Grainçš„ OnActivateAsync() ç”Ÿå‘½å‘¨æœŸå›è°ƒæ–¹æ³•ã€‚ å¯¼è‡´æ¿€æ´»è¯¥Grainçš„å¤±è´¥çš„åŸå§‹è¯·æ±‚å°†åƒåœ¨Grainæ¿€æ´»æœŸé—´ä»»ä½•å…¶ä»–æ•…éšœä¸€æ ·è¿”å›ç»™è°ƒç”¨æ–¹ã€‚ å­˜å‚¨æä¾›ç¨‹åºåœ¨è¯»å–ç‰¹å®šGrainsçš„çŠ¶æ€æ•°æ®æ—¶é‡åˆ°å¤±è´¥ï¼Œå°†å¯¼è‡´ ReadStateAsync() ä»»åŠ¡å¤±è´¥ã€‚Grainså¯ä»¥é€‰æ‹©å¤„ç†æˆ–å¿½ç•¥è¯¥æ•…éšœ Task ï¼Œå°±åƒå…¶ä»–ä»»ä½•ä¸œè¥¿ä¸€æ · Task åœ¨Orleansã€‚ ç”±äºç¼ºå°‘/é”™è¯¯çš„å­˜å‚¨æä¾›ç¨‹åºé…ç½®ï¼Œä»»ä½•åœ¨siloså¯åŠ¨æ—¶æ— æ³•åŠ è½½æ¶ˆæ¯çš„å°è¯•éƒ½ä¼šè¿”å›æ°¸ä¹…é”™è¯¯ Orleans.BadProviderConfigException ã€‚ å†™å…¥æ“ä½œçš„å¤±è´¥æ¨¡å¼ å­˜å‚¨æä¾›ç¨‹åºåœ¨å†™å…¥ç‰¹å®šGrainsçš„çŠ¶æ€æ•°æ®æ—¶é‡åˆ°å¤±è´¥ï¼Œå°†å¯¼è‡´ WriteStateAsync() ä»»åŠ¡å¤±è´¥ã€‚é€šå¸¸ï¼Œè¿™å°†æ„å‘³ç€Grainè°ƒç”¨å°†æŠŠé”™è¯¯è¿”å›ç»™å®¢æˆ·ç«¯è°ƒç”¨è€…ï¼Œå‰ææ˜¯ WriteStateAsync() ä»»åŠ¡è¢«æ­£ç¡®åœ°é“¾æ¥åˆ°è¿™ä¸ªGrainæ–¹æ³•æœ€ç»ˆè¿”å›çš„ Task ä¸­ã€‚ä½†æ˜¯ï¼ŒæŸäº›é«˜çº§æ–¹æ¡ˆå¯èƒ½ä¼šç¼–å†™Grainä»£ç æ¥ä¸“é—¨å¤„ç†æ­¤ç±»é”™è¯¯ï¼Œå°±åƒå®ƒä»¬å¯ä»¥å¤„ç†ä»»ä½•å…¶ä»–é”™è¯¯ä¸€æ · Task ã€‚ æ‰§è¡Œé”™è¯¯å¤„ç†/æ¢å¤ä»£ç çš„Grains å¿…é¡» æ•è· WriteStateAsync() ä»»åŠ¡çš„å¼‚å¸¸/é”™è¯¯ï¼Œè€Œä¸é‡æ–°æŠ›å‡ºä»¥è¡¨ç¤ºå®ƒä»¬å·²æˆåŠŸå¤„ç†äº†å†™å…¥é”™è¯¯ã€‚ æ¨èå»ºè®® ä½¿ç”¨JSONåºåˆ—åŒ–æˆ–å…¶ä»–ç‰ˆæœ¬å®¹å¿çš„åºåˆ—åŒ–æ ¼å¼ ä»£ç ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œå‘å±•ï¼Œå¹¶ä¸”é€šå¸¸è¿˜åŒ…æ‹¬å­˜å‚¨ç±»å‹ã€‚ä¸ºäº†é€‚åº”è¿™äº›æ›´æ”¹ï¼Œåº”é…ç½®é€‚å½“çš„åºåˆ—åŒ–æ–¹å¼ã€‚å¯¹äºå¤§å¤šæ•°å­˜å‚¨æä¾›å•†è€Œè¨€ï¼Œ Json é€‰é¡¹æˆ–ç±»ä¼¼é€‰é¡¹å¯ç”¨äºå°†JSONç”¨ä½œåºåˆ—åŒ–æ ¼å¼ã€‚ç¡®ä¿åœ¨å‘å±•æ•°æ®åˆåŒæ—¶ï¼Œå·²ç»å­˜å‚¨çš„æ•°æ®ä»ç„¶å¯ä»¥åŠ è½½ã€‚ ä½¿ç”¨Grain ä¸ºGrainsæŒ‡å®šå­˜å‚¨ æ³¨æ„ï¼š ä½¿ç”¨ grains<T> ä¸ºGrainszæŒ‡å®šå­˜å‚¨è€ƒè™‘ä¸º é—ç•™ åŠŸèƒ½ï¼šåº”ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ·»åŠ Grainså­˜å‚¨ IPersistentState <T> å¦‚å‰æ‰€è¿°ã€‚ ç»§æ‰¿è‡ªçš„Grainsç±» grains<T> (å“ªé‡Œ T æ˜¯éœ€è¦ä¿ç•™çš„ç‰¹å®šäºåº”ç”¨ç¨‹åºçš„çŠ¶æ€æ•°æ®ç±»å‹)ï¼Œå°†ä»æŒ‡å®šå­˜å‚¨ä¸­è‡ªåŠ¨åŠ è½½å…¶çŠ¶æ€ã€‚ æ­¤ç±»Grainsæ ‡æœ‰ [StorageProvider] è¯¥å±æ€§æŒ‡å®šä¸€ä¸ªå­˜å‚¨æä¾›ç¨‹åºçš„å‘½åå®ä¾‹ï¼Œè¯¥å®ä¾‹ç”¨äºè¯»å–/å†™å…¥æ­¤Grainsçš„çŠ¶æ€æ•°æ®ã€‚ [StorageProvider(ProviderName=\"store1\")] public class MyGrain : Grain<MyGrainState>, /*...*/ { /*...*/ } çš„ grains<T> åŸºç±»å®šä¹‰äº†ä»¥ä¸‹æ–¹æ³•ä¾›å­ç±»è°ƒç”¨ï¼š protected virtual Task ReadStateAsync() { /*...*/ } protected virtual Task WriteStateAsync() { /*...*/ } protected virtual Task ClearStateAsync() { /*...*/ } è¿™äº›æ–¹æ³•çš„è¡Œä¸ºå¯¹åº”äº IPersistentState <TState> è¾ƒæ—©å®šä¹‰ã€‚ åˆ›å»ºå­˜å‚¨æä¾›ç¨‹åº çŠ¶æ€æŒä¹…åŒ–APIæœ‰ä¸¤éƒ¨åˆ†ï¼šé€šè¿‡ IPersistentState <T> è¦ä¹ˆ grains<T> ï¼Œ ä»¥åŠä»¥ IGrainStorage ä¸ºä¸­å¿ƒçš„å­˜å‚¨æä¾›ç¨‹åºAPIâ€”â€”å­˜å‚¨æä¾›ç¨‹åºå¿…é¡»å®ç°çš„æ¥å£ã€‚ /// <summary> /// Interface to be implemented for a storage able to read and write Orleans grain state data. /// </summary> public interface IGrainStorage { /// <summary>Read data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">State data object to be populated for this grain.</param> /// <returns>Completion promise for the Read operation on the specified grain.</returns> Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); /// <summary>Write data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">State data object to be written for this grain.</param> /// <returns>Completion promise for the Write operation on the specified grain.</returns> Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); /// <summary>Delete / Clear data function for this storage instance.</summary> /// <param name=\"grainType\">Type of this grain [fully qualified class name]</param> /// <param name=\"grainReference\">Grain reference object for this grain.</param> /// <param name=\"grainState\">Copy of last-known state data object for this grain.</param> /// <returns>Completion promise for the Delete operation on the specified grain.</returns> Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); } é€šè¿‡å®ç°æ­¤æ¥å£æ¥åˆ›å»ºè‡ªå®šä¹‰å­˜å‚¨æä¾›ç¨‹åºï¼Œå¹¶ æ³¨å†Œ è¯¥å®æ–½ã€‚æœ‰å…³ç°æœ‰å­˜å‚¨æä¾›ç¨‹åºå®ç°çš„ç¤ºä¾‹ï¼Œè¯·å‚è§ AzureBlobGrainStorage ã€‚ å­˜å‚¨æä¾›ç¨‹åºè¯­ä¹‰ ç‰¹å®šäºä¸é€æ˜çš„æä¾›è€… Etag å€¼( string ) å¯èƒ½ ç”±å­˜å‚¨æä¾›è€…è®¾ç½®ä¸ºè¯»å–çŠ¶æ€æ—¶å¡«å……çš„GrainsçŠ¶æ€å…ƒæ•°æ®çš„ä¸€éƒ¨åˆ†ã€‚ä¸€äº›æä¾›å•†å¯èƒ½é€‰æ‹©å°†æ­¤ä¿ç•™ä¸º null å¦‚æœä»–ä»¬ä¸ä½¿ç”¨ Etag ã€‚ å½“å­˜å‚¨æä¾›ç¨‹åºæ£€æµ‹åˆ° Etag çº¦æŸè¿å_should_æ—¶ï¼Œä»»ä½•æ‰§è¡Œå†™æ“ä½œçš„å°è¯•éƒ½ä¼šå¯¼è‡´å†™ Task å‡ºç°æ•…éšœï¼Œå¹¶å‡ºç°ç¬æ—¶æŠ›å‡º Orleans.InconsistentStateException å¼‚å¸¸å¹¶å¹¶åŒ…è£…åŸºç¡€å­˜å‚¨å¼‚å¸¸ã€‚ public class InconsistentStateException : OrleansException { public InconsistentStateException( string message, string storedEtag, string currentEtag, Exception storageException) : base(message, storageException) { this.StoredEtag = storedEtag; this.CurrentEtag = currentEtag; } public InconsistentStateException(string storedEtag, string currentEtag, Exception storageException) : this(storageException.Message, storedEtag, currentEtag, storageException) { } /// <summary>The Etag value currently held in persistent storage.</summary> public string StoredEtag { get; private set; } /// <summary>The Etag value currently held in memory, and attempting to be updated.</summary> public string CurrentEtag { get; private set; } } æ¥è‡ªå­˜å‚¨æ“ä½œçš„ä»»ä½•å…¶ä»–å¤±è´¥æ¡ä»¶éƒ½ä¼šå¯¼è‡´è¿”å›çš„ Task è¢«ä¸­æ–­ï¼Œå¹¶å‡ºç°ä¸€ä¸ªå¼‚å¸¸ï¼ŒæŒ‡ç¤ºåº•å±‚å­˜å‚¨é—®é¢˜ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œæ­¤å¼‚å¸¸å¯èƒ½ä¼šè¿”å›ç»™è°ƒç”¨æ–¹ï¼Œåè€…é€šè¿‡åœ¨Grainsä¸Šè°ƒç”¨æ–¹æ³•æ¥è§¦å‘å­˜å‚¨æ“ä½œã€‚é‡è¦çš„æ˜¯è¦è€ƒè™‘è°ƒç”¨è€…æ˜¯å¦å¯ä»¥ååºåˆ—åŒ–æ­¤å¼‚å¸¸ã€‚ä¾‹å¦‚ï¼Œå®¢æˆ·ç«¯å¯èƒ½å°šæœªåŠ è½½åŒ…å«å¼‚å¸¸ç±»å‹çš„ç‰¹å®šæŒä¹…åŒ–åº“ã€‚å› æ­¤ï¼Œå»ºè®®å°†å¼‚å¸¸è½¬æ¢ä¸ºå¯ä»¥ä¼ æ’­å›è°ƒç”¨æ–¹çš„å¼‚å¸¸ã€‚ æ•°æ®æ˜ å°„ å„ä¸ªå­˜å‚¨æä¾›è€…åº”å†³å®šå¦‚ä½•æœ€å¥½åœ°å­˜å‚¨GrainsçŠ¶æ€-blob(å„ç§æ ¼å¼/åºåˆ—åŒ–å½¢å¼)æˆ–æ¯å­—æ®µåˆ—æ˜¯æ˜¾è€Œæ˜“è§çš„é€‰æ‹©ã€‚ æ³¨å†Œå­˜å‚¨æä¾›å•† Orleansè¿è¡Œæ—¶å°†ä»æœåŠ¡æä¾›å•†é‚£é‡Œè§£æå­˜å‚¨æä¾›å•†( IServiceProvider )åˆ›å»ºGrainæ—¶ã€‚è¿è¡Œæ—¶å°†è§£æä¸€ä¸ªå®ä¾‹ IGrainStorage ã€‚å¦‚æœå­˜å‚¨æä¾›è€…å·²å‘½åï¼Œä¾‹å¦‚é€šè¿‡ [PersistentState(stateNameï¼ŒstorageName)] å±æ€§ï¼Œç„¶åæ˜¯çš„å‘½åå®ä¾‹ IGrainStorage å°†å¾—åˆ°è§£å†³ã€‚ æ³¨å†Œçš„å‘½åå®ä¾‹ IGrainStorage ï¼Œ ä½¿ç”¨ IServiceCollection.AddSingletonNamedService æ‰©å±•æ–¹æ³•ï¼Œå¯ä»¥å‚è€ƒä»¥ä¸‹ AzureTableGrainStorageæä¾›ç¨‹åº ã€‚"
  },
  "Documentation/grains/grain_persistence/relational_storage.html": {
    "href": "Documentation/grains/grain_persistence/relational_storage.html",
    "title": "ADO.NET Grain Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ADO.NET GrainsæŒä¹…åŒ– Orleansçš„å…³ç³»å­˜å‚¨åç«¯ä»£ç æ˜¯åŸºäºADO.NETåŠŸèƒ½ï¼Œå› æ­¤ä¸æ•°æ®åº“ä¾›åº”å•†æ— å…³ã€‚Orleansæ•°æ®å­˜å‚¨å¸ƒå±€å·²ç»åœ¨è¿è¡Œæ—¶è¡¨ä¸­è§£é‡Šè¿‡äº†ã€‚æŒ‰ç…§ä¸­çš„è¯´æ˜è®¾ç½®è¿æ¥å­—ç¬¦ä¸² Orleansé…ç½®æŒ‡å— . è¦ä½¿Orleansä»£ç åœ¨ç»™å®šçš„å…³ç³»æ•°æ®åº“åç«¯è¿è¡Œï¼Œéœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š é€‚å½“çš„ADO.NETåº“å¿…é¡»åŠ è½½åˆ°è¿›ç¨‹ä¸­ã€‚è¿™åº”è¯¥åƒå¾€å¸¸ä¸€æ ·å®šä¹‰ï¼Œä¾‹å¦‚ æ•°æ®åº“ä¾›åº”å•†å·¥å‚ åº”ç”¨ç¨‹åºé…ç½®ä¸­çš„å…ƒç´ ã€‚ é…ç½®ADO.NETä¸å˜æ€§ Invariant å±æ€§ã€‚ æ•°æ®åº“éœ€è¦å­˜åœ¨å¹¶ä¸ä»£ç å…¼å®¹ã€‚è¿™æ˜¯é€šè¿‡è¿è¡Œç‰¹å®šäºä¾›åº”å•†çš„æ•°æ®åº“åˆ›å»ºè„šæœ¬æ¥å®Œæˆçš„ã€‚æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… ADO.NETé…ç½® . NETGrainå­˜å‚¨æä¾›ç¨‹åºå…è®¸æ‚¨åœ¨å…³ç³»æ•°æ®åº“ä¸­å­˜å‚¨GrainçŠ¶æ€ã€‚å½“å‰æ”¯æŒä»¥ä¸‹æ•°æ®åº“ï¼š SQLServer MySQL/MariaDB PostgreSQL Oracle é¦–å…ˆï¼Œå®‰è£…åŸºæœ¬è½¯ä»¶åŒ…ï¼š Install-Package Microsoft.Orleans.Persistence.AdoNet é˜…è¯» ADO.NETé…ç½® æ–‡ç« è·å–æœ‰å…³é…ç½®æ•°æ®åº“çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç›¸åº”çš„ADO.NETä¸å˜å’Œè®¾ç½®è„šæœ¬ã€‚ ä¸‹é¢æ˜¯å¦‚ä½•é€šè¿‡ ISiloHostBuilder é…ç½®ADO.NETå­˜å‚¨æä¾›å•†: var siloHostBuilder = new SiloHostBuilder() .AddAdoNetGrainStorage(\"OrleansStorage\", options => { options.Invariant = \"<Invariant>\"; options.ConnectionString = \"<ConnectionString>\"; options.UseJsonFormat = true; }); å®é™…ä¸Šï¼Œæ‚¨åªéœ€è¦è®¾ç½®ç‰¹å®šäºæ•°æ®åº“ä¾›åº”å•†çš„è¿æ¥å­—ç¬¦ä¸²å’Œ Invariant (å‚è§ ADO.NETé…ç½® )æ ‡è¯†ä¾›åº”å•†ã€‚æ‚¨è¿˜å¯ä»¥é€‰æ‹©ä¿å­˜æ•°æ®çš„æ ¼å¼ï¼Œå¯ä»¥æ˜¯äºŒè¿›åˆ¶(é»˜è®¤)ã€JSONæˆ–XMLã€‚è™½ç„¶äºŒè¿›åˆ¶æ˜¯æœ€ç´§å‡‘çš„é€‰é¡¹ï¼Œä½†å®ƒæ˜¯ä¸é€æ˜çš„ï¼Œæ‚¨å°†æ— æ³•è¯»å–æˆ–å¤„ç†æ•°æ®ã€‚JSONæ˜¯æ¨èçš„é€‰é¡¹ã€‚ æ‚¨å¯ä»¥é€šè¿‡è®¾ç½®ä»¥ä¸‹å±æ€§ AdoNetGrainStorageOptions : /// <summary> /// Options for AdoNetGrainStorage /// </summary> public class AdoNetGrainStorageOptions { /// <summary> /// Connection string for AdoNet storage. /// </summary> [Redact] public string ConnectionString { get; set; } /// <summary> /// Stage of silo lifecycle where storage should be initialized. Storage must be initialized prior to use. /// </summary> public int InitStage { get; set; } = DEFAULT_INIT_STAGE; /// <summary> /// Default init stage in silo lifecycle. /// </summary> public const int DEFAULT_INIT_STAGE = ServiceLifecycleStage.ApplicationServices; /// <summary> /// The default ADO.NET invariant used for storage if none is given. /// </summary> public const string DEFAULT_ADONET_INVARIANT = AdoNetInvariants.InvariantNameSqlServer; /// <summary> /// The invariant name for storage. /// </summary> public string Invariant { get; set; } = DEFAULT_ADONET_INVARIANT; /// <summary> /// Whether storage string payload should be formatted in JSON. /// <remarks>If neither <see cref=\"UseJsonFormat\"/> nor <see cref=\"UseXmlFormat\"/> is set to true, then BinaryFormatSerializer will be configured to format storage string payload.</remarks> /// </summary> public bool UseJsonFormat { get; set; } public bool UseFullAssemblyNames { get; set; } public bool IndentJson { get; set; } public TypeNameHandling? TypeNameHandling { get; set; } public Action<JsonSerializerSettings> ConfigureJsonSerializerSettings { get; set; } /// <summary> /// Whether storage string payload should be formatted in Xml. /// <remarks>If neither <see cref=\"UseJsonFormat\"/> nor <see cref=\"UseXmlFormat\"/> is set to true, then BinaryFormatSerializer will be configured to format storage string payload.</remarks> /// </summary> public bool UseXmlFormat { get; set; } } è¿™ä¸ªADO.NETpersistenceå…·æœ‰ç‰ˆæœ¬æ•°æ®å’Œä½¿ç”¨ä»»æ„åº”ç”¨ç¨‹åºè§„åˆ™å’Œæµå®šä¹‰ä»»æ„(å)åºåˆ—åŒ–ç¨‹åºçš„åŠŸèƒ½ï¼Œä½†ç›®å‰è¿˜æ²¡æœ‰å°†å®ƒä»¬å…¬å¼€ç»™åº”ç”¨ç¨‹åºä»£ç çš„æ–¹æ³•ã€‚ ADO.NETæŒä¹…åŒ–åŸç† åŸåˆ™ADO.NETæ”¯æŒçš„æŒä¹…åŒ–å­˜å‚¨åŒ…æ‹¬ï¼š åœ¨æ•°æ®ã€æ•°æ®æ ¼å¼å’Œä»£ç ä¸æ–­å‘å±•çš„åŒæ—¶ï¼Œä¿æŒä¸šåŠ¡å…³é”®æ•°æ®çš„å®‰å…¨æ€§ã€‚ åˆ©ç”¨ç‰¹å®šäºä¾›åº”å•†å’Œå­˜å‚¨çš„åŠŸèƒ½ã€‚ å®é™…ä¸Šï¼Œè¿™æ„å‘³ç€è¦åšæŒADO.NETä¸­çš„å®ç°ç›®æ ‡å’Œä¸€äº›æ·»åŠ çš„å®ç°é€»è¾‘ADO.NETå…è®¸æ”¹å˜å­˜å‚¨å™¨ä¸­æ•°æ®å½¢çŠ¶çš„ç‰¹å®šå­˜å‚¨æä¾›ç¨‹åºã€‚ é™¤äº†é€šå¸¸çš„å­˜å‚¨æä¾›ç¨‹åºåŠŸèƒ½ä¹‹å¤–ADO.NETæä¾›ç¨‹åºçš„å†…ç½®åŠŸèƒ½ åœ¨å¾€è¿”çŠ¶æ€ä¸‹ï¼Œå°†å­˜å‚¨æ•°æ®æ ¼å¼ä»ä¸€ç§æ ¼å¼æ›´æ”¹ä¸ºå¦ä¸€ç§æ ¼å¼(ä¾‹å¦‚ä»JSONæ›´æ”¹ä¸ºäºŒè¿›åˆ¶)ã€‚ ä»¥ä»»æ„æ–¹å¼å¡‘é€ è¦ä¿å­˜æˆ–ä»å­˜å‚¨å™¨ä¸­è¯»å–çš„ç±»å‹ã€‚è¿™æœ‰åŠ©äºæ”¹è¿›ç‰ˆæœ¬çŠ¶æ€ã€‚ ä»æ•°æ®åº“ä¸­æµå‡ºæ•°æ®ã€‚ ä¸¤è€…å…¼è€Œæœ‰ä¹‹ 1 å’Œ 2 å¯ä»¥åº”ç”¨äºä»»æ„å†³ç­–å‚æ•°ï¼Œä¾‹å¦‚ grains id , grains type , payload data . è¿™ç§æƒ…å†µçš„å‘ç”Ÿæ˜¯ä¸ºäº†é€‰æ‹©ä¸€ç§æ ¼å¼ï¼Œä¾‹å¦‚ã€‚ ç®€å•äºŒè¿›åˆ¶ç¼–ç (SBE) å’Œå·¥å…· IStorageDeserializer å’Œ IStorageSerializer . å†…ç½®åºåˆ—åŒ–ç¨‹åºæ˜¯ä½¿ç”¨æ­¤æ–¹æ³•ç”Ÿæˆçš„ã€‚è¿™ä¸ª OrleanStorageDefault(å)åºåˆ—åŒ–ç¨‹åº å¯ä»¥ä½œä¸ºå¦‚ä½•å®ç°å…¶ä»–æ ¼å¼çš„ç¤ºä¾‹ã€‚ å®ç°åºåˆ—åŒ–ç¨‹åºåï¼Œéœ€è¦å°†å®ƒä»¬æ·»åŠ åˆ° StorageSerializationPicker ä¸­çš„å±æ€§ AdoNetGrainStorage . è¿™æ˜¯ä¸€ä¸ª IStorageSerializationPicker . é»˜è®¤æƒ…å†µä¸‹ StorageSerializationPicker å°†è¢«ä½¿ç”¨ã€‚æ›´æ”¹æ•°æ®å­˜å‚¨æ ¼å¼æˆ–ä½¿ç”¨åºåˆ—åŒ–ç¨‹åºçš„ç¤ºä¾‹å¯ä»¥åœ¨ å…³ç³»å­˜å‚¨æµ‹è¯• . ç›®å‰è¿˜æ²¡æœ‰æ–¹æ³•å°†å…¶å…¬å¼€ç»™Orleansåº”ç”¨ç¨‹åºä½¿ç”¨ï¼Œå› ä¸ºæ²¡æœ‰æ–¹æ³•è®¿é—®æ‰€åˆ›å»ºçš„æ¡†æ¶ AdoNetGrainStorage . è®¾è®¡ç›®æ ‡ 1. å…è®¸ä½¿ç”¨ä»»ä½•å…·æœ‰ADO.NETä¾›åº”å•† è¿™åº”è¯¥åŒ…æ‹¬.NETå¯ç”¨çš„æœ€å¹¿æ³›çš„åç«¯é›†ï¼Œè¿™æ˜¯æœ¬åœ°å®‰è£…çš„ä¸€ä¸ªå› ç´ ã€‚ä¸€äº›æä¾›å•†åˆ—åœ¨ ADO.NETæ•°æ®æä¾›ç¨‹åºMSDNé¡µ ï¼Œä½†ä¸ºäº†è¯´æ˜ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„éƒ½åˆ—å‡ºæ¥äº†ï¼Œæ¯”å¦‚ Teradata . 2. å³ä½¿åœ¨éƒ¨ç½²æ­£åœ¨è¿è¡Œæ—¶ï¼Œä¹Ÿè¦ä¿æŒé€‚å½“åœ°ä¼˜åŒ–æŸ¥è¯¢å’Œæ•°æ®åº“ç»“æ„çš„æ½œåŠ› åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒæœåŠ¡å™¨å’Œæ•°æ®åº“ç”±ä¸å®¢æˆ·ç«¯æœ‰åˆåŒå…³ç³»çš„ç¬¬ä¸‰æ–¹æ‰˜ç®¡ã€‚ç”±äºè™šæ‹ŸåŒ–ç¯å¢ƒçš„ä¸å¯é¢„è§æ€§å’Œä¸å¯é¢„è§æ€§ç­‰å› ç´ ï¼Œè™šæ‹ŸåŒ–ç¯å¢ƒä¸‹çš„ä¸»æœºæ€§èƒ½æ˜¯ä¸å¯é¢„è§çš„ã€‚å¯èƒ½æ— æ³•æ›´æ”¹å’Œé‡æ–°éƒ¨ç½²OrleansäºŒè¿›åˆ¶æ–‡ä»¶(åˆåŒåŸå› )ç”šè‡³åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä½†é€šå¸¸å¯ä»¥è°ƒæ•´æ•°æ®åº“éƒ¨ç½²ã€‚æ”¹å˜ æ ‡å‡†éƒ¨ä»¶ ï¼Œä¾‹å¦‚OrleansäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œéœ€è¦ä¸€ä¸ªæ›´é•¿çš„è¿‡ç¨‹æ¥ç¡®å®šåœ¨ç»™å®šçš„æƒ…å†µä¸‹å¯ä»¥æä¾›ä»€ä¹ˆã€‚ 3. å…è®¸ä½¿ç”¨ä¾›åº”å•†å’Œç‰ˆæœ¬ç‰¹å®šçš„èƒ½åŠ› ä¾›åº”å•†åœ¨ä»–ä»¬çš„äº§å“ä¸­å®ç°äº†ä¸åŒçš„æ‰©å±•å’Œç‰¹æ€§ã€‚å½“è¿™äº›åŠŸèƒ½å¯ç”¨æ—¶ï¼Œä½¿ç”¨å®ƒä»¬æ˜¯æ˜æ™ºçš„ã€‚è¿™äº›åŠŸèƒ½åŒ…æ‹¬ æœ¬åœ°UPSERT æˆ– ç®¡é“æ•°æ®åº“ åœ¨PostgreSQLä¸­ï¼Œ å¤šåŸº æˆ– æœ¬æœºç¼–è¯‘çš„è¡¨å’Œå­˜å‚¨è¿‡ç¨‹ åœ¨SQL Serverä¸­â€“ä»¥åŠæ— æ•°å…¶ä»–åŠŸèƒ½ã€‚ 4. ä½¿ç¡¬ä»¶èµ„æºä¼˜åŒ–æˆä¸ºå¯èƒ½ åœ¨è®¾è®¡åº”ç”¨ç¨‹åºæ—¶ï¼Œé€šå¸¸å¯ä»¥é¢„æµ‹å“ªäº›æ•°æ®éœ€è¦æ¯”å…¶ä»–æ•°æ®æ›´å¿«åœ°æ’å…¥ï¼Œå“ªäº›æ•°æ®æ›´æœ‰å¯èƒ½è¢«æ”¾å…¥ å†·åº“ å“ªç§æ›´ä¾¿å®œ(ä¾‹å¦‚åœ¨SSDå’ŒHDDä¹‹é—´æ‹†åˆ†æ•°æ®)ã€‚ä¾‹å¦‚ï¼Œè¿›ä¸€æ­¥çš„è€ƒè™‘å› ç´ æ˜¯æŸäº›æ•°æ®çš„ç‰©ç†ä½ç½®å¯èƒ½æ›´æ˜‚è´µ(ä¾‹å¦‚SSD RAID viz HDD RAID)ã€æ›´å®‰å…¨æˆ–ä½¿ç”¨ä¸€äº›å…¶ä»–å†³ç­–å±æ€§ã€‚ä¸â€¦æœ‰å…³ ç¬¬ä¸‰ç‚¹ã€‚ æœ‰äº›æ•°æ®åº“æä¾›ç‰¹æ®Šçš„åˆ†åŒºæ–¹æ¡ˆï¼Œå¦‚sqlserver åˆ†åŒºè¡¨å’Œç´¢å¼• . è¿™ä¸€åŸåˆ™ä¹Ÿé€‚ç”¨äºæ•´ä¸ªåº”ç”¨ç¨‹åºç”Ÿå‘½å‘¨æœŸã€‚è€ƒè™‘åˆ°Orleansæœ¬èº«çš„ä¸€ä¸ªåŸåˆ™æ˜¯é«˜å¯ç”¨æ€§ç³»ç»Ÿï¼Œå› æ­¤åº”è¯¥å¯ä»¥åœ¨ä¸ä¸­æ–­Orleanséƒ¨ç½²çš„æƒ…å†µä¸‹è°ƒæ•´å­˜å‚¨ç³»ç»Ÿï¼Œæˆ–è€…å¯ä»¥æ ¹æ®æ•°æ®å’Œå…¶ä»–åº”ç”¨ç¨‹åºå‚æ•°è°ƒæ•´æŸ¥è¯¢ã€‚å˜åŒ–çš„ä¸€ä¸ªä¾‹å­æ˜¯å¸ƒè±æ©Â·å“ˆé‡Œçš„ åšå®¢æ–‡ç«  : å½“è¡¨å¾ˆå°æ—¶ï¼ŒæŸ¥è¯¢è®¡åˆ’æ˜¯ä»€ä¹ˆå‡ ä¹æ— å…³ç´§è¦ã€‚å½“å®ƒæ˜¯ä¸­ç­‰çš„æ—¶å€™ï¼Œä¸€ä¸ªå¥½çš„æŸ¥è¯¢è®¡åˆ’æ˜¯å¥½çš„ã€‚å½“å®ƒæ˜¯å·¨å¤§çš„(æ•°ä»¥ç™¾ä¸‡è®¡æˆ–æ•°åäº¿è¡Œ)æ—¶ï¼ŒæŸ¥è¯¢è®¡åˆ’ä¸­çš„å¾®å°å˜åŒ–å¯èƒ½ä¼šæ€æ­»æ‚¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯¹æ•æ„ŸæŸ¥è¯¢è¿›è¡Œäº†å¤§é‡æç¤ºã€‚ 5. å¯¹ç»„ç»‡ä¸­ä½¿ç”¨çš„å·¥å…·ã€åº“æˆ–éƒ¨ç½²è¿‡ç¨‹æ²¡æœ‰ä»»ä½•å‡è®¾ è®¸å¤šç»„ç»‡éƒ½ç†Ÿæ‚‰æŸç§æ•°æ®åº“å·¥å…·ï¼Œä¾‹å¦‚ Dacpac æˆ– Red Gate . éƒ¨ç½²æ•°æ®åº“å¯èƒ½éœ€è¦æƒé™æˆ–äººå‘˜(ä¾‹å¦‚DBAè§’è‰²ä¸­çš„äººå‘˜)æ¥æ‰§è¡Œæ­¤æ“ä½œã€‚é€šå¸¸è¿™æ„å‘³ç€è¿˜è¦æœ‰ç›®æ ‡æ•°æ®åº“å¸ƒå±€å’Œåº”ç”¨ç¨‹åºå°†å¯¹æ•°æ®åº“äº§ç”Ÿçš„æŸ¥è¯¢çš„ç²—ç•¥è‰å›¾æ¥ä¼°è®¡è´Ÿè½½ã€‚å¯èƒ½æœ‰ä¸€äº›æµç¨‹ï¼Œå¯èƒ½å—è¡Œä¸šæ ‡å‡†çš„å½±å“ï¼Œå¼ºåˆ¶è¦æ±‚åŸºäºè„šæœ¬çš„éƒ¨ç½²ã€‚å°†æŸ¥è¯¢å’Œæ•°æ®åº“ç»“æ„æ”¾åœ¨ä¸€ä¸ªå¤–éƒ¨è„šæœ¬ä¸­ä½¿è¿™æˆä¸ºå¯èƒ½ã€‚ 6. ä½¿ç”¨æ¥å£åŠŸèƒ½æ‰€éœ€çš„æœ€å°é›†æ¥åŠ è½½ADO.NETåº“å’ŒåŠŸèƒ½ è¿™æ˜¯æ—¢å¿«åˆè¾ƒå°‘æš´éœ²ADO.NETåº“çš„å®ç°ç»†èŠ‚ã€‚ 7. ä½¿è®¾è®¡å¯å…±äº« å½“å®ƒæœ‰æ„ä¹‰æ—¶ï¼Œä¾‹å¦‚åœ¨å…³ç³»å­˜å‚¨æä¾›ç¨‹åºä¸­ï¼Œä½¿è®¾è®¡æ˜“äºå…±äº«ã€‚è¿™æ„å‘³ç€æ²¡æœ‰ä¾èµ–äºæ•°æ®åº“çš„æ•°æ®(ä¾‹å¦‚ã€‚ Identity )åŸºæœ¬ä¸Šï¼Œè¿™æ„å‘³ç€åŒºåˆ†è¡Œæ•°æ®çš„ä¿¡æ¯åº”è¯¥åªå»ºç«‹åœ¨æ•°æ®å’Œå®é™…å‚æ•°çš„åŸºç¡€ä¸Šã€‚ 8. ä½¿è®¾è®¡æ˜“äºæµ‹è¯• ç†æƒ³æƒ…å†µä¸‹ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„åç«¯åº”è¯¥åƒç¿»è¯‘ä¸€ä¸ªéƒ¨ç½²è„šæœ¬å’Œå‘æµ‹è¯•æ·»åŠ ä¸€ä¸ªæ–°çš„è¿æ¥å­—ç¬¦ä¸²ä¸€æ ·ç®€å•ï¼Œå‡è®¾é»˜è®¤å‚æ•°ï¼Œæ£€æŸ¥æ˜¯å¦å®‰è£…äº†ç»™å®šçš„æ•°æ®åº“ï¼Œç„¶åå¯¹å…¶è¿è¡Œæµ‹è¯•ã€‚ 9. è€ƒè™‘åˆ°å‰é¢å‡ ç‚¹ï¼Œä½¿æ–°åç«¯çš„ç§»æ¤è„šæœ¬å’Œä¿®æ”¹å·²éƒ¨ç½²çš„åç«¯è„šæœ¬å°½å¯èƒ½é€æ˜ ç›®æ ‡çš„å®ç° Orleans frameworkä¸äº†è§£ç‰¹å®šäºéƒ¨ç½²çš„ç¡¬ä»¶(åœ¨ä¸»åŠ¨éƒ¨ç½²æœŸé—´å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–)ã€éƒ¨ç½²ç”Ÿå‘½å‘¨æœŸä¸­çš„æ•°æ®æ›´æ”¹ä»¥åŠæŸäº›ç‰¹å®šäºä¾›åº”å•†çš„ç‰¹æ€§ä»…åœ¨æŸäº›æƒ…å†µä¸‹å¯ç”¨ã€‚å› æ­¤ï¼Œå…³ç³»æ•°æ®åº“å’ŒOrleansä¹‹é—´çš„æ¥å£åº”è¯¥éµå¾ªä¸€ç»„æœ€å°çš„æŠ½è±¡å’Œè§„åˆ™ï¼Œä»¥æ»¡è¶³ç›®æ ‡ï¼Œä½†ä¹Ÿè¦ä½¿å…¶å¥å£®ï¼Œé˜²æ­¢è¯¯ç”¨ï¼Œå¹¶åœ¨éœ€è¦æ—¶æ˜“äºæµ‹è¯•ã€‚è¿è¡Œæ—¶è¡¨ã€é›†ç¾¤ç®¡ç†å’Œå…·ä½“çš„ æˆå‘˜åè®®å®ç° . æ­¤å¤–ï¼ŒSQL Serverå®ç°åŒ…å«SQL Serverç‰ˆæœ¬ç‰¹å®šçš„è°ƒæ•´ã€‚æ•°æ®åº“ä¸Orleansçš„æ¥å£åˆåŒå®šä¹‰å¦‚ä¸‹ï¼š æ€»çš„æƒ³æ³•æ˜¯é€šè¿‡Orleansç‰¹å®šçš„æŸ¥è¯¢æ¥è¯»å†™æ•°æ®ã€‚Orleansåœ¨è¯»å–æ—¶æ“ä½œåˆ—åå’Œç±»å‹ï¼Œåœ¨å†™å…¥æ—¶æ“ä½œå‚æ•°åç§°å’Œç±»å‹ã€‚ å®æ–½ å¿…é¡» ä¿ç•™è¾“å…¥å’Œè¾“å‡ºåç§°å’Œç±»å‹ã€‚Orleansä½¿ç”¨è¿™äº›å‚æ•°æŒ‰åç§°å’Œç±»å‹è¯»å–æŸ¥è¯¢ç»“æœã€‚åªè¦ä¿æŒæ¥å£å¥‘çº¦ï¼Œå°±å…è®¸è¿›è¡Œç‰¹å®šäºä¾›åº”å•†å’Œéƒ¨ç½²çš„è°ƒä¼˜ï¼Œå¹¶é¼“åŠ±è´¡çŒ®ã€‚ è·¨ä¾›åº”å•†ç‰¹å®šè„šæœ¬çš„å®ç° åº”è¯¥ ä¿ç•™çº¦æŸåç§°ã€‚è¿™é€šè¿‡è·¨å…·ä½“å®ç°çš„ç»Ÿä¸€å‘½åç®€åŒ–äº†æ•…éšœæ’é™¤ã€‚ ç‰ˆæœ¬ â€“æˆ– ETag åº”ç”¨ç¨‹åºä»£ç ä¸­â€“å› ä¸ºOrleansä»£è¡¨äº†ä¸€ä¸ªç‹¬ç‰¹çš„ç‰ˆæœ¬ã€‚å®ƒå®é™…å®ç°çš„ç±»å‹å¹¶ä¸é‡è¦ï¼Œåªè¦å®ƒä»£è¡¨ä¸€ä¸ªå”¯ä¸€çš„ç‰ˆæœ¬ã€‚åœ¨å®ç°ä¸­ï¼ŒOrleansä»£ç éœ€è¦ä¸€ä¸ªæœ‰ç¬¦å·çš„32ä½æ•´æ•°ã€‚ ä¸ºäº†æ˜ç¡®å’Œæ¶ˆé™¤æ­§ä¹‰ï¼ŒOrleanså¸Œæœ›ä¸€äº›æŸ¥è¯¢è¿”å› TRUE as > 0 å€¼æˆ– False as=0 ä»·å€¼è§‚ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå—å½±å“çš„è¡Œæˆ–ç±»ä¼¼çš„è¡Œå¹¶ä¸é‡è¦ã€‚å¦‚æœå¼•å‘é”™è¯¯æˆ–å¼•å‘å¼‚å¸¸ï¼Œåˆ™æŸ¥è¯¢ å¿…é¡» ç¡®ä¿æ•´ä¸ªäº‹åŠ¡è¢«å›æ»šï¼Œå¹¶ä¸”å¯èƒ½è¿”å›FALSEæˆ–ä¼ æ’­å¼‚å¸¸ã€‚ ç›®å‰é™¤äº†ä¸€ä¸ªæŸ¥è¯¢å¤–ï¼Œæ‰€æœ‰æŸ¥è¯¢éƒ½æ˜¯å•è¡Œæ’å…¥æˆ–æ›´æ–°(æ³¨æ„ï¼Œä¸€ä¸ªå¯ä»¥æ›¿æ¢ Update æŸ¥è¯¢ Insert ä»–ä»¬æä¾›äº† Select æŸ¥è¯¢å°†æä¾›æœ€åä¸€æ¬¡å†™å…¥)ç»Ÿè®¡æ’å…¥é™¤å¤–ã€‚ç»Ÿè®¡æ’å…¥ï¼Œå®šä¹‰å¦‚ä¸‹ InsertOrleansStatisticsKey ä½¿ç”¨ä»¥é¢„å®šä¹‰çš„æœ€å¤§å¤§å°æ‰¹é‡å†™å…¥ç»Ÿè®¡ä¿¡æ¯ Union All å¯¹äºé™¤Oracleä¹‹å¤–çš„æ‰€æœ‰æ•°æ®åº“ UNION ALL FROM DUAL æ„é€ è¢«ä½¿ç”¨ã€‚ InsertOrleansStatisticsKey æ˜¯å”¯ä¸€å®šä¹‰ä¸€ç§æ¨¡æ¿å‚æ•°çš„æŸ¥è¯¢ï¼ŒOrleanså°†å…¶ä¹˜ä»¥å…·æœ‰ä¸åŒå€¼çš„å‚æ•°çš„å€æ•°ã€‚ æ•°æ®åº“å¼•æ“æ”¯æŒæ•°æ®åº“ç¼–ç¨‹ï¼Œè¿™ç±»ä¼¼äºåŠ è½½å¯æ‰§è¡Œè„šæœ¬å¹¶è°ƒç”¨å®ƒæ¥æ‰§è¡Œæ•°æ®åº“æ“ä½œçš„æ€æƒ³ã€‚åœ¨ä¼ªä»£ç ä¸­ï¼Œå®ƒå¯ä»¥æè¿°ä¸º const int Param1 = 1; const DateTime Param2 = DateTime.UtcNow; const string queryFromOrleansQueryTableWithSomeKey = \"SELECT column1, column2 FROM <some Orleans table> where column1 = @param1 AND column2 = @param2;\"; TExpected queryResult = SpecificQuery12InOrleans<TExpected>(query, Param1, Param2); è¿™äº›åŸåˆ™ä¹Ÿæ˜¯ åŒ…å«åœ¨æ•°æ®åº“è„šæœ¬ä¸­ . åº”ç”¨å®šåˆ¶è„šæœ¬çš„å‡ ç‚¹æ€è€ƒ æ›´æ”¹ OrleansQuery ä¸­è„šæœ¬çš„ IF ELSE ï¼Œä»¥ä¾¿Grainsçš„æŒä¹…åŒ–ä½¿ç”¨é»˜è®¤å€¼ä¿å­˜æŸäº›çŠ¶æ€ æ’å…¥ ,ä¾‹å¦‚ï¼Œä¸€äº›GrainsçŠ¶æ€ä½¿ç”¨ï¼Œ å†…å­˜ä¼˜åŒ–è¡¨ . è¿™ä¸ª SELECT æŸ¥è¯¢éœ€è¦ç›¸åº”åœ°ä¿®æ”¹ã€‚ è¿™ä¸ªæƒ³æ³• 1 å¯ç”¨äºåˆ©ç”¨å…¶ä»–éƒ¨ç½²æˆ–ç‰¹å®šäºä¾›åº”å•†çš„æ–¹é¢ã€‚ä¾‹å¦‚åœ¨ SSD æˆ– HDD ï¼Œå°†ä¸€äº›æ•°æ®æ”¾åœ¨åŠ å¯†çš„è¡¨ä¸Šï¼Œæˆ–è€…é€šè¿‡sqlserverå°†ç»Ÿè®¡æ•°æ®æ’å…¥Hadoopï¼Œç”šè‡³ é“¾æ¥æœåŠ¡å™¨ . ä¿®æ”¹åçš„è„šæœ¬å¯ä»¥é€šè¿‡è¿è¡ŒOrleansæµ‹è¯•å¥—ä»¶æˆ–ç›´æ¥åœ¨æ•°æ®åº“ä¸­æµ‹è¯•ï¼Œä¾‹å¦‚ï¼Œ SQL Serverå•å…ƒæµ‹è¯•é¡¹ç›® . æ·»åŠ æ–°çš„ADO.NETä¾›åº”å•†æŒ‡å— æ ¹æ® ç›®æ ‡çš„å®ç° ä»¥ä¸Šç« èŠ‚ã€‚ å°†ä¾›åº”å•†ADOä¸å˜åç§°æ·»åŠ åˆ° ADOå˜é‡ ä»¥åŠADO.NETæä¾›ç¨‹åºç‰¹å®šæ•°æ® DbConstantStore . å®ƒä»¬(å¯èƒ½)ç”¨äºæŸäº›æŸ¥è¯¢æ“ä½œã€‚eã€ g.é€‰æ‹©æ­£ç¡®çš„ç»Ÿè®¡æ’å…¥æ¨¡å¼(å³ Union All æœ‰æˆ–æ²¡æœ‰ FROM DUAL ). Orleanså¯¹æ‰€æœ‰ç³»ç»Ÿå•†åº—éƒ½æœ‰å…¨é¢çš„æµ‹è¯•ï¼šä¼šå‘˜èµ„æ ¼ã€æé†’å’Œç»Ÿè®¡æ•°æ®ã€‚ä¸ºæ–°æ•°æ®åº“è„šæœ¬æ·»åŠ æµ‹è¯•æ˜¯é€šè¿‡å¤åˆ¶ç²˜è´´ç°æœ‰æµ‹è¯•ç±»å’Œæ›´æ”¹ADOä¸å˜åæ¥å®Œæˆçš„ã€‚åŒæ ·ï¼Œä» å…³ç³»å­˜å‚¨æµ‹è¯• ä»¥å®šä¹‰ADOInvariantçš„æµ‹è¯•åŠŸèƒ½ã€‚"
  },
  "Documentation/grains/timers_and_reminders.html": {
    "href": "Documentation/grains/timers_and_reminders.html",
    "title": "Timers and Reminders | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è®¡æ—¶å™¨å’Œæé†’ Orleansè¿è¡Œæ—¶æä¾›äº†ä¸¤ç§æœºåˆ¶ï¼Œç§°ä¸ºè®¡æ—¶å™¨å’Œæé†’ï¼Œä½¿å¼€å‘äººå‘˜å¯ä»¥æŒ‡å®šGrainsçš„å‘¨æœŸæ€§è¡Œä¸ºã€‚ è®¡æ—¶å™¨ è®¡æ—¶å™¨è¯´æ˜ è®¡æ—¶å™¨ ç”¨äºåˆ›å»ºä¸éœ€è¦å¤šæ¬¡æ¿€æ´»(Grainså®ä¾‹åŒ–)çš„å‘¨æœŸæ€§Grainsè¡Œä¸ºã€‚å®ƒä¸æ ‡å‡†åŸºæœ¬ä¸Šç›¸åŒã€‚ NET System.Threading.Timer ç±»ã€‚å¦å¤–ï¼Œå®ƒåœ¨è¿è¡Œçš„Grainsæ¿€æ´»ä¸­è¦å—å•çº¿ç¨‹æ‰§è¡Œä¿è¯çš„çº¦æŸã€‚ æ¯æ¬¡æ¿€æ´»å¯èƒ½å…·æœ‰é›¶ä¸ªæˆ–å¤šä¸ªä¸å…¶å…³è”çš„è®¡æ—¶å™¨ã€‚è¿è¡Œæ—¶åœ¨ä¸ä¹‹å…³è”çš„æ¿€æ´»çš„è¿è¡Œæ—¶ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œæ¯ä¸ªè®¡æ—¶å™¨ä¾‹ç¨‹ã€‚ è®¡æ—¶å™¨ä½¿ç”¨ è¦å¯åŠ¨è®¡æ—¶å™¨ï¼Œè¯·ä½¿ç”¨ Grain.RegisterTimer æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ª IDisposable å‚è€ƒï¼š public IDisposable RegisterTimer( Func<object, Task> asyncCallback, // function invoked when the timer ticks object state, // object tp pass to asyncCallback TimeSpan dueTime, // time to wait before the first timer tick TimeSpan period) // the period of the timer é€šè¿‡ä¸¢å¼ƒè®¡æ—¶å™¨æ¥å–æ¶ˆå®ƒã€‚ å¦‚æœå–æ¶ˆæ¿€æ´»æ¿€æ´»æˆ–å‘ç”Ÿæ•…éšœå¹¶ä¸”å…¶siloså´©æºƒï¼Œè®¡æ—¶å™¨å°†åœæ­¢è§¦å‘ã€‚ é‡è¦æ³¨æ„äº‹é¡¹ å¯ç”¨æ¿€æ´»æ”¶é›†åï¼Œè®¡æ—¶å™¨å›è°ƒçš„æ‰§è¡Œä¸ä¼šå°†æ¿€æ´»çŠ¶æ€ä»ç©ºé—²æ›´æ”¹ä¸ºä½¿ç”¨ä¸­ã€‚è¿™æ„å‘³ç€æ— æ³•ä½¿ç”¨è®¡æ—¶å™¨æ¥æ¨è¿Ÿå…¶ä»–æƒ…å†µä¸‹ç©ºé—²æ¿€æ´»çš„å–æ¶ˆæ¿€æ´»ã€‚ æœŸé—´è¿‡å»äº† Grain.RegisterTimer æ˜¯ä»ä»»åŠ¡è¿”å›çš„é‚£ä¸€åˆ»èµ·ç»è¿‡çš„æ—¶é—´ asyncCallback è§£å†³åˆ°ä¸‹ä¸€æ¬¡è°ƒç”¨ asyncCallback åº”è¯¥å‘ç”Ÿã€‚è¿™ä¸ä»…ä½¿å¾—æ— æ³•è¿ç»­è°ƒç”¨ asyncCallback é‡å ä½†ä¹Ÿä½¿æ—¶é—´é•¿ asyncCallback å®Œæˆéœ€è¦å½±å“çš„é¢‘ç‡ asyncCallback è¢«è°ƒç”¨ã€‚è¿™ä¸ System.Threading.Timer ã€‚ æ¯æ¬¡è°ƒç”¨ asyncCallback å°†åœ¨å•ç‹¬çš„å›åˆä¸Šä¼ é€’ç»™æ¿€æ´»ï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šä¸åŒä¸€æ¿€æ´»ä¸­çš„å…¶ä»–å›åˆåŒæ—¶è¿è¡Œã€‚è¯·æ³¨æ„ï¼Œ asyncCallback è°ƒç”¨ä¸ä½œä¸ºæ¶ˆæ¯ä¼ é€’ï¼Œå› æ­¤ä¸å—æ¶ˆæ¯äº¤ç»‡è¯­ä¹‰çš„çº¦æŸã€‚è¿™æ„å‘³ç€ asyncCallback ç›¸å¯¹äºä¼ é€’ç»™è¯¥Grainsçš„å…¶ä»–æ¶ˆæ¯ï¼Œåº”è¢«è§†ä¸ºè¡¨ç°ä¸ºåœ¨ReentrantGrainsä¸Šè¿è¡Œã€‚ æé†’äº‹é¡¹ æé†’è¯´æ˜ æé†’ä¸è®¡æ—¶å™¨ç±»ä¼¼ï¼Œä½†æœ‰ä¸€äº›é‡è¦åŒºåˆ«ï¼š æé†’æ˜¯æŒä¹…åŒ–çš„ï¼Œé™¤éæ˜ç¡®å–æ¶ˆï¼Œå¦åˆ™æé†’å°†åœ¨å‡ ä¹æ‰€æœ‰æƒ…å†µä¸‹(åŒ…æ‹¬éƒ¨åˆ†æˆ–å®Œå…¨é‡å¯ç¾¤é›†)ç»§ç»­è§¦å‘ã€‚ æé†’â€œå®šä¹‰â€è¢«å†™å…¥å­˜å‚¨ã€‚ä½†æ˜¯ï¼Œä¸æ˜¯æ¯ä¸ªç‰¹å®šçš„äº‹ä»¶åŠå…¶ç‰¹å®šçš„æ—¶é—´ã€‚è¿™æ ·åšçš„å‰¯ä½œç”¨æ˜¯ï¼Œå¦‚æœåœ¨æŸä¸ªç‰¹å®šçš„æé†’æ»´ç­”å£°æ—¶ç¾¤é›†å®Œå…¨å´©æºƒï¼Œåˆ™å®ƒå°†ä¸¢å¤±ï¼Œå¹¶ä¸”ä»…ä¼šå‘ç”Ÿæé†’çš„ä¸‹ä¸€ä¸ªæ»´ç­”å£°ã€‚ æé†’ä¸Grainsç›¸å…³è”ï¼Œè€Œä¸æ˜¯ä»»ä½•ç‰¹å®šçš„æ¿€æ´»ã€‚ å¦‚æœæŸä¸ªGrainsæ²¡æœ‰ä¸ä¹‹å…³è”çš„æ¿€æ´»å¹¶ä¸”æœ‰æç¤ºéŸ³ï¼Œåˆ™å°†åˆ›å»ºä¸€ä¸ªã€‚ä¾‹å¦‚ï¼šå¦‚æœæ¿€æ´»é—²ç½®è€Œè¢«åœç”¨ï¼Œåˆ™ä¸åŒä¸€Grainså…³è”çš„æé†’ä¼šåœ¨ä¸‹æ¬¡å‹¾é€‰æ—¶é‡æ–°æ¿€æ´»Grainsã€‚ æé†’æ˜¯é€šè¿‡æ¶ˆæ¯ä¼ é€’çš„ï¼Œå¹¶ä¸”ä¸å…¶ä»–æ‰€æœ‰grainæ–¹æ³•éƒ½å…·æœ‰ç›¸åŒçš„äº¤ç»‡è¯­ä¹‰ã€‚ æé†’äº‹é¡¹ä¸åº”ç”¨äºé«˜é¢‘è®¡æ—¶å™¨ï¼Œå…¶å‘¨æœŸåº”ä»¥åˆ†é’Ÿï¼Œå°æ—¶æˆ–å¤©ä¸ºå•ä½ã€‚ ç»„æ€ æé†’æ˜¯æŒä¹…çš„ï¼Œä¾èµ–äºå­˜å‚¨æ¥å‘æŒ¥ä½œç”¨ã€‚åœ¨æé†’å­ç³»ç»Ÿèµ·ä½œç”¨ä¹‹å‰ï¼Œæ‚¨å¿…é¡»æŒ‡å®šè¦ä½¿ç”¨çš„å­˜å‚¨æ”¯æŒã€‚è¿™æ˜¯é€šè¿‡ä»¥ä¸‹æ–¹å¼é…ç½®æé†’æä¾›ç¨‹åºä¹‹ä¸€æ¥å®Œæˆçš„ï¼š UseXReminderService æ‰©å±•æ–¹æ³•ï¼Œå…¶ä¸­Xæ˜¯æä¾›è€…çš„åç§°ï¼Œä¾‹å¦‚ï¼Œ UseAzureTableReminderService ã€‚ Azureè¡¨é…ç½®ï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() [...] .UseAzureTableReminderService(options => options.ConnectionString = connectionString) [...] SQLï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; const string invariant = \"YOUR_INVARIANT\"; var silo = new SiloHostBuilder() [...] .UseAdoNetReminderService(options => { options.ConnectionString = connectionString; options.Invariant = invariant; }) [...] å¦‚æœåªå¸Œæœ›ä½¿ç”¨æé†’çš„å ä½ç¬¦å®ç°è€Œä¸éœ€è¦è®¾ç½®Azureå¸æˆ·æˆ–SQLæ•°æ®åº“ï¼Œé‚£ä¹ˆè¿™å°†ä¸ºæ‚¨æä¾›æé†’ç³»ç»Ÿçš„ä»…å¼€å‘å®ç°ï¼š var silo = new SiloHostBuilder() [...] .UseInMemoryReminderService() [...] æé†’ç”¨æ³• ä½¿ç”¨æé†’çš„grainå¿…é¡»å®ç° IRemindable.RecieveReminder æ–¹æ³•ã€‚ Task IRemindable.ReceiveReminder(string reminderName, TickStatus status) { Console.WriteLine(\"Thanks for reminding me-- I almost forgot!\"); return Task.CompletedTask; } è¦å¯åŠ¨æé†’ï¼Œè¯·ä½¿ç”¨ Grain.RegisterOrUpdateReminder æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ª IOrleansReminder ç›®çš„ï¼š protected Task<IOrleansReminder> RegisterOrUpdateReminder(string reminderName, TimeSpan dueTime, TimeSpan period) hinterNameæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¿…é¡»åœ¨ä¸Šä¸‹æ–‡èŒƒå›´å†…å”¯ä¸€åœ°æ ‡è¯†æé†’ã€‚ dueTimeæŒ‡å®šå‘å‡ºç¬¬ä¸€ä¸ªè®¡æ—¶å™¨åˆ»åº¦ä¹‹å‰è¦ç­‰å¾…çš„æ—¶é—´ã€‚ periodæŒ‡å®šè®¡æ—¶å™¨çš„æ—¶é—´ã€‚ ç”±äºæé†’åœ¨ä»»ä½•ä¸€æ¬¡æ¿€æ´»çš„ç”Ÿå‘½å‘¨æœŸä¸­éƒ½å¯ä»¥ä¿ç•™ï¼Œå› æ­¤å¿…é¡»å°†å…¶æ˜ç¡®å–æ¶ˆ(è€Œä¸æ˜¯å¤„ç½®)ã€‚æ‚¨é€šè¿‡è°ƒç”¨å–æ¶ˆæé†’ Grain.UnregisterReminder ï¼š protected Task UnregisterReminder(IOrleansReminder reminder) æé†’æ˜¯è¿”å›çš„å¥æŸ„å¯¹è±¡ Grains.RegisterOrUpdateReminder . å®ä¾‹ IOrleansReminder ä¸èƒ½ä¿è¯åœ¨æ¿€æ´»çš„æœ‰æ•ˆæœŸä¹‹å¤–æœ‰æ•ˆã€‚å¦‚æœå¸Œæœ›ä»¥æŒç»­çš„æ–¹å¼æ ‡è¯†æé†’ï¼Œè¯·ä½¿ç”¨åŒ…å«æé†’åç§°çš„å­—ç¬¦ä¸²ã€‚ å¦‚æœæ‚¨åªæœ‰æé†’çš„åç§°å¹¶éœ€è¦ç›¸åº”çš„å®ä¾‹ IOrleansReminder ï¼Œè®¿é—® Grains.GetReminder æ–¹æ³•ï¼š protected Task<IOrleansReminder> GetReminder(string reminderName) æˆ‘åº”è¯¥ç”¨å“ªä¸€ä¸ªï¼Ÿ æˆ‘ä»¬å»ºè®®æ‚¨åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨è®¡æ—¶å™¨ï¼š å¦‚æœæ¿€æ´»è¢«åœç”¨æˆ–å‘ç”Ÿæ•…éšœï¼Œè®¡æ—¶å™¨åœæ­¢å·¥ä½œå¹¶ä¸é‡è¦(æˆ–æ˜¯å¯å–çš„)ã€‚ è®¡æ—¶å™¨çš„åˆ†è¾¨ç‡å¾ˆå°(ä¾‹å¦‚ï¼Œå¯ä»¥ç”¨ç§’æˆ–åˆ†é’Ÿè¡¨ç¤º)ã€‚ è®¡æ—¶å™¨å›è°ƒå¯ä»¥ä» Grain.OnActivateAsync æˆ–è€…è°ƒç”¨grainæ–¹æ³•æ—¶ã€‚ æˆ‘ä»¬å»ºè®®æ‚¨åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨æé†’ï¼š å½“å‘¨æœŸæ€§è¡Œä¸ºéœ€è¦åœ¨æ¿€æ´»å’Œä»»ä½•å¤±è´¥ä¸­å¹¸å­˜ä¸‹æ¥æ—¶ã€‚ æ‰§è¡Œä¸€äº›ä¸ç»å¸¸å‘ç”Ÿçš„ä»»åŠ¡(ä¾‹å¦‚ï¼Œåœ¨å‡ åˆ†é’Ÿã€å‡ å°æ—¶æˆ–å‡ å¤©å†…å¯ä»¥åˆç†åœ°è¡¨è¾¾)ã€‚ ç»„åˆè®¡æ—¶å™¨å’Œæé†’ ä½ å¯ä»¥è€ƒè™‘ç»“åˆä½¿ç”¨æé†’å’Œè®¡æ—¶å™¨æ¥å®Œæˆä½ çš„ç›®æ ‡ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨éœ€è¦ä¸€ä¸ªåˆ†è¾¨ç‡å¾ˆå°çš„è®¡æ—¶å™¨ï¼Œè€Œè¯¥è®¡æ—¶å™¨éœ€è¦åœ¨æ¿€æ´»æœŸé—´ç»§ç»­å­˜åœ¨ï¼Œåˆ™å¯ä»¥ä½¿ç”¨æ¯äº”åˆ†é’Ÿè¿è¡Œä¸€æ¬¡çš„æé†’ï¼Œè¯¥æé†’çš„ç›®çš„æ˜¯å”¤é†’ä¸€ä¸ªgrainsï¼Œè¯¥grainså°†é‡æ–°å¯åŠ¨å¯èƒ½å› åœç”¨è€Œä¸¢å¤±çš„æœ¬åœ°è®¡æ—¶å™¨ã€‚"
  },
  "Documentation/grains/code_generation.html": {
    "href": "Documentation/grains/code_generation.html",
    "title": "Code Generation | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä»£ç ç”Ÿæˆ orleansè¿è¡Œæ—¶ä½¿ç”¨ç”Ÿæˆçš„ä»£ç ï¼Œä»¥ç¡®ä¿è·¨é›†ç¾¤ä½¿ç”¨çš„ç±»å‹çš„æ­£ç¡®åºåˆ—åŒ–ï¼Œå¹¶ç”Ÿæˆæ ·æ¿æ–‡ä»¶ï¼Œè¯¥æ ·æ¿æ–‡ä»¶æŠ½è±¡å‡ºæ–¹æ³•ä¼ é€ã€å¼‚å¸¸ä¼ æ’­å’Œå…¶ä»–å†…éƒ¨è¿è¡Œæ—¶æ¦‚å¿µçš„å®ç°ç»†èŠ‚ã€‚ å¯ç”¨ä»£ç ç”Ÿæˆ ä»£ç ç”Ÿæˆå¯ä»¥åœ¨é¡¹ç›®ç”Ÿæˆæˆ–åº”ç”¨ç¨‹åºåˆå§‹åŒ–æ—¶æ‰§è¡Œã€‚ åœ¨æ„å»ºæœŸé—´ æ‰§è¡Œä»£ç ç”Ÿæˆçš„é¦–é€‰æ–¹æ³•æ˜¯åœ¨ç”Ÿæˆæ—¶ã€‚å¯ä»¥ä½¿ç”¨ä»¥ä¸‹åŒ…ä¹‹ä¸€å¯ç”¨ç”Ÿæˆæ—¶ä»£ç ç”Ÿæˆï¼š Microsoft.Orleans.OrleansCodeGenerator.Build æ˜¯çš„ã€‚ä½¿ç”¨Roslynç”Ÿæˆä»£ç å¹¶ä½¿ç”¨.NETåå°„è¿›è¡Œåˆ†æçš„åŒ…ã€‚ Microsoft.Orleans.CodeGenerator.MSBuild æ˜¯çš„ã€‚ä¸€ä¸ªæ–°çš„ä»£ç ç”ŸæˆåŒ…ï¼Œå®ƒåˆ©ç”¨roslynè¿›è¡Œä»£ç ç”Ÿæˆå’Œä»£ç åˆ†æã€‚å®ƒä¸åŠ è½½åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå› æ­¤é¿å…äº†ç”±ç›¸äº’å†²çªçš„ä¾èµ–é¡¹ç‰ˆæœ¬å’Œä¸åŒçš„ç›®æ ‡æ¡†æ¶å¼•èµ·çš„é—®é¢˜ã€‚æ–°çš„ä»£ç ç”Ÿæˆå™¨è¿˜æ”¹è¿›äº†å¯¹å¢é‡æ„å»ºçš„æ”¯æŒï¼Œè¿™å°†ç¼©çŸ­æ„å»ºæ—¶é—´ã€‚ è¿™äº›åŒ…ä¸­çš„ä¸€ä¸ªåº”è¯¥å®‰è£…åˆ°æ‰€æœ‰åŒ…å«Grainã€Grainæ¥å£ã€è‡ªå®šä¹‰åºåˆ—åŒ–ç¨‹åºæˆ–åœ¨Grainä¹‹é—´å‘é€çš„ç±»å‹çš„é¡¹ç›®ä¸­ã€‚å®‰è£…åŒ…ä¼šå°†ç›®æ ‡æ’å…¥åˆ°é¡¹ç›®ä¸­ï¼Œè¯¥é¡¹ç›®å°†åœ¨ç”Ÿæˆæ—¶ç”Ÿæˆä»£ç ã€‚ ä¸¤ä¸ªåŒ…( Microsoft.Orleans.CodeGenerator.MSBuild å’Œ Microsoft.Orleans.OrleansCodeGenerator.Build )åªæ”¯æŒCé¡¹ç›®ã€‚ä½¿ç”¨ Microsoft.Orleans.Orleanscodegenerator ä¸‹é¢æè¿°çš„åŒ…ï¼Œæˆ–è€…é€šè¿‡åˆ›å»ºä¸€ä¸ªcé¡¹ç›®ï¼Œè¯¥é¡¹ç›®å¯ä»¥ä½œä¸ºç”¨å…¶ä»–è¯­è¨€ç¼–å†™çš„ç¨‹åºé›†ç”Ÿæˆçš„ä»£ç çš„ç›®æ ‡ã€‚ é€šè¿‡æŒ‡å®š å¥¥å°”å…°æ–¯ç§‘å¾·æ ¼å‹’ åœ¨ç›®æ ‡é¡¹ç›®çš„ é¡¹ç›®æ–‡ä»¶ æ–‡ä»¶ã€‚ä¾‹å¦‚ï¼Œ <orleanscodegenloglevel>è·Ÿè¸ª</orleanscodegenloglevel> æ˜¯çš„ã€‚ åˆå§‹åŒ–æœŸé—´ é€šè¿‡å®‰è£… Microsoft.Orleans.Orleanscodegenerator æ‰“åŒ…å¹¶ä½¿ç”¨ IApplicationPartManager.WithCodeGeneration æ‰©å±•æ–¹æ³•ã€‚ builder.ConfigureApplicationParts( parts => parts .AddApplicationPart(typeof(IRuntimeCodeGenGrain).Assembly) .WithCodeGeneration()); åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ builder å¯èƒ½æ˜¯å…¶ä¸­ä¹‹ä¸€çš„å®ä¾‹ IsiloHostBuilder æˆ– IClientBuilder æ˜¯çš„ã€‚å¯é€‰çš„ ILoggerfactory å®ä¾‹å¯ä»¥ä¼ é€’åˆ° WithCodeGeneration è¦åœ¨ä»£ç ç”ŸæˆæœŸé—´å¯ç”¨æ—¥å¿—è®°å½•ï¼Œä¾‹å¦‚ï¼š ILoggerFactory codeGenLoggerFactory = new LoggerFactory(); codeGenLoggerFactory.AddProvider(new ConsoleLoggerProvider()); builder.ConfigureApplicationParts( parts => parts .AddApplicationPart(typeof(IRuntimeCodeGenGrain).Assembly) .WithCodeGeneration(codeGenLoggerFactory)); å½±å“ä»£ç ç”Ÿæˆ ä¸ºç‰¹å®šç±»å‹ç”Ÿæˆä»£ç  è‡ªåŠ¨ä¸ºgrainæ¥å£ã€grainç±»ã€grainçŠ¶æ€å’Œåœ¨grainæ–¹æ³•ä¸­ä½œä¸ºå‚æ•°ä¼ é€’çš„ç±»å‹ç”Ÿæˆä»£ç ã€‚å¦‚æœç±»å‹ä¸ç¬¦åˆæ­¤æ¡ä»¶ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•è¿›ä¸€æ­¥æŒ‡å¯¼ä»£ç ç”Ÿæˆã€‚ æ·»åŠ  [Serializable] æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨ä¸ºç±»å‹ç”Ÿæˆåºåˆ—åŒ–ç¨‹åºã€‚ æ·»åŠ  [assembly: GenerateSerializer(Type)] æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨å°†è¯¥ç±»å‹è§†ä¸ºå¯åºåˆ—åŒ–çš„ï¼Œå¹¶ä¸”å¦‚æœæ— æ³•ä¸ºè¯¥ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ç¨‹åº(ä¾‹å¦‚ï¼Œå› ä¸ºè¯¥ç±»å‹ä¸å¯è®¿é—®)ï¼Œåˆ™å°†å¯¼è‡´é”™è¯¯ã€‚å¦‚æœå¯ç”¨ä»£ç ç”Ÿæˆï¼Œæ­¤é”™è¯¯å°†åœæ­¢ç”Ÿæˆã€‚æ­¤å±æ€§è¿˜å…è®¸ä»å¦ä¸€ä¸ªç¨‹åºé›†ä¸ºç‰¹å®šç±»å‹ç”Ÿæˆä»£ç ã€‚ [assemblyï¼šknownype(type)] è¿˜æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨åŒ…å«ç‰¹å®šç±»å‹(å¯èƒ½æ¥è‡ªå¼•ç”¨çš„ç¨‹åºé›†)ï¼Œä½†å¦‚æœè¯¥ç±»å‹ä¸å¯è®¿é—®ï¼Œåˆ™ä¸ä¼šå¯¼è‡´å¼‚å¸¸ã€‚ ä¸ºæ‰€æœ‰å­ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ç¨‹åº æ·»åŠ  [KnownBaseType] æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨ä¸ºç»§æ‰¿/å®ç°è¯¥ç±»å‹çš„æ‰€æœ‰ç±»å‹ç”Ÿæˆåºåˆ—åŒ–ä»£ç ã€‚ ä¸ºå…¶ä»–ç¨‹åºé›†ä¸­çš„æ‰€æœ‰ç±»å‹ç”Ÿæˆä»£ç  åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç”Ÿæˆçš„ä»£ç åœ¨ç”Ÿæˆæ—¶ä¸èƒ½åŒ…å«åœ¨ç‰¹å®šç¨‹åºé›†ä¸­ã€‚ä¾‹å¦‚ï¼Œè¿™å¯ä»¥åŒ…æ‹¬ä¸å¼•ç”¨Orleansçš„å…±äº«åº“ã€ç”¨Cä»¥å¤–çš„è¯­è¨€ç¼–å†™çš„ç¨‹åºé›†ä»¥åŠå¼€å‘äººå‘˜æ²¡æœ‰æºä»£ç çš„ç¨‹åºé›†ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä¸ºè¿™äº›ç¨‹åºé›†ç”Ÿæˆçš„ä»£ç å¯ä»¥æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„ç¨‹åºé›†ä¸­ï¼Œè¯¥ç¨‹åºé›†åœ¨åˆå§‹åŒ–æœŸé—´è¢«å¼•ç”¨ã€‚ è¦ä¸ºç¨‹åºé›†å¯ç”¨æ­¤åŠŸèƒ½ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š åˆ›å»ºä¸€ä¸ªCé¡¹ç›®ã€‚ å®‰è£… Microsoft.Orleans.CodeGenerator.MSBuild æˆ–è€… Microsoft.Orleans.OrleansCodeGenerator.Build åŒ…è£¹ã€‚ æ·»åŠ å¯¹ç›®æ ‡ç¨‹åºé›†çš„å¼•ç”¨ã€‚ æ·»åŠ  [assembly: knownAssembly(\"otherAssembly\")] åœ¨Cæ–‡ä»¶çš„é¡¶å±‚ã€‚ è¿™ä¸ª KnownAssemblyAttribute å±æ€§æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨æ£€æŸ¥æŒ‡å®šçš„ç¨‹åºé›†å¹¶ä¸ºå…¶ä¸­çš„ç±»å‹ç”Ÿæˆä»£ç ã€‚è¯¥å±æ€§å¯ä»¥åœ¨é¡¹ç›®ä¸­å¤šæ¬¡ä½¿ç”¨ã€‚ ç„¶åï¼Œå¿…é¡»åœ¨åˆå§‹åŒ–æœŸé—´å°†ç”Ÿæˆçš„ç¨‹åºé›†æ·»åŠ åˆ°å®¢æˆ·ç«¯/silosï¼š builder.ConfigureApplicationParts( parts => parts.AddApplicationPart(\"CodeGenAssembly\")); åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ builder å¯èƒ½æ˜¯å…¶ä¸­ä¹‹ä¸€çš„å®ä¾‹ IsiloHostBuilder æˆ– IClientBuilder æ˜¯çš„ã€‚ KnownAssemblyAttribute å…·æœ‰å¯é€‰å±æ€§ï¼Œ TreatTypesAsSerializable ï¼Œå¯ä»¥è®¾ç½®ä¸º true æŒ‡ç¤ºä»£ç ç”Ÿæˆå™¨å°†ç¨‹åºé›†ä¸­çš„æ‰€æœ‰ç±»å‹æ ‡è®°ä¸ºå¯åºåˆ—åŒ–ã€‚"
  },
  "Documentation/grains/stateless_worker_grains.html": {
    "href": "Documentation/grains/stateless_worker_grains.html",
    "title": "Stateless Worker Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ— çŠ¶æ€å·¥äººGrains é»˜è®¤æƒ…å†µä¸‹ï¼ŒOrleansè¿è¡Œæ—¶åœ¨é›†ç¾¤ä¸­åˆ›å»ºçš„grainä¸è¶…è¿‡ä¸€æ¬¡æ¿€æ´»ã€‚è¿™æ˜¯è™šæ‹Ÿè§’è‰²æ¨¡å‹æœ€ç›´è§‚çš„è¡¨è¾¾æ–¹å¼ï¼Œæ¯ä¸ªGrainå¯¹åº”ä¸€ä¸ªå…·æœ‰å”¯ä¸€ç±»å‹/æ ‡è¯†çš„å®ä½“ã€‚ä½†æ˜¯ï¼Œä¹Ÿæœ‰ä¸€äº›æƒ…å†µä¸‹ï¼Œåº”ç”¨ç¨‹åºéœ€è¦æ‰§è¡Œä¸ç³»ç»Ÿä¸­ç‰¹å®šå®ä½“æ— å…³çš„åŠŸèƒ½æ€§æ— çŠ¶æ€æ“ä½œã€‚ä¾‹å¦‚ï¼Œå¦‚æœå®¢æˆ·ç«¯å‘é€çš„è¯·æ±‚å¸¦æœ‰å‹ç¼©çš„æœ‰æ•ˆè´Ÿè½½ï¼Œè€Œè¿™äº›è´Ÿè½½éœ€è¦åœ¨å°†å®ƒä»¬è·¯ç”±åˆ°ç›®æ ‡Grainè¿›è¡Œå¤„ç†ä¹‹å‰è¿›è¡Œè§£å‹ç¼©ï¼Œé‚£ä¹ˆè¿™ç§è§£å‹ç¼©/è·¯ç”±é€»è¾‘å°±ä¸ä¼šç»‘å®šåˆ°åº”ç”¨ç¨‹åºä¸­çš„ç‰¹å®šå®ä½“ï¼Œå¹¶ä¸”å¯ä»¥å¾ˆå®¹æ˜“åœ°è¿›è¡Œæ‰©å±•ã€‚ å½“ [æ— çŠ¶æ€ Worker] å±æ€§åº”ç”¨äºgrainç±»ï¼Œå®ƒå‘Orleansè¿è¡Œæ—¶æŒ‡ç¤ºè¯¥ç±»çš„grainsåº”è¢«è§†ä¸º æ— çŠ¶æ€ Worker Grainsã€‚ æ— çŠ¶æ€ Worker grainså…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼Œä½¿å¾—å®ƒä»¬çš„æ‰§è¡Œä¸æ™®é€šgrainsç±»çš„æ‰§è¡Œéå¸¸ä¸åŒã€‚ Orleansè¿è¡Œæ—¶å¯ä»¥å¹¶ä¸”å°†åœ¨é›†ç¾¤çš„ä¸åŒsilosä¸Šåˆ›å»ºå¤šä¸ªæ— çŠ¶æ€å·¥ä½œçº¿ç¨‹çš„æ¿€æ´»ã€‚ å¯¹æ— çŠ¶æ€å·¥ä½œGrainçš„è¯·æ±‚æ€»æ˜¯åœ¨æœ¬åœ°æ‰§è¡Œï¼Œå³åœ¨å‘å‡ºè¯·æ±‚çš„åŒä¸€ä¸ªsilosä¸Šæ‰§è¡Œï¼Œæˆ–è€…ç”±silosä¸Šè¿è¡Œçš„Grainå‘å‡ºï¼Œæˆ–è€…ç”±silosçš„å®¢æˆ·ç«¯ç½‘å…³æ¥æ”¶ã€‚å› æ­¤ï¼Œä»å…¶ä»–Grainæˆ–å®¢æˆ·ç«¯ç½‘å…³è°ƒç”¨æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹ä¸ä¼šå¼•å‘è¿œç¨‹æ¶ˆæ¯ã€‚ å¦‚æœå·²ç»å­˜åœ¨çš„å·¥ä½œçº¿ç¨‹ç¹å¿™ï¼ŒOrleansè¿è¡Œæ—¶ä¼šè‡ªåŠ¨åˆ›å»ºæ— çŠ¶æ€å·¥ä½œçº¿ç¨‹çš„é¢å¤–æ¿€æ´»ã€‚è¿è¡Œæ—¶ä¸ºæ¯ä¸ªsilosåˆ›å»ºçš„æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹çš„æœ€å¤§æ¿€æ´»æ•°é»˜è®¤ç”±è®¡ç®—æœºä¸Šçš„CPUå†…æ ¸æ•°é™åˆ¶ï¼Œé™¤éå¯é€‰çš„ maxLocalWorkers äº‰è®ºã€‚ ç”±äº2å’Œ3ï¼Œæ— çŠ¶æ€çš„Worker-grainæ¿€æ´»ä¸èƒ½å•ç‹¬å¯»å€ã€‚å¯¹æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹Grainçš„ä¸¤ä¸ªåç»­è¯·æ±‚å¯ä»¥é€šè¿‡å¯¹å…¶è¿›è¡Œä¸åŒçš„æ¿€æ´»æ¥å¤„ç†ã€‚ æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹æä¾›äº†ä¸€ç§ç›´æ¥çš„æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªè‡ªåŠ¨ç®¡ç†çš„grainæ¿€æ´»æ± ï¼Œè¯¥æ± æ ¹æ®å®é™…è´Ÿè½½è‡ªåŠ¨ä¼¸ç¼©ã€‚è¿è¡Œæ—¶æ€»æ˜¯ä»¥ç›¸åŒçš„é¡ºåºæ‰«æå¯ç”¨çš„æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹Grainæ¿€æ´»ã€‚å› æ­¤ï¼Œå®ƒæ€»æ˜¯å°†è¯·æ±‚å‘é€åˆ°å®ƒå¯ä»¥æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªç©ºé—²æœ¬åœ°æ¿€æ´»ï¼Œå¹¶ä¸”åªæœ‰åœ¨æ‰€æœ‰ä»¥å‰çš„æ¿€æ´»éƒ½å¾ˆå¿™çš„æƒ…å†µä¸‹æ‰èƒ½åˆ°è¾¾æœ€åä¸€ä¸ªã€‚å¦‚æœæ‰€æœ‰çš„æ¿€æ´»éƒ½å¾ˆå¿™å¹¶ä¸”è¿˜æ²¡æœ‰è¾¾åˆ°æ¿€æ´»é™åˆ¶ï¼Œå®ƒä¼šåœ¨åˆ—è¡¨çš„æœ«å°¾å†åˆ›å»ºä¸€ä¸ªæ¿€æ´»ï¼Œå¹¶å°†è¯·æ±‚å‘é€ç»™å®ƒã€‚è¿™æ„å‘³ç€ï¼Œå½“å¯¹æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹çš„è¯·æ±‚é€Ÿç‡å¢åŠ ï¼Œå¹¶ä¸”ç°æœ‰çš„æ¿€æ´»å½“å‰éƒ½å¾ˆå¿™æ—¶ï¼Œè¿è¡Œæ—¶ä¼šå°†å…¶æ¿€æ´»æ± æ‰©å±•åˆ°æœ€å¤§é™åº¦ã€‚ç›¸åï¼Œå½“è´Ÿè½½ä¸‹é™æ—¶ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡è¾ƒå°‘æ•°é‡çš„æ— çŠ¶æ€å·¥ä½œçº¿ç¨‹çš„æ¿€æ´»æ¥å¤„ç†ï¼Œåˆ™åˆ—è¡¨æœ«å°¾çš„æ¿€æ´»å°†ä¸ä¼šå¾—åˆ°åˆ†æ´¾ç»™å®ƒä»¬çš„è¯·æ±‚ã€‚å®ƒä»¬å°†å˜ä¸ºç©ºé—²ï¼Œå¹¶æœ€ç»ˆè¢«æ ‡å‡†æ¿€æ´»æ”¶é›†è¿‡ç¨‹åœç”¨ã€‚å› æ­¤ï¼Œæ¿€æ´»æ± æœ€ç»ˆå°†ç¼©å°ä»¥åŒ¹é…è´Ÿè½½ã€‚ ä¸‹é¢çš„ç¤ºä¾‹å®šä¹‰äº†ä¸€ä¸ªæ— çŠ¶æ€çš„Worker grainç±» è‡ªè¿°å‰‘å°¾è‰ ä½¿ç”¨é»˜è®¤çš„æœ€å¤§æ¿€æ´»æ•°é™åˆ¶ã€‚ [StatelessWorker] public class MyStatelessWorkerGrain : Grain, IMyStatelessWorkerGrain { ... } å¯¹æ— çŠ¶æ€Worker-grainçš„è°ƒç”¨ä¸å¯¹ä»»ä½•å…¶ä»–grainçš„è°ƒç”¨ç›¸åŒã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½¿ç”¨å•ä¸ªgrainsIDï¼Œ0æˆ– Guidã€‚ç©º . å½“éœ€è¦å¤šä¸ªæ— çŠ¶æ€å·¥ä½œçº¿ç¨‹Grainæ± æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¤šä¸ªgrain IDï¼Œæ¯ä¸ªIDä¸€ä¸ªã€‚ var worker = GrainFactory.GetGrain<IMyStatelessWorkerGrain>(0); await worker.Process(args); è¿™ä¸€ä¸ªå®šä¹‰äº†ä¸€ä¸ªæ— çŠ¶æ€çš„Worker-grainç±»ï¼Œæ¯ä¸ªsilosåªæœ‰ä¸€ä¸ªgrainæ¿€æ´»ã€‚ [StatelessWorker(1)] // max 1 activation per silo public class MyLonelyWorkerGrain : ILonelyWorkerGrain { ... } è¯·æ³¨æ„ [æ— çŠ¶æ€ Worker] å±æ€§ä¸ä¼šæ›´æ”¹ç›®æ ‡grainç±»çš„Reentrantæ€§ã€‚ä¸å…¶ä»–ä»»ä½•Grainä¸€æ ·ï¼Œæ— çŠ¶æ€å·¥ä½œGrainåœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸Reentrantçš„ã€‚é€šè¿‡æ·»åŠ ä¸€ä¸ª [Reentrant] å±æ€§è®¾ç½®ä¸ºgrainç±»ã€‚ å· â€œæ— çŠ¶æ€å·¥ä½œäººå‘˜â€çš„â€œæ— çŠ¶æ€â€éƒ¨åˆ†å¹¶ä¸æ„å‘³ç€æ— çŠ¶æ€å·¥ä½œäººå‘˜ä¸èƒ½æœ‰çŠ¶æ€ï¼Œå¹¶ä¸”ä»…é™äºæ‰§è¡ŒåŠŸèƒ½æ€§æ“ä½œã€‚ä¸å…¶ä»–ä»»ä½•Grainä¸€æ ·ï¼Œæ— çŠ¶æ€å·¥ä½œçº¿ç¨‹å¯ä»¥åŠ è½½æ‰€éœ€çš„ä»»ä½•çŠ¶æ€å¹¶å°†å…¶ä¿å­˜åœ¨å†…å­˜ä¸­ã€‚è¿™åªæ˜¯å› ä¸ºä¸€ä¸ªæ— çŠ¶æ€çš„Worker-grainçš„å¤šä¸ªæ¿€æ´»å¯ä»¥åœ¨é›†ç¾¤çš„åŒä¸€ä¸ªå’Œä¸åŒçš„ç«–äº•ä¸Šåˆ›å»ºï¼Œæ‰€ä»¥æ²¡æœ‰ä¸€ä¸ªç®€å•çš„æœºåˆ¶æ¥åè°ƒä¸åŒæ¿€æ´»æ‰€ä¿æŒçš„çŠ¶æ€ã€‚ æœ‰å‡ ä¸ªæœ‰ç”¨çš„æ¨¡å¼æ¶‰åŠåˆ°æ— çŠ¶æ€å·¥ä½œè€…ä¿æŒçŠ¶æ€ã€‚ æ‰©å±•çƒ­ç¼“å­˜é¡¹ å¯¹äºå…·æœ‰é«˜ååé‡çš„çƒ­ç¼“å­˜é¡¹ï¼Œå°†æ¯ä¸ªè¿™æ ·çš„é¡¹ä¿å­˜åœ¨æ— çŠ¶æ€å·¥ä½œè¿›ç¨‹ä¸­ä¼šä½¿å…¶a)åœ¨silosä¸­è‡ªåŠ¨æ¨ªå‘æ‰©å±•å¹¶è·¨ç¾¤é›†ä¸­çš„æ‰€æœ‰silosï¼›b)ä½¿æ•°æ®å§‹ç»ˆåœ¨é€šè¿‡å…¶å®¢æˆ·ç«¯ç½‘å…³æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚çš„silosä¸Šæœ¬åœ°å¯ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ä¸éœ€è¦é¢å¤–çš„ç½‘ç»œè·ƒç‚¹åˆ°å¦ä¸€ä¸ªsilosçš„æƒ…å†µä¸‹å“åº”è¯·æ±‚ã€‚ å‡å°‘æ ·å¼èšåˆ åœ¨æŸäº›åœºæ™¯ä¸­ï¼Œåº”ç”¨ç¨‹åºéœ€è¦è®¡ç®—é›†ç¾¤ä¸­ç‰¹å®šç±»å‹çš„æ‰€æœ‰Grainçš„ç‰¹å®šåº¦é‡ï¼Œå¹¶å®šæœŸæŠ¥å‘Šèšåˆã€‚ä¾‹å¦‚ï¼ŒæŠ¥å‘Šæ¯ä¸ªæ¸¸æˆåœ°å›¾ä¸Šçš„ç©å®¶æ•°é‡ã€VoIPè®¿é—®çš„å¹³å‡æŒç»­æ—¶é—´ç­‰ã€‚å¦‚æœæˆåƒä¸Šä¸‡æˆ–æ•°ç™¾ä¸‡ä¸ªgrainsä¸­çš„æ¯ä¸€ä¸ªéƒ½å‘å•ä¸ªå…¨å±€èšåˆå™¨æŠ¥å‘Šå…¶æŒ‡æ ‡ï¼Œèšåˆå™¨å°†ç«‹å³è¿‡è½½ï¼Œæ— æ³•å¤„ç†å¤§é‡æŠ¥å‘Šã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯å°†æ­¤ä»»åŠ¡è½¬æ¢ä¸º2æ­¥(æˆ–æ›´å¤š)çš„reduceæ ·å¼èšåˆã€‚ç¬¬ä¸€å±‚èšåˆæ˜¯é€šè¿‡æŠ¥å‘Šgrainæ¥å®Œæˆçš„ï¼Œå°†å®ƒä»¬çš„åº¦é‡å‘é€ç»™æ— çŠ¶æ€çš„Worker pre-aggregation grainã€‚Orleansè¿è¡Œæ—¶å°†è‡ªåŠ¨ä¸ºæ¯ä¸ªsilosåˆ›å»ºå¤šä¸ªæ— çŠ¶æ€Worker grainçš„æ¿€æ´»ã€‚ç”±äºæ‰€æœ‰è¿™äº›è°ƒç”¨éƒ½å°†åœ¨æœ¬åœ°å¤„ç†ï¼Œè€Œä¸è¿›è¡Œè¿œç¨‹è°ƒç”¨æˆ–æ¶ˆæ¯åºåˆ—åŒ–ï¼Œå› æ­¤è¿™ç§èšåˆçš„æˆæœ¬å°†å¤§å¤§ä½äºè¿œç¨‹æƒ…å†µä¸‹çš„æˆæœ¬ã€‚ç°åœ¨ï¼Œæ¯ä¸ªé¢„èšåˆæ— çŠ¶æ€å·¥ä½œè¿›ç¨‹Grainæ¿€æ´»ï¼Œå¯ä»¥ç‹¬ç«‹åœ°æˆ–ä¸å…¶ä»–æœ¬åœ°æ¿€æ´»åä½œï¼Œå°†å®ƒä»¬çš„èšåˆæŠ¥å‘Šå‘é€åˆ°å…¨å±€æœ€ç»ˆèšåˆå™¨(æˆ–åœ¨å¿…è¦æ—¶å‘é€åˆ°å¦ä¸€ä¸ªç¼©å‡å±‚)ï¼Œè€Œä¸ä¼šä½¿å…¶è¿‡è½½ã€‚"
  },
  "Documentation/grains/observers.html": {
    "href": "Documentation/grains/observers.html",
    "title": "Observers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è§‚å¯Ÿè€… åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç®€å•çš„æ¶ˆæ¯/å“åº”æ¨¡å¼æ˜¯ä¸å¤Ÿçš„ï¼Œå®¢æˆ·ç«¯éœ€è¦æ¥æ”¶å¼‚æ­¥é€šçŸ¥ã€‚ä¾‹å¦‚ï¼Œå½“æœ‹å‹å‘å¸ƒäº†æ–°çš„å³æ—¶æ¶ˆæ¯æ—¶ï¼Œç”¨æˆ·å¯èƒ½å¸Œæœ›æ”¶åˆ°é€šçŸ¥ã€‚ å®¢æˆ·ç«¯è§‚å¯Ÿå™¨æ˜¯ä¸€ç§å…è®¸å¼‚æ­¥é€šçŸ¥å®¢æˆ·ç«¯çš„æœºåˆ¶ã€‚è§‚å¯Ÿè€…æ˜¯ä¸€ä¸ªå•å‘å¼‚æ­¥æ¥å£ï¼Œå®ƒç»§æ‰¿è‡ª IGrainObserver ï¼Œå…¶æ‰€æœ‰æ–¹æ³•éƒ½å¿…é¡»æ˜¯æ— æ•ˆçš„ã€‚grainé€šè¿‡åƒgrainæ¥å£æ–¹æ³•ä¸€æ ·è°ƒç”¨å®ƒæ¥å‘è§‚å¯Ÿè€…å‘é€é€šçŸ¥ï¼Œåªæ˜¯å®ƒæ²¡æœ‰è¿”å›å€¼ï¼Œå› æ­¤grainä¸éœ€è¦ä¾èµ–äºç»“æœã€‚Orleansè¿è¡Œæ—¶å°†ç¡®ä¿å•å‘ä¼ é€’é€šçŸ¥ã€‚å‘å¸ƒæ­¤ç±»é€šçŸ¥çš„Grainåº”è¯¥æä¾›ä¸€ä¸ªapiæ¥æ·»åŠ æˆ–åˆ é™¤è§‚å¯Ÿè€…ã€‚æ­¤å¤–ï¼Œé€šå¸¸å…¬å¼€ä¸€ç§å…è®¸å–æ¶ˆç°æœ‰è®¢é˜…çš„æ–¹æ³•é€šå¸¸æ˜¯æ–¹ä¾¿çš„ã€‚Grainså¼€å‘å•†å¯èƒ½ä¼šä½¿ç”¨Orleans ObserverSubscriptionManager<T> ç±»ï¼Œä»¥ç®€åŒ–è§‚å¯Ÿåˆ°çš„grainsç±»å‹çš„å¼€å‘ã€‚ è¦è®¢é˜…é€šçŸ¥ï¼Œå®¢æˆ·ç«¯å¿…é¡»é¦–å…ˆåˆ›å»ºä¸€ä¸ªå®ç°è§‚å¯Ÿè€…æ¥å£çš„æœ¬åœ°cå¯¹è±¡ã€‚ç„¶åè°ƒç”¨è§‚å¯Ÿè€…å·¥å‚ä¸Šçš„é™æ€æ–¹æ³•ï¼Œ CreateObjectReference() ï¼Œå°†cå¯¹è±¡è½¬æ¢ä¸ºä¸€ä¸ªgrainå¼•ç”¨ï¼Œç„¶åå¯ä»¥å°†å…¶ä¼ é€’ç»™é€šçŸ¥grainä¸Šçš„è®¢é˜…æ–¹æ³•ã€‚ è¿™ä¸ªæ¨¡å‹ä¹Ÿå¯ä»¥è¢«å…¶ä»–Grainsç”¨æ¥æ¥æ”¶å¼‚æ­¥é€šçŸ¥ã€‚ä¸å®¢æˆ·ç«¯è®¢é˜…æƒ…å†µä¸åŒï¼Œè®¢é˜…Grainåªæ˜¯å°†observeræ¥å£å®ç°ä¸ºä¸€ä¸ªæ–¹é¢ï¼Œå¹¶å°†å¼•ç”¨ä¼ é€’ç»™è‡ªå·±(ä¾‹å¦‚ã€‚ this.AsReference<IMyGrainObserverInterface> )ä¸­ã€‚ ä»£ç ç¤ºä¾‹ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå‘¨æœŸæ€§åœ°å‘å®¢æˆ·å‘é€æ¶ˆæ¯çš„Grainã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬çš„ç¤ºä¾‹ä¸­çš„æ¶ˆæ¯å°†æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚æˆ‘ä»¬é¦–å…ˆåœ¨å®¢æˆ·ç«¯ä¸Šå®šä¹‰å°†æ¥æ”¶æ¶ˆæ¯çš„æ¥å£ã€‚ æ¥å£å°†å¦‚ä¸‹æ‰€ç¤º public interface IChat : IGrainObserver { void ReceiveMessage(string message); } å”¯ä¸€ç‰¹åˆ«çš„æ˜¯æ¥å£åº”è¯¥ç»§æ‰¿è‡ª IGrainObserver æ˜¯çš„ã€‚ç°åœ¨ï¼Œä»»ä½•å¸Œæœ›è§‚å¯Ÿè¿™äº›æ¶ˆæ¯çš„å®¢æˆ·ç«¯éƒ½åº”è¯¥å®ç°ä¸€ä¸ªå®ç° IChat æ˜¯çš„ã€‚ æœ€ç®€å•çš„ä¾‹å­æ˜¯è¿™æ ·çš„ï¼š public class Chat : IChat { public void ReceiveMessage(string message) { Console.WriteLine(message); } } ç°åœ¨åœ¨æœåŠ¡å™¨ä¸Šï¼Œæˆ‘ä»¬åº”è¯¥æœ‰ä¸€ä¸ªGrainså‘é€è¿™äº›èŠå¤©ä¿¡æ¯ç»™å®¢æˆ·ç«¯ã€‚grainè¿˜åº”è¯¥æœ‰ä¸€ä¸ªæœºåˆ¶ï¼Œè®©å®¢æˆ·ç«¯è®¢é˜…å’Œå–æ¶ˆè®¢é˜…è‡ªå·±ä»¥æ¥æ”¶é€šçŸ¥ã€‚å¯¹äºè®¢é˜…ï¼Œgrainå¯ä»¥ä½¿ç”¨utilityç±» ObserverSubscriptionManager æ˜¯çš„ã€‚è¿™ä¸ªç­çš„å­¦ç”Ÿ OrleansException å¦‚æœæ‚¨å°è¯•è®¢é˜…å·²è®¢é˜…çš„è§‚å¯Ÿè€…(æˆ–å–æ¶ˆè®¢é˜…æœªè®¢é˜…çš„è§‚å¯Ÿè€…)ï¼Œé‚£ä¹ˆä½¿ç”¨ IsSubscribed() æ–¹æ³•æˆ–é€šè¿‡å¤„ç† OrleansException ä»¥ä¸‹å†…å®¹ï¼š class HelloGrain : Grain, IHello { private ObserverSubscriptionManager<IChat> _subsManager; public override async Task OnActivateAsync() { // We created the utility at activation time. _subsManager = new ObserverSubscriptionManager<IChat>(); await base.OnActivateAsync(); } // Clients call this to subscribe. public Task Subscribe(IChat observer) { if (!_subsManager.IsSubscribed(observer)) { _subsManager.Subscribe(observer); } return Task.CompletedTask; } //Also clients use this to unsubscribe themselves to no longer receive the messages. public Task UnSubscribe(IChat observer) { if (_subsManager.IsSubscribed(observer)) { _subsManager.Unsubscribe(observer); } return Task.CompletedTask; } } å°†æ¶ˆæ¯å‘é€åˆ°å®¢æˆ·ç«¯ Notify æ–¹æ³• ObserverSubscriptionManager<Ichat> å¯ä»¥ä½¿ç”¨å®ä¾‹ã€‚è¿™ç§æ–¹æ³•éœ€è¦ Action<T> æ–¹æ³•æˆ–lambdaè¡¨è¾¾å¼(å…¶ä¸­ T å±äºç±»å‹ IChat )ã€‚å¯ä»¥è°ƒç”¨æ¥å£ä¸Šçš„ä»»ä½•æ–¹æ³•å°†å…¶å‘é€ç»™å®¢æˆ·ç«¯ã€‚æˆ‘ä»¬åªæœ‰ä¸€ç§æ–¹æ³• ReceiveMessage æˆ‘ä»¬åœ¨æœåŠ¡å™¨ä¸Šå‘é€çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š public Task SendUpdateMessage(string message) { _subsManager.Notify(s => s.ReceiveMessage(message)); return Task.CompletedTask; } ç°åœ¨ï¼Œæˆ‘ä»¬çš„æœåŠ¡å™¨æœ‰ä¸€ä¸ªå‘è§‚å¯Ÿè€…å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯çš„æ–¹æ³•ï¼Œä¸¤ä¸ªç”¨äºè®¢é˜…/å–æ¶ˆè®¢é˜…çš„æ–¹æ³•ï¼Œå¹¶ä¸”å®¢æˆ·ç«¯å®ç°äº†ä¸€ä¸ªèƒ½å¤Ÿè§‚å¯Ÿåˆ°grainæ¶ˆæ¯çš„ç±»ã€‚æœ€åä¸€æ­¥æ˜¯ä½¿ç”¨ä¹‹å‰å®ç°çš„ Chat ç±»å¹¶è®©å®ƒåœ¨è®¢é˜…åæ¥æ”¶æ¶ˆæ¯ã€‚ ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š //First create the grain reference var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Chat c = new Chat(); //Create a reference for chat usable for subscribing to the observable grain. var obj = await GrainClient.GrainFactory.CreateObjectReference<IChat>(c); //Subscribe the instance to receive messages. await friend.Subscribe(obj); ç°åœ¨æ¯å½“æœåŠ¡å™¨ä¸Šçš„Grainsè°ƒç”¨ SendUpdateMessage æ–¹æ³•ï¼Œæ‰€æœ‰å·²è®¢é˜…çš„å®¢æˆ·ç«¯éƒ½å°†æ”¶åˆ°æ¶ˆæ¯ã€‚åœ¨æˆ‘ä»¬çš„å®¢æˆ·ä»£ç ä¸­ï¼Œ Chat å˜é‡ä¸­çš„å®ä¾‹ C å°†æ¥æ”¶æ¶ˆæ¯å¹¶å°†å…¶è¾“å‡ºåˆ°æ§åˆ¶å°ã€‚ æ³¨ï¼š ä¼ é€’ç»™çš„å¯¹è±¡ CreateObjectReference é€šè¿‡ WeakReference<T> å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–å¼•ç”¨ï¼Œåˆ™å°†è¢«åƒåœ¾æ”¶é›†ã€‚ç”¨æˆ·åº”è¯¥ä¸ºæ¯ä¸ªä¸å¸Œæœ›è¢«æ”¶é›†çš„è§‚å¯Ÿè€…ç»´æŠ¤ä¸€ä¸ªå¼•ç”¨ã€‚ æ³¨ï¼š è§‚å¯Ÿè€…æœ¬è´¨ä¸Šæ˜¯ä¸å¯é çš„ï¼Œå› ä¸ºæ‚¨æ²¡æœ‰å¾—åˆ°ä»»ä½•å“åº”æ¥çŸ¥é“æ¶ˆæ¯æ˜¯è¢«æ¥æ”¶å’Œå¤„ç†çš„ï¼Œè¿˜æ˜¯ä»…ä»…ç”±äºåˆ†å¸ƒå¼ç³»ç»Ÿä¸­å¯èƒ½å‡ºç°çš„ä»»ä½•æƒ…å†µè€Œå¤±è´¥ã€‚å› æ­¤ï¼Œæ‚¨çš„è§‚å¯Ÿè€…åº”è¯¥å®šæœŸè½®è¯¢grainæˆ–ä½¿ç”¨ä»»ä½•å…¶ä»–æœºåˆ¶æ¥ç¡®ä¿ä»–ä»¬æ¥æ”¶åˆ°äº†æ‰€æœ‰åº”è¯¥æ¥æ”¶åˆ°çš„æ¶ˆæ¯ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½ä¼šä¸¢å¤±ä¸€äº›æ¶ˆæ¯ï¼Œå¹¶ä¸”ä¸éœ€è¦ä»»ä½•é™„åŠ æœºåˆ¶ï¼Œä½†å¦‚æœæ‚¨éœ€è¦ç¡®ä¿æ‰€æœ‰è§‚å¯Ÿè€…å§‹ç»ˆæ¥æ”¶æ¶ˆæ¯å¹¶æ¥æ”¶æ‰€æœ‰æ¶ˆæ¯ï¼Œåˆ™å®šæœŸé‡æ–°è®¢é˜…å’Œè½®è¯¢è§‚å¯Ÿè€…Grainæœ‰åŠ©äºç¡®ä¿æœ€ç»ˆå¤„ç†æ‰€æœ‰æ¶ˆæ¯ã€‚"
  },
  "Documentation/grains/grainservices.html": {
    "href": "Documentation/grains/grainservices.html",
    "title": "GrainServices | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "grainæœåŠ¡ GrainServiceæ˜¯ä¸€ç§ç‰¹æ®Šçš„Grainsã€‚ä¸€ä¸ªæ²¡æœ‰èº«ä»½çš„ï¼Œå¹¶ä¸”ä»å¯åŠ¨åˆ°å…³é—­éƒ½åœ¨æ¯ä¸ªsilosä¸­è¿è¡Œçš„ç¨‹åºã€‚ åˆ›å»ºä¸€ä¸ªGrainService ç¬¬1æ­¥ã€‚ åˆ›å»ºæ¥å£ã€‚GrainServiceçš„æ¥å£æ˜¯ä½¿ç”¨ä¸æ„å»ºå…¶ä»–ä»»ä½•grainçš„æ¥å£å®Œå…¨ç›¸åŒçš„åŸç†æ„å»ºçš„ã€‚ public interface IDataService : IGrainService { Task MyMethod(); } ç¬¬2æ­¥ã€‚ åˆ›å»ºDataServiceæœ¬èº«ã€‚å¦‚æœå¯èƒ½ï¼Œä½¿GrainServiceReentrantä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚æ³¨æ„å¿…è¦çš„åŸºæœ¬æ„é€ å‡½æ•°è°ƒç”¨ã€‚å¾ˆé«˜å…´çŸ¥é“æ‚¨ä¹Ÿå¯ä»¥æ³¨å…¥ IGrainFactory å› æ­¤æ‚¨å¯ä»¥ä»GrainServiceè¿›è¡ŒGrainsè°ƒç”¨ã€‚ å…³äºæµçš„è¯´æ˜ï¼šGrainServiceæ— æ³•åœ¨Orleansæµä¸­å†™å…¥ï¼Œå› ä¸ºå®ƒåœ¨Grain Task Schedulerä¸­ä¸èµ·ä½œç”¨ã€‚å¦‚æœæ‚¨éœ€è¦GrainServiceä¸ºæ‚¨å†™å…¥æµï¼Œåˆ™å¿…é¡»å°†å¯¹è±¡å‘é€åˆ°å¦ä¸€ç§Grainsä»¥å†™å…¥æµã€‚ [Reentrant] public class LightstreamerDataService : GrainService, IDataService { readonly IGrainFactory GrainFactory; public LightstreamerDataService(IServiceProvider services, IGrainIdentity id, Silo silo, ILoggerFactory loggerFactory, IGrainFactory grainFactory) : base(id, silo, loggerFactory) { GrainFactory = grainFactory; } public override Task Init(IServiceProvider serviceProvider) { return base.Init(serviceProvider); } public override async Task Start() { await base.Start(); } public override Task Stop() { return base.Stop(); } public Task MyMethod() { } } ç¬¬ä¸‰æ­¥ ä¸ºGrainServiceClientåˆ›å»ºä¸€ä¸ªæ¥å£ï¼Œä¾›å…¶ä»–Grainsä½¿ç”¨ä»¥è¿æ¥åˆ°GrainServiceã€‚ public interface IDataServiceClient : IGrainServiceClient<IDataService>, IDataService { } ç¬¬4æ­¥ã€‚ åˆ›å»ºå®é™…çš„GrainsæœåŠ¡å®¢æˆ·ç«¯ã€‚å®ƒå‡ ä¹åªæ˜¯å……å½“æ•°æ®æœåŠ¡çš„ä»£ç†ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ‚¨å¿…é¡»æ‰‹åŠ¨è¾“å…¥æ‰€æœ‰æ–¹æ³•æ˜ å°„ï¼Œå®ƒä»¬åªæ˜¯ç®€å•çš„ä¸€åˆ—å¼ã€‚ public class DataServiceClient : GrainServiceClient<IDataService>, IDataServiceClient { public DataServiceClient(IServiceProvider serviceProvider) : base(serviceProvider) { } public Task MyMethod() => GrainService.MyMethod(); } ç¬¬äº”æ­¥ å°†GrainsæœåŠ¡å®¢æˆ·ç«¯æ³¨å…¥éœ€è¦å®ƒçš„å…¶ä»–Grainsä¸­ã€‚æ³¨æ„ï¼ŒGrainServiceClientä¸ä¿è¯è®¿é—®æœ¬åœ°silosä¸Šçš„GrainServiceã€‚æ‚¨çš„å‘½ä»¤å¯èƒ½ä¼šå‘é€åˆ°é›†ç¾¤ä¸­ä»»ä½•silosä¸Šçš„GrainServiceã€‚ public class MyNormalGrain: Grain<NormalGrainState>, INormalGrain { readonly IDataServiceClient DataServiceClient; public MyNormalGrain(IGrainActivationContext grainActivationContext, IDataServiceClient dataServiceClient) { DataServiceClient = dataServiceClient; } } ç¬¬å…­æ­¥ å°†grainæœåŠ¡æ³¨å…¥Siloæœ¬èº«ã€‚æ‚¨éœ€è¦æ‰§è¡Œæ­¤æ“ä½œï¼Œä»¥ä¾¿siloså°†å¯åŠ¨GrainServiceã€‚ (ISiloHostBuilder builder) => builder .ConfigureServices(services => { services.AddSingleton<IDataService, DataService>(); }); è¡¥å……ç¬”è®° ###æ³¨1 æœ‰ä¸€ä¸ªæ‰©å±•æ–¹æ³• ISiloHostBuilderï¼šAddGrainService <SomeGrainService>() ã€‚ç±»å‹çº¦æŸæ˜¯ï¼š å…¶ä¸­Tï¼šGrainService ã€‚æœ€ç»ˆè°ƒç”¨æ­¤ä½ï¼š orleans / src / Orleans.Runtime / Services / GrainServicesSiloBuilderExtensions.cs è¿”å›æœåŠ¡ã€‚AddSingleton <IGrainService>(sp => GrainServiceFactory(grainServiceTypeï¼Œsp)); åŸºæœ¬ä¸Šï¼Œsiloså– IGrainæœåŠ¡ å¯åŠ¨æ—¶æ¥è‡ªæœåŠ¡æä¾›å•†çš„ç±»å‹ï¼š orleans / src / Orleans.Runtime / Silo / Silo.cs var grainServices = this.Services.GetServices <IGrainService>(); çš„ Microsoft.Orleans.OrleansRuntime Nugetè½¯ä»¶åŒ…åº”ç”±Grainserviceé¡¹ç›®å¼•ç”¨ã€‚ ï¼ƒï¼ƒï¼ƒç¬”è®°2 ä¸ºäº†ä½¿å…¶æ­£å¸¸å·¥ä½œï¼Œæ‚¨å¿…é¡»æ³¨å†ŒæœåŠ¡åŠå…¶å®¢æˆ·ç«¯ã€‚ä»£ç çœ‹èµ·æ¥åƒè¿™æ ·ï¼š var builder = new SiloHostBuilder() .AddGrainService<DataService>() // Register GrainService .ConfigureServices(s => { // Register Client of GrainService s.AddSingleton<IDataServiceClient, DataServiceClient>(); })"
  },
  "Documentation/grains/reentrancy.html": {
    "href": "Documentation/grains/reentrancy.html",
    "title": "Reentrancy | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Reentrant Grainæ¿€æ´»æ˜¯å•çº¿ç¨‹çš„ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨ä¸‹ä¸€ä¸ªè¯·æ±‚å¯ä»¥å¼€å§‹å¤„ç†ä¹‹å‰ï¼Œä»å¤´åˆ°å°¾å¤„ç†æ¯ä¸ªè¯·æ±‚ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå½“ä¸€ä¸ªè¯·æ±‚ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆæ—¶ï¼Œå¯èƒ½éœ€è¦æ¿€æ´»æ¥å¤„ç†å…¶ä»–è¯·æ±‚ã€‚ç”±äºè¿™ä¸ªå’Œå…¶ä»–åŸå› ï¼ŒOrleansç»™äº†å¼€å‘äººå‘˜ä¸€äº›æ§åˆ¶è¯·æ±‚äº¤é”™è¡Œä¸ºçš„æƒé™ã€‚åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œå¤šä¸ªè¯·æ±‚å¯èƒ½è¢«äº¤é”™ï¼š Grainsç­‰çº§æ ‡è®°ä¸º [Reentrant] æ¥å£æ–¹æ³•æ ‡è®°ä¸º [AlwaysInterleave] åŒä¸€è°ƒç”¨é“¾ä¸­çš„è¯·æ±‚ Grainsçš„ MayInterleave è°“è¯è¿”å› true ä»¥ä¸‹å„èŠ‚å°†è®¨è®ºè¿™äº›æƒ…å†µã€‚ é‡å…¥grains Grains å®ç°ç±»å¯ä»¥ç”¨ [Reentrant] å±æ€§æŒ‡ç¤ºä¸åŒçš„è¯·æ±‚å¯ä»¥è‡ªç”±äº¤é”™ã€‚ æ¢è¨€ä¹‹ï¼ŒReentrantæ¿€æ´»å¯èƒ½åœ¨å‰ä¸€ä¸ªè¯·æ±‚å°šæœªå®Œæˆå¤„ç†æ—¶å¼€å§‹æ‰§è¡Œå¦ä¸€ä¸ªè¯·æ±‚ã€‚æ‰§è¡Œä»ç„¶å±€é™äºå•ä¸ªçº¿ç¨‹ï¼Œå› æ­¤æ¿€æ´»ä»ç„¶ä¸€æ¬¡æ‰§è¡Œä¸€ä¸ªå›åˆï¼Œå¹¶ä¸”æ¯ä¸ªå›åˆåªä»£è¡¨æ¿€æ´»çš„ä¸€ä¸ªè¯·æ±‚æ‰§è¡Œã€‚ ReentrantGrainä»£ç æ°¸è¿œä¸ä¼šå¹¶è¡Œè¿è¡Œå¤šä¸ªGrainä»£ç (Grainä»£ç çš„æ‰§è¡Œå°†å§‹ç»ˆæ˜¯å•çº¿ç¨‹çš„)ï¼Œä½†ReentrantGrainä»£ç  å¯èƒ½ çœ‹è§ä¸åŒè¯·æ±‚äº¤é”™æ‰§è¡Œçš„ä»£ç ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸åŒè¯·æ±‚çš„ç»­è½¬å¯ä»¥äº¤é”™ã€‚ ä¾‹å¦‚ï¼Œä½¿ç”¨ä¸‹é¢çš„ä¼ªä»£ç ï¼Œå½“Fooå’ŒBaræ˜¯åŒä¸€grainç±»çš„2ä¸ªæ–¹æ³•æ—¶ï¼š Task Foo() { await task1; // line 1 return Do2(); // line 2 } Task Bar() { await task2; // line 3 return Do2(); // line 4 } å¦‚æœè¿™ä¸ªgrainsæœ‰æ ‡è®° [Reentrant] ï¼ŒFooå’ŒBarçš„æ‰§è¡Œå¯ä»¥äº¤é”™æ‰§è¡Œã€‚ ä¾‹å¦‚ï¼Œå¯ä»¥æŒ‰ä»¥ä¸‹é¡ºåºæ‰§è¡Œï¼š 1å·çº¿ã€3å·çº¿ã€2å·çº¿å’Œ4å·çº¿ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¥è‡ªä¸åŒè¯·æ±‚çš„åœˆæ•°äº¤é”™ã€‚ å¦‚æœgrainä¸Reentrantï¼Œå”¯ä¸€å¯èƒ½çš„æ‰§è¡Œå°†æ˜¯ï¼šç¬¬1è¡Œã€ç¬¬2è¡Œã€ç¬¬3è¡Œã€ç¬¬4è¡Œæˆ–ï¼šç¬¬3è¡Œã€ç¬¬4è¡Œã€ç¬¬1è¡Œã€ç¬¬2è¡Œ(åœ¨å‰ä¸€ä¸ªè¯·æ±‚å®Œæˆä¹‹å‰ï¼Œæ–°è¯·æ±‚æ— æ³•å¯åŠ¨)ã€‚ åœ¨é€‰æ‹©Reentrantå’Œä¸Reentrantgrainsæ—¶ï¼Œä¸»è¦çš„æŠ˜è¡·æ˜¯ä½¿äº¤ç»‡æ­£ç¡®å·¥ä½œçš„ä»£ç å¤æ‚åº¦å’Œå¯¹æ­¤è¿›è¡Œæ¨ç†çš„å›°éš¾ã€‚ åœ¨ä¸€ä¸ªå¾ˆå°çš„ä¾‹å­ä¸­ï¼Œå½“Grainæ˜¯æ— çŠ¶æ€çš„ï¼Œé€»è¾‘ä¹Ÿå¾ˆç®€å•æ—¶ï¼Œæ›´å°‘(ä½†ä¸æ˜¯å¤ªå°‘ï¼Œä»¥ä¾¿ä½¿ç”¨æ‰€æœ‰çš„ç¡¬ä»¶çº¿ç¨‹)Reentrantgrainsé€šå¸¸ä¼šç¨å¾®æ›´æœ‰æ•ˆä¸€äº›ã€‚ å¦‚æœä»£ç æ›´å¤æ‚ï¼Œé‚£ä¹ˆå¤§é‡çš„ä¸Reentrantgrainsï¼Œå³ä½¿æ€»ä½“æ•ˆç‡ç¨ä½ï¼Œä¹Ÿå¯ä»¥é¿å…æ‚¨åœ¨è§£å†³ä¸æ˜æ˜¾çš„äº¤é”™é—®é¢˜æ—¶çš„è®¸å¤šç—›è‹¦ã€‚ æœ€ç»ˆç­”æ¡ˆå°†å–å†³äºå…·ä½“çš„åº”ç”¨ç¨‹åºã€‚ äº¤é”™æ–¹æ³• grainsæ¥å£è¢«æ ‡è®°ä¸º [AlwaysInterleave] æ— è®ºgrainsæ˜¯å¦Reentrantï¼Œéƒ½å°†è¢«äº¤é”™æ‰§è¡Œã€‚è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š public interface ISlowpokeGrain : IGrainWithIntegerKey { Task GoSlow(); [AlwaysInterleave] Task GoFast(); } public class SlowpokeGrain : Grain, ISlowpokeGrain { public async Task GoSlow() { await Task.Delay(TimeSpan.FromSeconds(10)); } public async Task GoFast() { await Task.Delay(TimeSpan.FromSeconds(10)); } } ç°åœ¨è€ƒè™‘ç”±ä»¥ä¸‹å®¢æˆ·ç«¯è¯·æ±‚å¯åŠ¨çš„è°ƒç”¨æµï¼š var slowpoke = client.GetGrain<ISlowpokeGrain>(0); // A) This will take around 20 seconds await Task.WhenAll(slowpoke.GoSlow(), slowpoke.GoSlow()); // B) This will take around 10 seconds. await Task.WhenAll(slowpoke.GoFast(), slowpoke.GoFast(), slowpoke.GoFast()); è®¿é—® GoSlow ä¸ä¼šäº¤é”™ï¼Œæ‰€ä»¥æ‰§è¡Œä¸¤ä¸ª GoSlow() è°ƒç”¨å¤§çº¦éœ€è¦20ç§’ã€‚å¦ä¸€æ–¹é¢ï¼Œå› ä¸º GoFast æœ‰æ ‡è®° [AlwaysInterleave] ï¼Œå¯¹å®ƒçš„ä¸‰ä¸ªè°ƒç”¨å°†åŒæ—¶æ‰§è¡Œï¼Œå¹¶å°†åœ¨å¤§çº¦10ç§’å†…å®Œæˆï¼Œè€Œä¸æ˜¯è‡³å°‘éœ€è¦30ç§’æ‰èƒ½å®Œæˆã€‚ è®¿é—®é“¾ä¸­çš„Reentrantæ€§ ä¸ºäº†é¿å…æ­»é”ï¼Œè°ƒåº¦å™¨å…è®¸åœ¨ç»™å®šçš„è°ƒç”¨é“¾ä¸­è¿›è¡Œé‡å…¥ã€‚è€ƒè™‘ä»¥ä¸‹ä¸¤ä¸ªgrainsçš„ä¾‹å­ï¼Œå®ƒä»¬å…·æœ‰ç›¸äº’é€’å½’çš„æ–¹æ³•ï¼Œ IsEven å’Œ IsOdd : public interface IEvenGrain : IGrainWithIntegerKey { Task<bool> IsEven(int num); } public interface IOddGrain : IGrainWithIntegerKey { Task<bool> IsOdd(int num); } public class EvenGrain : Grain, IEvenGrain { public async Task<bool> IsEven(int num) { if (num == 0) return true; var oddGrain = this.GrainFactory.GetGrain<IOddGrain>(0); return await oddGrain.IsOdd(num - 1); } } public class OddGrain : Grain, IOddGrain { public async Task<bool> IsOdd(int num) { if (num == 0) return false; var evenGrain = this.GrainFactory.GetGrain<IEvenGrain>(0); return await evenGrain.IsEven(num - 1); } } ç°åœ¨è€ƒè™‘ç”±ä»¥ä¸‹å®¢æˆ·ç«¯è¯·æ±‚å¯åŠ¨çš„è°ƒç”¨ï¼š var evenGrain = client.GetGrain<IEvenGrain>(0); await evenGrain.IsEven(2); ä¸Šé¢çš„ä»£ç è°ƒç”¨ IEvenGrain.IsEven(2) ï¼Œè°ƒç”¨ IOddGrain.IsOdd(1) ï¼Œè°ƒç”¨ IEvenGrain.IsEven(0) ï¼Œè¿”å› true å°†è®¿é—®é“¾å¤‡ä»½åˆ°å®¢æˆ·ç«¯ã€‚å¦‚æœæ²¡æœ‰è°ƒç”¨é“¾Reentrantï¼Œä¸Šè¿°ä»£ç å°†åœ¨ä»¥ä¸‹æƒ…å†µä¸‹å¯¼è‡´æ­»é”å½“ IOddGrain è°ƒç”¨ IEvenGrain.IsEven(0) . ç„¶è€Œï¼Œå¯¹äºè°ƒç”¨é“¾Reentrantï¼Œè°ƒç”¨è¢«è®¤ä¸ºæ˜¯å¼€å‘äººå‘˜çš„æ„å›¾ï¼Œå› æ­¤å…è®¸ç»§ç»­è¿›è¡Œã€‚ å¯ä»¥é€šè¿‡è®¾ç½®æ¥ç¦ç”¨æ­¤è¡Œä¸º SchedulingOptions.AllowCallChainEntrancy ä¸º false . ä¾‹å¦‚ï¼š siloHostBuilder.Configure<SchedulingOptions>( options => options.AllowCallChainReentrancy = false); ä½¿ç”¨è°“è¯çš„Reentrantæ€§ Grainç±»å¯ä»¥æŒ‡å®šä¸€ä¸ªè°“è¯ï¼Œç”¨äºé€šè¿‡æ£€æŸ¥è¯·æ±‚é€ä¸ªè°ƒç”¨ç¡®å®šäº¤é”™ã€‚è¿™ä¸ª [MayInterleave(string methodName)] å±æ€§æä¾›æ­¤åŠŸèƒ½ã€‚å±æ€§çš„å‚æ•°æ˜¯grainç±»ä¸­æ¥å— InvokeMethodRequest å¯¹è±¡å¹¶è¿”å› bool æŒ‡ç¤ºæ˜¯å¦åº”äº¤é”™è¯·æ±‚ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå¦‚æœè¯·æ±‚å‚æ•°ç±»å‹å…·æœ‰ [Interleave] å±æ€§ï¼š [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)] public sealed class InterleaveAttribute : Attribute { } // Specify the may-interleave predicate. [MayInterleave(nameof(ArgHasInterleaveAttribute))] public class MyGrain : Grain, IMyGrain { public static bool ArgHasInterleaveAttribute(InvokeMethodRequest req) { // Returning true indicates that this call should be interleaved with other calls. // Returning false indicates the opposite. return req.Arguments.Length == 1 && req.Arguments[0]?.GetType().GetCustomAttribute<InterleaveAttribute>() != null; } public Task Process(object payload) { // Process the object. } }"
  },
  "Documentation/clusters_and_clients/powershell_client.html": {
    "href": "Documentation/clusters_and_clients/powershell_client.html",
    "title": "PowerShell Client Module | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "powershellå®¢æˆ·ç«¯æ¨¡å— Orleans Powershellå®¢æˆ·ç«¯æ¨¡å—æ˜¯ä¸€ç»„ powershell cmdlet é‚£åŒ…è£¹ç€ grainså®¢æˆ·ç«¯ åœ¨ä¸€ç»„æ–¹ä¾¿çš„å‘½ä»¤ä¸­ï¼Œä¸ä»…å¯ä»¥ä¸ ç®¡ç†grain ä½†æ˜¯ä»»ä½• ä¼Šæ ¼æ‹‰å›  å°±åƒæ™®é€šçš„Orleansåº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ä½¿ç”¨powershellè„šæœ¬ä¸€æ ·ã€‚ è¿™äº›cmdleté€šè¿‡åˆ©ç”¨powershellè„šæœ¬ï¼Œä»å¼€å§‹ç»´æŠ¤ä»»åŠ¡ã€æµ‹è¯•ã€ç›‘è§†æˆ–ä»»ä½•å…¶ä»–ç±»å‹çš„è‡ªåŠ¨åŒ–ï¼Œå¯ç”¨ä¸€ç³»åˆ—åœºæ™¯ã€‚ ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š å®‰è£…æ¨¡å— æ¥æº æ‚¨å¯ä»¥ä»æºä»£ç æ„å»º å¥¥åˆ©æ©æ–¯æ™®æå°”æ–¯ æŠ•å°„å¹¶å¯¼å…¥ï¼š PS> Import-Module .\\projectOutputDir\\Orleans.psd1 å°½ç®¡æ‚¨å¯ä»¥è¿™æ ·åšï¼Œä½†æ˜¯æœ‰ä¸€ç§æ›´ç®€å•æœ‰è¶£çš„æ–¹æ³•å¯ä»¥é€šè¿‡ä» powershellåº“ æ˜¯çš„ã€‚ æ¥è‡ªpowershellåº“ ç°åœ¨çš„powershellæ¨¡å—å¾ˆå®¹æ˜“åƒnugetåŒ…ä¸€æ ·å…±äº«ï¼Œä½†æ˜¯å®ƒä»¬æ‰˜ç®¡åœ¨ powershellåº“ æ˜¯çš„ã€‚ è¦å°†å…¶å®‰è£…åˆ°ç‰¹å®šæ–‡ä»¶å¤¹ï¼Œè¯·è¿è¡Œï¼š PS> Save-Module -Name OrleansPSUtils -Path <path> åœ¨powershellæ¨¡å—è·¯å¾„ä¸Šå®‰è£…( æ¨èçš„æ–¹æ³• )ï¼Œåªéœ€è¿è¡Œï¼š PS> Install-Module -Name OrleansPSUtils å¦‚æœæ‚¨è®¡åˆ’åœ¨ azureè‡ªåŠ¨åŒ– ï¼Œåªéœ€å•å‡»ä¸‹é¢çš„æŒ‰é’®ï¼š ä½¿ç”¨æ¨¡å— æ— è®ºæ‚¨å†³å®šä»¥ä½•ç§æ–¹å¼å®‰è£…å®ƒï¼Œè¦å®é™…ä½¿ç”¨å®ƒï¼Œé¦–å…ˆéœ€è¦åœ¨å½“å‰çš„powershellä¼šè¯ä¸­å¯¼å…¥æ¨¡å—ï¼Œä»¥ä¾¿é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤ä½¿cmdletå¯ç”¨ï¼š PS> Import-Module OrleansPSUtils æ³¨æ„ ï¼šå¦‚æœæ˜¯ä»æºä»£ç ç”Ÿæˆï¼Œåˆ™å¿…é¡»ä½¿ç”¨ .psd1æ®µ è€Œä¸æ˜¯ä½¿ç”¨æ¨¡å—åï¼Œå› ä¸ºå®ƒä¸åœ¨ $env:psmodulepathè·¯å¾„ powershellè¿è¡Œæ—¶å˜é‡ã€‚åŒæ ·ï¼Œå¼ºçƒˆå»ºè®®æ‚¨æ”¹ä¸ºä»powershellåº“å®‰è£…ã€‚ å¯¼å…¥æ¨¡å—(è¿™æ„å‘³ç€è¯¥æ¨¡å—å·²åŠ è½½åˆ°powershellä¼šè¯ä¸­)åï¼Œå°†æœ‰ä»¥ä¸‹cmdletå¯ç”¨ï¼š å¯åŠ¨GrainClient åœæ­¢GrainClient è·å–Grains å¯åŠ¨GrainClient è¿™ä¸ªæ¨¡å—æ˜¯ä¸€ä¸ªåŒ…è£…å™¨ grainclient.initialize() ä»¥åŠå®ƒçš„è¶…è½½ã€‚ ç”¨æ³• ä»¥ä¸‹å†…å®¹ï¼š å¯åŠ¨GrainClient ä¸Callç›¸åŒ grainclient.initialize() å®ƒå°†æŸ¥æ‰¾å·²çŸ¥çš„Orleanså®¢æˆ·ç«¯é…ç½®æ–‡ä»¶å å¯åŠ¨grainclient[-configfilepath]<string>[[-timeout]<timespan>] å°†ä½¿ç”¨æä¾›çš„æ–‡ä»¶è·¯å¾„ï¼Œå¦‚ä¸­æ‰€ç¤º grainclient.initialize(æ–‡ä»¶è·¯å¾„) å¯åŠ¨grainclient[-configfile]<fileinfo>[[-timeout]<timespan>] ä½¿ç”¨ ç³»ç»Ÿæ–‡ä»¶ä¿¡æ¯ ç±»è¡¨ç¤ºé…ç½®æ–‡ä»¶ï¼Œå°±åƒ grainclient.initialize(æ–‡ä»¶ä¿¡æ¯) å¯åŠ¨grainclient[-config]<clientconfiguration>[[-timeout]<timeSPAN>] ä½¿ç”¨ Orleans.runtime.configuration.clientconfiguration å°±åƒåœ¨ grainclient.initialize(é…ç½®) å¯åŠ¨grainclient[-gatewayaddress]<ipendpoint>[[-overrideconfig]<bool>[[-timeout]<timespan>] é‡‡ç”¨Orleansç¾¤é›†ç½‘å…³åœ°å€ç»ˆç»“ç‚¹ æ³¨æ„ ï¼šçš„ è¶…æ—¶ å‚æ•°æ˜¯å¯é€‰çš„ï¼Œå¦‚æœå®ƒè¢«å‘ŠçŸ¥å¹¶ä¸”å¤§äº System.TimeSpan.Zeroç³»ç»Ÿ.TimeSpan.Zero ï¼Œå®ƒå°†è°ƒç”¨ orleans.grainclient.setResponseTimeout(è¶…æ—¶) åœ¨å†…éƒ¨ã€‚ åœæ­¢GrainClient ä¸æ¥å—ä»»ä½•å‚æ•°ï¼Œå½“è°ƒç”¨æ—¶ï¼Œå¦‚æœ grainså®¢æˆ·ç«¯ åˆå§‹åŒ–å°†æ­£å¸¸å–æ¶ˆåˆå§‹åŒ–ã€‚ è·å–Grains åŒ…è£…ç‰© grainclient.grainfactory.getgrain<t>() ä»¥åŠå®ƒçš„è¶…è½½ã€‚ å¼ºåˆ¶å‚æ•°æ˜¯ -Grain ä»¥åŠ -xxxé”® å¯¹äºOrleansæ”¯æŒçš„å½“å‰Grainså¯†é’¥ç±»å‹( ä¸€ä¸² ï¼Œè¯· æŒ‡å¯¼æ–¹é’ˆ æˆ‘æ˜¯è¯´ï¼Œ é•¿çš„ )è¿˜æœ‰ -é”®æ‰©å±• å¯ä»¥ç”¨åœ¨æœ‰å¤åˆé”®çš„Grainsä¸Šã€‚ æ­¤cmdletè¿”å›ä½œä¸ºä¸Šçš„å‚æ•°ä¼ é€’çš„ç±»å‹çš„Grainå¼•ç”¨ -Grain æ˜¯çš„ã€‚ ä¾‹å­ï¼š ä¸€ä¸ªç®€å•çš„è°ƒç”¨ç¤ºä¾‹ MyInterfacesNamespace.IMyGrain.SayHeloTo grainsæ³•ï¼š PS> Import-Module OrleansPSUtils PS> $configFilePath = Resolve-Path(\".\\ClientConfig.xml\").Path PS> Start-GrainClient -ConfigFilePath $configFilePath PS> Add-Type -Path .\\MyGrainInterfaceAssembly.dll PS> $grainInterfaceType = [MyInterfacesNamespace.IMyGrain] PS> $grainId = [System.Guid]::Parse(\"A4CF7B5D-9606-446D-ACE9-C900AC6BA3AD\") PS> $grain = Get-Grain -GrainType $grainInterfaceType -GuidKey $grainId PS> $message = $grain.SayHelloTo(\"Gutemberg\").Result PS> Write-Output $message Hello Gutemberg! PS> Stop-GrainClient æˆ‘ä»¬è®¡åˆ’æ›´æ–°è¿™ä¸ªé¡µé¢ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨powershellä¸Šå¼•å…¥äº†æ›´å¤šçš„cmdletï¼Œå¦‚useobservatorsã€streamså’Œå…¶ä»–orleansæ ¸å¿ƒç‰¹æ€§ã€‚æˆ‘ä»¬å¸Œæœ›è¿™èƒ½å¸®åŠ©äººä»¬æˆä¸ºè‡ªåŠ¨åŒ–çš„èµ·ç‚¹ã€‚ä¸€å¦‚æ—¢å¾€ï¼Œè¿™æ˜¯ä¸€é¡¹æ­£åœ¨è¿›è¡Œçš„å·¥ä½œï¼Œæˆ‘ä»¬çƒ­çˆ±è´¡çŒ®ï¼ï¼š) è¯·æ³¨æ„ï¼Œç›®çš„ä¸æ˜¯åœ¨powershellä¸Šé‡æ–°å®ç°æ•´ä¸ªå®¢æˆ·ç«¯ï¼Œè€Œæ˜¯ç»™itå’Œdevopså›¢é˜Ÿä¸€ç§ä¸grainsäº¤äº’çš„æ–¹å¼ï¼Œè€Œæ— éœ€å®ç°ä¸€ä¸ª.netåº”ç”¨ç¨‹åºã€‚"
  },
  "Documentation/clusters_and_clients/heterogeneous_silos.html": {
    "href": "Documentation/clusters_and_clients/heterogeneous_silos.html",
    "title": "Heterogeneous silos | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "éå‡è´¨silos æ¦‚è¿° åœ¨ç»™å®šçš„é›†ç¾¤ä¸Šï¼Œsiloså¯ä»¥æ”¯æŒä¸€ç»„ä¸åŒçš„Grainsç±»å‹ï¼š åœ¨æœ¬ä¾‹ä¸­ï¼Œé›†ç¾¤æ”¯æŒç±»å‹ä¸º ä¸€ æˆ‘æ˜¯è¯´ï¼Œ ä¹™ æˆ‘æ˜¯è¯´ï¼Œ Cç±» ï¼Œè¯· ä¸ æˆ‘æ˜¯è¯´ï¼Œ Eç±» ï¼š grainsç±»å‹ ä¸€ å’Œ ä¹™ å¯å­˜å‚¨åœ¨silos1å’Œ2ä¸Šã€‚ grainsç±»å‹ Cç±» å¯å­˜å‚¨åœ¨silos1ã€2æˆ–3ä¸Šã€‚ grainsç±»å‹ ä¸ åªèƒ½æ”¾åœ¨silos3ä¸Š grainsç±»å‹ Eç±» åªèƒ½å­˜å‚¨åœ¨silos4ä¸Šã€‚ æ‰€æœ‰çš„siloséƒ½åº”è¯¥å¼•ç”¨é›†ç¾¤çš„æ‰€æœ‰Grainsç±»å‹çš„æ¥å£ï¼Œä½†æ˜¯Grainsç±»åº”è¯¥åªè¢«å°†æ‰¿è½½å®ƒä»¬çš„siloså¼•ç”¨ã€‚ å®¢æˆ·ç«¯ä¸çŸ¥é“å“ªä¸ªsilosæ”¯æŒç»™å®šçš„Grainsç±»å‹ã€‚ ç»™å®šçš„Grainsç±»å‹å®ç°åœ¨æ”¯æŒå®ƒçš„æ¯ä¸ªsilosä¸Šå¿…é¡»ç›¸åŒã€‚ä»¥ä¸‹æ–¹æ¡ˆæ— æ•ˆï¼š åœ¨silos1å’Œ2ä¸Šï¼š public class C: Grain, IMyGrainInterface { public Task SomeMethod() { â€¦ } } åœ¨silos3ä¸Š public class C: Grain, IMyGrainInterface, IMyOtherGrainInterface { public Task SomeMethod() { â€¦ } public Task SomeOtherMethod() { â€¦ } } é…ç½® ä¸éœ€è¦é…ç½®ï¼Œæ‚¨å¯ä»¥åœ¨é›†ç¾¤ä¸­çš„æ¯ä¸ªsilosä¸Šéƒ¨ç½²ä¸åŒçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ä½†æ˜¯ï¼Œå¦‚æœéœ€è¦ï¼Œå¯ä»¥æ›´æ”¹siloå’Œå®¢æˆ·ç«¯æ£€æŸ¥å±æ€§æ”¯æŒçš„ç±»å‹æ›´æ”¹çš„é—´éš” ç±»å‹æ˜ å°„åˆ·æ–°é—´éš” ä» ç±»å‹ç®¡ç†é€‰é¡¹ å‡ºäºæµ‹è¯•ç›®çš„ï¼Œå¯ä»¥ä½¿ç”¨å±æ€§ æ’é™¤é›¨æ°´ç±»å‹ åœ¨é‡Œé¢ GrainClassé€‰é¡¹ ï¼Œè¿™æ˜¯è¦åœ¨silosä¸Šæ’é™¤çš„ç±»å‹çš„åˆ—è¡¨åç§°ã€‚ é™åˆ¶ å¦‚æœå—æ”¯æŒçš„Grainç±»å‹é›†å‘ç”Ÿæ›´æ”¹ï¼Œåˆ™ä¸ä¼šé€šçŸ¥å·²è¿æ¥çš„å®¢æˆ·ç«¯ã€‚åœ¨å‰é¢çš„ç¤ºä¾‹ä¸­ï¼š å¦‚æœsilo 4ç¦»å¼€é›†ç¾¤ï¼Œå®¢æˆ·ç«¯ä»å°†å°è¯•è°ƒç”¨ç±»å‹ä¸ºgrainçš„ Eç±» æ˜¯çš„ã€‚å®ƒå°†åœ¨è¿è¡Œæ—¶å¤±è´¥ï¼Œå¹¶å¸¦æœ‰orleansexceptionã€‚ å¦‚æœå®¢æˆ·ç«¯æ˜¯åœ¨silos4åŠ å…¥ç¾¤é›†ä¹‹å‰è¿æ¥åˆ°ç¾¤é›†çš„ï¼Œåˆ™å®¢æˆ·ç«¯å°†æ— æ³•è°ƒç”¨ç±»å‹ä¸º Eç±» æ˜¯çš„ã€‚å®ƒä¼šå¤±è´¥çš„ ä¸æ”¯æŒæ— çŠ¶æ€grainsï¼šé›†ç¾¤ä¸­çš„æ‰€æœ‰siloså¿…é¡»æ”¯æŒåŒä¸€ç»„æ— çŠ¶æ€grainsã€‚"
  },
  "Documentation/clusters_and_clients/silo_lifecycle.html": {
    "href": "Documentation/clusters_and_clients/silo_lifecycle.html",
    "title": "Silo Lifecycle | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "silosç”Ÿå‘½å‘¨æœŸ æ¦‚è¿° Orleanssilosä½¿ç”¨å¯è§‚å¯Ÿçš„ç”Ÿå‘½å‘¨æœŸ(å‚è§ Orleansç”Ÿå‘½å‘¨æœŸ )ç”¨äºOrleansç³»ç»Ÿå’Œåº”ç”¨å±‚ç»„ä»¶çš„æœ‰åºå¯åŠ¨å’Œå…³é—­ã€‚ é˜¶æ®µ Orleanssiloså’Œé›†ç¾¤å®¢æˆ·ç«¯ä½¿ç”¨ä¸€ç»„å…¬å…±çš„æœåŠ¡ç”Ÿå‘½å‘¨æœŸé˜¶æ®µã€‚ public static class ServiceLifecycleStage { public const int First = int.MinValue; public const int RuntimeInitialize = 2000; public const int RuntimeServices = 4000; public const int RuntimeStorageServices = 6000; public const int RuntimeGrainServices = 8000; public const int ApplicationServices = 10000; public const int BecomeActive = Active-1; public const int Active = 20000; public const int Last = int.MaxValue; } æœåŠ¡ç”Ÿå‘½å‘¨æœŸçš„ç¬¬ä¸€é˜¶æ®µ è¿è¡Œæ—¶åˆå§‹åŒ–-åˆå§‹åŒ–è¿è¡Œæ—¶ç¯å¢ƒã€‚silosåˆå§‹åŒ–çº¿ç¨‹ã€‚ runtime services-å¯åŠ¨è¿è¡Œæ—¶æœåŠ¡ã€‚siloåˆå§‹åŒ–ç½‘ç»œå’Œå„ç§ä»£ç†ã€‚ RuntimeStorageServices-åˆå§‹åŒ–è¿è¡Œæ—¶å­˜å‚¨ã€‚ runtimegrainservices-å¯åŠ¨grainsçš„è¿è¡Œæ—¶æœåŠ¡ã€‚è¿™åŒ…æ‹¬Grainsç±»å‹ç®¡ç†ã€æˆå‘˜æœåŠ¡å’ŒGrainsç›®å½•ã€‚ åº”ç”¨æœåŠ¡â€“åº”ç”¨å±‚æœåŠ¡ã€‚ å˜ä¸ºæ´»åŠ¨-silosåŠ å…¥ç¾¤é›†ã€‚ æ´»åŠ¨â€”silosåœ¨ç¾¤é›†ä¸­å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œå¹¶å‡†å¤‡æ¥å—å·¥ä½œè´Ÿè½½ã€‚ æœåŠ¡ç”Ÿå‘½å‘¨æœŸçš„æœ€åé˜¶æ®µ ç™»å½•ä¸­ ç”±äºæ§åˆ¶æƒå€’ç½®ï¼Œå‚ä¸è€…åŠ å…¥ç”Ÿå‘½å‘¨æœŸï¼Œè€Œä¸æ˜¯å…·æœ‰ä¸€äº›é›†ä¸­çš„åˆå§‹åŒ–æ­¥éª¤é›†çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤ä»£ç ä¸­å¹¶ä¸æ€»æ˜¯æ¸…æ¥šå¯åŠ¨/å…³é—­é¡ºåºæ˜¯ä»€ä¹ˆã€‚ä¸ºäº†å¸®åŠ©è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåœ¨siloså¯åŠ¨ä¹‹å‰æ·»åŠ äº†æ—¥å¿—è®°å½•ï¼Œä»¥æŠ¥å‘Šæ¯ä¸ªé˜¶æ®µå‚ä¸çš„ç»„ä»¶ã€‚è¿™äº›æ—¥å¿—è®°å½•åœ¨ Orleans.Runtime.SiloLifecycleSubject è®°å½•å‘˜ã€‚ä¾‹å¦‚ï¼š ä¿¡æ¯ï¼Œorleans.runtime.silolifecyclesubjectï¼Œâ€œé˜¶æ®µ2000:orleans.statistics.perfcounterevironmentstatisticsï¼Œorleans.runtime.insideruntimeclientï¼Œorleans.runtime.siloâ€ ä¿¡æ¯ï¼Œorleans.runtime.silolifecyclesubjectï¼Œâ€œstage 4000:orleans.runtime.siloâ€ ä¿¡æ¯ï¼Œorleans.runtime.silolifecyclesubjectï¼Œâ€œé˜¶æ®µ10000:orleans.runtime.versions.grainversionstoreï¼Œorleans.storage.azuretablegrainstorage-defaultï¼Œorleans.storage.azuretablegrainstorage pubstoreâ€ æ­¤å¤–ï¼Œå¯¹æ¯ä¸ªç»„ä»¶çš„å®šæ—¶å’Œé”™è¯¯ä¿¡æ¯ä¹Ÿè¿›è¡Œäº†ç±»ä¼¼çš„é€çº§è®°å½•ã€‚ä¾‹å¦‚ï¼š ä¿¡æ¯ï¼Œorleans.runtime.silolifecyclesubjectï¼Œâ€œç”Ÿå‘½å‘¨æœŸè§‚å¯Ÿè€…orleans.runtime.insideruntimeclientåœ¨2000é˜¶æ®µå¯åŠ¨ï¼Œè€—æ—¶33æ¯«ç§’ã€‚â€ ä¿¡æ¯ï¼Œorleans.runtime.silolifecyclesubjectï¼Œâ€œç”Ÿå‘½å‘¨æœŸè§‚å¯Ÿè€…orleans.statistics.perfcounterenvironmentstatisticså¼€å§‹äº2000é˜¶æ®µï¼Œè€—æ—¶17æ¯«ç§’ã€‚â€ silosç”Ÿå‘½å‘¨æœŸå‚ä¸ åº”ç”¨ç¨‹åºé€»è¾‘å¯ä»¥é€šè¿‡åœ¨silosçš„æœåŠ¡å®¹å™¨ä¸­æ³¨å†Œå‚ä¸æœåŠ¡æ¥å‚ä¸silosçš„ç”Ÿå‘½å‘¨æœŸã€‚æœåŠ¡å¿…é¡»æ³¨å†Œä¸ºILifecycleParticipant æ˜¯çš„ã€‚ public interface ISiloLifecycle : ILifecycleObservable { } public interface ILifecycleParticipant<TLifecycleObservable> where TLifecycleObservable : ILifecycleObservable { void Participate(TLifecycleObservable lifecycle); } siloså¯åŠ¨æ—¶ï¼Œæ‰€æœ‰å‚ä¸è€…( å¾ªç¯å‚ä¸äºº<Isilifecycle> )åœ¨å®¹å™¨ä¸­ï¼Œå°†æœ‰æœºä¼šé€šè¿‡è°ƒç”¨ å‚ä¸(â€¦) è¡Œä¸ºã€‚ä¸€æ—¦æ‰€æœ‰äººéƒ½æœ‰æœºä¼šå‚ä¸ï¼Œsilosçš„å¯è§‚æµ‹ç”Ÿå‘½å‘¨æœŸå°†ä¾æ¬¡å¼€å§‹æ‰€æœ‰é˜¶æ®µã€‚ ä¾‹å­ éšç€siloç”Ÿå‘½å‘¨æœŸçš„å¼•å…¥ï¼Œç”¨äºå…è®¸åº”ç”¨ç¨‹åºå¼€å‘äººå‘˜åœ¨æä¾›ç¨‹åºåˆå§‹åŒ–é˜¶æ®µæ³¨å…¥é€»è¾‘çš„å¼•å¯¼æä¾›ç¨‹åºä¸å†æ˜¯å¿…éœ€çš„ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºé€»è¾‘ç°åœ¨å¯ä»¥åœ¨siloå¯åŠ¨çš„ä»»ä½•é˜¶æ®µæ³¨å…¥ã€‚å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ·»åŠ äº†ä¸€ä¸ªâ€œå¯åŠ¨ä»»åŠ¡â€fa_adeæ¥å¸®åŠ©ä½¿ç”¨å¼•å¯¼æä¾›ç¨‹åºçš„å¼€å‘äººå‘˜è¿›è¡Œè½¬æ¢ã€‚ä½œä¸ºå¦‚ä½•å¼€å‘å‚ä¸silosç”Ÿå‘½å‘¨æœŸçš„ç»„ä»¶çš„ç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹å¯åŠ¨ä»»åŠ¡fa_adeã€‚ å¯åŠ¨ä»»åŠ¡åªéœ€è¦ç»§æ‰¿è‡ª å¾ªç¯å‚ä¸äºº<Isilifecycle> å¹¶åœ¨æŒ‡å®šé˜¶æ®µå°†åº”ç”¨ç¨‹åºé€»è¾‘è®¢é˜…åˆ°silosç”Ÿå‘½å‘¨æœŸã€‚ class StartupTask : ILifecycleParticipant<ISiloLifecycle> { private readonly IServiceProvider serviceProvider; private readonly Func<IServiceProvider, CancellationToken, Task> startupTask; private readonly int stage; public StartupTask( IServiceProvider serviceProvider, Func<IServiceProvider, CancellationToken, Task> startupTask, int stage) { this.serviceProvider = serviceProvider; this.startupTask = startupTask; this.stage = stage; } public void Participate(ISiloLifecycle lifecycle) { lifecycle.Subscribe<StartupTask>( this.stage, cancellation => this.startupTask(this.serviceProvider, cancellation)); } } ä»ä¸Šé¢çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨startuptaskçš„ å‚ä¸(â€¦) è°ƒç”¨å®ƒè®¢é˜…é…ç½®é˜¶æ®µçš„silosç”Ÿå‘½å‘¨æœŸï¼Œä¼ é€’åº”ç”¨ç¨‹åºå›è°ƒï¼Œè€Œä¸æ˜¯å®ƒè‡ªå·±çš„åˆå§‹åŒ–é€»è¾‘ã€‚ éœ€è¦åœ¨ç»™å®šé˜¶æ®µåˆå§‹åŒ–çš„ç»„ä»¶å°†æä¾›è‡ªå·±çš„å›è°ƒï¼Œä½†æ¨¡å¼æ˜¯ç›¸åŒçš„ã€‚ ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªstartuptaskï¼Œå®ƒå°†ç¡®ä¿åœ¨é…ç½®é˜¶æ®µè°ƒç”¨åº”ç”¨ç¨‹åºçš„é’©å­ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿startuptaskå‚ä¸ç«–äº•ç”Ÿå‘½å‘¨æœŸã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨å®¹å™¨ä¸­æ³¨å†Œå®ƒã€‚ æˆ‘ä»¬ä½¿ç”¨silohostæ„å»ºå™¨ä¸Šçš„æ‰©å±•å‡½æ•°æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ public static ISiloHostBuilder AddStartupTask( this ISiloHostBuilder builder, Func<IServiceProvider, CancellationToken, Task> startupTask, int stage = ServiceLifecycleStage.Active) { builder.ConfigureServices(services => services.AddTransient<ILifecycleParticipant<ISiloLifecycle>>(sp => new StartupTask( sp, startupTask, stage))); return builder; } é€šè¿‡åœ¨silosçš„æœåŠ¡å®¹å™¨ä¸­å°†startuptaskæ³¨å†Œä¸ºæ ‡è®°æ¥å£ å¾ªç¯å‚ä¸äºº<Isilifecycle> ï¼Œè¿™å‘siloså‘å‡ºä¿¡å·ï¼Œè¡¨æ˜æ­¤ç»„ä»¶éœ€è¦å‚ä¸silosçš„ç”Ÿå‘½å‘¨æœŸã€‚"
  },
  "1.5/Documentation/Samples-Overview/Chirper.html": {
    "href": "1.5/Documentation/Samples-Overview/Chirper.html",
    "title": "Chirper | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Chirper A simple social network pub/sub system, with short text messages being sent between users. Publishers send out short \"Chirp\" messages (not to be confused with \"Tweets\", for a variety of legal reasons! ;) to any other users that are following them. Instructions Build Chirper.sln Start your local Silo from a command window using command file #1. The loader script, #2 Start the Chirper client #3 Start a second Chirper client as a publisher #4 Type a comment into the publisher client window, and see it displayed on the other client console window. Overview The NetworkLoader program reads a graphml data file containing a description of a network of Users and Followers. The NetworkLoader program sets up a network of ChirperAccount (aka \"users\") grains based on the input data file, one grain for each user defined in the network. It then creates the follower links between those users by calling the FollowUserId method on the appropriate user grain. For this demo, we use a simplified network of 1,000 Users with a total of 27,000 Follower links connecting those Users, but other network data files can be created with the NetworkGenerator program, or with a normal text / XML editor. The ChirperClient program connects to the Chirper network as a user specified on the cmd line. It then listens for any new Chirps that might be sent out by the other users they follow. When you type a comment into the publisher window, the text is sent as a Chirp message to all followers of that user, including the first client console window, as well as being echo'ed on the publisher's window. Why Orleans? Orleans allows the network of Chirper users to be described via very simple C# code whilst allowing it to easily scale out to handle increasing number of users and volume of chirp messages. How is it modeled? Chirper users are modeled as grains, which provides a very natural mapping of concepts. These grains allow to distribute the load for handling the message throughput, with each grain handling the forwarding of messages generated by that user to any other users that are following them. The grains implement three different grain interfaces to represent the three functional facets of those entities -- IChirperPublisher , IChirperSubscriber and IChirperAccount There is also an IChirperViewer observer interface for applications to subscribe for status changes from a particular Chirper user without becoming a Follower. This observer interface is typically used when writing client UI applications such as ChirperClient . Things for you to do if you are so inclined: Connect more clients to see the Chirper broadcast behavior. Make the network of users much bigger. Make the rate of generating messages higher."
  },
  "1.5/Documentation/Samples-Overview/Adventure.html": {
    "href": "1.5/Documentation/Samples-Overview/Adventure.html",
    "title": "Adventure | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Adventure A simple multiplayer text adventure game inspired by old-fashioned, text-based adventure games. Instructions: Build Adventure.sln Start your local Silo from a command window using command file #1. The game map initialization script, #2 Start the client #3 Reminisce about the good old days before graphical user interfaces Overview The AdventureSetup program reads a game description (\"map\") from AdventureConfig.txt. It sets up a series of \"rooms\" e.g. forest, beach, caves, a clearing etc . These locations are connected to other rooms to model the places and layout of the game. The sample configuration describes only a handful of locations. Rooms can contain \"things\" such as keys, swords etc. The AdventureClient program sets up your player and provides a simple text based user interface to allow you to play the game. You can move around rooms and interact with things using a simple command language, saying things such as \"go north\" or \"take brass key\". Why Orleans? Orleans allows the game to be described via very simple C# code while allowing it to scale to a massive multiplayer game. For this motivation to be meaningful, the labyrinth of rooms needs to be very large and need to support a large number of simultaneous players. One value of Orleans is that the service can be designed for growth, the overhead of running it at a small scale is not significant, and you can remain confident that it will scale if the need arises. How is it modeled? Player and Rooms are modeled as grains. These grains allow us to distribute the game with each grain modelling state and functionality. Things such as keys are modeled as plain old objects - they are really just simple immutable data structures that move around rooms and among players; they don't need to be grains. Things for you to do if you are so inclined Make the map much, much, bigger Make the brass key unlock something Allow players to message each other Make eating food and drinking water possible and meaningful"
  },
  "1.5/Documentation/Samples-Overview/Hello-World.html": {
    "href": "1.5/Documentation/Samples-Overview/Hello-World.html",
    "title": "Hello World | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Hello World In this sample, a client connects with an Orleans grain instance, sends it a greeting and receives a greeting back. The client then prints that greeting and that's that. Simple enough in theory, but since there's distribution involved, there's a bit more to it. There are three projects involved -- one for declaring the communication interfaces, one for the grain implementations, and one for the client, which also hosts the Orleans silo that loads the grain when activated. There's only one communication interface, in IHello.cs: public interface IHello : Orleans.IGrainWithIntegerKey { Task<string> SayHello(string greeting); } This is simple enough, and we can see that all replies must be represented as a Task or Task in communication interfaces. The implementation, found in HelloGrain.cs, is similarly trivial: public class HelloGrain : Orleans.Grain, HelloWorldInterfaces.IHello { Task<string> HelloWorldInterfaces.IHello.SayHello(string greeting) { return Task.FromResult(\"You said: '\" + greeting + \"', I say: Hello!\"); } } The class inherits from an Orleans-defined base class, and implements the communication interface defined earlier. Since there is nothing that the grain needs to wait on, the method is not declared async and instead returns its value using Task.FromResult() . The client, which orchestrates the grain code and is found in Program.cs, looks like this: Orleans.GrainClient.Initialize(\"DevTestClientConfiguration.xml\"); var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Console.WriteLine(\"\\n\\n{0}\\n\\n\", friend.SayHello(\"Good morning!\").Result); There's other code in the method, too, but that is unrelated to the client logic, it's hosting the Orleans silo."
  },
  "1.5/Documentation/Deployment-and-Operations/Docker-Deployment.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Docker-Deployment.html",
    "title": "Docker Deployment | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Docker Deployment Note : Even if you are very familiar with Docker and/or Orleans, as any other Orleans documentation, I recommend you to read it to the end in order to avoid problems you may face that we already worked around. Note : This article and its sample are a work in progress. Any feedback, PR or suggestion is very welcome. Deploying Orleans solutions to Docker Deploying Orleans to Docker can be tricky given the way Docker orchestrators and clustering stacks was designed. The most complicated thing is to understand the concept of Overlay Network from Docker Swarm and Kubernets Networking model. Docker containers and networking model were designed to run mostly stateless and immutable containers. So, spin up a cluster running node.js or nginx applications, is pretty easy. However, if you try to use something more elaborated, like a real clustered or distributed application (like Orleans-based ones) you will eventually have troubles setting it up. It is possible, but not as simples as web-based applications. Docker clustering consist of putting together multiple hosts to work as a single pool of resources managed using a Container Orchestrator . Docker Inc. provide Swarm as their option for Container Orchestration while Google has Kubernetes (aka K8s ). There are other Orchestrators like DC/OS , Mesos , etc., but in this document we will talk about Swarm and K8s as they are more widely used. The same grain interfaces and implementation which run anywhere Orleans is already supported, will run on Docker containers as well, so no special considerations are needed in order to be able to run your application in Docker containers. The Orleans-Docker sample provides a working example of how to run two console applications. One as Orleans Client and another as Silo, and the details are described below. The concepts discussed here, can be used on both .Net Core and .Net 4.6.1 flavors of Orleans but to ilustrate the cross-platform nature of Docker and .Net Core, we are going to focus on the example considering you are using .Net Core. Platform-specific (Windows/Linux/OSX) details may be provide along this article. Pre-requisites This article assume that you have the following prerequisites installed: Docker - Docker4X has a easy-to-use installer for the major supported platforms. It contains Docker engine and also Docker Swarm. Kubernetes (K8s) - Google's offer for Container Orchestration. It contains a guidance to install Minikube (a local deployment of K8s) and kubectl along with all its dependencies. .Net Core - Cross-platform flavor of .Net Visual Studio Code (VSCode) - You can use whatever IDE you want. VSCode is cross-platform so we are using it to ensure it works on all platforms. Once you installed VSCode, install the C# extension . Note : You are not required to have Kubernetes installed if you are not going to use it. Docker4X installer already includes Swarm so no extra installation is required to use it. Note for Windows Users : On Windows, Docker installer will enable Hyper-V at installation process. As this article and its examples are using .Net Core, the container images used are based on Windows Server NanoServer . If you don't plan to use .Net Core and will target .Net 4.6.1 full framework, the image used should be Windows Server Core and the 1.4+ version of Orleans (which support only .net full framework). Creating Orleans Solution The following instructions show how to create a regular Orleans solution using the new dotnet tooling. Note : Please adapt the commands to whatever appropriate in your platform. Also, the directory structure is just a suggestion. Please adapt it whatever way you want. mkdir Orleans-Docker cd Orleans-Docker dotnet new sln mkdir -p src/OrleansSilo mkdir -p src/OrleansClient mkdir -p src/OrleansGrains mkdir -p src/OrleansGrainInterfaces dotnet new console -o src/OrleansSilo --framework netcoreapp1.1 dotnet new console -o src/OrleansClient --framework netcoreapp1.1 dotnet new classlib -o src/OrleansGrains --framework netstandard1.5 dotnet new classlib -o src/OrleansGrainInterfaces --framework netstandard1.5 dotnet sln add src/OrleansSilo/OrleansSilo.csproj dotnet sln add src/OrleansClient/OrleansClient.csproj dotnet sln add src/OrleansGrains/OrleansGrains.csproj dotnet sln add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansClient/OrleansClient.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansGrains/OrleansGrains.csproj reference src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj dotnet add src/OrleansSilo/OrleansSilo.csproj reference src/OrleansGrains/OrleansGrains.csproj What we did so far was just boilerplate code to create the solution structure, projects, and add references between projects. Nothing different than a regular Orleans project. By the time this article was written, Orleans 2.0 (which is the only version which support .Net Core and cross-platform) is in Technology Preview so its nugets are hosted in a MyGet feed and not published to Nuget.org official feed. In order to install the preview nugets, we will use dotnet cli forcing the source feed and version from MyGet: dotnet add src/OrleansClient/OrleansClient.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrainInterfaces/OrleansGrainInterfaces.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansGrains/OrleansGrains.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.Core -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet add src/OrleansSilo/OrleansSilo.csproj package Microsoft.Orleans.OrleansRuntime -s https://dotnet.myget.org/F/orleans-prerelease/api/v3/index.json -v 2.0.0-preview2-201705020000 dotnet restore Ok, now you have all the basic dependencies to run a simple Orleans application. Note that so far, nothing changed from your regular Orleans application. Now, lets add some code so we can do something with it. Implementing your Orleans Application Assuming that you are using VSCode , from the solution directory, run code . . That will open the directory in VSCode and load the solution. This is the solution structure we just created previously. We also added Program.cs , OrleansHostWrapper , IGreetingGrain and GreetingGrain files to the interfaces and grain projects respectively and here is the code for those files: IGreetingGrain.cs : using System; using System.Threading.Tasks; using Orleans; namespace OrleansGrainInterfaces { public interface IGreetingGrain : IGrainWithGuidKey { Task<string> SayHello(string name); } } GreetingGrain.cs : using System; using System.Threading.Tasks; using OrleansGrainInterfaces; namespace OrleansGrains { public class GreetingGrain : Grain, IGreetingGrain { public Task<string> SayHello(string name) { return Task.FromResult($\"Hello from Orleans, {name}\"); } } } OrleansHostWrapper.cs : using System; using System.Net; using Orleans.Runtime; using Orleans.Runtime.Configuration; using Orleans.Runtime.Host; namespace OrleansSilo { public class OrleansHostWrapper { private readonly SiloHost siloHost; public OrleansHostWrapper(ClusterConfiguration config) { siloHost = new SiloHost(Dns.GetHostName(), config); siloHost.LoadOrleansConfig(); } public int Run() { if (siloHost == null) { return 1; } try { siloHost.InitializeOrleansSilo(); if (siloHost.StartOrleansSilo()) { Console.WriteLine($\"Successfully started Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); return 0; } else { throw new OrleansException($\"Failed to start Orleans silo '{siloHost.Name}' as a {siloHost.Type} node.\"); } } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } public int Stop() { if (siloHost != null) { try { siloHost.StopOrleansSilo(); siloHost.Dispose(); Console.WriteLine($\"Orleans silo '{siloHost.Name}' shutdown.\"); } catch (Exception exc) { siloHost.ReportStartupError(exc); Console.Error.WriteLine(exc); return 1; } } return 0; } } } Program.cs (Silo): using System; using System.Collections.Generic; using System.Linq; using System.Net; using Orleans.Runtime.Configuration; namespace OrleansSilo { public class Program { private static OrleansHostWrapper hostWrapper; static int Main(string[] args) { int exitCode = InitializeOrleans(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); exitCode += ShutdownSilo(); return exitCode; } private static int InitializeOrleans() { var config = new ClusterConfiguration(); config.Globals.DataConnectionString = \"[AZURE STORAGE CONNECTION STRING HERE]\"; config.Globals.DeploymentId = \"Orleans-Docker\"; config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.AzureTable; config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable; config.Defaults.PropagateActivityId = true; config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any, 10400); config.Defaults.Port = 10300; var ips = Dns.GetHostAddressesAsync(Dns.GetHostName()).Result; config.Defaults.HostNameOrIPAddress = ips.FirstOrDefault()?.ToString(); hostWrapper = new OrleansHostWrapper(config); return hostWrapper.Run(); } private static int ShutdownSilo() { if (hostWrapper != null) { return hostWrapper.Stop(); } return 0; } } } Program.cs (client): using System; using System.Net; using System.Threading; using System.Threading.Tasks; using Orleans; using Orleans.Runtime.Configuration; using OrleansGrainInterfaces; namespace OrleansClient { class Program { private static IClusterClient client; private static bool running; static void Main(string[] args) { Task.Run(() => InitializeOrleans()); Console.ReadLine(); running = false; } static async Task InitializeOrleans() { var config = new ClientConfiguration(); config.DeploymentId = \"Orleans-Docker\"; config.PropagateActivityId = true; var hostEntry = await Dns.GetHostEntryAsync(\"orleans-silo\"); var ip = hostEntry.AddressList[0]; config.Gateways.Add(new IPEndPoint(ip, 10400)); Console.WriteLine(\"Initializing...\"); client = new ClientBuilder().UseConfiguration(config).Build(); await client.Connect(); running = true; Console.WriteLine(\"Initialized!\"); var grain = client.GetGrain<IGreetingGrain>(Guid.Empty); while(running) { var response = await grain.SayHello(\"Gutemberg\"); Console.WriteLine($\"[{DateTime.UtcNow}] - {response}\"); await Task.Delay(1000); } client.Dispose(); } } } We are not going into details about the grain implementation here since it is out of the scope of this article. Please check other documents related to it. Those files are essentially a minimal Orleans application and we will start from it to move forward with the remaining of this article. Note : In this article we are using OrleansAzureUtils membership provider but you can use any other already supported by Orleans. Dockerfile In order to create your container, Docker use images. For more details on how to create your own, you can check Docker documentation . In this article we are going to use official Microsoft images . Based on the target and development platforms, you need to pick the appropriate image. In this article, we are using microsoft/dotnet:1.1.2-sdk which is a linux-based image. You can use microsoft/dotnet:1.1.2-sdk-nanoserver for Windows for example. Pick one that suit your needs. Note for Windows users : As previously mentioned, to be cross-platform, we are using .Net Core and Orleans Technical preview 2.0 in this article. If you want to use Docker on Windows with the fully released Orleans 1.4+, you need to use the images that are based on Windows Server Core since NanoServer and Linux based images, only support .Net Core. Dockerfile.debug : FROM microsoft/dotnet:1.1.2-sdk ENV NUGET_XMLDOC_MODE skip WORKDIR /vsdbg RUN apt-get update \\ && apt-get install -y --no-install-recommends \\ unzip \\ && rm -rf /var/lib/apt/lists/* \\ && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg WORKDIR /app ENTRYPOINT [\"tail\", \"-f\", \"/dev/null\"] This dockerfile essentially download and install the VSdbg debugger and start an empty container and keep it alive forever so we don't need tear down/up while debugging. Now, for production, the image is smaller since it contains only the .Net Core runtime and not the whole SDK, and the dockerfile is a bit simpler: Dockerfile : FROM microsoft/dotnet:1.1.2-runtime WORKDIR /app ENTRYPOINT [\"dotnet\", \"OrleansSilo.dll\"] COPY . /app docker-compose The docker-compose.yml file, essentially pack up within a project a set of services and its dependencies at service level. Each service contains one or more instances of a given container, which is based on the images you selected on your Dockerfile. More details on the docker-compose you you can find on docker-compose documentation . For an Orleans deployment, a common use case is to have a docker-compose.yml which contains two services. One for Orleans Silo, and other for Orleans Client. The Client would have a dependency on the Silo and that means, it will only start after the Silo service is up. Another case is to add a storage/database service/container, like for example SQL Server, which should start first before the client and the silo, so both services should take a dependency on it. Note : Before you read further (and eventually get crazy with it), please note that identation matters in docker-compose files. So pay attention to it if you have any problem. Here is how we will describe our services for this article: docker-compose.override.yml (Debug): version: '3.1' services: orleans-client: image: orleans-client:debug build: context: ./src/OrleansClient/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansClient/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro depends_on: - orleans-silo orleans-silo: image: orleans-silo:debug build: context: ./src/OrleansSilo/bin/PublishOutput/ dockerfile: Dockerfile.Debug volumes: - ./src/OrleansSilo/bin/PublishOutput/:/app - ~/.nuget/packages:/root/.nuget/packages:ro docker-compose.yml (production): version: '3.1' services: orleans-client: image: orleans-client depends_on: - orleans-silo orleans-silo: image: orleans-silo Note that in production, we don't map the local directory and neither we have the build: action. The reason is that in production, the images should be already being built and pushed to your own Docker Registry. Put everything together Now we have all the moving parts required to run your Orleans Application, we are going to put it together so we can run our Orleans solution inside Docker (Finally!). Note : The following commands should be performed from the solution directory. First, lets make sure we restore all NuGet packages from our solution. You only need to do it once. You are only required to do it again if you change any package dependency on your project. # dotnet restore Now, let's build our solution using dotnet CLI as usual and publish it to an output directory: # dotnet publish -o ./bin/PublishOutput Note : We are using publish here instead of build, to avoid problems with our dynamicaly loaded assemblied in Orleans. We are still looking for a better solution for it. With the application built and published, you need to build your Dockerfile images. This step is only required to be performed once per project and should be only performed again if you change the Dockerfil, docker-compose, or for any reason you cleaned up your local image registry. # docker-compose build All the images used in both Dockerfile and docker-compose.yml are pulled from the registry and cached on your development machine. Your images are built, and you are all set to run. Now lets run it! # docker-compose up -d Creating network \"orleansdocker_default\" with the default driver Creating orleansdocker_orleans-silo_1 ... Creating orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-client_1 ... Creating orleansdocker_orleans-client_1 ... done # Now if you run a docker-compose ps , you will see 2 containers running for the orleansdocker project: # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up Note for Windows users : If you are on Windows, and your container is using a Windows image as base, the Command column will show you the Powershell relative command to a tail on *NIX systems so the container will keep up the same way. Now that you have your containers up, you don't need to stop it every time you want to start your Orleans application. All you need is to integrate your IDE to debug the application inside the container which was previously mapped in your docker-compose.yml . Scaling Once you have your compose project running, you can easily scale up or down your application using docker-compose scale command: # docker-compose scale orleans-silo=15 Starting orleansdocker_orleans-silo_1 ... done Creating orleansdocker_orleans-silo_2 ... Creating orleansdocker_orleans-silo_3 ... Creating orleansdocker_orleans-silo_4 ... Creating orleansdocker_orleans-silo_5 ... Creating orleansdocker_orleans-silo_6 ... Creating orleansdocker_orleans-silo_7 ... Creating orleansdocker_orleans-silo_8 ... Creating orleansdocker_orleans-silo_9 ... Creating orleansdocker_orleans-silo_10 ... Creating orleansdocker_orleans-silo_11 ... Creating orleansdocker_orleans-silo_12 ... Creating orleansdocker_orleans-silo_13 ... Creating orleansdocker_orleans-silo_14 ... Creating orleansdocker_orleans-silo_15 ... Creating orleansdocker_orleans-silo_6 Creating orleansdocker_orleans-silo_5 Creating orleansdocker_orleans-silo_3 Creating orleansdocker_orleans-silo_2 Creating orleansdocker_orleans-silo_4 Creating orleansdocker_orleans-silo_9 Creating orleansdocker_orleans-silo_7 Creating orleansdocker_orleans-silo_8 Creating orleansdocker_orleans-silo_10 Creating orleansdocker_orleans-silo_11 Creating orleansdocker_orleans-silo_15 Creating orleansdocker_orleans-silo_12 Creating orleansdocker_orleans-silo_14 Creating orleansdocker_orleans-silo_13 Few seconds later, you will see the services scaled to the specific number of instances you requested. # docker-compose ps Name Command State Ports ------------------------------------------------------------------ orleansdocker_orleans-client_1 tail -f /dev/null Up orleansdocker_orleans-silo_1 tail -f /dev/null Up orleansdocker_orleans-silo_10 tail -f /dev/null Up orleansdocker_orleans-silo_11 tail -f /dev/null Up orleansdocker_orleans-silo_12 tail -f /dev/null Up orleansdocker_orleans-silo_13 tail -f /dev/null Up orleansdocker_orleans-silo_14 tail -f /dev/null Up orleansdocker_orleans-silo_15 tail -f /dev/null Up orleansdocker_orleans-silo_2 tail -f /dev/null Up orleansdocker_orleans-silo_3 tail -f /dev/null Up orleansdocker_orleans-silo_4 tail -f /dev/null Up orleansdocker_orleans-silo_5 tail -f /dev/null Up orleansdocker_orleans-silo_6 tail -f /dev/null Up orleansdocker_orleans-silo_7 tail -f /dev/null Up orleansdocker_orleans-silo_8 tail -f /dev/null Up orleansdocker_orleans-silo_9 tail -f /dev/null Up Note : The Command column on those examples are showing the tail command just because we are using the debugger container. If we were in production, it would be showing dotnet OrleansSilo.dll for example. Docker Swarm Docker clustering stack is called Swarm and you can find more by reading its documentation here . To run this article in a Swarm cluster, you don't have any extra work. When you run docker-compose up -d in a Swarm node, it will schedule containers based on the configured rules. The same applies to other Swarm-based services like Docker Datacenter , Azure ACS (in Swarm mode), AWS ECS Container Service and so on. All you need to do is to deploy your Swarm cluster before deploy your dockerized Orleans application. Note : If you are using a Docker engine with the Swarm mode that already have support to stack , deploy and compose v3, a better approach to deploy your solution would be docker stack deploy -c docker-compose.yml <name> . Just keep in mind that it requires v3 compose file support at your Docker engine and the majority of hosted services like Azure and AWS still use v2 and older engines. Google Kubernetes (K8s) If you plan to use Kubernetes to host Orleans, there is a community-maintained clustering provider available at OrleansContrib\\Orleans.Clustering.Kubernetes and there you can find documentation and samples on how to host Orleans in Kubernetes seamlessly using the provider. [Bonus topic] Debugging Orleans inside Containers Well, now that you know how to run Orleans in a container from scratch, would be good to leverage one of the most important principles in Docker. Containers are immutable. And they should have (almost) the same image, dependencies, and runtime in development as in production. That ensure the good old statement \"It work on my machine!\" never happen again. To make that possible, you need to have a way to develop inside the container and that includes have a debugger attached to your application inside the container. There are multiple ways to achieve that using multiple tools. After evaluate several, by the time I wrote this article, I ended up choosing one that looks more simple and is less intrusive in the application. As mentioned ealier in this article, we are using VSCode to develop the sample, so here is how to get the debugger attached to your Orleans Application inside the container. First, change two files inside your .vscode directory in your solution: tasks.json : { \"version\": \"0.1.0\", \"command\": \"dotnet\", \"isShellCommand\": true, \"args\": [], \"tasks\": [ { \"taskName\": \"publish\", \"args\": [ \"${workspaceRoot}/Orleans-Docker.sln\", \"-c\", \"Debug\", \"-o\", \"./bin/PublishOutput\" ], \"isBuildCommand\": true, \"problemMatcher\": \"$msCompile\" } ] } This file essentially tells VSCode that whenever you build the project, it will actually execute the publish command as we manually did earlier. launch.json : { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Silo\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansSilo.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansSilo\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-silo_1 /vsdbg/vsdbg --interpreter=vscode\" ] } }, { \"name\": \"Client\", \"type\": \"coreclr\", \"request\": \"launch\", \"cwd\": \"/app\", \"program\": \"/app/OrleansClient.dll\", \"sourceFileMap\": { \"/app\": \"${workspaceRoot}/src/OrleansClient\" }, \"pipeTransport\": { \"debuggerPath\": \"/vsdbg/vsdbg\", \"pipeProgram\": \"/bin/bash\", \"pipeCwd\": \"${workspaceRoot}\", \"pipeArgs\": [ \"-c\", \"docker exec -i orleansdocker_orleans-client_1 /vsdbg/vsdbg --interpreter=vscode\" ] } } ] } Now you can just build the solution from VSCode (which will publish) and start both the Silo and the Client. It will send a docker exec command to the running docker-compose service instance/container to start the debugger to the application and thats it. You have the debugger attached to the container and use it as if it was a locally running Orleans application. The difference now is that it is inside the container, and once you are done, you can just publish the container to your registry and pull it on your Docker hosts in production."
  },
  "1.5/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html": {
    "href": "1.5/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html",
    "title": "Heterogeneous silos | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Heterogeneous silos Overview On a given cluster, silos can support a different set of grain types: In this example the cluster support grain of type A , B , C , D , E : Grain types A and B can be placed on Silo 1 and 2. Grain type C can be placed on Silo 1, 2 or 3. Grain type D can be only placed on Silo 3 Grain Type E can be only placed on Silo 4. All silos should reference interfaces of all grain types of the cluster, but grain classes should only be referenced by the silos that will host them. The client does not know which silo support a given Grain Type. A given Grain Type implementation must be the same on each silo that support it. The following scenario is NOT valid: On Silo 1 and 2: public class C: Grain, IMyGrainInterface { public Task SomeMethod() { â€¦ } } On Silo 3 public class C: Grain, IMyGrainInterface, IMyOtherGrainInterface { public Task SomeMethod() { â€¦ } public Task SomeOtherMethod() { â€¦ } } Configuration No configuration is needed, you can deploy different binaries on each silo in your cluster. However, if necessary, you can change the interval that silos check for changes in types supported in ClusterConfig.Globals.TypeMapRefreshInterval . For testing purpose, you can use the property ExcludedGrainTypes in NodeConfiguration . In code based config you can find it in ClusterConfig.Defaults.ExcludedGrainTypes , which is a list names of the types you want to exclude. Limitations Connected clients will not be notified if the set of supported Grain Types changed. In the previous example: If Silo 4 leave the cluster, the client will still try to make calls to grain of type E . It will fail at runtime with a OrleansException. If the client was connected to the cluster before Silo 4 joined it, the client will not be able to make calls to grain of type E . It will fail will a ArgumentException Stateless grains is not supported: all silos in the cluster must support the same set of stateless grains."
  },
  "1.5/Documentation/Orleans-Streams/Streams-Quick-Start.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Quick-Start.html",
    "title": "Orleans Streams Quick Start | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Quick Start This guide will show you a quick way to setup and use Orleans Streams. To learn more about the details of the streaming features, read other parts of this documentation. Required Configurations In this guide we'll use a Simple Message based Stream which uses grain messaging to send stream data to subscribers. We will use the in-memory storage provider to store lists of subscriptions so it is not a wise choise for real production applications. <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"PubSubStore\" /> </StorageProviders> <StreamProviders> <Provider Type=\"Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider\" Name=\"SMSProvider\"/> </StreamProviders> Now we can create streams, send data using them as producers and also receive data as subscribers. Producing Events Producing events for streams is relatively easy. You should first get access to the stream provider which you defined in the config above ( SMSProvider ) and then choose a stream and push data to it. //Pick a guid for a chat room grain and chat room stream var guid = some guid identifying the chat room //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); As you can see our stream has a GUID and a namespace. This will make it easy to identify unique streams. For example, in a chat room namespace can \"Rooms\" and GUID be the owning RoomGrain's GUID. Here we use the GUID of some known chat room. Now using the OnNext method of the stream we can push data to it. Let's do it inside a timer and using random numbers. You could use any other data type for the stream as well. RegisterTimer(s => { return stream.OnNextAsync(new System.Random().Next()); }, null, TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000)); Subscribing and receiving streaming data For receiving data we can use implicit/explicit subscriptions, which are fully described in other pages of the manual. Here we use implicit subscriptions which are easier. When a grain type wants to implicitly subscribe to a stream it uses the attribute ImplicitStreamSubscription (namespace)] . For our case we'll define a ReceiverGrain like this: [ImplicitStreamSubscription(\"RANDOMDATA\")] public class ReceiverGrain : Grain, IRandomReceiver Now whenever some data is pushed to the streams of namespace RANDOMDATA as we have in the timer, a grain of type ReceiverGrain with the same guid of the stream will receive the message. Even if no activations of the grain currently exist, the runtime will automatically create a new one and send the message to it. In order for this to work however, we need to complete the subscription process by setting our OnNext method for receiving data. So our ReceiverGrain should call in its OnActivateAsync something like this //Create a GUID based on our GUID as a grain var guid = this.GetPrimaryKey(); //Get one of the providers which we defined in config var streamProvider = GetStreamProvider(\"SMSProvider\"); //Get the reference to a stream var stream = streamProvider.GetStream<int>(guid, \"RANDOMDATA\"); //Set our OnNext method to the lambda which simply prints the data, this doesn't make new subscriptions await stream.SubscribeAsync<int>(async (data, token) => Console.WriteLine(data)); We are all set now. The only requirement is that something triggers our producer grain's creation and then it will registers the timer and starts sending random ints to all interested parties. Again, this guide skips lots of details and is only good for showing the big picture. Read other parts of this manual and other resources on RX to gain a good understanding on what is available and how. Reactive programming can be a very powerful approach to solve many problems. You could for example use LINQ in the subscriber to filter numbers and do all sorts of interesting stuff. Next Orleans Streams Programming APIs"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Implementation.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Implementation.html",
    "title": "Orleans Streams Implementation Details | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Implementation Details This section provides a high level overview of Orleans Stream implementation. It describes concepts and details that are not visible on the application level. If you only plan to use streams, you do not have to read this section. However, if you plan to extend streams, please read this section before reading Streams Extensibility section . Terminology : We refer by the word \"queue\" to any durable storage technology that can ingest stream events and allows either to pull events or provides a push-based mechanism to consume events. Usually, to provide scalability, those technologies provide sharded/partitions queues. For example, Azure Queues allow to create multiple queues, Event Hubs have multiple hubs, Kafka topics, ... Persistent Streams All Orleans Persistent Stream Providers share a common implementation PersistentStreamProvider . This generic stream provider is parametrized with a technology specific IQueueAdapter . When stream producer generates a new stream item and calls stream.OnNext() , Orleans Streaming Runtime invokes the appropriate method on the IQueueAdapter of that stream provider that enqueues the item directly into an appropriate queue. Pulling Agents At the heart of the Persistent Stream Provider are the pulling agents. Pulling agents pull events from a set of durable queues and deliver them to the application code in grains that consumes them. One can think of the pulling agents as a distributed \"micro-service\" -- a partitioned, highly available, and elastic distributed component. The pulling agents run inside the same silos that host application grains and are fully managed by the Orleans Streaming Runtime. StreamQueueMapper and StreamQueueBalancer Pulling agents are parametrized with IStreamQueueMapper and StreamQueueBalancerType . IStreamQueueMapper provides a list of all queues and is also responsible for mapping streams to queues. That way, the producer side of the Persistent Stream Provider know which queue to enqueue the message into. StreamQueueBalancerType expresses the way queues are balanced across Orleans silos and agents. The goal is to assign queues to agents in a balanced way, to prevent bottlenecks and support elasticity. When new silo is added to the Orleans cluster, queues are automatically rebalanced across the old and new silos. StreamQueueBalancer allows to customize that process. Orleans has a number of built in StreamQueueBalancers, to support different balancing scenarios (large and small number of queues) and different environments (Azure, on prem, static). Pulling Protocol Every silo runs a set of pulling agents, every agent is pulling from one queue. Pulling agents themselves are implemented by the internal runtime component, called SystemTarget . SystemTargets are essentially runtime grains, are subject to single threaded concurrency, can use regular grain messaging and are as lightweight as grains. As opposite to grain, SystemTargets are not virtual: they are explicitly created (by the runtime) and are also not location transparent. By implementing pulling agents as SystemTargets Orleans Streaming Runtime can rely on a lot of built-in Orleans features and can also scale to a very large number of queues, since creating a new pulling agent is as cheap as creating a new grain. Every pulling agent runs periodic timer that pulls from the queue (by invoking IQueueAdapterReceiver ) GetQueueMessagesAsync() method. The returned messages are put in the internal per-agent data structure called IQueueCache . Every message is inspected to find out its destination stream. The agent uses the Pub Sub to find out the list of stream consumers that subscribed to this stream. Once the consumer list if retrieved, the agent stores it locally (in its pub-sub cache) so it does not need to consult with Pub Sub on every message. The agent also subscribes with the pub-sub to receive notification of any new consumers that subscribe to that stream. This handshake between the agent and the pub-sub guarantees strong streaming subscription semantics : once the consumer has subscribed to the stream it will see all events that were generated after it has subscribed (in addition, using StreamSequenceToken allows to subscribe in the past). Queue Cache IQueueCache is an internal per-agent data structure that allows to decouple bringing new events from the queue from delivering them to consumers. It also allows to decouple delivery to different streams and to different consumers. Imagine a situation when one stream has 3 stream consumers and one of them is slow. If care not taken, it is possible that this slow consumer will impact agent's progress, slowing the consumption of other consumers of that stream, and even potentially slowing the de-queuing and delivering of events for other stream. To prevent that and allow maximum parallelism in the agent, we use IQueueCache . IQueueCache buffers stream events and provides a way to the agent to deliver events to each consumer at its pace. The per-consumer delivery is implemented by the internal component called IQueueCacheCursor , which tracks per consumer progress. That way each consumer receives events at its own pace :fast consumers receive events as quickly as they are dequeued from the queue, while slow consumers receive them later on. Once the message was delivered to all consumers, it can be deleted from the cache. Backpressure Backpressure in Orleans Streaming Runtime applies in two places: bringing stream events from the queue to the agent and delivering the events from the agent to stream consumers . The latter is provided by the built-in Orleans messaging delivery mechanism. Every stream event is delivered from the agent to consumers via the standard Orleans grain messaging, one at a time. That is, the agents sends one event (or a limited size batch of events) to each individual stream consumer and awaits this call. The next event will not start being delivered until the Task for the previous event was resolved or broken. That way we naturally limit the per-consumer delivery rate to one message at a time. With regard to bringing stream events from the queue to the agent Orleans Streaming provides a new special Backpressure mechanism. Since the agent decouples de-queuing of events from the queue and delivering them to consumers, it is possible that a single slow consumer will fall behind so much that the IQueueCache will fill up. To prevent IQueueCache from growing indefinitely, we limit its size (the size limit is configurable). However, the agent never throws away undelivered events. Instead, when the cache starts to fill up, the agents slows the rate of dequeing events from the queue. That way, we can \"ride\" the slow delivery periods by adjusting the rate at which we consume from the queue (\"backpressure\") and get back into fast consumption rate later on. To detect the \"slow delivery\" valleys the IQueueCache uses an internal data structure of cache buckets that track the progress of delivery of events to individual stream consumer. This results in a very responsive and self-adjusting systems. Next Orleans Streams Extensibility"
  },
  "1.5/Documentation/Orleans-Streams/Stream-Providers.html": {
    "href": "1.5/Documentation/Orleans-Streams/Stream-Providers.html",
    "title": "Orleans Stream Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Stream Providers Streams can come in different shapes and forms. Some streams may deliver events over direct TCP links, while others deliver events via durable queues. Different stream types may use different batching strategies, different caching algorithms, or different back pressure procedures. We did not want to constrain streaming applications to only a small subset of those behavioral choices. Instead, Stream Providers are extensibility points to Orleans Streaming Runtime that allow users to implement any type of stream. This extensibility point is similar in spirit to Orleans Storage Providers . Orleans currently ships with two default stream providers: Simple Message Stream Provider and Azure Queue Stream Provider . Simple Message Stream Provider Simple Message Stream Provider, also known as the SMS provider, delivers events over TCP by utilizing regular Orleans grain messaging. Since events in SMS are delivered over unreliable TCP links, SMS does not guarantee reliable event delivery and does not automaticaly resend failed messages for SMS streams. The producer of the SMS stream has a way to know if his event was successfully received and processed or not: by default the call to stream.OnNextAsync returns a Task that represents the processing status of the stream consumer. If this Task fails, the producer can decide to send the same event again, thus achieving reliability on ther application level. Although individual stream messages delivery is best effort, SMS streams themselves are reliable. That is, the subscriber-to-producer binding performed by Pub Sub is fully reliable. Azure Queue (AQ) Stream Provider Azure Queue (AQ) Stream Provider delivers events over Azure Queues. On the producer side, AQ Stream Provider enqueues events directly into Azure Queue. On the consumer side, AQ Stream Provider manages a set of pulling agents that pull events from a set of Azure Queues and deliver them to application code that consumes them. One can think of the pulling agents as a distributed \"micro-service\" -- a partitioned, highly available, and elastic distributed component. The pulling agents run inside the same silos that host application grains. Thus, there is no need to run separate Azure worker roles to pull from the queues. The existence of pulling agents, their management, backpresure, balancing the queues between them, and handing off queues from a failed agent to another agent are fully managed by Orleans Streaming Runtime and are transparent to application code that uses streams. Queue Adapters Different stream providers that deliver events over durable queues exhibit similar behavior and are subject to a similar implementation. Therefore, we provide a generic extensible PersistentStreamProvider that allows developers to plug in different types of queues without writing a completely new stream provider from scratch. PersistentStreamProvider is parameterized with an IQueueAdapter , which abstracts specific queue implementation details and provides means to enqueue and dequeue events. All the rest is handled by the logic inside the PersistentStreamProvider . Azure Queue Provider mentioned above is also implemented this way: it is an instance of PersistentStreamProvider with AzureQueueAdapter . Next Orleans Streams Implementation Details"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Programming-APIs.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Programming-APIs.html",
    "title": "Orleans Streams Programming APIs | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Streams Programming APIs Applications interact with streams via APIs that are very similar to the well known Reactive Extensions (Rx) in .NET . The main difference is that Orleans stream extensions are asynchronous , to make processing more efficient in Orleans' distributed and scalable compute fabric. Async Stream An application starts by using a stream provider to get a handle to a stream. You can read more about stream providers here , but for now you can think of it as stream factory that allows implementers to customize streams behavior and semantics: IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(Guid, \"MyStreamNamespace\"); Application can get a reference to the stream provider either by calling the GetStreamProvider method on the Grain class when inside a grain, or by calling GrainClient.GetStreamProvider() method when on the client. Orleans.Streams.IAsyncStream<T> is a logical, strongly-typed handle to a virtual stream . It is similar in spirit to Orleans Grain Reference. Calls to GetStreamProvider and GetStream are purely local. The arguments to GetStream are a GUID and an additional string that we call a stream namespace (which can be null). Together the GUID and the namespace string comprise the stream identity (similar in sprit to the arguments to GrainFactory.GetGrain ). The combination of GUID and namespace string provide extra flexibility in determining stream identities. Just like grain 7 may exist within the Grain type PlayerGrain and a different grain 7 may exist within the grain type ChatRoomGrain , Stream 123 may exist with the stream namespace PlayerEventsStream and a different stream 123 may exist within the stream namespace ChatRoomMessagesStream . Producing and Consuming IAsyncStream<T> implements both Orleans.Streams.IAsyncObserver<T> and Orleans.Streams.IAsyncObservable<T> interfaces. That way an application can use the stream either to produce new events into the stream by using Orleans.Streams.IAsyncObserver<T> or to subscribe to and consume events from a stream by using Orleans.Streams.IAsyncObservable<T> . public interface IAsyncObserver<in T> { Task OnNextAsync(T item, StreamSequenceToken token = null); Task OnCompletedAsync(); Task OnErrorAsync(Exception ex); } public interface IAsyncObservable<T> { Task<StreamSubscriptionHandle<T>> SubscribeAsync(IAsyncObserver<T> observer); } To produce events into the stream, an application just calls await stream.OnNextAsync<T>(event) To subscribe to a stream, an application calls StreamSubscriptionHandle<T> subscriptionHandle = await stream.SubscribeAsync(IAsyncObserver) The argument to SubscribeAsync can either be an object that implements the IAsyncObserver interface or a combination of lambda functions to process incoming events. More options for SubscribeAsync are available via AsyncObservableExtensions class. SubscribeAsync returns a StreamSubscriptionHandle<T> , which is an opaque handle that can be used to unsubscribe from the stream (similar in spirit to an asynchronous version of IDisposable ). await subscriptionHandle.UnsubscribeAsync() It is important to note that the subscription is for a grain, not for an activation . Once the grain code subscribed to the stream, this subscription surpasses the life of this activation and stays durable forever, until the grain code (potentially in a different activation) explicitly unsubscribes. This is the heart of a virtual stream abstraction : not only all the streams always exists, logically, but also that a stream subscription is durable and lives beyond a particular physical activation that issued this subscription. Multiplicity An Orleans stream may have multiple producers and multiple consumers. A message published by a producer will be delivered to all consumers that were subscribed to the stream before the message was published. In addition, the consumer can subscribe to the same stream multiple times. Each time it subscribes it gets back a unique StreamSubscriptionHandle<T> . If a grain (or client) is subscribed X times to the same stream, it will receive the same event X times, once for each subscription. The consumer can also unsubscribe from an individual subscription or find out all its current subscriptions, by calling: IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() Recovering From Failures If the producer of a stream dies (or its grain is deactivated), there is nothing it needs to do. Next time this grain wants to produce more events it can get the stream handle again and produce new events in the same way. Consumer logic is a little bit more involved. As we said before, once consumer grain subscribed to a stream, this subscription is valid until it explicitly unsubscribes. If the consumer of the stream dies (or its grain is deactivated) and new event is generated on the stream, the consumer grain will be automatically re-activated (just like any regular Orleans grain is automatically activated upon message to it). The only thing that the grain code needs to do now is to provide a IAsyncObserver<T> to process the data. The consumer basically need to re-attach processing logic as part of OnActivateAsync method. To do that it can call: StreamSubscriptionHandle<int> newHandle = await subscriptionHandle.ResumeAsync(IAsyncObserver) The consumer uses the previous handle it got when it first subscribed in order to \"resume processing\". Notice that ResumeAsync merely updates an existing subscription with the new instance of IAsyncObserver logic and does not change the fact that this consumer is already subscribed to this stream. How the consumer has an old subscriptionHandle? There are 2 options. The consumer may have persisted the handle it was given back from the original SubscribeAsync operation and can use it now. Alternatively, if the consumer does not have the handle, it can ask the IAsyncStream<T> for all its active subscription handles, by calling: IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() The consumer can now resume all of them, or unsubscribe from some if he wishes to. COMMENT: If the consumer grain implements the the IAsyncObserver interface directly ( public class MyGrain<T> : Grain, IAsyncObserver<T> ), it should in theory not be required to re-attach the IAsyncObserver and thus will not need to call ResumeAsync . The streaming runtime should be able to automatically figure out that the grain already implements IAsyncObserver and will just invoke those IAsyncObserver methods. However, the streaming runtime currently does not support this and the grain code still needs to explicitly call ResumeAsync , even if the grain implements IAsyncObserver directly. Supporting this is on our TODO list. Explicit and Implicit Subscriptions By default, stream consumer has to explicitly subscribe to the stream. This subscription would usually be triggered by some external message that the grain (or client) receive that instructs them to subscribe. For example, in a chat service when user joins a chat room his grain receives a JoinChatGroup message with the chat name and it will cause the user grain to subscribe to this chat stream. In addition, Orleans Streams also support \"Implicit Subscriptions\" . In this model the grain does not explicitely subscribe to the stream. This grain is subscribed automatically, implicitly, just based on its grain identity and an ImplicitStreamSubscription attribute. Implicit subscriptions main value is allowing the stream activity to trigger the grain activation (hence triggering the subscription) automaticaly. For example, using SMS streams, if one grain wanted to produce a stream and another grain process this stream, the producer would need to know the identity of the consumer grain and make a grain call to it telling it to subscribe to the stream. Only after that it can start sending events. Instead, using implicit subscriptions, the producer can just start producing events onto a stream, and the consumer grain will automatically be activated and subscribe to the stream. In that case, the producer doesn't care at all who is reading the events Grain implementation class of type MyGrainType can declare an attribute [ImplicitStreamSubscription(\"MyStreamNamespace\")] . This tells the streaming runtime that when an event is generated on a stream whose identity is GUID XXX and \"MyStreamNamespace\" namespace, it should be delivered to grain whose identity is XXX of type MyGrainType . That is, the runtime maps stream <XXX, MyStreamNamespace> to consumer grain <XXX, MyGrainType> . The presence of ImplicitStreamSubscription causes the streaming runtime to automatically subscribe this grain to a stream and deliver the stream events to it. However, the grain code still needs to tell the runtime how it wants events to be processed. Essentially, it need to attach the IAsyncObserver . Therefore, when the grain is activated, the grain code inside OnActivateAsync needs to call: IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(this.GetPrimaryKey(), \"MyStreamNamespace\"); StreamSubscriptionHandle<T> subscription = await stream.SubscribeAsync(IAsyncObserver<T>); Writing Subscription Logic Below are the guidelines on how to write the subscription logic for various cases: explicit and implicit subscriptions, rewindable and non-rewindable streams. The main difference between explicit and implicit subscriptions is that for implicit the grain always has exactly one implicit subscription for every stream namespace, there is no way to create multiple subscriptions (there is no subscription multiplicity), there is no way to unsubscribe, and the grain logic always only needs to attach the processing logic. That also means that for implicit subscriptions there is never a need to Resume a subscription. On the other hand, for explicit subscriptions, one needs to Resume the subscription, otherwise if the grain subscribes again it will result in the grain being subscribed multiple times. Implicit Subscriptions: For implicit subscriptions the grain needs to subscribe to attach the processing logic. This should be done in the grain's OnActivateAsync method. The grain should simply execute await stream.SubscribeAsync(OnNext ...) in its OnActivateAsync method. That will cause this particular activation to attach the OnNext function to process that stream. The grain can optionally specify the StreamSequenceToken as an argument to SubscribeAsync , which will cause this implicit subscription to start consuming from that token. There is never a need for implicit subscription to call ResumeAsync . public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); await stream.SubscribeAsync(OnNextAsync) } Explicit Subscriptions: For explicit subscriptions, a grain must call SubscribeAsync to subscribe to the stream. This creates a subscription, as well as attaches the processing logic. The explicit subscription will exist until the grain unsubscribes, so if a grain gets deactivated and reactivated, the grain is still explicitly subscribed, but no processing logic will be attached. In this case the grain needs to re-attach the processing logic. To do that, in its OnActivateAsync , the grain first needs to find out what subscriptions it has, by calling stream.GetAllSubscriptionHandles() . The grain must execute ResumeAsync on each handle it wishes to continue processing or UnsubscribeAsync on any handles it is done with. The grain can also optionally specify the StreamSequenceToken as an argument to the ResumeAsync calls, which will cause this explicit subscription to start consuming from that token. public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); var subscriptionHandles = await stream.GetAllSubscriptionHandles(); if (!subscriptionHandles.IsNullOrEmpty()) subscriptionHandles.ForEach(async x => await x.ResumeAsync(OnNextAsync)); } Stream Order and Sequence Tokens The order of events delivery between an individual producer and an individual consumer depends on a stream provider. With SMS the producer explicitly controls the order of events seen by the consumer by controlling the way he publishes them. By default (if the FireAndForget options for SMS provider is set to false) and if the producer awaits every OnNextAsync call, the events arrive in FIFO order. In SMS it is up to the producer to decide how to handle delivery failures that will be indicated by a broken Task returned by the OnNextAsync call. Azure Queue streams do not guarantee FIFO order, since the underlying Azure Queues do not guarantee order in failure cases (they do guarantee FIFO order in failure free executions). When a producer produces the event into Azure Queue, if the enqueue operation failed, it is up to the producer to attempt another enqueue and later on deal with potential duplicates messages. On the delivery side, Orleans Streaming runtime dequeues the event from the Azure Queue and attempts to deliver it for processing to consumers. Orleans Streaming runtime deletes the event from the queue only upon successful processing. If the delivery or processing failed, the event is not delete from the queue and will automatically re-appear in the queue much later. The Streaming runtime will try to deliver it again, thus potentially breaking the FIFO order. The described behaivour matches the regular semantics of Azure Queues. Application Defined Order : To deal with the above ordering issues, application can optionally specify its own ordering. This is achived via a notion of StreamSequenceToken . StreamSequenceToken is an opaque IComparable object that can be used to order events. A producer can pass an optional StreamSequenceToken to the OnNext call. This StreamSequenceToken will be passed all the way to the consumer and will be delivered together with the event. That way, application can reason and reconstruct it's order independently from the streaming runtime. Rewindable Streams Some streams only allow application to subscribe to them starting at the latest point in time, while other streams allow \"going back in time\". The latter capability is dependent on the underlying queuing technology and the particular stream provider. For example, Azure Queues only allow consuming the latest enqueued events, while EventHub allows replaying events from an arbitrary point in time (up to some expiration time). Streams that support going back in time are called Rewindable Streams . The consumer of a rewindable stream can pass a StreamSequenceToken to the SubscribeAsync call and the runtime will deliver events to it starting from that StreamSequenceToken (a null token means the consumer wants to receive events starting from the latest). The ability to rewind a stream is very useful in recovery scenarios. For example, consider a grain that subscribes to a stream and periodically checkpoints its state together with the latest sequence token. When recovering from a failure, the grain can re-subscribe to the same stream from the latest checkpointed sequence token, thereby recovering without losing any events that were generated since the last checkpoint. Event Hubs provider is rewindable. You can find its code here . SMS and Azure Queue providers are not rewindable. Stateless Automatically Scaled-Out Processing By default Orleans Streaming is targeted to support a large number of relatively small streams, each is processed by one or more statefull grains. Collectively, the processing of all the streams together is sharded among a large number of regular (statefull) grains. The application code controls this sharding by assigning stream ids, grain ids and explicitly subscribing. The goal is sharded statefull processing . However, there is also an interesting scenario of automatically scaled-out stateless processing . In this scenario application has a small number of streams (or even one large stream) and the goal is stateless processing. For example, a global stream of all messages for all events and the processing involving some kind of decoding/deciphering and potentially forwarding them for further statefull processing into another set of streams. The stateless scaled-out stream processing can be supported in Orleans via StatelessWorker grains. Current Status of Stateless Automatically Scaled-Out Processing: This is currently not implemented (due to priority constrains). An attempt to subscribe to a stream from a StatelessWorker grain will result in undefined behavior. We are currently considering to support this option . Grains and Orleans Clients Orleans streams work uniformly across grains and Orleans clients . That is, exactly the same APIs can be used inside a grain and in an Orleans client to produce and consume events. This greatly simplifies the application logic, making special client-side APIs, such as Grain Observers, redundant. Fully Managed and Reliable Streaming Pub-Sub To track stream subscriptions, Orleans uses a runtime component called Streaming Pub-Sub which serves as a rendezvous point for stream consumers and stream producers. Pub Sub tracks all stream subscriptions, persists them, and matches stream consumers with stream producers. Applications can choose where and how the Pub-Sub data is stored. The Pub-Sub component itself is implemented as grains (called PubSubRendezvousGrain ) and it is using Orleans Declarative Persistence for those grain. PubSubRendezvousGrain uses storage provider named PubSubStore . As with any grain, you can designate an implementation for a storage provider. For Streaming Pub-Sub you can change the implementation of the PubSubStore in the config file: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"PubSubStore\" /> </StorageProviders> </Globals> </OrleansConfiguration> That way Pub-Sub data will be durably stored in Azure Table. For initial development you can use the memory storage as well. In addition to the Pub-Sub, Orleans Streaming Runtime delivers events from producers to consumers, manages all runtime resources allocated to actively used streams, and transparently garbage collects runtime resources from unused streams. Configuration In order to use streams you need to enable stream providers via configuration. You can read more about stream providers here . Sample stream providers configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StreamProviders> <Provider Type=\"Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider\" Name=\"SMSProvider\"/> <Provider Type=\"Orleans.Providers.Streams.AzureQueue.AzureQueueStreamProvider\" Name=\"AzureQueueProvider\"/> </StreamProviders> </Globals> </OrleansConfiguration> It is also possible to register a stream provider programmatically, via calling one of the RegisterStreamProvider methods on the Orleans.Runtime.Configuration.GlobalConfiguration or Orleans.Runtime.Configuration.ClientConfiguration classes. public void RegisterStreamProvider(string providerTypeFullName, string providerName, IDictionary<string, string> properties = null) public void RegisterStreamProvider<T>(string providerName, IDictionary<string, string> properties = null) where T : IStreamProvider Next Orleans Stream Providers"
  },
  "1.5/Documentation/Orleans-Streams/Streams-Why.html": {
    "href": "1.5/Documentation/Orleans-Streams/Streams-Why.html",
    "title": "Why Orleans Streams? | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Why Orleans Streams? There are already a wide range of technologies that allow you to build stream processing systems. Those include systems to durably store stream data (e.g., Event Hubs and Kafka ) and systems to express compute operations over stream data (e.g., Azure Stream Analytics , Apache Storm , and Apache Spark Streaming ). Those are great systems that allow you to build efficient data stream processing pipelines. Limitations of Existing Systems However, those systems are not suitable for fine-grained free-form compute over stream data . The Streaming Compute systems mentioned above all allow you to specify a unified data-flow graph of operations that are applied in the same way to all stream items . This is a powerful model when data is uniform and you want to express the same set of transformation, filtering, or aggregation operations over this data. But there are other use cases where you need to express fundamentally different operations over different data items. And in some of them as part of this processing you occasionally need to make an external call, such as invoke some arbitrary REST API. The unified data-flow stream processing engines either do not support those scenarios, support them in a limited and constrained way, or are inefficient in supporting them. This is because they are inherently optimized for a large volume of similar items, and usually limited in terms of expressiveness, processing . Orleans Streams target those other scenarios. Motivation It all started with requests from Orleans users to support returning a sequence of items from a grain method call. As you can imagine, that was only the tip of the iceberg. They actually needed much more than that. A typical scenario for Orleans Streams is when you have per user streams and you want to perform different processing for each user , within the context of an individual user. We may have millions of users but some of them are interested in weather and can subscribe to weather alerts for a particular location, while some are interested in sports events; somebody is tracking status of a particular flight. Processing those events requires different logic, but you don't want to run two independent instances of stream processing. Some users are interested in only a particular stock and only if certain external condition applies, condition that may not necessarily be part of the stream data (thus needs to be checked dynamically at runtime as part of processing). Users change their interests all the time, hence their subscriptions to specific streams of events come and go dynamically, thus the streaming topology changes dynamically and rapidly . On top of that, the processing logic per user evolves and changes dynamically as well, based on user state and external events . External events may modify the processing logic for a particular user. For example, in a game cheating detection system, when a new way to cheat is discovered the processing logic needs to be updated with the new rule to detect this new violation. This needs to be done of course without disrupting the ongoing processing pipeline . Bulk data-flow stream processing engines were not build to support such scenarios. It goes almost without saying that such a system has to run on a number of network-connected machines, not on a single node. Hence, the processing logic has to be distributed in a scalable and elastic manner across a cluster of servers. New Requirements We identified 4 basic requirements for our Stream Processing system that will allow it to target the above scenarios. Flexible stream processing logic Support for highly dynamic topologies Fine-grained stream granularity Distribution Flexible stream processing logic We want the system to support different ways of expressing the stream processing logic. The existing systems we mentioned above require the developer to write a declarative data-flow computation graph, usually by following a functional programming style. This limits the expressiveness and flexibility of the processing logic. Orleans streams are indifferent to the way processing logic is expressed. It can be expressed as a data-flow (e.g., by using Reactive Extensions (Rx) in .NET ); as a functional program; as a declarative query; or in a general imperative logic. The logic can be stateful or stateless, may or may not have side effects, and can trigger external actions. All power goes to the developer. Support for dynamic topologies We want the system to allow for dynamically evolving topologies. The existing systems we mentioned above are usually limited to only static topologies that are fixed at deployment time and cannot evolve at runtime. In the following example of a dataflow expression everything is nice and simple until you need to change it. Stream.GroupBy(x=> x.key).Extract(x=>x.field).Select(x=>x+2).AverageWindow(x, 5sec).Where(x=>x > 0.8) * Change the threshold condition in the Where filter, add an additional Select statement or add another branch in the data-flow graph and produce a new output stream. In existing systems this is not possible without tearing down the entire topology and restarting the data-flow from scratch. Practically, those systems will checkpoint the existing computation and will be able to restart from the latest checkpoint. Still, such a restart is disruptive and costly to an online service that produces results in real time. Such a restart becomes especially impractical when we are talking about a large number of such expressions being executed with similar but different (per-user, per-deveice, et.) parameters and that keep constantly changing. We want the system to allow for evolving the stream processing graph at runtime, by adding new links or nodes to the computation graph, or by changing the processing logic within the computation nodes. Fine grained stream granularity In the existing systems, the smallest unit of abstraction is usually the whole flow (topology). However, many of our target scenarios require individual node/link in the topology to be a logical entity by itself. That way each entity can be potentially managed independently. For example, in the big stream topology comprising of multiple links, different links can have different characteristics and can be implemented over different physical transports. Some links can go over TCP sockets, while others over reliable queues. Different links can have different delivery guarantees. Different nodes can have different checkpointing strategies, and their processing logic can be expressed in different models or even different languages. Such flexibility is usually not possible in existing systems. The unit of abstraction and flexibility argument is similar to comparison of SoA (Service Oriented Architectures) vs. Actors. Actor systems allow more flexibility, since each is essentially an independently managed ''tiny service''. Similarly, we want the system to allow for such a fine grained control. Distribution And of course, our system should have all the properties of a \"good distributed system\" . That includes: Scalability - supports large number of streams and compute elements. Elasticity - allows to add/remove resources to grow/shrink based on load. Reliability - be resilient to failures Efficiency - use the underlying resources efficiently Responsiveness - enable near real time scenarios. These were the requirements we had in mind for building Orleans Streaming . Clarificaton : Orleans currently does not directly support writing declarative dataflow expressions like in the example above. The current Orleans Streaming APIs are more low level building blocks, as described here . Providing declarative dataflow expressions is our future goal. Next Orleans Streams Programming APIs"
  },
  "1.5/Documentation/Installation/Prerequisites.html": {
    "href": "1.5/Documentation/Installation/Prerequisites.html",
    "title": "Prerequisites | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Prerequisites Orleans is a set of .NET libraries delivered via NuGet packages . In order to use Orleans, you need .NET Framework 4.6.1 (since 1.5.0, 4.5.1 for prior versions) or higher and a copy of Visual Studio 2015 or higher. Note that the Express versions of Visual Studio do not support extension packages, but you can use Orleans by adding references to the NuGet packages directly. In production, Orleans requires persistent storage for reliable cluster membership. The following storage technologies are supported for managing cluster membership state (only need one of those): Azure Table Storage - Tested with Azure SDK 2.4 - 2.8 SQL Server 2008 or higher ZooKeeper 3.4.0 or higher MySQL 5.0 or higher PostgreSQL 9.5 or higher Consul 0.6.0 or higher DynamoDB - Tested with AWSSDK - Amazon DynamoDB 3.1.5.3 Another production deployment option is to use Azure Service Fabric . There is a NuGet package that helps with that. It has a dependency on Service Fabric 2.1.163."
  },
  "1.5/Documentation/Installation/NuGets.html": {
    "href": "1.5/Documentation/Installation/NuGets.html",
    "title": "Orleans NuGet Packages | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Nuget Packages Orleans NuGet packages as of v1.5.0 There are 4 key NuGet packages you will need to use in most scenarios: Microsoft Orleans Build-time Code Generation PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build Build support for grain interfaces and implementation projects. Add it to your grain interfaces and implementation projects to enable code generation of grain references and serializers. Microsoft.Orleans.Templates.Interfaces and Microsoft.Orleans.Templates.Grains packages are obsolete and provided only for backward compatibility and migration. Microsoft Orleans Core Library PM> Install-Package Microsoft.Orleans.Core Contains Orleans.dll, which defines most of Orleans public types and Orleans Client. Reference it for building libraries and client applications that use Orleans types but don't need any of the included providers. Microsoft Orleans Server Libraries PM> Install-Package Microsoft.Orleans.Server Includes everything you need to run a silo. Microsoft Orleans Client Libraries PM> Install-Package Microsoft.Orleans.Client Includes everything you need for an Orleans client (frontend). Additional Packages The below packages provide additional functionality. Microsoft Orleans Providers PM> Install-Package Microsoft.Orleans.OrleansProviders Contains a set of built-in persistence and stream providers, primarily for testing, as well as some abstractions and utility types for building persistence and stream providers. Included in Microsoft.Orleans.Client and Microsoft.Orleans.Server. Microsoft Orleans Event-Sourcing PM> Install-Package Microsoft.Orleans.EventSourcing Contains a set of base types for creating grain classes with event-sourced state. Providers and extensions Microsoft Orleans Azure Utilities PM> Install-Package Microsoft.Orleans.OrleansAzureUtils Contains Azure Table based cluster membership provider, wrapper classes that simplify instantiation of silos and clients in Azure Worker/Web roles, persistence providers for Azure Tables and Azure Blobs, and a stream provider for Azure Queues. Microsoft Orleans Sql Utilities PM> Install-Package Microsoft.Orleans.OrleansSqlUtils Contains SQL based cluster membership and persistence providers for use with SQL Server, MySQL, PostgreSQL, and other SQL databases. Microsoft Orleans ServiceBus Utilities PM> Install-Package Microsoft.Orleans.OrleansServiceBus Includes the stream provider for Azure Event Hubs. Microsoft Orleans Consul Utilities PM> Install-Package Microsoft.Orleans.OrleansConsulUtils Includes the plugin for using Consul for storing cluster membership data. Microsoft Orleans ZooKeeper Utilities PM> Install-Package Microsoft.Orleans.OrleansZooKeeperUtils Includes the plugin for using ZooKeeper for storing cluster membership data. Microsoft Orleans AWS Utilities PM> Install-Package Microsoft.Orleans.OrleansAWSUtils Includes DynamoDB based cluster membership provider, DynamoDB persistence provider, and SQS based stream provider. Microsoft Orleans Telemetry Consumer - Performance Counters PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.Counters Windows Performance Counters implementation of Orleans Telemetry API. Microsoft Orleans Telemetry Consumer - Azure Application Insights PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.AI Includes the telemetry consumer for Azure Application Insights. Microsoft Orleans Telemetry Consumer - NewRelic PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.NewRelic Includes the telemetry consumer for NewRelic. Microsoft Orleans Bond Serializer PM> Install-Package Microsoft.Orleans.Serialization.Bond Includes support for Bond serializer . Microsoft Orleans Google Utilities PM> Install-Package Microsoft.Orleans.OrleansGoogleUtils Includes Google Protocol Buffers serializer. Hosting and testing Microsoft Orleans Runtime PM> Install-Package Microsoft.Orleans.OrleansRuntime Core runtime library of Microsoft Orleans that hosts and executes grains within a silo. Microsoft Orleans Silo Host PM> Install-Package Microsoft.Orleans.OrleansHost Includes the default silo host - OrleansHost.exe. Can be used for on-premises deployments or as an out-of-process silo host in Azure Worker Role. Included in Microsoft.Orleans.Server. We are planning to deprecate this package in favor of customers building their custom silo host processes in order to simplify dependency management and programmatic configuration. Microsoft Orleans Service Fabric Support PM> Install-Package Microsoft.Orleans.ServiceFabric Support for hosting Microsoft Orleans on Service Fabric. Microsoft Orleans Testing Host Library PM> Install-Package Microsoft.Orleans.TestingHost Includes the library for hosting silos in a testing project. Microsoft Orleans Code Generation PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator Includes the run time code generator. Included in Microsoft.Orleans.Server and Microsoft.Orleans.Client. Tools Microsoft Orleans Performance Counter Tool PM> Install-Package Microsoft.Orleans.CounterControl Includes OrleansCounterControl.exe, which registers Windows performance counter categories for Orleans statistics and for deployed grain classes. Requires elevation. Can be executed in Azure as part of a role startup task. Included in Microsoft.Orleans.Server. Microsoft Orleans Management Tool PM> Install-Package Microsoft.Orleans.OrleansManager Includes Orleans management tool - OrleansManager.exe. We are planning to deprecate this package in favor of customers building their custom management tools in order to simplify dependency management and programmatic configuration."
  },
  "1.5/Documentation/Event-Sourcing/MultiInstance.html": {
    "href": "1.5/Documentation/Event-Sourcing/MultiInstance.html",
    "title": "Replicated Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Replicated Grains Sometimes, there can be multiple instances of the same grain active, such as when operating a multi-cluster, and using the [OneInstancePerCluster] attribute. The JournaledGrain is designed to support replicated instances with minimal friction. It relies on log-consistency providers to run the necessary protocols to ensure all instances agree on the same sequence of events. In particular, it takes care of the following aspects: Consistent Versions : All versions of the grain state (except for tentative versions) are based on the same global sequence of events. In particular, if two instances see the same version number, then they see the same state. Racing Events : Multiple instances can simultaneously raise an event. The consistency provider resolves this race and ensures everyone agrees on the same sequence. Notifications/Reactivity : After an event is raised at one grain instance, the consistency provider not only updates storage, but also notifies all the other grain instances. For a general discussion of the consistency model see our TechReport and the GSP paper (Global Sequence Protocol). Conditional Events Racing events can be problematic if they have a conflict, i.e. should not both commit for some reason. For example, when withdrawing money from a bank account, two instances may independently determine that there are sufficient funds for a withdrawal, and issue a withdrawal event. But the combination of both events could overdraw. To avoid this, the JournaledGrain API supports a RaiseConditionalEvent method. bool success = await RaiseConditionalEvent(new WithdrawalEvent() { ... }); Conditional events double-check if the local version matches the version in storage. If not, it means the event sequence has grown in the meantime, which means this event has lost a race against some other event. In that case, the conditional event is not appended to the log, and RaiseConditionalEvent returns false. This is the analogue of using e-tags with conditional storage updates, and likewise provides a simple mechanism to avoid committing conflicting events. It is possible and sensible to use both conditional and unconditional events for the same grain, such as a DepositEvent and a WithdrawalEvent . Deposits need not be conditional: even if a DepositEvent loses a race, it does not have to be cancelled, but can still be appended to the global event sequence. Awaiting the task returned by RaiseConditionalEvent is sufficient to confirm the event, i.e. it is not necessary to also call ConfirmEvents . Explicit Synchronization Sometimes, it is desirable to ensure that a grain is fully caught up with the latest version. This can be enforced by calling await RefreshNow(); which both (1) confirms all unconfirmed events, and (2) loads the latest version from storage."
  },
  "1.5/Documentation/Event-Sourcing/GrainStateAPI.html": {
    "href": "1.5/Documentation/Event-Sourcing/GrainStateAPI.html",
    "title": "JournaledGrain API | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . JournaledGrain Basics Journaled grains derive from <JournaledGrain<StateType,EventType> , with the following type parameters: The StateType represents the state of the grain. It must be a class with a public default constructor. EventType is a common supertype for all the events that can be raised for this grain, and can be any class or interface. All state and event objects should be serializable (because the log-consistency providers may need to persist them, and/or send them in notification messages). For grains whose events are POCOs (plain old C# objects), JournaledGrain<StateType> can be used as a shorthand for JournaledGrain<StateType,Object> . Reading the Grain State To read the current grain state, and determine its version number, the JournaledGrain has properties GrainState State { get; } int Version { get; } The version number is always equal to the total number of confirmed events, and the state is the result of applying all the confirmed events to the initial state. The initial state, which has version 0 (because no events have been applied to it), is determined by the default constructor of the GrainState class. Important: The application should never directly modify the object returned by State . It is meant for reading only. Rather, when the application wants to modify the state, it must do so indirectly by raising events. Raising Events Raising events is accomplished by calling the RaiseEvent function. For example, a grain representing a chat can raise a PostedEvent to indicate that a user submitted a post: RaiseEvent(new PostedEvent() { Guid = guid, User = user, Text = text, Timestamp = DateTime.UtcNow }); Note that RaiseEvent kicks off a write to storage access, but does not wait for the write to complete. For many applications, it is important to wait until we have confirmation that the event has been persisted. In that case, we always follow up by waiting for ConfirmEvents : RaiseEvent(new DepositTransaction() { DepositAmount = amount, Description = description }); await ConfirmEvents(); Note that even if you don't explicitly call ConfirmEvents , the events will eventually be confirmed - it happens automatically in the background. For more discussion on this topic, see Immediate vs. Delayed Confirmation . State Transition Methods The runtime updates the grain state automatically whenever events are raised. There is no need for the application to explicitly update the state after raising an event. However, the application still has to provide the code that specifies how to update the state in response to an event. This can be done in two ways. (a) The GrainState class can implement one or more Apply methods on the StateType . Typically, one would create multiple overloads, and the closest match is chosen for the runtime type of the event: class GrainState { Apply(E1 @event) { // code that updates the state } Apply(E2 @event) { // code that updates the state } } (b) The grain can override the TransitionState function: protected override void TransitionState(State state, EventType @event) { // code that updates the state } The transition methods are assumed to have no side effects other than modifying the state object, and should be deterministic (otherwise, the effects are unpredictable). If the transition code throws an exception, that exception is caught and included in a warning in the Orleans log, issued by the log-consistency provider. When, exactly, the runtime calls the transition methods depends on the chosen log consistency provider and its configuration. It is best for applications not to rely on a particular timing, except when specifically guaranteed by the log consistency provider. Some providers, such as the LogStorage log-consistency provider, replay the event sequence every time the grain is loaded. Therefore, as long as the event objects can still be properly deserialized from storage, it is possibly to radically modify the GrainState class and the transition methods. But for other providers, such as the StateStorage log-consistency provider, only the GrainState object is persisted, so developers must ensure that it can be deserialized correctly when read from storage. Raising Multiple Events It is possible to make multiple calls to RaiseEvent before calling ConfirmEvents: RaiseEvent(e1); RaiseEvent(e2); await ConfirmEvents(); However, this is likely to cause two successive storage accesses, and it incurs a risk that the grain fails after writing only the first event. Thus, it is usually better to raise multiple events at once, using RaiseEvents(IEnumerable<EventType> events) This guarantees that the given sequence of events is written to storage atomically. Note that since the version number always matches the length of the event sequence, raising multiple events increases the version number by more than one at a time. Retrieving the Event Sequence The following method from the base JournaledGrain class allows the application to retrieve a specified segment of the sequence of all confirmed events: Task<IReadOnlyList<EventType>> RetrieveConfirmedEvents(int fromVersion, int toVersion) However, it is not supported by all log consistency providers. If not supported, or if the specified segment of the sequence is no longer available, a NotSupportedException is thrown. To retrieve all events up to the latest confirmed version, one would call await RetrieveConfirmedEvents(0, Version); Only confirmed events can be retrieved: an exception is thrown if toVersion is larger than the current value of the property Version . Since confirmed events never change, there are no races to worry about, even in the presence of multiple instances or delayed confirmation . However, in such situations, it is possible that the value of the property Version is larger by the time the await resumes than at the time RetrieveConfirmedEvents is called, so it may be advisable to save its value in a variable. See also the section on Concurrency Guarantees ."
  },
  "1.5/Documentation/Event-Sourcing/LogConsistencyProviders.html": {
    "href": "1.5/Documentation/Event-Sourcing/LogConsistencyProviders.html",
    "title": "Included Log-Consistency Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Built-In Log-Consistency Providers The Microsoft.Orleans.EventSourcing package includes several log-consistency providers that cover basic scenarios suitable to get started, and allow some extensibility. Orleans.EventSourcing. StateStorage .LogConsistencyProvider This provider stores grain state snapshots , using a standard storage provider that can be configured independently. The data that is kept in storage is an object that contains both the grain state (as specified by the first type parameter to JournaledGrain ) and some meta-data (the version number, and a special tag that is used to avoid duplication of events when storage accesses fail). Since the entire grain state is read/written every time we access storage, this provider is not suitable for objects whose grain state is very large. This provider does not support RetrieveConfirmedEvents : it cannot retrieve the events from storage because the events are not persisted. Orleans.EventSourcing. LogStorage .LogConsistencyProvider This provider stores the complete event sequence as a single object , using a standard storage provider that can be configured independently. The data that is kept in storage is an object that contains a List<EventType> object , and some meta-data (a special tag that is used to avoid duplication of events when storage accesses fail). This provider does support RetrieveConfirmedEvents . All events are always available and kept in memory. Since the whole event sequence is read/written every time we access storage, this provider is not suitable for use in production , unless the event sequences are guaranteed to remain pretty short. The main purpose of this provider is to illustrate the semantics of the event sourcing, and for samples/testing environments. Orleans.EventSourcing. CustomStorage .LogConsistencyProvider This provider allows the developer to plug in their own storage interface, which is then called by the conistency protocol at appropriate times. This provider does not make specific assumptions about whether what is stored are state snapshots or events - the programmer assumes control over that choice (and may store either or both). To use this provider, a grain must derive from JournaledGrain<StateType,EventType> , as before, but additionally must also implement the following interface: public interface ICustomStorageInterface<StateType, EventType> { Task<KeyValuePair<int,StateType>> ReadStateFromStorage(); Task<bool> ApplyUpdatesToStorage(IReadOnlyList<EventType> updates, int expectedversion); } The consistency provider expects these to behave a certain way. Programmers should be aware that: The first method, ReadStateFromStorage , is expected to return both the version, and the state read. If there is nothing stored yet, it should return zero for the version and a state that matches corresponds to the default constructor for StateType . ApplyUpdatesToStorage must return false if the expected version does not match the actual version (this is analogous to an e-tag check). If ApplyUpdatesToStorage fails with an exception, the consistency provider retries. This means some events could be duplicated if such an exception is thrown, but the event was actually persisted. The developer is responsible to make sure this is safe: e.g. either avoid this case by not throwing an exception, or ensure duplicated events are harmless for the application logic, or add some extra mechanism to filter duplicates. This provider does not support RetrieveConfirmedEvents . Of course, since the developer controls the storage interface anyway, they don't need to call this in the first place, but can implement their own event retrieval."
  },
  "1.5/Documentation/Event-Sourcing/Configuration.html": {
    "href": "1.5/Documentation/Event-Sourcing/Configuration.html",
    "title": "Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Configuration Configuring Project References Grain Interfaces As before, interfaces depend only on the Microsoft.Orleans.Core package, because the grain interface is independent of the implementation. Grain Implementations JournaledGrains need to derive from JournaledGrain<S,E> or JournaledGrain<S> , which is defined in the Microsoft.Orleans.EventSourcing package. Log-Consistency Providers We currently include three log-consistency providers (for state storage, log storage, and custom storage). All three are contained in the Microsoft.Orleans.EventSourcing package as well. Therefore, all Journaled Grains already have access to those. For a description of what these providers do and how they differ, see Included Log-Consistency Providers . Cluster Configuration Log-consistency providers are configured just like any other Orleans providers. For example, to include all three providers (of course, you probably won't need all three), add this to the <Globals> element of the configuration file: <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.StateStorage.LogConsistencyProvider\" Name=\"StateStorage\" /> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"LogStorage\" /> <Provider Type=\"Orleans.EventSourcing.CustomStorage.LogConsistencyProvider\" Name=\"CustomStorage\" /> </LogConsistencyProviders> The same can be achieved programmatically. Assuming the project contains the Microsoft.Orleans.EventSourcing package, and config is a ClusterConfiguration object: using Orleans.Runtime.Configuration; // pick up the necessary extension methods config.AddLogStorageBasedLogConsistencyProvider(\"LogStorage\"); config.AddStateStorageBasedLogConsistencyProvider(\"StateStorage\"); config.AddCustomStorageBasedLogConsistencyProvider(\"CustomStorage\"); Grain Class Attributes Each journaled grain class must have a LogConsistencyProvider attribute to specify the log-consistency provider. Some providers additionally require a StorageProvider attribute. LogConsistencyProvider Attributes To specify the log-consistency provider, add a [LogConsistencyProvider(ProviderName=...)] attribute to the grain class, and give the name of the provider as configured by the Cluster Configuration. For example: [LogConsistencyProvider(ProviderName = \"CustomStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain, ICustomStorage { ... } StorageProvider Attributes Some log-consistency providers (including LogStorage and StateStorage ) use a standard StorageProvider to communicate with storage. This provider is specified using a separate StorageProvider attribute, as follows: [LogConsistencyProvider(ProviderName = \"LogStorage\")] [StorageProvider(ProviderName = \"AzureBlobStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain { ... } Default Providers It is possible to omit the LogConsistencyProvider and/or the StorageProvider attributes, if a default is specified in the configuration. This is done by using the special name Default for the respective provider. For example: <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"Default\" /> </LogConsistencyProviders> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> </StorageProviders>"
  },
  "Documentation/clusters_and_clients/configuration_guide/adonet_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/adonet_configuration.html",
    "title": "æ•°æ®åº“é…ç½® | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ•°æ®åº“é…ç½® ä¸‹é¢çš„æ®µè½åŒ…å«é“¾æ¥SQLè„šæœ¬ï¼Œä»¥é…ç½®æ‚¨çš„æ•°æ®åº“ï¼Œä»¥åŠç›¸åº”çš„ADO.Netä¸å˜æ€§ï¼Œç”¨äºé…ç½®ADO.Net Providers in Orleansã€‚è¿™äº›è„šæœ¬å¦‚æœéœ€è¦æ‰©å……ï¼Œå°†è¢«å…³é—­ã€‚ èšç±» æ•°æ®åº“ è„šæœ¬ NugetåŒ…è£… ä¸å˜æ€§ SQLæœåŠ¡å™¨ SQLServer-Clustering.sql System.Data.SqlClient System.Data.SqlClient ç›ä¸½äºš MySQL-Clustering.sql MySql.Data MySql.Data.MySqlClient åæ ¼é›·æ–¯å…‹å°” PostgreSQL-Clustering.sql ä¸­åäººæ°‘å…±å’Œå›½ ä¸­åäººæ°‘å…±å’Œå›½ ç¥è°• ç¥è°•é›†ç¾¤ ODP.net oracle.dataaccess.clientæ–‡ä»¶ æŒä¹…åŒ– æ•°æ®åº“ è„šæœ¬ NuGETåŒ… ADO.NETä¸å˜é‡ SQL Server sqlserver-persistence.sqlæ•°æ®åº“ system.data.sqlclientç³»ç»Ÿ system.data.sqlclientç³»ç»Ÿ MySQL/é©¬é‡Œäºšè¡Œ mysql-persistence.sqlæ–‡ä»¶ mysql.æ•°æ® MySql.Data.MySqlClient PostgreSQL PostgreSQL-æŒä¹…åŒ–.sql NPGSQL NPGSQL ç”²éª¨æ–‡ OracleæŒä¹…åŒ–.sql ç½‘ oracle.dataaccess.clientæ–‡ä»¶ æé†’ æ•°æ®åº“ è„šæœ¬ NuGETåŒ… ADO.NETä¸å˜é‡ SQL Server sqlserver-reminders.sqlæç¤º system.data.sqlclientç³»ç»Ÿ system.data.sqlclientç³»ç»Ÿ MySQL/é©¬é‡Œäºšè¡Œ mysql-reminders.sqlæ–‡ä»¶ MySQLæ•°æ® MySql.Data.MySqlClient PostgreSQL PostgreSQLæé†’.sql NPGSQL NPGSQL ç¥è°•ã€‚ Oracleæé†’.sql ç½‘ oracle.dataaccess.clientæ–‡ä»¶"
  },
  "Documentation/clusters_and_clients/configuration_guide/local_development_configuration.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/local_development_configuration.html",
    "title": "Local development configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æœ¬åœ°å¼€å‘é…ç½® æœ‰å…³é’ˆå¯¹Orleans 2.0çš„å·¥ä½œç¤ºä¾‹åº”ç”¨ç¨‹åºï¼Œè¯·å‚è§ï¼š https://github.com/dotnet/orleans/tree/master/samples/2.0/helloworldç½‘ç«™ æ­¤ç¤ºä¾‹æ‰˜ç®¡äº†åœ¨ä¸åŒå¹³å°ä¸Šå·¥ä½œçš„.NET Coreæ§åˆ¶å°åº”ç”¨ç¨‹åºä¸­çš„å®¢æˆ·ç«¯å’Œsilosï¼Œä½†å¯¹äº.NET Framework 4.6.1+æ§åˆ¶å°åº”ç”¨ç¨‹åº(ä»…åœ¨Windowsä¸Šå·¥ä½œ)ä¹Ÿå¯ä»¥è¿™æ ·åšã€‚ silosé…ç½® å¯¹äºæœ¬åœ°å¼€å‘ï¼Œè¯·å‚é˜…ä¸‹é¢çš„ç¤ºä¾‹ï¼Œäº†è§£å¦‚ä½•ä¸ºè¿™ç§æƒ…å†µé…ç½®silosã€‚å®ƒé…ç½®å¹¶å¯åŠ¨ä¸€ä¸ªsilosï¼Œåˆ†åˆ«ä½œä¸ºsiloså’Œç½‘å…³ç«¯å£ç›‘å¬â€œç¯å›â€åœ°å€å’Œ11111å’Œ30000ã€‚ æ·»åŠ  Microsoft.Orleans.Server é¡¹ç›®çš„nugetå…ƒåŒ…ã€‚åœ¨æ‚¨ç†Ÿæ‚‰äº†apiä¹‹åï¼Œå¯ä»¥é€‰æ‹©åŒ…å«åœ¨ Microsoft.Orleans.Server ä½ çœŸçš„éœ€è¦ï¼Œå¹¶å‚è€ƒä»–ä»¬ã€‚ PM> Install-Package Microsoft.Orleans.Server æ‚¨éœ€è¦é…ç½® ç¦»åˆå™¨é€‰é¡¹ é€šè¿‡ ISiloBuilder.Configure æ–¹æ³•ï¼ŒæŒ‡å®šæ‚¨æƒ³è¦çš„ å‘å±•é›†ç¾¤ å°†æ­¤silosä½œä¸ºä¸»è¦çš„ç¾¤é›†é€‰æ‹©ï¼Œç„¶åé…ç½®silosç»ˆç»“ç‚¹ã€‚ é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ callæ˜¾å¼åœ°å°†å…·æœ‰grainç±»çš„ç¨‹åºé›†æ·»åŠ åˆ°åº”ç”¨ç¨‹åºè®¾ç½®ä¸­ã€‚å®ƒè¿˜æ·»åŠ ä»»ä½•å¼•ç”¨çš„ç¨‹åºé›†ï¼Œå› ä¸º æœ‰å‚è€ƒæ–‡çŒ® åˆ†æœºã€‚å®Œæˆè¿™äº›æ­¥éª¤åï¼Œå°†ç”Ÿæˆsilosä¸»æœºå¹¶å¯åŠ¨silosã€‚ æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªç©ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ï¼Œç›®æ ‡æ˜¯.NETFramework4.6.1æˆ–æ›´é«˜ç‰ˆæœ¬ï¼Œç”¨äºæ‰˜ç®¡siloså’Œ.NETCoreæ§åˆ¶å°åº”ç”¨ç¨‹åºã€‚ ä»¥ä¸‹æ˜¯å¦‚ä½•å¯åŠ¨æœ¬åœ°silosçš„ç¤ºä¾‹ï¼š public class Program { public static async Task Main(string[] args) { try { var host = await StartSilo(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); await host.StopAsync(); return; } catch (Exception ex) { Console.WriteLine(ex); return; } } private static async Task<ISiloHost> StartSilo() { var builder = new SiloHostBuilder() // Use localhost clustering for a single local silo .UseLocalhostClustering() // Configure ClusterId and ServiceId .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"MyAwesomeService\"; }) // Configure connectivity .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) // Configure logging with any logging framework that supports Microsoft.Extensions.Logging. // In this particular case it logs using the Microsoft.Extensions.Logging.Console package. .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } å®¢æˆ·ç«¯é…ç½® å¯¹äºæœ¬åœ°å¼€å‘ï¼Œè¯·å‚é˜…ä¸‹é¢çš„ç¤ºä¾‹ï¼Œäº†è§£å¦‚ä½•ä¸ºè¿™ç§æƒ…å†µé…ç½®å®¢æˆ·ç«¯ã€‚å®ƒé…ç½®å°†è¿æ¥åˆ° å›é€ silosã€‚ æ·»åŠ  Microsoft.Orleans.client é¡¹ç›®çš„nugetå…ƒåŒ…ã€‚åœ¨æ‚¨ç†Ÿæ‚‰äº†apiä¹‹åï¼Œå¯ä»¥é€‰æ‹©åŒ…å«åœ¨ Microsoft.Orleans.client ä½ çœŸçš„éœ€è¦ï¼Œå¹¶å‚è€ƒä»–ä»¬ã€‚ PM> Install-Package Microsoft.Orleans.Client æ‚¨éœ€è¦é…ç½® å®¢æˆ·ç«¯ç”Ÿæˆå™¨ ä½¿ç”¨ä¸ä¸ºæœ¬åœ°silosæŒ‡å®šçš„ç¾¤é›†IDåŒ¹é…çš„ç¾¤é›†IDï¼Œå¹¶å°†é™æ€ç¾¤é›†æŒ‡å®šä¸ºæŒ‡å‘silosç½‘å…³ç«¯å£çš„ç¾¤é›†é€‰æ‹© é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ callæ˜¾å¼åœ°å°†å…·æœ‰grainæ¥å£çš„ç¨‹åºé›†æ·»åŠ åˆ°åº”ç”¨ç¨‹åºè®¾ç½®ä¸­ã€‚ å®Œæˆè¿™äº›æ­¥éª¤åï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå®¢æˆ·ç«¯å¹¶ è¿æ¥() æ–¹æ³•è¿æ¥åˆ°ç¾¤é›†ã€‚ æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªç©ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ï¼Œç›®æ ‡æ˜¯.net framework 4.6.1æˆ–æ›´é«˜ç‰ˆæœ¬ä»¥è¿è¡Œå®¢æˆ·ç«¯ï¼Œæˆ–è€…é‡ç”¨ä¸ºæ‰˜ç®¡silosè€Œåˆ›å»ºçš„æ§åˆ¶å°åº”ç”¨ç¨‹åºé¡¹ç›®ã€‚ ä»¥ä¸‹æ˜¯å®¢æˆ·ç«¯å¦‚ä½•è¿æ¥åˆ°æœ¬åœ°silosçš„ç¤ºä¾‹ï¼š client = new ClientBuilder() // Use localhost clustering for a single local silo .UseLocalhostClustering() // Configure ClusterId and ServiceId .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"MyAwesomeService\"; }) .ConfigureLogging(logging => logging.AddConsole()) var client = builder.Build(); await client.Connect();"
  },
  "Documentation/clusters_and_clients/configuration_guide/list_of_options_classes.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/list_of_options_classes.html",
    "title": "List of Options Classes | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é€‰é¡¹ç±»åˆ—è¡¨ ç”¨äºé…ç½®Orleansçš„æ‰€æœ‰é€‰é¡¹ç±»éƒ½åº”è¯¥åœ¨ Orleansã€‚é…ç½® å‘½åç©ºé—´ã€‚ä»–ä»¬ä¸­çš„è®¸å¤šäººåœ¨ Orleansã€‚æ¥å¾… å‘½åç©ºé—´ã€‚ iclientbuilderå’Œisilohostbuilderçš„é€šç”¨æ ¸å¿ƒé€‰é¡¹ é€‰é¡¹ç±»å‹ ç”¨äº ç¦»åˆå™¨é€‰é¡¹ è®¾ç½® æ£’çŠ¶çš„ ä»¥åŠ æœåŠ¡ID ç½‘ç»œé€‰é¡¹ ä¸ºå¥—æ¥å­—å’Œæ‰“å¼€çš„è¿æ¥è®¾ç½®è¶…æ—¶å€¼ åºåˆ—åŒ–æä¾›ç¨‹åºé€‰é¡¹ è®¾ç½®åºåˆ—åŒ–æä¾›ç¨‹åº ç±»å‹ç®¡ç†é€‰é¡¹ è®¾ç½®ç±»å‹æ˜ å°„çš„åˆ·æ–°å‘¨æœŸ(è¯·å‚é˜…å¼‚æ„siloså’Œç‰ˆæœ¬æ§åˆ¶) iclientbuilderç‰¹å®šé€‰é¡¹ é€‰é¡¹ç±»å‹ ç”¨äº å®¢æˆ·ä¿¡æ¯é€‰é¡¹ è®¾ç½®è¦ä¿æŒæ‰“å¼€çš„è¿æ¥æ•°ï¼Œå¹¶æŒ‡å®šè¦ä½¿ç”¨çš„ç½‘ç»œæ¥å£ å®¢æˆ·ç»Ÿè®¡é€‰é¡¹ è®¾ç½®ä¸ç»Ÿè®¡è¾“å‡ºç›¸å…³çš„å„ç§è®¾ç½® ç½‘å…³é€‰é¡¹ è®¾ç½®å¯ç”¨ç½‘å…³åˆ—è¡¨çš„åˆ·æ–°å‘¨æœŸ StaticGatewayListProviderOptions è®¾ç½®å®¢æˆ·ç«¯ç”¨äºè¿æ¥åˆ°ç¾¤é›†çš„uri IsiloHostBuilderç‰¹å®šé€‰é¡¹ é€‰é¡¹ç±»å‹ ç”¨äº ClusterMembershipé€‰é¡¹ ç¾¤é›†æˆå‘˜èº«ä»½çš„è®¾ç½® ä¸€è‡´æ€§é€‰é¡¹ ä¸€è‡´æ•£åˆ—ç®—æ³•çš„é…ç½®é€‰é¡¹ï¼Œç”¨äºå¹³è¡¡é›†ç¾¤ä¸­çš„èµ„æºåˆ†é…ã€‚ ç«¯ç‚¹é€‰é¡¹ è®¾ç½®silosç»ˆç»“ç‚¹é€‰é¡¹ GrainCollectioné€‰é¡¹ Grainsåƒåœ¾æ”¶é›†é€‰é¡¹ grainsè½¬åŒ–é€‰é¡¹ ç®¡ç†å¼‚æ„éƒ¨ç½²ä¸­çš„Grainå®ç°é€‰æ‹© åŠ è½½é€‰é¡¹ å‡è½½é…ç½®è®¾ç½®ã€‚å¿…é¡»æœ‰ ihostenvironmentstatistics ä¾‹å¦‚é€šè¿‡ builder.UsePerfCounterEnvironmentStatistics() (ä»…é™Windows)ç”¨äº å‡è½½ å‘æŒ¥ä½œç”¨ã€‚ å¤šè‰²å…‰ é…ç½®å¤šç¾¤é›†æ”¯æŒçš„é€‰é¡¹ æ€§èƒ½è°ƒæ•´é€‰é¡¹ æ€§èƒ½è°ƒæ•´é€‰é¡¹(ç½‘ç»œã€çº¿ç¨‹æ•°) è¿›ç¨‹Exthandé€‰é¡¹ åœ¨è¿›ç¨‹å‡ºå£é…ç½®silosè¡Œä¸º è®¡åˆ’é€‰é¡¹ é…ç½®è®¡åˆ’ç¨‹åºè¡Œä¸º Silomessagingoptions é…ç½®ä¸silosç›¸å…³çš„å…¨å±€æ¶ˆæ¯ä¼ é€’é€‰é¡¹ã€‚ silosé€‰é¡¹ è®¾ç½®silosçš„åç§° silosç»Ÿè®¡é€‰é¡¹ è®¾ç½®ä¸ç»Ÿè®¡è¾“å‡ºç›¸å…³çš„å„ç§è®¾ç½® é¥æµ‹é€‰é¡¹ è®¾ç½®é¥æµ‹ç”¨æˆ·è®¾ç½®"
  },
  "Documentation/clusters_and_clients/configuration_guide/activation_garbage_collection.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/activation_garbage_collection.html",
    "title": "Activation Garbage Collection | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ¿€æ´»åƒåœ¾å›æ”¶ å¦‚æ ¸å¿ƒæ¦‚å¿µéƒ¨åˆ†æ‰€è¿°ï¼Œ grainsæ´»åŒ– æ˜¯ä¸€ä¸ªgrainç±»çš„å†…å­˜å®ä¾‹ï¼Œç”±orleansè¿è¡Œæ—¶æ ¹æ®éœ€è¦è‡ªåŠ¨åˆ›å»ºï¼Œä½œä¸ºgrainçš„ä¸´æ—¶ç‰©ç†å®æ–½ä¾‹ã€‚ æ¿€æ´»åƒåœ¾æ”¶é›†(activation gc)æ˜¯ä»å†…å­˜ä¸­åˆ é™¤æœªä½¿ç”¨çš„grainsæ¿€æ´»çš„è¿‡ç¨‹ã€‚å®ƒåœ¨æ¦‚å¿µä¸Šç±»ä¼¼äº.netä¸­çš„å†…å­˜åƒåœ¾æ”¶é›†å·¥ä½œæ–¹å¼ã€‚ç„¶è€Œï¼Œæ¿€æ´»gcåªè€ƒè™‘ç‰¹å®šgrainsæ¿€æ´»ç©ºé—²çš„æ—¶é—´ã€‚å†…å­˜ä½¿ç”¨ç‡ä¸æ˜¯ä¸€ä¸ªå› ç´ ã€‚ æ¿€æ´»gcçš„å·¥ä½œåŸç† æ¿€æ´»gcçš„ä¸€èˆ¬è¿‡ç¨‹åŒ…æ‹¬åœ¨silosä¸­çš„orleansè¿è¡Œæ—¶å®šæœŸæ‰«æåœ¨é…ç½®çš„æ—¶é—´æ®µ(æ”¶é›†æœŸé™)å†…æ ¹æœ¬æ²¡æœ‰ä½¿ç”¨çš„Grainsæ¿€æ´»ã€‚ä¸€æ—¦Grainsæ¿€æ´»é—²ç½®äº†é‚£ä¹ˆé•¿æ—¶é—´ï¼Œå®ƒå°±ä¼šè¢«åœç”¨ã€‚åœç”¨è¿‡ç¨‹å¼€å§‹äºè¿è¡Œæ—¶è°ƒç”¨grainçš„ OnDeactivateAsync() æ–¹æ³•ï¼Œå¹¶é€šè¿‡ä»silosçš„æ‰€æœ‰æ•°æ®ç»“æ„ä¸­ç§»é™¤å¯¹Grain Activationå¯¹è±¡çš„å¼•ç”¨æ¥å®Œæˆï¼Œä»¥ä¾¿.NET GCå›æ”¶å†…å­˜ã€‚ å› æ­¤ï¼Œåœ¨ä¸ç»™åº”ç”¨ç¨‹åºä»£ç å¢åŠ è´Ÿæ‹…çš„æƒ…å†µä¸‹ï¼Œåªæœ‰æœ€è¿‘ä½¿ç”¨çš„grainsæ¿€æ´»ä¼šä¿ç•™åœ¨å†…å­˜ä¸­ï¼Œè€Œä¸å†ä½¿ç”¨çš„æ¿€æ´»ä¼šè¢«è‡ªåŠ¨åˆ é™¤ï¼Œå®ƒä»¬ä½¿ç”¨çš„ç³»ç»Ÿèµ„æºä¼šè¢«è¿è¡Œæ—¶å›æ”¶ã€‚ å¯¹äºGrainsæ´»åŒ–æ”¶é›†è€Œè¨€ï¼Œä»€ä¹ˆç®—æ˜¯â€œæ´»è·ƒâ€ æ¥æ”¶æ–¹æ³•è°ƒç”¨ æ”¶åˆ°æé†’ é€šè¿‡æµæ¥æ”¶äº‹ä»¶ å¯¹äºGrainsæ´»åŒ–æ”¶é›†è€Œè¨€ï¼Œä»€ä¹ˆä¸ç®—â€œæ´»è·ƒâ€ æ‰§è¡Œè®¿é—®(å¯¹å¦ä¸€ä¸ªGrainsæˆ–å¯¹ä¸€ä¸ªOrleanså®¢æˆ·) å®šæ—¶å™¨äº‹ä»¶ ä¸æ¶‰åŠorleansæ¡†æ¶çš„ä»»æ„ioæ“ä½œæˆ–å¤–éƒ¨è°ƒç”¨ æ”¶æ¬¾å¹´é¾„é™åˆ¶ åœ¨è¿™æ®µæ—¶é—´ä¹‹åï¼Œé—²ç½®Grainsçš„æ¿€æ´»ä¼šå—åˆ°æ¿€æ´»GCçš„å½±å“ï¼Œè¿™æ®µæ—¶é—´ç§°ä¸ºæ”¶é›†æœŸé™é™åˆ¶ã€‚é»˜è®¤çš„æ”¶é›†æœŸé™ä¸º2å°æ—¶ï¼Œä½†å¯ä»¥å…¨å±€æ›´æ”¹ï¼Œä¹Ÿå¯ä»¥é’ˆå¯¹å•ä¸ªGrainsç±»æ›´æ”¹ã€‚ æ˜¾å¼æ§åˆ¶æ¿€æ´»åƒåœ¾å›æ”¶ å»¶è¿Ÿæ¿€æ´»gc Grainsæ¿€æ´»å¯ä»¥é€šè¿‡è°ƒç”¨ this.delaydeactivation() æ–¹æ³•ï¼š protected void DelayDeactivation(TimeSpan timeSpan) æ­¤è°ƒç”¨å°†ç¡®ä¿æ­¤æ¿€æ´»è‡³å°‘åœ¨æŒ‡å®šçš„æŒç»­æ—¶é—´å†…ä¸è¢«åœç”¨ã€‚å®ƒçš„ä¼˜å…ˆçº§é«˜äºé…ç½®ä¸­æŒ‡å®šçš„æ¿€æ´»åƒåœ¾å›æ”¶è®¾ç½®ï¼Œä½†ä¸ä¼šå–æ¶ˆè¿™äº›è®¾ç½®ã€‚å› æ­¤ï¼Œæ­¤è°ƒç”¨ä¸º å°†åœç”¨å»¶è¿Ÿåˆ°æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®ä¸­æŒ‡å®šçš„æ—¶é—´ä¹‹å¤– æ˜¯çš„ã€‚æ­¤è°ƒç”¨ä¸èƒ½ç”¨äºåŠ é€Ÿæ¿€æ´»åƒåœ¾æ”¶é›†ã€‚ ç§¯æçš„ æ—¶é—´è·¨åº¦ å€¼è¡¨ç¤ºâ€œåœ¨è¯¥æ—¶é—´æ®µå†…é˜»æ­¢æ­¤æ¿€æ´»çš„GCâ€ã€‚ å¦å®šçš„ æ—¶é—´è·¨åº¦ å€¼è¡¨ç¤ºâ€œå–æ¶ˆ Task.Delay è°ƒç”¨å¹¶ä½¿æ­¤æ¿€æ´»è¡Œä¸ºåŸºäºå¸¸è§„æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®â€ã€‚ æƒ…èŠ‚ï¼š 1)æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®æŒ‡å®š10åˆ†é’Ÿçš„æœŸé™ï¼ŒGrainsæ­£åœ¨è°ƒç”¨ Task.Delay(TimeSpan.FromMinutes(20)) ï¼Œå®ƒå°†å¯¼è‡´è‡³å°‘20åˆ†é’Ÿå†…æ— æ³•æ”¶é›†æ­¤æ¿€æ´»ã€‚ 2)æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®æŒ‡å®š10åˆ†é’Ÿçš„æœŸé™ï¼ŒGrainsæ­£åœ¨è°ƒç”¨ Task.Delay(TimeSpan.FromMinutes(5)) ï¼Œå¦‚æœæ²¡æœ‰é¢å¤–è®¿é—®ï¼Œåˆ™æ¿€æ´»å°†åœ¨10åˆ†é’Ÿåæ”¶é›†ã€‚ 3)æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®æŒ‡å®š10åˆ†é’Ÿçš„æœŸé™ï¼ŒGrainsæ­£åœ¨è°ƒç”¨ Task.Delay(TimeSpan.FromMinutes(5)) ï¼Œ7åˆ†é’Ÿåï¼Œå¦‚æœæ²¡æœ‰é¢å¤–çš„è°ƒç”¨ï¼Œåˆ™ä¼šåœ¨17åˆ†é’Ÿåä»æ—¶é—´0å¼€å§‹æ”¶é›†æ¿€æ´»ã€‚ 4)æ¿€æ´»åƒåœ¾æ”¶é›†è®¾ç½®æŒ‡å®š10åˆ†é’Ÿçš„æœŸé™ï¼ŒGrainsæ­£åœ¨è°ƒç”¨ Task.Delay(TimeSpan.FromMinutes(20)) ï¼Œ7åˆ†é’Ÿåï¼Œæ­¤Grainsä¸Šè¿˜æœ‰å¦ä¸€ä¸ªè°ƒç”¨ï¼Œå¦‚æœæ²¡æœ‰é¢å¤–çš„è°ƒç”¨ï¼Œåˆ™å°†åœ¨ä»æ—¶é—´0å¼€å§‹çš„20åˆ†é’Ÿåæ”¶é›†æ¿€æ´»ã€‚ è¯·æ³¨æ„ Task.Delay æ— æ³•100%ä¿è¯åœ¨æŒ‡å®šçš„æ—¶é—´æ®µåˆ°æœŸä¹‹å‰ä¸ä¼šåœç”¨Grainsæ¿€æ´»ã€‚æœ‰äº›å¤±æ•ˆæ¡ˆä¾‹å¯èƒ½å¯¼è‡´Grainsè¿‡æ—©å¤±æ´»ã€‚ä¹Ÿå°±æ˜¯è¯´ Task.Delay ä¸èƒ½ç”¨ä½œæ°¸ä¹…â€œå›ºå®šâ€å†…å­˜ä¸­çš„grainsæ¿€æ´»æˆ–å›ºå®šåˆ°ç‰¹å®šsilosçš„æ–¹æ³• æ˜¯çš„ã€‚ Task.Delay è¿™ä»…ä»…æ˜¯ä¸€ç§ä¼˜åŒ–æœºåˆ¶ï¼Œå¯ä»¥å¸®åŠ©é™ä½Grainséšç€æ—¶é—´çš„æ¨ç§»è¢«åœç”¨å’Œé‡æ–°æ¿€æ´»çš„æ€»æˆæœ¬ï¼Œå¦‚æœè¿™å¾ˆé‡è¦çš„è¯ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä¸éœ€è¦ä½¿ç”¨ Task.Delay å®Œå…¨ã€‚ åŠ é€Ÿæ´»åŒ–æ°”ç›¸è‰²è°± Grainsæ¿€æ´»è¿˜å¯ä»¥é€šè¿‡è°ƒç”¨ è¿™ä¸ªã€‚åœç”¨ç©ºé—²() æ–¹æ³•ï¼š protected void DeactivateOnIdle() å¦‚æœæ­¤æ—¶ä¸å¤„ç†ä»»ä½•æ¶ˆæ¯ï¼Œåˆ™è®¤ä¸ºGrainsæ¿€æ´»å¤„äºç©ºé—²çŠ¶æ€ã€‚å¦‚æœä½ è°ƒç”¨ åœç”¨ç©ºé—² å½“Grainsæ­£åœ¨å¤„ç†æ¶ˆæ¯æ—¶ï¼Œä¸€æ—¦å½“å‰æ¶ˆæ¯çš„å¤„ç†å®Œæˆï¼Œå®ƒå°†è¢«åœç”¨ã€‚ å¦‚æœæœ‰ä»»ä½•è¯·æ±‚æ’é˜Ÿç­‰å¾…Grainsï¼Œå®ƒä»¬å°†è¢«è½¬å‘åˆ°ä¸‹ä¸€ä¸ªæ¿€æ´»ã€‚ åœç”¨ç©ºé—² ä¼˜å…ˆäºé…ç½®æˆ– Task.Delay æ˜¯çš„ã€‚è¯·æ³¨æ„ï¼Œæ­¤è®¾ç½®ä»…é€‚ç”¨äºè°ƒç”¨å®ƒçš„grainsæ¿€æ´»ï¼Œè€Œä¸é€‚ç”¨äºæ­¤ç±»å‹çš„å…¶ä»–grainsæ¿€æ´»ã€‚ é…ç½® å¯ä»¥ä½¿ç”¨ GrainCollectioné€‰é¡¹ é€‰é¡¹ï¼š mySiloHostBuilder.Configure<GrainCollectionOptions>(options => { // Set the value of CollectionAge to 10 minutes for all grain options.CollectionAge = TimeSpan.FromMinutes(10); // Override the value of CollectionAge to 5 minutes for MyGrainImplementation options.ClassSpecificCollectionAge[typeof(MyGrainImplementation).FullName] = TimeSpan.FromMinutes(5); })"
  },
  "Documentation/clusters_and_clients/configuration_guide/typical_configurations.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/typical_configurations.html",
    "title": "Typical Configurations | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å…¸å‹é…ç½® ä¸‹é¢æ˜¯å¯ç”¨äºå¼€å‘å’Œç”Ÿäº§éƒ¨ç½²çš„å…¸å‹é…ç½®ç¤ºä¾‹ã€‚ åœ°æ–¹å‘å±• è§ æœ¬åœ°å¼€å‘é…ç½® ä½¿ç”¨azureçš„å¯é ç”Ÿäº§éƒ¨ç½² è¦ä½¿ç”¨azureè¿›è¡Œå¯é çš„ç”Ÿäº§éƒ¨ç½²ï¼Œéœ€è¦ä½¿ç”¨azureè¡¨é€‰é¡¹ä½œä¸ºç¾¤é›†æˆå‘˜èº«ä»½ã€‚æ­¤é…ç½®æ˜¯éƒ¨ç½²åˆ°æœ¬åœ°æœåŠ¡å™¨ã€å®¹å™¨æˆ–azureè™šæ‹Ÿæœºå®ä¾‹çš„å…¸å‹é…ç½®ã€‚ æ•°æ®è¿æ¥å­—ç¬¦ä¸²çš„æ ¼å¼ä¸º â€œDefaultEndpointsProtocol=httpsï¼›å¸æˆ·å=<azureå­˜å‚¨å¸æˆ·>ï¼›å¸æˆ·å¯†é’¥=<azureè¡¨å­˜å‚¨å¸æˆ·å¯†é’¥>â€ silosé…ç½®ï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAzureStorageClustering(options => options.ConnectionString = connectionString) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); å®¢æˆ·ç«¯é…ç½®ï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var client = new ClientBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAzureStorageClustering(options => options.ConnectionString = connectionString) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); ä½¿ç”¨SQL Serverè¿›è¡Œå¯é çš„ç”Ÿäº§éƒ¨ç½² ä¸ºäº†ä½¿ç”¨SQL Serverè¿›è¡Œå¯é çš„ç”Ÿäº§éƒ¨ç½²ï¼Œéœ€è¦æä¾›SQL Serverè¿æ¥å­—ç¬¦ä¸²ã€‚ silosé…ç½®ï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var silo = new SiloHostBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAdoNetClustering(options => { options.ConnectionString = connectionString; options.Invariant = \"System.Data.SqlClient\"; }) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); å®¢æˆ·ç«¯é…ç½®ï¼š // TODO replace with your connection string const string connectionString = \"YOUR_CONNECTION_STRING_HERE\"; var client = new ClientBuilder() .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .UseAdoNetClustering(options => { options.ConnectionString = connectionString; options.Invariant = \"System.Data.SqlClient\"; }) .ConfigureLogging(builder => builder.SetMinimumLevel(LogLevel.Warning).AddConsole()) .Build(); åœ¨ä¸“ç”¨æœåŠ¡å™¨ç¾¤é›†ä¸Šéƒ¨ç½²ä¸å¯é  å¯¹äºåœ¨ä¸è€ƒè™‘å¯é æ€§çš„æƒ…å†µä¸‹åœ¨ä¸“ç”¨æœåŠ¡å™¨é›†ç¾¤ä¸Šè¿›è¡Œæµ‹è¯•ï¼Œå¯ä»¥åˆ©ç”¨MembershipTableGrainå¹¶é¿å…å¯¹azureè¡¨çš„ä¾èµ–ã€‚æ‚¨åªéœ€è¦å°†å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å®šä¸ºä¸»èŠ‚ç‚¹ã€‚ åœ¨silosä¸Šï¼š var primarySiloEndpoint = new IPEndpoint(PRIMARY_SILO_IP_ADDRESS, 11111); var silo = new SiloHostBuilder() .UseDevelopmentClustering(primarySiloEndpoint) .Configure<ClusterOptions>(options => { options.ClusterId = \"Cluster42\"; options.ServiceId = \"MyAwesomeService\"; }) .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000) .ConfigureLogging(logging => logging.AddConsole()) .Build(); å¯¹å®¢æˆ·ï¼š var gateways = new IPEndPoint[] { new IPEndPoint(PRIMARY_SILO_IP_ADDRESS, 30000), new IPEndPoint(OTHER_SILO__IP_ADDRESS_1, 30000), [...] new IPEndPoint(OTHER_SILO__IP_ADDRESS_N, 30000), }; var client = new ClientBuilder() .UseStaticClustering(gateways) .Configure<ClusterOptions>(options => { options.ClusterId = \"dev\"; options.ServiceId = \"AdventureApp\"; }) .ConfigureLogging(logging => logging.AddConsole()) .Build();"
  },
  "Documentation/clusters_and_clients/monitoring/client_error_code_monitoring.html": {
    "href": "Documentation/clusters_and_clients/monitoring/client_error_code_monitoring.html",
    "title": "Client Error Code Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å®¢æˆ·ç«¯é”™è¯¯ä»£ç ç›‘è§† ç¾¤ç»„ æ—¥å¿—ç±»å‹ æ—¥å¿—ä»£ç å€¼ é—¨æ§› è¯´æ˜ azureé—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 100800è‡³100899 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š è¯»å–æˆ–å†™å…¥azureè¡¨å­˜å‚¨çš„æš‚æ—¶æ€§é—®é¢˜å°†è®°å½•ä¸ºè­¦å‘Šã€‚å°†è‡ªåŠ¨é‡è¯•ä¸´æ—¶è¯»å–é”™è¯¯ã€‚æœ€åä¸€æ¡é”™è¯¯æ—¥å¿—æ¶ˆæ¯æ„å‘³ç€è¿æ¥åˆ°azureè¡¨å­˜å‚¨å­˜åœ¨å®é™…é—®é¢˜ã€‚ ç½‘å…³è¿æ¥é—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 100901-100904ã€100912ã€100913ã€100921ã€100923ã€100158ã€100161ã€100178ã€101313 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š è¿æ¥åˆ°ç½‘å…³æ—¶å‡ºç°é—®é¢˜ã€‚azureè¡¨ä¸­æ²¡æœ‰æ´»åŠ¨ç½‘å…³ã€‚ä¸æ´»åŠ¨ç½‘å…³çš„è¿æ¥ä¸¢å¤±ã€‚ Grainsè®¿é—®è¶…æ—¶ è­¦å‘Š 100157ä¸ª çŸ­æ—¶é—´å†…è®°å½•å¤šä¸ªè­¦å‘Š Grainsè°ƒç”¨è¶…æ—¶é—®é¢˜é€šå¸¸ç”±ä¸´æ—¶ç½‘ç»œè¿æ¥é—®é¢˜æˆ–silosé‡æ–°å¯åŠ¨/é‡æ–°å¯åŠ¨é—®é¢˜å¼•èµ·ã€‚ç³»ç»Ÿåº”åœ¨çŸ­æ—¶é—´åæ¢å¤(å–å†³äºæ´»åŠ¨é…ç½®è®¾ç½®)ï¼Œæ­¤æ—¶åº”æ¸…é™¤è¶…æ—¶ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä»…ç›‘è§†æ‰¹é‡æ—¥å¿—ä»£ç 600157è¿™äº›è­¦å‘Šçš„ç§ç±»å°±åº”è¯¥è¶³å¤Ÿäº†ã€‚ ç½‘ç»œå¥—æ¥å­—é—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 101000è‡³101999ã€100307ã€100015ã€100016 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š æ’åº§æ–­å¼€è®°å½•ä¸ºè­¦å‘Šæ¶ˆæ¯ã€‚æ‰“å¼€å¥—æ¥å­—æˆ–åœ¨æ¶ˆæ¯ä¼ è¾“æœŸé—´å‡ºç°çš„é—®é¢˜è®°å½•ä¸ºé”™è¯¯ã€‚ å¤§å®¹é‡æ—¥å¿—æ¶ˆæ¯å‹ç¼© ä»»ä½• 500000æˆ–æ›´é«˜ åŸºäºæ‰¹é‡æ¶ˆæ¯é˜ˆå€¼è®¾ç½®çš„æ¶ˆæ¯æ‘˜è¦ å¦‚æœåŒä¸€æ—¥å¿—ä»£ç çš„å¤šä¸ªæ—¥å¿—åœ¨æŒ‡å®šçš„æ—¶é—´é—´éš”å†…å‡ºç°(é»˜è®¤å€¼ä¸º1åˆ†é’Ÿå†…>5)ï¼Œåˆ™å…·æœ‰è¯¥æ—¥å¿—ä»£ç çš„å…¶ä»–æ—¥å¿—æ¶ˆæ¯å°†è¢«æŠ‘åˆ¶ï¼Œå¹¶ä½œä¸ºæ—¥å¿—ä»£ç ç­‰äºåŸå§‹æ—¥å¿—ä»£ç +500000çš„â€œæ‰¹é‡â€æ¡ç›®è¾“å‡ºã€‚ä¾‹å¦‚ï¼Œå¤šä¸ª100157æ¡ç›®å°†åœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºä¸ºæ¯åˆ†é’Ÿ5 x 100157+1 x 600157ä¸ªæ—¥å¿—æ¡ç›®ã€‚"
  },
  "Documentation/clusters_and_clients/monitoring/index.html": {
    "href": "Documentation/clusters_and_clients/monitoring/index.html",
    "title": "Runtime Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "è¿è¡Œæ—¶ç›‘è§† Orleansé€šè¿‡ ITelemetryConsumer æ¥å£ã€‚åº”ç”¨ç¨‹åºå¯ä»¥å‘ä¸€ä¸ªæˆ–å¤šä¸ªé¥æµ‹ç”¨æˆ·æ³¨å†Œå®ƒä»¬çš„siloså’Œå®¢æˆ·ç«¯ï¼Œä»¥æ¥æ”¶Orleans Runtime Perioticå‘å¸ƒçš„ç»Ÿè®¡ä¿¡æ¯å’Œåº¦é‡ã€‚å®ƒä»¬å¯ä»¥æ˜¯æµè¡Œçš„é¥æµ‹åˆ†æè§£å†³æ–¹æ¡ˆçš„æ¶ˆè´¹è€…ï¼Œä¹Ÿå¯ä»¥æ˜¯ä»»ä½•å…¶ä»–ç›®çš„åœ°å’Œç”¨é€”çš„è‡ªå®šä¹‰è§£å†³æ–¹æ¡ˆçš„æ¶ˆè´¹è€…ã€‚ä¸‰ä¸ªé¥æµ‹ç”¨æˆ·ç›®å‰åŒ…å«åœ¨Orleansä»£ç åº“ä¸­ã€‚ å®ƒä»¬ä½œä¸ºå•ç‹¬çš„nugetåŒ…å‘å¸ƒï¼š Microsoft.Orleans.OrleanstelemtryConsumers.ai å‘å¸ƒåˆ° åº”ç”¨æ´å¯Ÿ æ˜¯çš„ã€‚ Microsoft.Orleans.OrleanstelemtryConsumers.Counters ç”¨äºå‘å¸ƒåˆ°Windowsæ€§èƒ½è®¡æ•°å™¨ã€‚Orleansè¿è¡Œæ—¶ä¼šä¸æ–­æ›´æ–°å…¶ä¸­çš„ä¸€äº›ã€‚CounterControl.exeå·¥å…·ï¼ŒåŒ…å«åœ¨ Microsoft.Orleans.CounterControl nugetåŒ…ï¼Œå¸®åŠ©æ³¨å†Œå¿…è¦çš„æ€§èƒ½è®¡æ•°å™¨ç±»åˆ«ã€‚å®ƒå¿…é¡»ä»¥æå‡çš„æƒé™è¿è¡Œã€‚å¯ä»¥ä½¿ç”¨ä»»ä½•æ ‡å‡†ç›‘è§†å·¥å…·ç›‘è§†æ€§èƒ½è®¡æ•°å™¨ã€‚ microsoft.orleans.orleanstelemtryconsumers.newrelic ï¼Œç”¨äºå‘å¸ƒåˆ° æ–°æ–‡ç‰© æ˜¯çš„ã€‚ è¦å°†siloså’Œå®¢æˆ·ç«¯é…ç½®ä¸ºä½¿ç”¨é¥æµ‹ç”¨æˆ·ï¼Œsilosé…ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š var siloHostBuilder = new SiloHostBuilder(); //configure the silo with AITelemetryConsumer siloHostBuilder.AddApplicationInsightsTelemetryConsumer(\"INSTRUMENTATION_KEY\"); å®¢æˆ·ç«¯é…ç½®ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š var clientBuilder = new ClientBuilder(); //configure the clientBuilder with AITelemetryConsumer clientBuilder.AddApplicationInsightsTelemetryConsumer(\"INSTRUMENTATION_KEY\");"
  },
  "1.5/Tutorials/Actor-Identity.html": {
    "href": "1.5/Tutorials/Actor-Identity.html",
    "title": "Actor Identity | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Actor Identity In object-oriented environments, the identity of an object is hard to distinguish from a reference to it. Thus, when an object is created using new, the reference you get back represents all aspects of its identity except those that map the object to some external entity that it represents. In distributed systems, object references cannot represent instance identity, since references are typically limited to a single address space. That is certainly the case for .NET references. Furthermore, a virtual actor must have an identity regardless of whether it is active, so that we can activate it on demand. Therefore grains have a primary key. The primary key can be either a GUID (A Globally Unique Identifier), a long integer, or a string. The primary key is scoped to the grain type. Therefore, the complete identity of a grain is formed from the actor type and its key. The caller of the grain decides a long, a GUID, or a string scheme should be used. In fact the underlying data is the same, so the schemes can be used interchangeably. When a long is used, a GUID is actually created, and padded with zeros. Situations that require a singleton grain instance, such as a dictionary or registry, benefit from using 0 (a valid GUID) as its key. This is merely a convention, but by adhering, it becomes clear at the call site that it is what is going on, as we saw in the first tutorial: Using GUIDs GUIDs are useful when there are several processes that could request a grain, such as a number of web servers in a web farm. You don't need to coordinate the allocation of keys, which could introduce a single point of failure in the system, or a system-side lock on a resource which could present a bottleneck. There is a very low chance of GUIDs colliding, so they would probably be the default choice when architecting an Orleans system. Referencing a grain by GUID in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(Guid.NewGuid()); Retrieving the primary key from grain code: public override Task OnActivateAsync() { Guid primaryKey = this.GetPrimaryKey(); return base.OnActivateAsync(); } Using Longs A long integer is also available, which would make sense if the grain is persisted to a relational database, where numerical indexes are preferred over GUIDs. Referencing a grain by long integer in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(1); Retrieving the primary key form grain code: public override Task OnActivateAsync() { long primaryKey = this.GetPrimaryKeyLong(); return base.OnActivateAsync(); } Using Strings A string is also available. Referencing a grain by String in client code: var grain = GrainClient.GrainFactory.GetGrain<IExample>(\"myGrainKey\"); Retrieving the primary key form grain code: public override Task OnActivateAsync() { string primaryKey = this.GetPrimaryKeyString(); return base.OnActivateAsync(); } The stock ticker example used in the Interaction with Libraries and Services uses a string keys to activate grains representing different stock symbols. Using Compound Primary Key If you have a system that doesn't fit well with either GUIDs or longs, you can opt for a compound primary key which allows you to use a combination of a GUID or long and a string to reference a grain. You can inherit your interface from 'IGrainWithGuidCompoundKey' or 'IGrainWithIntegerCompoundKey\" interface like this: public interface IExampleGrain : Orleans.IGrainWithIntegerCompoundKey { Task Hello(); } In client code, this adds a second argument to the GetGrain method on the grain factory. var grain = GrainClient.GrainFactory.GetGrain<IExample>(0, \"a string!\", null); To access the compound key in the grain, we can call an overload on the GetPrimaryKey method: public class ExampleGrain : Orleans.Grain, IExampleGrain { public Task Hello() { string keyExtension; long primaryKey = this.GetPrimaryKey(out keyExtension); Console.WriteLine(\"Hello from \" + keyExtension); return TaskDone.Done; } } Next Let's add another type of grain into the solution, and demonstrate inter-grain communication. A Service is a Collection of Communicating Actors"
  },
  "1.5/Tutorials/Interaction-with-Libraries-and-Services.html": {
    "href": "1.5/Tutorials/Interaction-with-Libraries-and-Services.html",
    "title": "Interaction with Libraries and Services | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Interaction with Libraries and Services Code running in a grain is not prohibited from calling external systems or services, but the rule for always using asynchronous code must be maintained. In this sample we'll see how a grain can call out to an external service. Creating a Stock Grain For this sample, let's create a grain which maintains the current price for a stock. Create a grain interface project, and add an interface for an IStockGrain : public interface IStockGrain : Orleans.IGrainWithStringKey { Task<string> GetPrice(); } Note, we've opted for an string-based key for our grain, which is useful since the ticker symbol makes a natural key. The IGrainWithStringKey interface is new in the September refresh. Now add a grain implementation project, and add a reference to the interface project. Add a reference to System.Net.Http . We'll implement the grain so it retrieves the price of the stock when it is activated: public class StockGrain : Orleans.Grain, IStockGrain { // demo key might not work, claim yours at https://www.alphavantage.co/support/# private const string apiKey = \"demo\"; string price; public override async Task OnActivateAsync() { string stock; this.GetPrimaryKey(out stock); await UpdatePrice(stock); await base.OnActivateAsync(); } async Task UpdatePrice(string stock) { price = await GetPriceQuote(stock); } async Task<string> GetPriceQuote(string stock) { var uri = $\"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol={stock}&apikey={apiKey}&datatype=csv\"; using (var http = new HttpClient()) using (var resp = await http.GetAsync(uri)) { return await resp.Content.ReadAsStringAsync(); } } public Task<string> GetPrice() { return Task.FromResult(price); } } Next create some client code to connect to the Orleans Silo, and retrieve the grain state: Console.WriteLine(\"Waiting for Orleans Silo to start. Press Enter to proceed...\"); Console.ReadLine(); var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000); GrainClient.Initialize(config); // retrieve the MSFT stock var grain = GrainClient.GrainFactory.GetGrain<IStockGrain>(\"MSFT\"); var price = grain.GetPrice().Result; Console.WriteLine(price); Console.ReadLine(); When we start the local silo, and run the application, we should see the stock value written out symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.6875,20725407,2018-10-18,110.7100,-2.0225,-1.8268% Note that the extra text in the stock price is just the formatting that Alphavantage returned. Refreshing the value with a timer The problem with the grain as it stands is that the value of the stock will change, but the grain will maintain the same value for it's lifetime (an indefinite period of time). One way to fix this is to periodically refresh the price. A traditional .NET timer is not suitable for running in a grain. Instead, Orleans provides it's own timer. Let's re-factor the OnActivateAsync() method to introduce a timer which will call the UpdatePrice method in 1 minute, and then repeatedly every minute from then on, until the grain is deactivated: public override async Task OnActivateAsync() { string stock; this.GetPrimaryKey(out stock); await UpdatePrice(stock); RegisterTimer( UpdatePrice, stock, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1)); await base.OnActivateAsync(); } We'll also have to slightly adjust the UpdatePrice method, as the stock argument must be an object rather than a string. We'll also add some logging so we can see what's happening: async Task UpdatePrice(object stock) { price = await GetPriceQuote(stock as string); Console.WriteLine(price); } The RegisterTimer method takes four arguments: callback - A function to call. state - An object to pass as the first argument of the callback function (this can be null). dueTime - The period to wait before starting the first call to callback . period - The period between subsequent calls to callback . Note: In our sample we're passing the stock name as the state argument when we register the timer. This means the stock name is presented to the UpdatePrice method as the argument. Alternative we could set state to be null , and read the stock name from inside UpdatePrice using GetPrimaryKey . The method returns an IOrleansTimer which is disposable and can be used to stop the timer. It's a good idea to hold on to a reference to this in case you need to stop the timer. Now when we run the sample, the grain is activated, the timer gets registered and every minute the price is updated for us: symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3000,21747221,2018-10-18,110.7100,-2.4100,-2.1769% symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3100,21750728,2018-10-18,110.7100,-2.4000,-2.1678% symbol,open,high,low,price,volume,latestDay,previousClose,change,changePercent MSFT,110.1000,110.5300,107.8300,108.3300,21762108,2018-10-18,110.7100,-2.3800,-2.1498% Orleans is acting as an automatically refreshing cache. Whenever a stock grain is queried Orleans will provide the latest price it has, without having to make a call to the stock web service. Parallelization Running code in a single threaded execution model, does not prohibit you from awaiting several tasks at once (or in parallel). Let's add a new function to retrieve the graph data for a stock: async Task<string> GetDailySeries(string stock) { var uri = $\"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={stock}&apikey={apiKey}&datatype=csv\"; using (var http = new HttpClient()) using (var resp = await http.GetAsync(uri)) { return await resp.Content.ReadAsStringAsync(); } } We'll also add a new field to the grain to store this information: string graphData; Now we can retrieve the graph data and current price like this: async Task UpdatePrice(object stock) { price = await GetPriceQuote(stock as string); graphData = await GetDailySeries(stock as string); Console.WriteLine(price); } However, by doing this we're waiting for the price from Yahoo, and after that's complete we request the graph data. This is inefficient, as we could be doing these at the same time. Fortunately, Task has a convenient WhenAll method which allows us to await multiple tasks at once, allowing these tasks to complete in parallel. async Task UpdatePrice(object stock) { // collect the task variables without awaiting var priceTask = GetPriceQuote(stock as string); var graphDataTask = GetDailySeries(stock as string); // await both tasks await Task.WhenAll(priceTask, graphDataTask); // read the results price = priceTask.Result; graphData = graphDataTask.Result; Console.WriteLine(price); } Note: The Result of a Task will block execution if the task hasn't completed. This should be avoided in Orleans, tasks should always be awaited before Result is read. Note: When a large number of asynchronous actions need to happen simultaneously you can collect the tasks in a List<Task<T>> and present this to Task.WhenAll . External Tasks It's tempting to use the Task Parallel Library \"TPL\" for executing parallel tasks in Orleans, but TPL uses the .NET thread pool to dispatch tasks. This is prohibited within grain code. Orleans has its own task scheduler which provides the single threaded execution model used within grains. It's important that when running tasks the Orleans scheduler is used, and not the .NET thread pool. Should your grain code require a sub-task to be created, you should use Task.Factory.StartNew : await Task.Factory.StartNew(() =>{ /* logic */ }); This technique will use the current task scheduler, which will be the Orleans scheduler. You should avoid using Task.Run , which always uses the .NET thread pool, and therefore will not run in the single-threaded execution model. Next Let's look at how Orleans can persist grain state for us: Declarative Persistence"
  },
  "1.5/Tutorials/Cloud-Deployment.html": {
    "href": "1.5/Tutorials/Cloud-Deployment.html",
    "title": "Cloud Deployment | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Cloud Deployment Deploying Orleans to Windows Azure This walkthrough shows the steps required to deploy the sample created in the Front Ends for Orleans Services to Windows Azure Cloud Services. In Azure, one or more worker roles will be used to host the Orleans silos, and an Azure web role will act as the presentation layer for the application and client to the application grains running in the Orleans silos. The same grain interfaces and implementation can run on both Windows Server and Windows Azure, so no special considerations are needed in order to be able to run your application in a Windows Azure hosting environment. The Azure Web Sample sample app provides a working example of how to run a web application with supporting Orleans silo cluster backend in an Azure hosted service, and the details are described below. Pre-requisites The following prerequisites are required: Visual Studio 2013 or 2015 Windows Azure SDK v2.4 or higher For more info on installing and working with Windows Azure in general, see the Microsoft Azure documentation web site: ( https://docs.microsoft.com/en-us/azure/ ) Create Azure Worker Role for Orleans Silos Right click on your solution, and select 'Add | New Project...'. Choose the 'Windows Azure Cloud Service' project template: When prompted, select a new 'Worker Role' to add to the project. This will be used to host the Orleans Silos: Add project references for Orleans Silo binaries Add references to the OrleansAzureSilo project for the required Orleans server library files. Copies of these files can be found in the .\\Binaries\\OrleansServer folder under the Orleans SDK. Orleans.dll OrleansAzureUtils.dll OrleansRuntime.dll OrleansProviders.dll (Only required if you your grains use the Declarative Persistence functionality.) Note: All of these references MUST have Copy Local = 'True' settings to ensure the necessary library DLLs get copied into the OrleansAzureSilo project output directory. Configure Azure Worker Role for Orleans Silos The Worker Role initialization class is a normal Azure worker role - it needs to inherit from the usual Microsoft.WindowsAzure.ServiceRuntime.RoleEntryPoint base class. The worker role initialization class needs to create an instance of Orleans.Runtime.Host.AzureSilo class, and call the appropriate Start / Run / Stop functions in the appropriate places: public class WorkerRole : RoleEntryPoint { AzureSilo silo; public override bool OnStart() { // Do other silo initialization â€“ for example: Azure diagnostics, etc return base.OnStart(); } public override void OnStop() { silo.Stop(); base.OnStop(); } public override void Run() { var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); // Configure storage providers silo = new AzureSilo(); bool ok = silo.Start(config); silo.Run(); // Call will block until silo is shutdown } } It is IMPORTANT to start the silo not in OnStart but in Run. Azure may not have the firewalls open yet (on the remote silos) at the OnStart phase. Then, in the ServiceDefinition.csdef file for this role, add some required configuration items used by the Orleans Azure hosting library to the WorkerRole configuration: Add a ConfigurationSettings declaration named 'DataConnectionString'. This is the Azure storage location where Orleans Azure hosting library will place / look for its silo instance table. Add an InternalEndpoint declaration for a TCP endpoint named 'OrleansSiloEndpoint' Add an InternalEndpoint declaration for a TCP endpoint named 'OrleansProxyEndpoint' <ServiceDefinition ...> <WorkerRole name=\"OrleansAzureSilos\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" /> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> ... </WorkerRole> ... </ServiceDefinition> In the ServiceConfiguration.cscfg file for this role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings definition for 'DataConnectionString' This will be a normal Azure storage connection â€“ either for the development storage emulator (only valid if running locally), or a full Azure storage account connection string for cloud-storage. In general, this connection string is likely to use the same configuration values as the Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString diagnostics connection string setting, but is not required to. Be careful to not mix up Azure storage and local storage. This can cause deployments to not work. See the Configure Azure Storage Connection Strings for more information. For example, to use local Developer Storage emulator (for local testing only) <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"UseDevelopmentStorage=true\" /> <Setting name=\"DataConnectionString\" value=\"UseDevelopmentStorage=true\" /> </ConfigurationSettings> Or using an Azure cloud storage account: <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> </ConfigurationSettings> Changing DataConnectionString The \"DataConnectionString\" setting in ServiceDefinition.csdef is the default name use by the Orleans silo for the Azure table account connection string that will be used for Orleans system tables such as OrleanSiloInstances . If you wish to use a different setting name for this value, then in the silo role initialization code set the property OrleansAzureSilo.DataConnectionConfigurationSettingName before the call to OrleansAzureSilo.Start(...) Add your grain binaries to Azure Worker Role for Orleans Silos Add the grain interfaces DLL and implementation classes DLL for the grains to be hosted in the Azure silo into the OrleansAzureSilo project, along with any supporting libraries those grains need. Note: You MUST ensure that all the referenced binaries are copied into the OrleansAzureSilo project output directory, to ensure they get picked up by the Azure packaging tools. Running Orleans Client as Azure Web Role The user interface / presentation layer for your application will usually run as a Web Role in Azure. The Orleans.Runtime.Host.AzureClient utility class is the main mechanism for bootstrapping connection to the Orleans silo worker roles from an Azure Web Role. A few additional configuration steps are needed to make the AzureClient utility class work â€“ see below for details. Create Azure Web Role for Orleans Client Any type of web role can be used as an Orleans client, and there are no specific naming requirements or conventions for this project. Add a web role to the solution using the existing web application project that we created in the Front Ends for Orleans Services tutorial. Add project references for Orleans Client binaries. Add references to the web role project for the required Orleans client library files. Copies of these files can be found in either SDK-ROOT\\Samples\\References or SDK-ROOT\\Binaries\\OrleansClient directories. Orleans.dll OrleansAzureUtils.dll Note: All of these references MUST have Copy Local = 'True' settings to ensure the necessary library DLLs get copied into the web role project output directory. Configure Azure Web Role to be an Orleans Client In the ServiceDefinition.csdef file for this web role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings declaration named 'DataConnectionString'. This is the Azure storage location where Orleans Azure hosting library will place / look for its silo instance table. In addition, a http/s InputEndpoint will also need to be declared, just as for any other Azure web role config. <ServiceDefinition ...> <WebRole name=\"MyWebRole\" ...> ... <Sites> <Site name=\"Web\"> <Bindings> <Binding name=\"Endpoint1\" endpointName=\"Endpoint1\" /> </Bindings> </Site> </Sites> <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" /> <Setting name=\"DataConnectionString\" /> </ConfigurationSettings> <Endpoints> <InputEndpoint name=\"Endpoint1\" protocol=\"http\" port=\"80\" /> </Endpoints> ... </WebRole> ... </ServiceDefinition> In the ServiceConfiguration.cscfg file for this role, add some required configuration items used by the Orleans Azure hosting library: Add a ConfigurationSettings definition for 'DataConnectionString'. This will be a normal Azure storage connection â€“ either for the development storage emulator (if running locally), or a full Azure storage account connection string for cloud-storage. This setting MUST match the DataConnectionString value used by the OrleansSiloWorker role in order for the client to discover and bootstrap the connection to the Orleans silos. For example, to use local Developer Storage emulator (for local testing only) <ServiceConfiguration ...> <Role name=\"OrleansWebClient\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"UseDevelopmentStorage=true\" /> <Setting name=\"DataConnectionString\" value=\"UseDevelopmentStorage=true\" /> </ConfigurationSettings> ... </Role> ... </ServiceConfiguration> Or using an Azure cloud storage account: <ServiceConfiguration ...> <Role name=\"OrleansWebClient\" ...> ... <ConfigurationSettings> <Setting name=\"Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> <Setting name=\"DataConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=MyAccount;AccountKey=MyKey\" /> </ConfigurationSettings> ... </Role> ... </ServiceConfiguration> Add your grain interface binaries to Azure Web Role for Orleans Client Add the grain interfaces DLL for the application grains into this web role project. Access to the DLL containing the grain implementation classes should not be required by the client web role. Note: You MUST ensure that all the referenced binaries for grain interfaces and the generated proxy / factory libraries are copied into the web role project output directory, to ensure they get picked up by the Azure packaging tools. The grain implementation DLLs should not be required by the client and so should not be referenced by the web role. Initialize Client Connection to Orleans Silos It is recommended to bootstrap and initialize the client connection to the Orleans silo worker roles, to ensure a connection is set up before use in the Global.asax initialization methods. Edit the configuration of the client in the Global.asax.cs file to use AzureClient . namespace WebApplication1 { public class WebApiApplication : System.Web.HttpApplication { protected void Application_Start() { ... var config = AzureClient.DefaultConfiguration(); // Attempt to connect a few times to overcome transient failures and to give the silo enough // time to start up when starting at the same time as the client (useful when deploying or during development). const int initializeAttemptsBeforeFailing = 5; int attempt = 0; while (true) { try { AzureClient.Initialize(config); break; } catch (SiloUnavailableException e) { attempt++; if (attempt >= initializeAttemptsBeforeFailing) { throw; } Thread.Sleep(TimeSpan.FromSeconds(2)); } } ... Repeated calls to AzureClient.Initialize() will return and do nothing if the Orleans client connection is already set up. An additional variant of AzureClient.Initialize(System.IO.FileInfo) allows a base client config file location to be specified explicitly. The internal endpoint addresses of the Orleans silo nodes will still be determined dynamically from the Orleans Silo instance table each silo node registers with. <!--TODO: Create link to Orleans API when the link is created/found--> See the Orleans API docs for details of the various Initialize methods available. Deploying to Azure The normal Azure deployment tools are used to deploy the application to Windows Azure â€“ either into the local Azure Compute Emulator for local development / test (Press F5 to run), or into the Azure cloud hosting environment right click on the Cloud project and select 'Publish': Next Let's look at the steps required to run Orleans on Windows Server: On-Premise Deployment"
  },
  "1.5/Tutorials/index.html": {
    "href": "1.5/Tutorials/index.html",
    "title": "Step by Step Tutorials | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "These tutorials are for the 1.5 release Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Step by Step Tutorials The collection of technology walkthrough tutorials found here is intended to introduce you to the features of this exciting technology, spanning the programming model, its configuration, deployment, and customization. They build on each other, so it is best to go through them in the order outlined below. Each walkthrough is focused narrowly on just a couple of specific concepts in isolation from the scenarios that motivate your using Orleans in the first place, they are intended to teach you the mechanics of Orleans, not to explain when or why you should be using them. My First Orleans Application This walkthrough shows you how to create a \"Hello World\" application using Orleans and run it in the simplest possible single-process environment, one that is convenient for debugging your code. Minimal Orleans Application This walkthrough is an alternative to the My First Orleans Application tutorial. It walks step by step through a basic application, using only the nuget packages. Running in a Stand-Alone Silo In this walkthrough, the simple \"Hello World\" application is modified to use a more typical environment for services: separate processes for the client and service code. It is still a development and debugging environment, simpler than a production configuration, which would involve multiple processes on multiple computers. Actor Identity Actors are a lot like regular objects, but there are a couple of quirks that make them different. One is the notion of actor identity, which surfaces in Orleans in the form of grains' primary keys. A Service is a Collection of Communicating Actors The previous examples used only a single actor type and instance to demonstrate their concepts. In almost all real systems, this is the opposite of what you would want to do; actors are intended to be as light-weight as objects and you would expect hundreds of thousands or millions of them to be active on a single system simultaneously, with as potentially billions waiting inactive in persistent store. This walkthrough explains the actor lifecycle and identity, how actors are activated and deactivated. Concurrency What distinguishes the actor model from most other (distributed) object models is that it enforces a specific set of rules for concurrent access to state, allowing it to be free of data races by exchanging data between actors using message-passing and only allowing a single thread of execution to access each actor's internal state at any given point in time. On the other hand, there are many situations where data races are not a risk, and the single-threaded model is too conservative. Further, single-threaded execution can cause other problems, such as deadlocks. Orleans offers a few tools that allow developers to control this behavior, explained in this walkthrough. Interaction with Libraries and Services Applications using Orleans are regular .NET applications, and can interact freely with other .NET components. In order to not undermine the scalability inherent in the actor model, programmers have to take care to follow a few rules, mostly related to using asynchronous APIs whenever they are available. This walkthrough demonstrates the basic principles. Declarative Persistence Actors are often transient, i.e., their state lives only for a short period of time, or is reconstructible at will from other actors. In many circumstances, however, actor state needs to persist for longer periods of time and be stored in an external database of some sort. Orleans offers the developer flexible options on where to store actor state, and this walkthrough will introduce the simplest way to deal with long-lived actor state: declaratively. Handling Failures Everything is easy and beautiful in a distributed system until something fails and handling failures is one of the hardest things in any computer program. In this section we will learn how we can handle failures. Front Ends for Orleans Services Many Orleans services will be private and available only to front-end services that rely on the Orleans-based code as one of several backend services. In some circumstances, what is needed is to put a thin HTTP layer in front of the backend service, essentially making the Orleans service itself publically available via HTTP. In this walk-through, the steps of producing a thin HTTP layer based on ASP.NET Web API is described. Cloud Deployment The next walkthrough demonstrates how to get your Orleans application deployed in the cloud using Azure. On-Premise Deployment Orleans applications can be deployed both on your server equipment as well as in the cloud. In this walkthrough, you will see how to set up an on premise cluster and deploy your application to it. Custom Storage Providers Defining your own storage provider is the easiest way to extend the persistence choices of your Orleans application. While Orleans comes with a couple of storage providers in the box, they are not intended to be the only choices or constrain you unnecessarily. Therefore, the library offers a way to extend the set of storage providers to include This walkthrough demonstrates how to extend the choices by building a storage provider based on regular files. Unit Testing Grains Writing tests is one of the essential parts of the software development process which allows you to maintain your code easily, refactor with ease and sleep well when a new team member is changing 3 years old code. Orleans makes it very easy to write different kinds of tests for your Orleans application. this tutorial describes how to write simple unit tests to check if each grain method is having the right behavior. More complex scenarios like load testing and object mocking are not described here."
  },
  "1.5/Tutorials/Unit-Testing-Grains.html": {
    "href": "1.5/Tutorials/Unit-Testing-Grains.html",
    "title": "Unit Testing Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Unit Testing Grains This tutorial shows how to unit test your grains to make sure they behave correctly. There are two main ways to unit test your grains, and the method you choose will depend on the type of functionality you are testing. The Microsoft.Orleans.TestingHost NuGet package can be used to create test silos for your grains, or you can use a mocking framework like Moq to mock parts of the Orleans runtime that your grain interacts with. Using TestCluster The Microsoft.Orleans.TestingHost NuGet package contains TestCluster which can be used to create an in-memory cluster, comprised of two silos by default, which can be used to test grains. using System; using System.Threading.Tasks; using Orleans; using Orleans.TestingHost; using Xunit; namespace Tests { public class HelloGrainTests { [Fact] public async Task SaysHelloCorrectly() { var cluster = new TestCluster(); cluster.Deploy(); var hello = cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHello(); cluster.StopAllSilos(); Assert.Equal(\"Hello, World\", greeting); } } } Due to the overhead of starting an in-memory cluster you may wish to create a TestCluster and reuse it among multiple test cases. For example this can be done using xUnit's class or collection fixtures (see https://xunit.github.io/docs/shared-context.html for more details). In order to share a TestCluster between multiple test cases, first create a fixture type: public class ClusterFixture : IDisposable { public ClusterFixture() { this.Cluster = new TestCluster(); this.Cluster.Deploy(); } public void Dispose() { this.Cluster.StopAllSilos(); } public TestCluster Cluster { get; private set; } } Next create a collection fixture: [CollectionDefinition(ClusterCollection.Name)] public class ClusterCollection : ICollectionFixture<ClusterFixture> { public const string Name = \"ClusterCollection\"; } You can now reuse a TestCluster in your test cases: using System; using System.Threading.Tasks; using Orleans; using Xunit; namespace Tests { [Collection(ClusterCollection.Name)] public class HelloGrainTests { private readonly TestCluster _cluster; public HelloGrainTests(ClusterFixture fixture) { _cluster = fixture.Cluster; } [Fact] public async Task SaysHelloCorrectly() { var hello = _cluster.GrainFactory.GetGrain<IHelloGrain>(Guid.NewGuid()); var greeting = await hello.SayHell(); Assert.Equal(\"Hello, World\", greeting); } } } xUnit will call the Dispose method of the ClusterFixture type when all tests have been completed and the in-memory cluster silos will be stopped. TestCluster also has a constructor which accepts TestClusterOptions that can be used to configure the silos in the cluster. Using Mocks Orleans also makes it possible to mock many parts of system, and for many of scenarios this is the easiest way to unit test grains. This approach does have limitations (e.g. around scheduling reentrancy and serialization), and may require that grains include code used only by your unit tests. The Orleans TestKit provides an alternative approach which side-steps many of these limitations. For example, let us imagine that the grain we are testing interacts with other grains. In order to be able to mock those other grains we also need to mock the GrainFactory member of the grain under test. By default GrainFactory is a normal protected property, but most mocking frameworks require properties to be public and virtual to be able to mock them. So the first thing we need to do is make GrainFactory both public and virtual property: public new virtual IGrainFactory GrainFactory { get { return base.GrainFactory; } } Now we can create our grain outside of the Orleans runtime and use mocking to control the behaviour of GrainFactory : using System; using System.Threading.Tasks; using Orleans; using Xunit; using Moq; namespace Tests { public class WorkerGrainTests { [Fact] public async Task RecordsMessageInJournal() { var data = \"Hello, World\"; var journal = new Mock<IJournalGrain>(); var worker = new Mock<WorkerGrain>(); myGrain.Setup(x => x.GrainFactory.GetGrain<IJournalGrain>(It.IsAny<Guid>())).Returns(journal.Object); await worker.DoWork(data) journal.Verfiy(x => x.Record(data), Times.Once()); } } } Here we create our grain under test, WorkerGrain , using Moq which means we can then override the behaviour of the GrainFactory so that it returns a mocked IJournalGrain . We can then verify that our WorkerGrain interacts with the IJournalGrain as we expect."
  },
  "1.5/Tutorials/Concurrency.html": {
    "href": "1.5/Tutorials/Concurrency.html",
    "title": "Concurrency | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Concurrency Please read about Grains before following this tutorial. Let's go back to the code that was established in the tutorial on collections of actors and modify it to demonstrate how things can go bad by creating a trivial cycle in the messaging graph: when an employee receives a greeting, he sends another greeting back to the sender and waits for the acknowledgment. This will send a back-and-forth series of messages, until we get to 3. First create a class in the interface project which we'll use to send the greetings around: public class GreetingData { public Guid From { get; set; } public string Message { get; set; } public int Count { get; set; } } From will be the sender of the message (the ID of the grain), Message will be the message text, and Count will be the number of times the message has been sent back and forth. This stops us from getting a stack overflow. We need to modify the arguments of Greeting on the IEmployee interface to : Task Greeting(GreetingData data); We need to update the implementation accordingly: public async Task Greeting(GreetingData data) { Console.WriteLine(\"{0} said: {1}\", data.From, data.Message); // stop this from repeating endlessly if (data.Count >= 3) return; // send a message back to the sender var fromGrain = GrainFactory.GetGrain<IEmployee>(data.From); await fromGrain.Greeting(new GreetingData { From = this.GetPrimaryKey(), Message = \"Thanks!\", Count = data.Count + 1 }); } We'll also update the Manager class, so it send the new message object: public async Task AddDirectReport(IEmployee employee) { _reports.Add(employee); await employee.SetManager(this); await employee.Greeting(new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }); } Now the Employee sends a message back to the manager, saying \"Thanks!\". Let's add some simple client code to add a direct report to a manager: var e0 = GrainClient.GrainFactory.GetGrain<IEmployee>(Guid.NewGuid()); var m1 = GrainClient.GrainFactory.GetGrain<IManager>(Guid.NewGuid()); m1.AddDirectReport(e0).Wait(); When we run this code, the first \"Thanks!\" greeting is received. However, when this message is responded to this we get a 30 second pause (or 10 minutes when the debugger is attached), then warnings appear in the log and we're told the grain is about to break it's promise. 7b66f830-8d81-49fc-b8fc-279af6924bd3 said: Welcome to my team! ce14310a-8500-4b2f-a21b-b4b23eb48d0d said: Thanks! [2014-03-12 15:25:37.398 GMT 31 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/906ECA4C/00000001@68e2b3ab->S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #13: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187>. About to break its promise. [2014-03-12 15:25:37.398 GMT 27 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187->S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4 #14: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000001:@afc70cb4>. About to break its promise. [2014-03-12 15:25:37.407 GMT 28 WARNING 100157 CallbackData 127.0.0.1:11111] Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4->S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #15: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: <S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187>. About to break its promise. An exception is then thrown in the client code. We've created a deadlock. Grain 0 sends a message to grain 1. In that call grain 1 sends a message back to grain 0. However, grain 0 can't process it because it's awaiting the first message, so it gets queued. The await can't complete until the second message is returned, so we've entered a state that we can't escape from. Orleans waits for 30 seconds (10 minutes with the debugger), then kills the request. Orleans offers us a way to deal with this, by marking the grain [Reentrant] , which means that additional calls may be made while the grain is waiting for a task to complete, resulting in interleaved execution. [Reentrant] public class Employee : Grain, IEmployee { ... } We see that the sample works, and Orleans is able to interleave the grain calls: aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Welcome to my team! 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks! aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Thanks! 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks! Messages Messages are simply data passed from one actor to another, we just created the GreetingData class to do just this. In .NET, most objects are created from a class of some sort and are passed around by reference, something that doesn't work well with concurrency, and definitely not with distribution. When Orleans sends a message from one grain to another, it creates a deep copy of the object, and provides the copy to the second grain, and not the object stored in the first grain. This prohibits the mutation of state from one grain to another, one of the main tenets in the actor model is that state shouldn't be shared, and message passing is the only mechanism for exchanging data. When the grains are in different silos, the object model is serialized to a binary format, and sent over the wire. However, this deep copy process is expensive, and if you promise not to modify the message, then for communication with grains within a silo, it's unnecessary. If you indicate to Orleans that you are not going to modify the object (i.e. it's immutable) then it can skip the deep copy step, and it will pass the object by reference. There's no way Orleans or C# can stop you from modifying the state, you have to be disciplined. Immutability is indicated with a the [Immutable] attribute on the class: [Immutable] public class GreetingData { public Guid From { get; set; } public string Message { get; set; } public int Count { get; set; } } No other code change is required, this is just a signal to give to Orleans to tell it your not going to modify this object. Next Next, we'll see how we can interact with external services from inside our grain. Interaction with Libraries and Services"
  },
  "1.5/Documentation/Samples-Overview/Presence-Service.html": {
    "href": "1.5/Documentation/Samples-Overview/Presence-Service.html",
    "title": "Presence Service | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Presence Service A presence service serves as the hub of many social applications, including multi-player games and chats. Its essential function is to know who is online at given point in time and alert other users of their online presence. Each logged-in player sends a \"heartbeat pulse\" at regular intervals, In this section we walk through the steps involved in defining and using a new Player grain type. The grain type we define will have one property that returns a reference to the game the player is currently in, and two methods for joining and leaving a game. We will create three separate pieces of code: the grain interface definition, the grain implementation, and a standard C# class that uses the grain. Each of these belongs in a different project, built into a different DLL: the interface needs to be available on both the \"client\" and \"server\" sides, while the implementation class should be hidden from the client, and the client class from the server. The interface project should be created using the Visual Studio \"Orleans Grain Interface Collection\" template that is included in the Orleans SDK, and the grain implementation project should be created using the Visual Studio \"Orleans Grain Class Collection\" template. The grain client project can use any standard .NET code project template, such as the standard Console Application or Class Library templates. A grain cannot be explicitly created or deleted. It always exists \"virtually\" and is activated automatically when a request is sent to it. A grain has either a GUID, string or a long integer key within the grain type. Application code creates a reference to a grain by calling the GetGrain<TGrainType>(Guid id) or GetGrain<TGrainType>(long id) or other overloads of a generic grain factory methods for a specific grain identity. The GetGrain() call is a purely local operation to create a grain reference. It does not trigger creation of a grain activation and has not impact on its life cycle. A grain activation is automatically created by the Orleans runtime upon a first request sent to the grain. A grain interface must inherit from one of the IGrainWithXKey .interfaces where X is the type of the key used. The GUID, string or long integer key of a grain can later be retrieved via the GetPrimaryKey() or GetPrimaryKeyLong() extension methods, respectively. Defining the Grain Interface A grain type is defined by an interface that inherits from one of the IGrainWithXKey marker interfaces like 'IGrainWithGuidKey' or 'IGrainWithStringKey'. All of the methods in the grain interface must return a Task or a Task<T> . The underlying type T for value Task must be serializable. Example: public interface IPlayerGrain : IGrainWithGuidKey { Task<IGameGrain> GetCurrentGame(); Task JoinGame(IGameGrain game); Task LeaveGame(IGameGrain game); } Using the Grain Factory After the grain interface has been defined, building the project originally created with the Orleans Visual Studio project template will use the Orleans-specific MSBuild targets to generate a client proxy classes corresponding to the user-defined grain interfaces and to merge this additional code back into the interface DLL. Application should use the generic grain factory class to get references to grains. Inside the grain code, the factory is available via the protected GrainFactory class member property. On the client side the factory is available via the GrainClient.GrainFactory static field. When running inside a grain the following code should be used to get the grain reference: this.GrainFactory.GetGrain<IPlayerGrain>(grainKey); When running on the Orleans client side the following code should be used to get the grain reference: GrainClient.GrainFactory.GetGrain<IPlayerGrain>(grainKey); The Implementation Class A grain type is materialized by a class that implements the grain typeâ€™s interface and inherits directly or indirectly from Orleans.Grain . The PlayerGrain grain class implements the IPlayerGrain interface. public class PlayerGrain : Grain, IPlayerGrain { private IGameGrain currentGame; // Game the player is currently in. May be null. public Task<IGameGrain> GetCurrentGameAsync() { return Task.FromResult(currentGame); } // Game grain calls this method to notify that the player has joined the game. public Task JoinGameAsync(IGameGrain game) { currentGame = game; Console.WriteLine(\"Player {0} joined game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return TaskDone.Done; } // Game grain calls this method to notify that the player has left the game. public Task LeaveGameAsync(IGameGrain game) { currentGame = null; Console.WriteLine(\"Player {0} left game {1}\", this.GetPrimaryKey(), game.GetPrimaryKey()); return TaskDone.Done; } }"
  },
  "1.5/Documentation/Samples-Overview/Storage-Providers.html": {
    "href": "1.5/Documentation/Samples-Overview/Storage-Providers.html",
    "title": "Storage Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Storage Providers Note : This sample requires the \"Official MongoDB C# Driver\" NuGet package from 10gen, Inc. If you want to run the sample and store data using MongoDB, you will also need to download and install MongoDB. Custom storage providers allow you to extend the capabilities of Orleans to store application data in new storage services. In this sample, we have code to store data in a file system (presumably networked) and in MongoDB. While binary formatting is almost always better to use for persistent storage, this sample chooses to use JSON as the external format for one reason: it's easier to read and verify, which is a good thing in a sample. As you adopt the sample code for more realistic use, you will probably want to switch to something else than JSON as the external format. Running the sample The sample solution consists of four projects -- the storage provider library, and three test libraries, with the same client+server structure that the Hello World sample has. Edit the DevTestServerConfiguration.xml file in the Test.Client project, uncommenting the element of the file-storage provider. <!-- To test the sample storage providers, uncomment one of the following two lines: <Provider Type=\"Samples.StorageProviders.MongoDBStorage\" Name=\"TestStore\" Database=\"orleanssamples\" ConnectionString=\"mongodb://localhost:27017/\" /> --> <Provider Type=\"Samples.StorageProviders.OrleansFileStorage\" Name=\"TestStore\" RootDirectory=\".\\Samples.FileStorage\"/> Build the solution. This will move everything where it needs to go, including the MongoDB client libraries that NuGet brought in. Set the 'Test.Client' project as the startup project and hit F5. Right before it stops spitting out text, it will have this to say: Successfully started Orleans silo 'host-001' as a Primary node. We just wrote something to the persistent store. Please verify! Orleans Silo is running. Press Enter to terminate... Stop the program and open a command line windows, move to the bin\\Debug folder of the Test.Client project. There should be a folder called Samples.FileStorage there. In that folder, you should find a single file: >>dir Directory: c:\\Orleans\\Samples\\StorageProviders\\Test.Client\\bin\\Debug\\Samples.FileStorage Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 3/26/2014 19:50 48 0000...003ffffffc0950639.PersonState If you look at the contents of that file, you should see some JSON text: >> more .\\Samples.FileStorage\\0000000000000000000000000000000003ffffffc0950639.PersonState {\"FirstName\":\"John\",\"LastName\":\"Doe\",\"Gender\":0} Now, run the program again. It's written to detect that state already exists, so this time, it will have something else to say: Successfully started Orleans silo host-001' as a Primary node. This was found in the persistent store: John, Doe, Male Orleans Silo is running. Press Enter to terminate... If you have MongoDB installed , you can repeat this procedure to test the other storage provider. Just change which XML element in the configuration file that is uncommented and ensure that the mongod.exe process is running. When you inspect the data with the MongoDB shell (mongo.exe), it should look something like this: MongoDB shell version: 2.4.6 connecting to: test > use orleanssamples switched to db orleanssamples > db.PersonState.find() { \"_id\" : ObjectId(\"533391afcf20b011307a82bf\"), \"FirstName\" : \"John\", \"LastName\" : \"Doe\", \"Gender\" : 0, \"key\" : \"0000000000000000000000000000000003ffffffc0950639\" } > Design Since both concrete storage providers use JSON, we place the serialization and deserialization code in a base class, BaseJSONStorageProvider . It contains the logic for Init() , ReadStateAsync() , WriteStateAsync() and ClearStateAsync() , the main interface methods of IStorageProvider. The logic to deal with the underlying store is delegated to a DataManager class hiearchy: IJSONStateDataManager , GrainFileStateManager , and GrainStateMongoDataManager . Their methods Delete() , Read() and Write() correspond directly to the methods defined in the storage provider classes. In this description, we won't go into the details of interacting with the file system or MongoDB via .NET, that is described in detail elsewhere. A couple of things in the code requires explanation, though. In both cases, the name of the grain type is used as name for the collection of instances; in the file storage provider case, the collection name is mapped to the folder that data is stored in, while the primary key is used to identify the actual instance; in the MongoDB case, the type name denotes a database collection, while the primary key is used as the document name. In the MongoDB case, the JSON structure is augmented during a write operation with another element, key, which contains the Orleans grain key and allows us to query for that document when reading. Care is also taken to maintain the Mongo-internal _id document identity. public Task Write(string collectionName, string key, string entityData) { var collection = GetOrCreateCollection(collectionName); var query = Query.EQ(\"key\", key); var existing = collection.FindOne(query); var doc = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(entityData); doc[\"key\"] = key; if ( existing == null ) { collection.Insert(doc); } else { doc[\"_id\"] = existing[\"_id\"]; collection.Update(query, Update.Replace(doc)); } return TaskDone.Done; } On read, the _id field is removed from the JSON document that is passed back to the caller, since that is not part of the Orleans data model. public Task<string> Read(string collectionName, string key) { var collection = GetCollection(collectionName); if (collection == null) return Task.FromResult<string>(null); var query = Query.EQ(\"key\", key); var existing = collection.FindOne(query); if (existing == null) return Task.FromResult<string>(null); existing.Remove(\"_id\"); existing.Remove(\"key\"); var strwrtr = new System.IO.StringWriter(); var writer = new MongoDB.Bson.IO.JsonWriter(strwrtr, new MongoDB.Bson.IO.JsonWriterSettings()); MongoDB.Bson.Serialization.BsonSerializer.Serialize<BsonDocument>(writer, existing); return Task.FromResult(strwrtr.ToString()); }"
  },
  "Documentation/deployment/azure_web_apps_with_azure_cloud_services.html": {
    "href": "Documentation/deployment/azure_web_apps_with_azure_cloud_services.html",
    "title": "ä½¿ç”¨Azure Web Appså’ŒAzure Cloud Services | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å°†azure webåº”ç”¨ä¸azureäº‘æœåŠ¡ä¸€èµ·ä½¿ç”¨ å¦‚æœä½ æƒ³ä» azure webåº”ç”¨ è€Œä¸æ˜¯æ‰˜ç®¡åœ¨åŒä¸€ä¸ªäº‘æœåŠ¡ä¸­çš„webè§’è‰²ã€‚ è¦ä½¿å…¶å®‰å…¨å·¥ä½œï¼Œæ‚¨éœ€è¦å°†azure webåº”ç”¨å’Œæ‰˜ç®¡silosçš„å·¥ä½œè§’è‰²éƒ½åˆ†é…ç»™ azureè™šæ‹Ÿç½‘ç»œ æ˜¯çš„ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬å°†è®¾ç½®azure webåº”ç”¨ç¨‹åºï¼Œæ‚¨å¯ä»¥è·Ÿéš æœ¬æŒ‡å— å®ƒå°†åˆ›å»ºè™šæ‹Ÿç½‘ç»œå¹¶å°†å…¶åˆ†é…ç»™azure webåº”ç”¨ç¨‹åºã€‚ ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ æœåŠ¡é…ç½® æ–‡ä»¶ã€‚ <NetworkConfiguration> <VirtualNetworkSite name=\"virtual-network-name\" /> <AddressAssignments> <InstanceAddress roleName=\"role-name\"> <Subnets> <Subnet name=\"subnet-name\" /> </Subnets> </InstanceAddress> </AddressAssignments> </NetworkConfiguration> è¿˜è¦ç¡®ä¿å·²é…ç½®silosç»ˆç»“ç‚¹ã€‚ <Endpoints> <InternalEndpoint name=\"OrleansSiloEndpoint\" protocol=\"tcp\" port=\"11111\" /> <InternalEndpoint name=\"OrleansProxyEndpoint\" protocol=\"tcp\" port=\"30000\" /> </Endpoints> ç°åœ¨æ‚¨å¯ä»¥ä»webåº”ç”¨è¿æ¥åˆ°é›†ç¾¤çš„å…¶ä½™éƒ¨åˆ†ã€‚ æ½œåœ¨é—®é¢˜ å¦‚æœWebåº”ç”¨æ— æ³•è¿æ¥åˆ°silosï¼š ç¡®ä¿ä½ è‡³å°‘æœ‰ ä¸¤ä¸ªè§’è‰² ï¼Œæˆ–è€…åœ¨ä½ çš„azureäº‘æœåŠ¡ä¸­ä¸€ä¸ªè§’è‰²çš„ä¸¤ä¸ªå®ä¾‹ï¼Œæˆ–è€… å†…éƒ¨ç»ˆç»“ç‚¹ ä¸èƒ½ç”Ÿæˆé˜²ç«å¢™è§„åˆ™ã€‚ æ£€æŸ¥Webåº”ç”¨ç¨‹åºå’Œsilosæ˜¯å¦ä½¿ç”¨ç›¸åŒçš„ æ£’çŠ¶çš„ å’Œ æœåŠ¡ID æ˜¯çš„ã€‚ ç¡®ä¿ç½‘ç»œå®‰å…¨ç»„è®¾ç½®ä¸ºå…è®¸å†…éƒ¨è™šæ‹Ÿç½‘ç»œè¿æ¥ã€‚å¦‚æœæ‚¨æ²¡æœ‰ä¸€ä¸ªï¼Œæ‚¨å¯ä»¥åˆ›å»ºå’Œåˆ†é…ä¸€ä¸ªå¾ˆå®¹æ˜“ä½¿ç”¨ä»¥ä¸‹ PowerShell ä»¥ä¸‹å†…å®¹ï¼š New-AzureNetworkSecurityGroup -Name \"Default\" -Location \"North Europe\" Get-AzureNetworkSecurityGroup -Name \"Default\" | Set-AzureNetworkSecurityGroupToSubnet -VirtualNetworkName \"virtual-network-name\" -SubnetName \"subnet-name\""
  },
  "Documentation/implementation/scheduler.html": {
    "href": "Documentation/implementation/scheduler.html",
    "title": "Scheduler | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ’ç¨‹å™¨ Orleans Scheduleræ˜¯Orleansè¿è¡Œæ—¶ä¸­çš„ä¸€ä¸ªç»„ä»¶ï¼Œè´Ÿè´£æ‰§è¡Œåº”ç”¨ç¨‹åºä»£ç å’Œéƒ¨åˆ†è¿è¡Œæ—¶ä»£ç ï¼Œä»¥ç¡®ä¿ å•çº¿ç¨‹æ‰§è¡Œè¯­ä¹‰ ã€‚å®ƒå®ç°äº†è‡ªå®šä¹‰çš„TPLä»»åŠ¡è®¡åˆ’ç¨‹åºã€‚ Orleansä»»åŠ¡è®¡åˆ’ç¨‹åºæ˜¯ä¸€ä¸ª2çº§å±‚æ¬¡çš„è®¡åˆ’ç¨‹åºã€‚åœ¨ç¬¬ä¸€å±‚æ˜¯å…¨çƒ OrleansTaskScheduler è´Ÿè´£æ‰§è¡Œç³»ç»Ÿæ´»åŠ¨ã€‚åœ¨ç¬¬äºŒçº§ï¼Œæ¯ä¸ªGrainsæ´»åŒ–éƒ½æœ‰è‡ªå·±çš„ ActivationTaskScheduler ï¼Œå®ƒæä¾›äº†å•çº¿ç¨‹æ‰§è¡Œè¯­ä¹‰ã€‚ ä»é«˜å±‚æ¬¡ä¸Šè®²ï¼Œæ‰§è¡Œè·¯å¾„å¦‚ä¸‹ï¼š è¯·æ±‚åˆ°è¾¾æ­£ç¡®çš„silosï¼Œå¹¶æ‰¾åˆ°ç›®æ ‡æ¿€æ´»ã€‚ è¯·æ±‚åœ¨å…¶ActivationTaskSchedulerä¸Šè½¬æ¢ä¸ºä¸€ä¸ªä»»åŠ¡ï¼Œæ’é˜Ÿç­‰å¾…è¯¥æ¿€æ´»æ‰§è¡Œã€‚ é€šè¿‡æ ‡å‡†TaskScheduleræœºåˆ¶ï¼Œä½œä¸ºè°·ç±»æ–¹æ³•æ‰§è¡Œçš„ä¸€éƒ¨åˆ†è€Œåˆ›å»ºçš„ä»»ä½•åç»­Taskéƒ½ä¼šè‡ªç„¶åœ°æ’é˜Ÿåˆ°åŒä¸€ActivationTaskSchedulerä¸­ã€‚ æ¯ä¸ªActivationTaskScheduleréƒ½æœ‰ä¸€ä¸ªæ’é˜Ÿç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡é˜Ÿåˆ—ã€‚ Orleans Schedulerå…·æœ‰ä¸€ç»„ç”±æ‰€æœ‰æ¿€æ´»è°ƒåº¦ç¨‹åºå…±åŒä½¿ç”¨çš„å·¥ä½œçº¿ç¨‹ã€‚è¿™äº›çº¿ç¨‹å®šæœŸæ‰«ææ‰€æœ‰è°ƒåº¦ç¨‹åºé˜Ÿåˆ—ä»¥æ‰§è¡Œå·¥ä½œã€‚ çº¿ç¨‹æ¥å—ä¸€ä¸ªé˜Ÿåˆ—(æ¯ä¸ªé˜Ÿåˆ—ä¸€æ¬¡ç”±ä¸€ä¸ªçº¿ç¨‹æ¥å—)å¹¶å¼€å§‹æŒ‰FIFOé¡ºåºåœ¨è¯¥é˜Ÿåˆ—ä¸­æ‰§è¡ŒTasksã€‚ ä¸€æ¬¡å°†ä¸€ä¸ªçº¿ç¨‹æ’å…¥é˜Ÿåˆ—ï¼Œç„¶åä¾æ¬¡æ‰§è¡ŒTasksçš„çº¿ç¨‹çš„ç»„åˆæä¾›äº†å•çº¿ç¨‹æ‰§è¡Œè¯­ä¹‰ã€‚ å·¥ä½œé¡¹ç›®ï¼š Orleansä½¿ç”¨å·¥ä½œé¡¹çš„æ¦‚å¿µæ¥æŒ‡å®šè°ƒåº¦ç¨‹åºçš„å…¥å£ç‚¹ã€‚æœ€åˆï¼Œæ¯ä¸ªæ–°è¯·æ±‚éƒ½ä½œä¸ºå·¥ä½œé¡¹å…¥é˜Ÿï¼Œè¯¥å·¥ä½œé¡¹ä»…åŒ…è£…è¯¥è¯·æ±‚çš„ç¬¬ä¸€ä¸ªä»»åŠ¡çš„æ‰§è¡Œã€‚å·¥ä½œé¡¹åªæ˜¯æä¾›æœ‰å…³è°ƒåº¦æ´»åŠ¨çš„æ›´å¤šä¸Šä¸‹æ–‡ä¿¡æ¯(è°ƒç”¨æ–¹ï¼Œæ´»åŠ¨çš„åç§°ï¼Œæ—¥å¿—è®°å½•)ï¼Œæœ‰æ—¶è¿˜éœ€è¦ä»£è¡¨è¯¥è°ƒåº¦æ´»åŠ¨è¿›è¡Œä¸€äº›é¢å¤–çš„å·¥ä½œ(Invokeå·¥ä½œé¡¹ä¸­çš„è°ƒç”¨åæ´»åŠ¨)ã€‚å½“å‰æœ‰ä»¥ä¸‹å·¥ä½œé¡¹ç±»å‹ï¼š1.è°ƒç”¨å·¥ä½œé¡¹â€“è¿™æ˜¯æœ€å¸¸ç”¨çš„å·¥ä½œé¡¹ç±»å‹ã€‚å®ƒè¡¨ç¤ºåº”ç”¨ç¨‹åºè¯·æ±‚çš„æ‰§è¡Œã€‚2.è¯·æ±‚/å“åº”å·¥ä½œé¡¹â€“æ‰§è¡Œç³»ç»Ÿè¯·æ±‚(å¯¹SystemTargetçš„è¯·æ±‚)ã€‚3. TaskWorkItem â€“ä»£è¡¨æ’é˜Ÿåˆ°æœ€é«˜OrleansTaskSchedulerçš„ä»»åŠ¡ã€‚åªæ˜¯ä¸ºäº†æ–¹ä¾¿æ•°æ®ç»“æ„è€Œä½¿ç”¨å®ƒè€Œä¸æ˜¯ç›´æ¥ä»»åŠ¡(ä¸‹é¢æœ‰æ›´å¤šè¯¦ç»†ä¿¡æ¯)ã€‚4. WorkItemGroup â€“å…±äº«åŒä¸€è°ƒåº¦ç¨‹åºçš„å·¥ä½œé¡¹ç»„ã€‚ç”¨äºä¸ºæ¯ä¸ªActivationTaskScheduleråŒ…è£…ä»»åŠ¡é˜Ÿåˆ—ã€‚5. ClosureWorkItem â€“å°è£…åœ¨æ’é˜Ÿåˆ°ç³»ç»Ÿä¸Šä¸‹æ–‡çš„é—­åŒ…(ä»»æ„lambda)å‘¨å›´çš„åŒ…è£…å™¨ã€‚ è°ƒåº¦ä¸Šä¸‹æ–‡ï¼š è°ƒåº¦ä¸Šä¸‹æ–‡æ˜¯ä¸€ä¸ªæ ‡ç­¾ï¼Œåªæ˜¯ä¸€ä¸ªä¸é€æ˜çš„å¯¹è±¡ï¼Œä»£è¡¨è°ƒåº¦ç›®æ ‡â€“æ¿€æ´»æ•°æ®ï¼Œç³»ç»Ÿç›®æ ‡æˆ–ç³»ç»Ÿç©ºä¸Šä¸‹æ–‡ã€‚ é«˜çº§åŸåˆ™ï¼š ä»»åŠ¡æ€»æ˜¯æ’é˜Ÿåˆ°æ­£ç¡®çš„è°ƒåº¦ç¨‹åº 1.1ä»»åŠ¡æ°¸è¿œä¸ä¼šä»ä¸€ä¸ªè°ƒåº¦ç¨‹åºè½¬ç§»åˆ°å¦ä¸€ä¸ªè°ƒåº¦ç¨‹åºã€‚ 1.2æˆ‘ä»¬ç»ä¸ä¼šä»£è¡¨å…¶ä»–ä»»åŠ¡åˆ›å»ºä»»åŠ¡æ¥æ‰§è¡Œå®ƒä»¬ã€‚ 1.3å·¥ä½œé¡¹åŒ…è£…åœ¨Taskä¸­(ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ºäº†æ‰§è¡Œå·¥ä½œé¡¹ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªTaskï¼Œå…¶lambdaå‡½æ•°å°†ä»…è¿è¡Œå·¥ä½œé¡¹lambda)ã€‚é€šè¿‡å§‹ç»ˆæ‰§è¡Œä»»åŠ¡ï¼Œæˆ‘ä»¬ç¡®ä¿é€šè¿‡é€‚å½“çš„ä»»åŠ¡è®¡åˆ’ç¨‹åºæ‰§è¡Œä»»ä½•æ´»åŠ¨ã€‚ ä½¿ç”¨base.TryExecute(è€Œä¸æ˜¯RunSynchronously)åœ¨è®¡åˆ’äº†é˜Ÿåˆ—çš„è°ƒåº¦ç¨‹åºä¸Šæ‰§è¡Œä»»åŠ¡ ATSï¼ŒWorkItemç»„å’Œè°ƒåº¦ä¸Šä¸‹æ–‡ä¹‹é—´å­˜åœ¨ä¸€å¯¹ä¸€çš„æ˜ å°„ï¼š 3.1æ¿€æ´»ä»»åŠ¡è®¡åˆ’ç¨‹åº(ATS)æ˜¯è‡ªå®šä¹‰çš„TPLè®¡åˆ’ç¨‹åºã€‚æˆ‘ä»¬ä¿æŒATSç¨€è–„ï¼Œå¹¶å°†æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨WorkItemGroupä¸­ã€‚ATSæŒ‡å‘å…¶WorkItemGroupã€‚ 3.2 WorkItemç»„æ˜¯æ¿€æ´»ä»»åŠ¡çš„å®é™…æŒæœ‰äºº(æ•°æ®å¯¹è±¡)ã€‚ä»»åŠ¡å­˜å‚¨åœ¨åˆ—è¡¨ä¸­ -ATSçš„æ‰€æœ‰ä»»åŠ¡çš„é˜Ÿåˆ—ã€‚WorkItemGroupæŒ‡å‘å…¶ATSã€‚ æ•°æ®æµä»¥åŠä»»åŠ¡å’Œå·¥ä½œé¡¹çš„æ‰§è¡Œï¼š å…¥å£ç‚¹å§‹ç»ˆæ˜¯æ’é˜Ÿåˆ°OrleansTaskSchedulerä¸­çš„å·¥ä½œé¡¹ã€‚å®ƒå¯ä»¥æ˜¯â€œè°ƒç”¨/è¯·æ±‚/å“åº”/å…³é—­å·¥ä½œé¡¹â€ä¹‹ä¸€ã€‚ æ ¹æ®Task.Startçš„ä¸Šä¸‹æ–‡åŒ…è£…åˆ°Taskä¸­ï¼Œå¹¶æ”¾å…¥æ­£ç¡®çš„ActivationTaskSchedulerä¸­ã€‚ æ’é˜Ÿåˆ°å…¶ActivationTaskSchedulerçš„ä»»åŠ¡è¢«æ”¾å…¥WorkItemGroupé˜Ÿåˆ—ã€‚ å°†ä»»åŠ¡æ”¾å…¥WorkItemGroupé˜Ÿåˆ—æ—¶ï¼ŒWorkItemGroupç¡®ä¿å°†å…¶æ˜¾ç¤ºåœ¨OrleansTaskSchedulerå…¨å±€RunQueueä¸­ã€‚RunQueueæ˜¯å¯è¿è¡Œçš„WorkItemGroupsçš„å…¨å±€é˜Ÿåˆ—ï¼Œè¿™äº›é˜Ÿåˆ—ä¸­è‡³å°‘æœ‰ä¸€ä¸ªTaskå·²æ’é˜Ÿï¼Œå› æ­¤å¯ä»¥æ‰§è¡Œã€‚ è¾…åŠ©çº¿ç¨‹æ‰«æOrleansTaskSchedulerçš„RunQueueï¼Œè¯¥é˜Ÿåˆ—ä¿å­˜WorkItemGroupså¹¶è°ƒç”¨WorkItemGroups.Executeã€‚ WorkItemGroups.Executeæ‰«æå…¶ä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶é€šè¿‡ActivationTaskScheduler.RunTask(Task)æ‰§è¡Œå®ƒä»¬ 6.1 ActivationTaskScheduler.RunTask(Task)è°ƒç”¨base.TryExecuteã€‚ 6.2é€šè¿‡TPLç›´æ¥æ’é˜Ÿåˆ°è°ƒåº¦ç¨‹åºçš„ä»»åŠ¡å°†ç«‹å³æ‰§è¡Œã€‚ 6.3åŒ…è£…å·¥ä½œé¡¹çš„ä»»åŠ¡å°†è°ƒç”¨workItem.Executeï¼Œå®ƒå°†æ‰§è¡ŒClosureå·¥ä½œé¡¹å§”æ‰˜ã€‚ ä½å±‚è®¾è®¡â€“å·¥ä½œé¡¹ç›®ï¼š åœ¨OrleansTaskSchedulerä¸­æ’é˜Ÿå·¥ä½œé¡¹æ˜¯å¦‚ä½•åœ¨Orleansè¿è¡Œæ—¶ä¸­å¼€å§‹æ¯ä¸ªè¯·æ±‚çš„æ•´ä¸ªæ‰§è¡Œé“¾çš„ã€‚è¿™æ˜¯æˆ‘ä»¬è¿›å…¥è°ƒåº¦ç¨‹åºçš„å…¥å£ã€‚ å·¥ä½œé¡¹é¦–å…ˆæäº¤ç»™OrleansTaskScheduler(å› ä¸ºè¿™æ˜¯å‘ˆç°ç»™ç³»ç»Ÿå…¶ä½™éƒ¨åˆ†çš„æ¥å£)ã€‚ 2.1è¿™æ ·åªèƒ½æäº¤å…³é—­/è°ƒç”¨/æ¢å¤å·¥ä½œé¡¹ç›®ã€‚ 2.2æ— æ³•å°†TaskWorkItemç›´æ¥æäº¤ç»™OrleansTaskScheduler(æœ‰å…³å¤„ç†TaskWorkItemçš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ä¸‹æ–‡)ã€‚ æ¯ä¸ªå·¥ä½œé¡¹éƒ½å¿…é¡»åŒ…è£…åˆ°Taskä¸­ï¼Œå¹¶é€šè¿‡Task.Startæ’é˜Ÿåˆ°æ­£ç¡®çš„è°ƒåº¦ç¨‹åºä¸­ã€‚ 3.1è¿™å°†ç¡®ä¿åœ¨æ‰§è¡Œæ­¤workItemæœŸé—´éšå¼åˆ›å»ºçš„ä»»ä½•Taskä¸Šæ­£ç¡®è®¾ç½®TaskScheduler.Currentã€‚ 3.2åŒ…è£…æ˜¯é€šè¿‡WrapWorkItemAsTaskåˆ›å»ºä¸€ä¸ªTaskæ¥å®Œæˆçš„ï¼Œè¯¥Taskå°†æ‰§è¡Œå·¥ä½œé¡¹ï¼Œå¹¶é€šè¿‡Task.Start(scheduler)å°†å…¶æ’é˜Ÿåˆ°æ­£ç¡®çš„è°ƒåº¦ç¨‹åºä¸­ã€‚ 3.3ç©ºä¸Šä¸‹æ–‡çš„å·¥ä½œé¡¹å°†æ’é˜Ÿåˆ°OrleansTaskSchedulerã€‚ 3.4éç©ºä¸Šä¸‹æ–‡çš„å·¥ä½œé¡¹å°†æ’é˜Ÿåˆ°ActivationTaskSchedulerä¸­ã€‚ ä½å±‚è®¾è®¡â€“æ’é˜Ÿä»»åŠ¡ï¼š ä»»åŠ¡ç›´æ¥æ’é˜Ÿåˆ°æ­£ç¡®çš„è°ƒåº¦ç¨‹åºä¸­ 1.1ä»»åŠ¡ç”±TPLé€šè¿‡å—ä¿æŠ¤çš„é‡å†™void QueueTask(ä»»åŠ¡ä»»åŠ¡)éšå¼æ’é˜Ÿã€‚ 1.2å…·æœ‰éç©ºä¸Šä¸‹æ–‡çš„ä»»åŠ¡å§‹ç»ˆæ’é˜Ÿåˆ°ActivationTaskSchedulerä¸­ 1.3å…·æœ‰ç©ºä¸Šä¸‹æ–‡çš„ä»»åŠ¡å§‹ç»ˆæ’é˜Ÿåˆ°OrleansTaskScheduler å°†ä»»åŠ¡æ’é˜Ÿåˆ°ActivationTaskSchedulerï¼š 2.1æˆ‘ä»¬ç»ä¸ä¼šå°†ä¸€ä¸ªä»»åŠ¡åŒ…è£…åœ¨å¦ä¸€ä¸ªä»»åŠ¡ä¸­ã€‚ä»»åŠ¡è¢«ç›´æ¥æ·»åŠ åˆ°å·¥ä½œé¡¹ç»„é˜Ÿåˆ—ä¸­ å‘OrleansTaskScheduleræ’é˜Ÿä»»åŠ¡ï¼š 3.1å½“Taskæ’å…¥OrleansTaskScheduleræ—¶ï¼Œæˆ‘ä»¬å°†å…¶åŒ…è£…åˆ°TaskWorkItemä¸­ï¼Œå¹¶å°†å…¶æ”¾å…¥æ­¤è®¡åˆ’ç¨‹åºçš„å·¥ä½œé¡¹é˜Ÿåˆ—ä¸­ã€‚ 3.2è¿™ä»…æ˜¯æ•°æ®ç»“æ„é—®é¢˜ï¼Œæ— ä»»ä½•å†…åœ¨å› ç´ ï¼š 3.3 OrleansTaskScheduleré€šå¸¸ä¿å­˜å·¥ä½œé¡¹ç»„ä»¥å®‰æ’å®ƒä»¬ï¼Œå› æ­¤å…¶RunQueueå…·æœ‰BlockingCollection ã€‚ 3.4ç”±äºç©ºä¸Šä¸‹æ–‡çš„ä»»åŠ¡ä¹Ÿæ’é˜Ÿåˆ°OrleansTaskSchedulerä¸­ï¼Œå› æ­¤æˆ‘ä»¬é‡å¤ä½¿ç”¨ç›¸åŒçš„æ•°æ®ç»“æ„ï¼Œå› æ­¤å¿…é¡»å°†æ¯ä¸ªTaskåŒ…è£…åœ¨TaskWorkItemä¸­ã€‚ 3.5æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿé€šè¿‡è°ƒæ•´RunQueueæ•°æ®ç»“æ„å®Œå…¨æ‘†è„±è¿™ç§åŒ…è£…ã€‚è¿™å¯ä»¥ç¨å¾®ç®€åŒ–ä»£ç ï¼Œä½†é€šå¸¸ä¸é‡è¦ã€‚è€Œä¸”ï¼Œå°†æ¥æ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½åº”è¯¥ç¦»å¼€nullä¸Šä¸‹æ–‡ï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½•è¿™ä¸ªé—®é¢˜éƒ½å°†æ¶ˆå¤± å†…è”ä»»åŠ¡ï¼š ç”±äºä»»åŠ¡æ€»æ˜¯æ’é˜Ÿåœ¨æ­£ç¡®çš„è°ƒåº¦ç¨‹åºä¸Šï¼Œå› æ­¤ä»ç†è®ºä¸Šè®²ï¼Œå†…è”ä»»ä½•ä»»åŠ¡åº”è¯¥æ€»æ˜¯å®‰å…¨çš„ã€‚"
  },
  "Documentation/streaming/streams_programming_APIs.html": {
    "href": "Documentation/streaming/streams_programming_APIs.html",
    "title": "Orleans Streams Programming APIs | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansæµç¼–ç¨‹API åº”ç”¨ç¨‹åºé€šè¿‡ä¸ä¼—æ‰€å‘¨çŸ¥çš„APIéå¸¸ç›¸ä¼¼çš„APIä¸æµäº¤äº’ NETä¸­çš„æ— åŠŸæ‰©å±•(Rx) . ä¸»è¦çš„åŒºåˆ«æ˜¯Orleansæ²³çš„å»¶ä¼¸æ˜¯ å¼‚æ­¥ ï¼Œä»¥ä½¿å¤„ç†åœ¨Orleansçš„åˆ†å¸ƒå¼å’Œå¯æ‰©å±•è®¡ç®—ç»“æ„ä¸­æ›´é«˜æ•ˆã€‚ å¼‚æ­¥æµ åº”ç”¨ç¨‹åºé€šè¿‡ä½¿ç”¨ æµæä¾›ç¨‹åº è·å–æµçš„å¥æŸ„ã€‚æ‚¨å¯ä»¥é˜…è¯»æœ‰å…³æµæä¾›ç¨‹åºçš„æ›´å¤šä¿¡æ¯ åœ¨è¿™é‡Œ ï¼Œä½†ç°åœ¨æ‚¨å¯ä»¥å°†å…¶è§†ä¸ºå…è®¸å®ç°è€…è‡ªå®šä¹‰æµè¡Œä¸ºå’Œè¯­ä¹‰çš„æµå·¥å‚ï¼š IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(Guid, \"MyStreamNamespace\"); åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡è°ƒç”¨ GetStreamProvider æ–¹æ³• Grains ç±»ï¼Œæˆ–è€…è°ƒç”¨ GrainClient.GetStreamProvider() æ–¹æ³•ã€‚ Orleans.Streams.IAsyncStream<T> æ˜¯ä¸€ä¸ª è™šæ‹Ÿæµçš„é€»è¾‘å¼ºç±»å‹å¥æŸ„ . å®ƒåœ¨ç²¾ç¥ä¸Šç±»ä¼¼äºOrleansGrainså¼•ç”¨ã€‚è®¿é—® GetStreamProvider å’Œ GetStream å®Œå…¨æ˜¯æœ¬åœ°çš„ã€‚å…³äº GetStream æ˜¯ä¸€ä¸ªGUIDå’Œä¸€ä¸ªé¢å¤–çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæµå‘½åç©ºé—´(å¯ä»¥ä¸ºnull)ã€‚GUIDå’Œåç§°ç©ºé—´å­—ç¬¦ä¸²ä¸€èµ·æ„æˆæµæ ‡è¯†(ä¸ GrainFactory.GetGrain ). GUIDå’Œå‘½åç©ºé—´å­—ç¬¦ä¸²çš„ç»„åˆä¸ºç¡®å®šæµæ ‡è¯†æä¾›äº†é¢å¤–çš„çµæ´»æ€§ã€‚å°±åƒGrains7å¯èƒ½å­˜åœ¨äºGrainsç±»å‹ä¸­ä¸€æ · æ’­æ”¾å™¨ è€Œä¸åŒçš„grains7å¯èƒ½å­˜åœ¨äºè¯¥grainsç±»å‹ä¸­ èŠå¤©å®¤Grains ï¼Œæµ123å¯èƒ½ä¸æµå‘½åç©ºé—´ä¸€èµ·å­˜åœ¨ æ’­æ”¾äº‹ä»¶æµ å¹¶ä¸”ä¸åŒçš„æµ123å¯ä»¥å­˜åœ¨äºæµå‘½åç©ºé—´ä¸­ èŠå¤©å®¤æ¶ˆæ¯æµ . ç”Ÿäº§å’Œæ¶ˆè´¹ IAsyncStream<T> åŒæ—¶å®ç° Orleans.Streams.IAsyncObserver<T> å’Œ Orleans.Streams.IAsyncObservable<T> æ¥å£ã€‚è¿™æ ·ï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥ä½¿ç”¨æµé€šè¿‡ä½¿ç”¨ Orleans.Streams.IAsyncObserver<T> æˆ–è€…ä½¿ç”¨ Orleans.Streams.IAsyncObservable<T> . public interface IAsyncObserver<in T> { Task OnNextAsync(T item, StreamSequenceToken token = null); Task OnCompletedAsync(); Task OnErrorAsync(Exception ex); } public interface IAsyncObservable<T> { Task<StreamSubscriptionHandle<T>> SubscribeAsync(IAsyncObserver<T> observer); } ä¸ºäº†åœ¨æµä¸­ç”Ÿæˆäº‹ä»¶ï¼Œåº”ç”¨ç¨‹åºåªè°ƒç”¨ await stream.OnNextAsync<T>(event) ä¸ºäº†è®¢é˜…æµï¼Œåº”ç”¨ç¨‹åºè°ƒç”¨ StreamSubscriptionHandle<T> subscriptionHandle = await stream.SubscribeAsync(IAsyncObserver) äº‰è®º è®¢é˜…åŒæ­¥ å¯ä»¥æ˜¯å®ç° IAsyncObserveræœåŠ¡å™¨ æ¥å£æˆ–lambdaå‡½æ•°çš„ç»„åˆæ¥å¤„ç†ä¼ å…¥äº‹ä»¶ã€‚æ›´å¤šé€‰é¡¹ è®¢é˜…åŒæ­¥ å¯é€šè¿‡ AsyncObservableExtensions ç­çº§ã€‚ è®¢é˜…åŒæ­¥ è¿”å› StreamSubscriptionHandle<T> ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸é€æ˜çš„å¥æŸ„ï¼Œå¯ç”¨äºä»æµä¸­å–æ¶ˆè®¢é˜…(åœ¨ç²¾ç¥ä¸Šç±»ä¼¼äºå¼‚æ­¥ç‰ˆæœ¬çš„ ä¸å¯åˆ†è§£ ). await subscriptionHandle.UnsubscribeAsync() éœ€è¦æ³¨æ„çš„æ˜¯ è®¢é˜…æ˜¯ä¸ºäº†Grainsï¼Œè€Œä¸æ˜¯ä¸ºäº†æ¿€æ´» . ä¸€æ—¦grainä»£ç è¢«è®¢é˜…åˆ°æµä¸­ï¼Œè¿™ä¸ªè®¢é˜…å°†è¶…è¿‡è¿™ä¸ªæ¿€æ´»çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶ä¸”æ°¸è¿œä¿æŒæŒä¹…ï¼Œç›´åˆ°grainä»£ç (å¯èƒ½åœ¨ä¸åŒçš„æ¿€æ´»ä¸­)æ˜¾å¼å–æ¶ˆè®¢é˜…ã€‚è¿™æ˜¯ä¸€ä¸ª è™šæ‹ŸæµæŠ½è±¡ ï¼šä¸ä»…æ‰€æœ‰æµåœ¨é€»è¾‘ä¸Šå§‹ç»ˆå­˜åœ¨ï¼Œè€Œä¸”æµè®¢é˜…ä¹Ÿæ˜¯æŒä¹…çš„ï¼Œå¹¶ä¸”åœ¨åˆ›å»ºè®¢é˜…çš„ç‰¹å®šç‰©ç†æ¿€æ´»ä¹‹åä»ç„¶æœ‰æ•ˆã€‚ å¤šé‡æ€§ ä¸€æ¡Orleansæ²³å¯èƒ½æœ‰å¤šä¸ªç”Ÿäº§è€…å’Œå¤šä¸ªæ¶ˆè´¹è€…ã€‚ç”Ÿäº§è€…å‘å¸ƒçš„æ¶ˆæ¯å°†è¢«ä¼ é€’ç»™åœ¨æ¶ˆæ¯å‘å¸ƒä¹‹å‰è®¢é˜…æµçš„æ‰€æœ‰ä½¿ç”¨è€…ã€‚ æ­¤å¤–ï¼Œæ¶ˆè´¹è€…å¯ä»¥å¤šæ¬¡è®¢é˜…åŒä¸€ä¸ªæµã€‚æ¯æ¬¡è®¢é˜…å®ƒéƒ½ä¼šè¿”å›ä¸€ä¸ªå”¯ä¸€çš„ StreamSubscriptionHandle<T> . å¦‚æœä¸€ä¸ªgrain(æˆ–å®¢æˆ·ç«¯)è®¢é˜…åŒä¸€ä¸ªæµXæ¬¡ï¼Œå®ƒå°†æ¥æ”¶ç›¸åŒçš„äº‹ä»¶Xæ¬¡ï¼Œæ¯æ¬¡è®¢é˜…ä¸€æ¬¡ã€‚æ¶ˆè´¹è€…è¿˜å¯ä»¥ä»å•ä¸ªè®¢é˜…ä¸­å–æ¶ˆè®¢é˜…ã€‚å®ƒå¯ä»¥é€šè¿‡è°ƒç”¨ä»¥ä¸‹å‘½ä»¤æ¥æŸ¥æ‰¾å…¶å½“å‰çš„æ‰€æœ‰è®¢é˜…ï¼š IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() ä»æ•…éšœä¸­æ¢å¤ å¦‚æœæµçš„ç”Ÿäº§è€…æ­»äº†(æˆ–è€…å®ƒçš„grainsè¢«åœç”¨)ï¼Œå®ƒå°±ä¸éœ€è¦åšä»€ä¹ˆäº†ã€‚ä¸‹æ¬¡è¿™ä¸ªgrainæƒ³è¦ç”Ÿæˆæ›´å¤šäº‹ä»¶æ—¶ï¼Œå®ƒå¯ä»¥å†æ¬¡è·å¾—æµå¥æŸ„ï¼Œå¹¶ä»¥ç›¸åŒçš„æ–¹å¼ç”Ÿæˆæ–°çš„äº‹ä»¶ã€‚ æ¶ˆè´¹è€…çš„é€»è¾‘æ›´å¤æ‚ä¸€äº›ã€‚æ­£å¦‚æˆ‘ä»¬å‰é¢æ‰€è¯´çš„ï¼Œä¸€æ—¦æ¶ˆè´¹è€…çš„Grainsè¢«è®¢é˜…åˆ°ä¸€ä¸ªæµä¸­ï¼Œè¿™ä¸ªè®¢é˜…åœ¨è¯¥Grainsæ˜ç¡®å–æ¶ˆè®¢é˜…ä¹‹å‰æ˜¯æœ‰æ•ˆçš„ã€‚å¦‚æœæµçš„æ¶ˆè´¹è€…æ­»äº¡(æˆ–å…¶Grainè¢«åœç”¨)å¹¶ä¸”æµä¸Šç”Ÿæˆäº†ä¸€ä¸ªæ–°äº‹ä»¶ï¼Œæ¶ˆè´¹Grainå°†è¢«è‡ªåŠ¨é‡æ–°æ¿€æ´»(å°±åƒä»»ä½•æ™®é€šçš„OrleansGrainsåœ¨å‘å…¶å‘é€æ¶ˆæ¯æ—¶è‡ªåŠ¨æ¿€æ´»ä¸€æ ·)ã€‚grainä»£ç ç°åœ¨åªéœ€è¦æä¾›ä¸€ä¸ª IAsyncObserver<T> å¤„ç†æ•°æ®ã€‚ä½¿ç”¨è€…åŸºæœ¬ä¸Šéœ€è¦é‡æ–°é™„åŠ å¤„ç†é€»è¾‘ä½œä¸º éæ¿€æ´»å¼‚æ­¥ æ–¹æ³•ã€‚ä¸ºæ­¤ï¼Œå®ƒå¯ä»¥è°ƒç”¨ï¼š StreamSubscriptionHandle<int> newHandle = await subscriptionHandle.ResumeAsync(IAsyncObserver) æ¶ˆè´¹è€…ä½¿ç”¨å®ƒç¬¬ä¸€æ¬¡è®¢é˜…æ—¶è·å¾—çš„å‰ä¸€ä¸ªå¥æŸ„æ¥â€œç»§ç»­å¤„ç†â€ã€‚æ³¨æ„åˆ° æ¢å¤å¼‚æ­¥ ä»…ä½¿ç”¨çš„æ–°å®ä¾‹æ›´æ–°ç°æœ‰è®¢é˜… IAsyncObserveræœåŠ¡å™¨ é€»è¾‘ï¼Œå¹¶ä¸ä¼šæ”¹å˜æ­¤ä½¿ç”¨è€…å·²è®¢é˜…æ­¤æµçš„äº‹å®ã€‚ æ¶ˆè´¹è€…å¦‚ä½•è·å¾—æ—§çš„è®¢é˜…å¥æŸ„ï¼Ÿæœ‰ä¸¤ç§é€‰æ‹©ã€‚æ¶ˆè´¹è€…å¯èƒ½ä¿ç•™äº†ä»åŸå§‹çŠ¶æ€è¿”å›çš„å¥æŸ„ è®¢é˜…åŒæ­¥ æ“ä½œï¼Œç°åœ¨å¯ä»¥ä½¿ç”¨å®ƒã€‚æˆ–è€…ï¼Œå¦‚æœæ¶ˆè´¹è€…æ²¡æœ‰æŠŠæ‰‹ï¼Œå®ƒå¯ä»¥è¯¢é—® IAsyncStream<T> å¯¹äºå…¶æ‰€æœ‰æ´»åŠ¨è®¢é˜…å¥æŸ„ï¼Œé€šè¿‡è°ƒç”¨ï¼š IList<StreamSubscriptionHandle<T>> allMyHandles = await IAsyncStream<T>.GetAllSubscriptionHandles() æ¶ˆè´¹è€…ç°åœ¨å¯ä»¥æ¢å¤æ‰€æœ‰è¿™äº›æœåŠ¡ï¼Œå¦‚æœæ„¿æ„ï¼Œä¹Ÿå¯ä»¥å–æ¶ˆè®¢é˜…ã€‚ è¯„è®ºï¼š å¦‚æœæ¶ˆè´¹Grainså®æ–½ IAsyncObserveræœåŠ¡å™¨ ç›´æ¥æ¥å£( å…¬å…±ç±»MyGrain<T>ï¼šGrainï¼ŒIAsyncObserver<T> )ï¼Œç†è®ºä¸Šä¸åº”è¦æ±‚é‡æ–°é™„åŠ  IAsyncObserveræœåŠ¡å™¨ å› æ­¤ä¸éœ€è¦è°ƒç”¨ æ¢å¤å¼‚æ­¥ . æµå¼è¿è¡Œæ—¶åº”è¯¥èƒ½å¤Ÿè‡ªåŠ¨å‘ç°grainå·²ç»å®ç°äº† IAsyncObserveræœåŠ¡å™¨ åªä¼šè°ƒç”¨é‚£äº› IAsyncObserveræœåŠ¡å™¨ æ–¹æ³•ã€‚ä½†æ˜¯ï¼Œæµå¼è¿è¡Œæ—¶å½“å‰ä¸æ”¯æŒæ­¤åŠŸèƒ½ï¼Œå¹¶ä¸”grainä»£ç ä»ç„¶éœ€è¦æ˜¾å¼è°ƒç”¨ æ¢å¤å¼‚æ­¥ å³ä½¿Grainså·¥å…· IAsyncObserveræœåŠ¡å™¨ ç›´æ¥ã€‚æ”¯æŒè¿™ä¸€ç‚¹æ˜¯æˆ‘ä»¬çš„å¾…åŠäº‹é¡¹ã€‚ æ˜¾å¼å’Œéšå¼è®¢é˜… é»˜è®¤æƒ…å†µä¸‹ï¼Œæµä½¿ç”¨è€…å¿…é¡»æ˜¾å¼è®¢é˜…æµã€‚æ­¤è®¢é˜…é€šå¸¸ç”±grain(æˆ–å®¢æˆ·ç«¯)æ”¶åˆ°çš„æŒ‡ç¤ºå…¶è®¢é˜…çš„å¤–éƒ¨æ¶ˆæ¯è§¦å‘ã€‚ä¾‹å¦‚ï¼Œåœ¨èŠå¤©æœåŠ¡ä¸­ï¼Œå½“ç”¨æˆ·åŠ å…¥èŠå¤©å®¤æ—¶ï¼Œä»–çš„Grainsæ”¶åˆ° åŠ å…¥èŠå¤©ç»„ å¸¦æœ‰èŠå¤©åç§°çš„æ¶ˆæ¯ï¼Œè¿™å°†å¯¼è‡´ç”¨æˆ·grainè®¢é˜…æ­¤èŠå¤©æµã€‚ æ­¤å¤–ï¼ŒOrleansStreamsä¹Ÿæ”¯æŒ â€œéšå¼è®¢é˜…â€ . åœ¨è¿™ä¸ªæ¨¡å‹ä¸­ï¼Œgrainså¹¶æ²¡æœ‰æ˜¾å¼åœ°è®¢é˜…æµã€‚è¿™ä¸ªgrainæ˜¯è‡ªåŠ¨çš„ï¼Œéšå¼çš„ï¼Œä»…ä»…åŸºäºå®ƒçš„grainæ ‡è¯†å’Œ éšå¼itstreamsubscription å±æ€§ã€‚éšå¼è®¢é˜…çš„ä¸»è¦ä»·å€¼æ˜¯å…è®¸æµæ´»åŠ¨è‡ªåŠ¨è§¦å‘Grainæ¿€æ´»(ä»è€Œè§¦å‘è®¢é˜…)ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨SMSæµï¼Œå¦‚æœä¸€ä¸ªgrainè¦ç”Ÿæˆä¸€ä¸ªæµï¼Œè€Œå¦ä¸€ä¸ªgrainè¦å¤„ç†è¿™ä¸ªæµï¼Œåˆ™ç”Ÿäº§è€…éœ€è¦çŸ¥é“æ¶ˆè´¹Grainsçš„èº«ä»½ï¼Œå¹¶å¯¹å…¶è¿›è¡Œgrainè°ƒç”¨ï¼Œå‘Šè¯‰å®ƒè®¢é˜…æµã€‚åªæœ‰åœ¨é‚£ä¹‹åï¼Œå®ƒæ‰èƒ½å¼€å§‹å‘é€äº‹ä»¶ã€‚ç›¸åï¼Œä½¿ç”¨éšå¼è®¢é˜…ï¼Œç”Ÿäº§è€…åªéœ€å¼€å§‹ä¸ºæµç”Ÿæˆäº‹ä»¶ï¼Œæ¶ˆè´¹Grainå°†è‡ªåŠ¨æ¿€æ´»å¹¶è®¢é˜…æµã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåˆ¶ä½œäººæ ¹æœ¬ä¸åœ¨ä¹è°åœ¨çœ‹äº‹ä»¶ ç±»å‹çš„Grainså®ç°ç±» æˆ‘çš„grainsç±»å‹ å¯ä»¥å£°æ˜å±æ€§ [éšå¼itstreamsubscription(â€œMyStreamNamespaceâ€)] . è¿™å°†å‘Šè¯‰æµå¼è¿è¡Œæ—¶ï¼Œå½“åœ¨æ ‡è¯†ä¸ºGUID XXXå’Œ â€œMyStreamNamespaceâ€ å‘½åç©ºé—´ï¼Œåˆ™åº”å°†å…¶ä¼ é€’åˆ°æ ‡è¯†ä¸ºXXXç±»å‹çš„grains æˆ‘çš„grainsç±»å‹ . ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿è¡Œæ—¶æ˜ å°„æµ <XXXï¼ŒMyStreamNamespace> æ¶ˆè´¹grain <XXXï¼Œæˆ‘çš„grainsç±»å‹> . å­˜åœ¨ éšå¼itstreamsubscription ä½¿æµå¼å¤„ç†æ‰§è¡Œé˜¶æ®µè‡ªåŠ¨å°†æ­¤grainsè®¢é˜…åˆ°æµï¼Œå¹¶å°†æµäº‹ä»¶ä¼ é€’ç»™å®ƒã€‚ä½†æ˜¯ï¼Œgrainä»£ç ä»ç„¶éœ€è¦å‘Šè¯‰è¿è¡Œæ—¶å®ƒå¸Œæœ›å¦‚ä½•å¤„ç†äº‹ä»¶ã€‚æœ¬è´¨ä¸Šï¼Œå®ƒéœ€è¦é™„åŠ  IAsyncObserveræœåŠ¡å™¨ . å› æ­¤ï¼Œå½“Grainsè¢«æ¿€æ´»æ—¶ï¼Œé‡Œé¢çš„Grainsä»£ç  éæ¿€æ´»å¼‚æ­¥ éœ€è¦è°ƒç”¨ï¼š IStreamProvider streamProvider = base.GetStreamProvider(\"SimpleStreamProvider\"); IAsyncStream<T> stream = streamProvider.GetStream<T>(this.GetPrimaryKey(), \"MyStreamNamespace\"); StreamSubscriptionHandle<T> subscription = await stream.SubscribeAsync(IAsyncObserver<T>); å†™å…¥è®¢é˜…é€»è¾‘ ä¸‹é¢æ˜¯å…³äºå¦‚ä½•ä¸ºå„ç§æƒ…å†µç¼–å†™è®¢é˜…é€»è¾‘çš„æŒ‡å—ï¼šæ˜¾å¼å’Œéšå¼è®¢é˜…ã€å¯å€’å¸¦å’Œä¸å¯å€’å¸¦æµã€‚æ˜¾å¼è®¢é˜…å’Œéšå¼è®¢é˜…çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œå¯¹äºéšå¼è®¢é˜…ï¼Œgrainå¯¹äºæ¯ä¸ªæµå‘½åç©ºé—´å§‹ç»ˆåªæœ‰ä¸€ä¸ªéšå¼è®¢é˜…ï¼›æ— æ³•åˆ›å»ºå¤šä¸ªè®¢é˜…(æ²¡æœ‰è®¢é˜…å¤šé‡æ€§)ï¼Œä¹Ÿæ— æ³•å–æ¶ˆè®¢é˜…ï¼Œè€Œgrainé€»è¾‘æ€»æ˜¯åªéœ€è¦é™„åŠ å¤„ç†é€»è¾‘ã€‚è¿™ä¹Ÿæ„å‘³ç€å¯¹äºéšå¼è®¢é˜…ï¼Œæ°¸è¿œä¸éœ€è¦æ¢å¤è®¢é˜…ã€‚å¦ä¸€æ–¹é¢ï¼Œå¯¹äºæ˜¾å¼è®¢é˜…ï¼Œéœ€è¦æ¢å¤è®¢é˜…ï¼Œå¦åˆ™å¦‚æœå†æ¬¡è®¢é˜…Grainï¼Œåˆ™ä¼šå¯¼è‡´è®¢é˜…å¤šæ¬¡ã€‚ éšå¼è®¢é˜…ï¼š å¯¹äºéšå¼è®¢é˜…ï¼Œgrainéœ€è¦è®¢é˜…ä»¥é™„åŠ å¤„ç†é€»è¾‘ã€‚è¿™åº”è¯¥åœ¨è°·ä»“é‡Œåš éæ¿€æ´»å¼‚æ­¥ æ–¹æ³•ã€‚Grainsåº”è¯¥ç®€å•åœ°æ‰§è¡Œ ç­‰å¾…æµå¼è®¢é˜…åŒæ­¥(ä¸‹ä¸€é¡µâ€¦) åœ¨å®ƒçš„ éæ¿€æ´»å¼‚æ­¥ æ–¹æ³•ã€‚è¿™å°†å¯¼è‡´æ­¤ç‰¹å®šæ¿€æ´»é™„åŠ  OnNext å‡½æ•°æ¥å¤„ç†è¯¥æµã€‚grainså¯ä»¥é€‰æ‹©æŒ‡å®š StreamSequenceToken ä½œä¸º è®¢é˜…åŒæ­¥ ï¼Œè¿™å°†å¯¼è‡´æ­¤éšå¼è®¢é˜…ä»è¯¥ä»¤ç‰Œå¼€å§‹ä½¿ç”¨ã€‚æ°¸è¿œä¸éœ€è¦éšå¼è®¢é˜…æ¥è°ƒç”¨ æ¢å¤å¼‚æ­¥ . public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); await stream.SubscribeAsync(OnNextAsync) } æ˜¾å¼è®¢é˜…ï¼š å¯¹äºæ˜¾å¼è®¢é˜…ï¼Œgrainå¿…é¡»è°ƒç”¨ è®¢é˜…åŒæ­¥ è®¢é˜…æµã€‚è¿™å°†åˆ›å»ºä¸€ä¸ªè®¢é˜…ï¼Œå¹¶é™„åŠ å¤„ç†é€»è¾‘ã€‚æ˜¾å¼è®¢é˜…å°†ä¸€ç›´å­˜åœ¨ï¼Œç›´åˆ°å–æ¶ˆè®¢é˜…è¯¥Grainï¼Œå› æ­¤ï¼Œå¦‚æœæŸä¸ªGrainè¢«åœç”¨å¹¶é‡æ–°æ¿€æ´»ï¼Œåˆ™è¯¥Grainä»ç„¶æ˜¾å¼è®¢é˜…ï¼Œä½†ä¸ä¼šé™„åŠ ä»»ä½•å¤„ç†é€»è¾‘ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒGrainséœ€è¦é‡æ–°é™„åŠ å¤„ç†é€»è¾‘ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ éæ¿€æ´»å¼‚æ­¥ ï¼Œgrainé¦–å…ˆéœ€è¦é€šè¿‡è°ƒç”¨ stream.GetAllSubscriptionHandles() . Grainså¿…é¡»æ‰§è¡Œ æ¢å¤å¼‚æ­¥ å¯¹äºæ¯ä¸ªå¥æŸ„ï¼Œå®ƒå¸Œæœ›ç»§ç»­å¤„ç†æˆ–å–æ¶ˆè®¢é˜…å·²å¤„ç†çš„ä»»ä½•å¥æŸ„çš„å¼‚æ­¥ã€‚grainsä¹Ÿå¯ä»¥é€‰æ‹©æŒ‡å®š StreamSequenceToken ä½œä¸º æ¢å¤å¼‚æ­¥ è°ƒç”¨ï¼Œè¿™å°†å¯¼è‡´æ­¤æ˜¾å¼è®¢é˜…ä»è¯¥ä»¤ç‰Œå¼€å§‹ä½¿ç”¨ã€‚ public async override Task OnActivateAsync() { var streamProvider = GetStreamProvider(PROVIDER_NAME); var stream = streamProvider.GetStream<string>(this.GetPrimaryKey(), \"MyStreamNamespace\"); var subscriptionHandles = await stream.GetAllSubscriptionHandles(); if (!subscriptionHandles.IsNullOrEmpty()) subscriptionHandles.ForEach(async x => await x.ResumeAsync(OnNextAsync)); } æµé¡ºåºå’Œåºåˆ—æ ‡è®° å•ä¸ªç”Ÿäº§è€…å’Œå•ä¸ªæ¶ˆè´¹è€…ä¹‹é—´çš„äº‹ä»¶ä¼ é€’é¡ºåºå–å†³äºæµæä¾›è€…ã€‚ å¯¹äºSMSï¼Œç”Ÿäº§è€…é€šè¿‡æ§åˆ¶ç”Ÿäº§è€…å‘å¸ƒäº‹ä»¶çš„æ–¹å¼æ¥æ˜¾å¼åœ°æ§åˆ¶æ¶ˆè´¹è€…çœ‹åˆ°çš„äº‹ä»¶é¡ºåºã€‚é»˜è®¤æƒ…å†µä¸‹(å¦‚æœ ç«ä¸Šæµ‡æ²¹ SMS providerçš„é€‰é¡¹è®¾ç½®ä¸ºfalse)ï¼Œå¹¶ä¸”å¦‚æœç”Ÿäº§è€…ç­‰å¾… OnNextAsync è®¿é—®ï¼Œäº‹ä»¶æŒ‰å…ˆè¿›å…ˆå‡ºé¡ºåºåˆ°è¾¾ã€‚åœ¨SMSä¸­ï¼Œç”±åˆ¶ä½œè€…å†³å®šå¦‚ä½•å¤„ç†å°†ç”±ä¸­æ–­è¡¨ç¤ºçš„ä¼ é€’å¤±è´¥ Task ç”± OnNextAsync è°ƒç”¨ã€‚ Azureé˜Ÿåˆ—æµä¸ä¿è¯FIFOé¡ºåºï¼Œå› ä¸ºåº•å±‚çš„Azureé˜Ÿåˆ—ä¸ä¿è¯æ•…éšœæƒ…å†µä¸‹çš„é¡ºåºã€‚(å®ƒä»¬ç¡®å®ä¿è¯äº†æ— æ•…éšœæ‰§è¡Œä¸­çš„å…ˆè¿›å…ˆå‡ºé¡ºåºã€‚)å½“ç”Ÿäº§è€…å°†äº‹ä»¶ç”Ÿæˆåˆ°Azureé˜Ÿåˆ—ä¸­æ—¶ï¼Œå¦‚æœæ’é˜Ÿæ“ä½œå¤±è´¥ï¼Œåˆ™ç”±ç”Ÿäº§è€…å°è¯•å¦ä¸€æ¬¡æ’é˜Ÿï¼Œç„¶åå†å¤„ç†æ½œåœ¨çš„é‡å¤æ¶ˆæ¯ã€‚åœ¨ä¼ é€’ç«¯ï¼ŒOrleansæµå¼å¤„ç†è¿è¡Œæ—¶å°†äº‹ä»¶ä»é˜Ÿåˆ—ä¸­å–å‡ºï¼Œå¹¶å°è¯•å°†å…¶ä¼ é€’ç»™æ¶ˆè´¹è€…è¿›è¡Œå¤„ç†ã€‚Orleansæµå¼å¤„ç†è¿è¡Œæ—¶ä»…åœ¨æˆåŠŸå¤„ç†åä»é˜Ÿåˆ—ä¸­åˆ é™¤äº‹ä»¶ã€‚å¦‚æœä¼ é€’æˆ–å¤„ç†å¤±è´¥ï¼Œåˆ™ä¸ä¼šä»é˜Ÿåˆ—ä¸­åˆ é™¤äº‹ä»¶ï¼Œç¨åå°†è‡ªåŠ¨é‡æ–°å‡ºç°åœ¨é˜Ÿåˆ—ä¸­ã€‚æµå¼è¿è¡Œæ—¶å°†å†æ¬¡å°è¯•ä¼ é€’å®ƒï¼Œå› æ­¤å¯èƒ½ä¼šç ´åFIFOé¡ºåºã€‚ä¸Šé¢çš„è¡Œä¸ºç¬¦åˆAzureé˜Ÿåˆ—çš„æ­£å¸¸è¯­ä¹‰ã€‚ åº”ç”¨ç¨‹åºå®šä¹‰çš„é¡ºåº ï¼šè¦å¤„ç†ä¸Šè¿°æ’åºé—®é¢˜ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥é€‰æ‹©æŒ‡å®šè‡ªå·±çš„æ’åºã€‚è¿™æ˜¯é€šè¿‡ StreamSequenceToken ï¼Œå®ƒæ˜¯ä¸é€æ˜çš„ iå¯æ¯”è¾ƒ å¯¹è±¡ï¼Œå¯ç”¨äºå¯¹äº‹ä»¶æ’åºã€‚åˆ¶ä½œè€…å¯ä»¥é€šè¿‡ä¸€ä¸ªå¯é€‰çš„ StreamSequenceToken è‡´ OnNext è°ƒç”¨ã€‚è¿™ä¸ª StreamSequenceToken å°†ä¸€ç›´ä¼ é€’ç»™æ¶ˆè´¹è€…ï¼Œå¹¶ä¸æ´»åŠ¨ä¸€èµ·äº¤ä»˜ã€‚è¿™æ ·ï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥ç‹¬ç«‹äºæµå¼è¿è¡Œæ—¶æ¨ç†å’Œé‡å»ºå…¶é¡ºåºã€‚ å¯å€’æµ æœ‰äº›æµåªå…è®¸åº”ç”¨ç¨‹åºä»æœ€æ–°çš„æ—¶é—´ç‚¹å¼€å§‹è®¢é˜…å®ƒä»¬ï¼Œè€Œå…¶ä»–æµåˆ™å…è®¸â€œè¿”å›æ—¶é—´â€ã€‚åä¸€ç§åŠŸèƒ½å–å†³äºåº•å±‚é˜Ÿåˆ—æŠ€æœ¯å’Œç‰¹å®šçš„æµæä¾›ç¨‹åºã€‚ä¾‹å¦‚ï¼ŒAzureé˜Ÿåˆ—åªå…è®¸ä½¿ç”¨æœ€æ–°çš„æ’é˜Ÿäº‹ä»¶ï¼Œè€ŒEventHubå…è®¸ä»ä»»æ„æ—¶é—´ç‚¹(ç›´åˆ°æŸä¸ªè¿‡æœŸæ—¶é—´)é‡æ”¾äº‹ä»¶ã€‚æ”¯æŒæ—¶é—´å€’æµçš„æµç§°ä¸º å¯å€’æµ . å¯å€’å¸¦æµçš„ä½¿ç”¨è€…å¯ä»¥ä¼ é€’ StreamSequenceToken è‡´ è®¢é˜…åŒæ­¥ è°ƒç”¨ã€‚è¿è¡Œæ—¶å°†ä»è¿™ä¸ªå¼€å§‹å‘å®ƒä¼ é€’äº‹ä»¶ StreamSequenceToken . ç©ºä»¤ç‰Œè¡¨ç¤ºæ¶ˆè´¹è€…å¸Œæœ›æ¥æ”¶ä»æœ€æ–°å¼€å§‹çš„äº‹ä»¶ã€‚ å›æ”¾æµçš„èƒ½åŠ›åœ¨æ¢å¤åœºæ™¯ä¸­éå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘è®¢é˜…æµå¹¶å®šæœŸæ£€æŸ¥å…¶çŠ¶æ€å’Œæœ€æ–°åºåˆ—æ ‡è®°çš„Grainã€‚å½“ä»å¤±è´¥ä¸­æ¢å¤æ—¶ï¼Œgrainå¯ä»¥ä»æœ€æ–°çš„æ£€æŸ¥ç‚¹åºåˆ—ä»¤ç‰Œé‡æ–°è®¢é˜…åŒä¸€ä¸ªæµï¼Œä»è€Œæ¢å¤è€Œä¸ä¼šä¸¢å¤±è‡ªä¸Šä¸€ä¸ªæ£€æŸ¥ç‚¹ä»¥æ¥ç”Ÿæˆçš„ä»»ä½•äº‹ä»¶ã€‚ äº‹ä»¶ä¸­å¿ƒæä¾›ç¨‹åº å¯å€’å¸¦ã€‚ä½ å¯ä»¥æ‰¾åˆ°å®ƒçš„ä»£ç  åœ¨è¿™é‡Œ . çŸ­è®¯æœåŠ¡ å’Œ Azureé˜Ÿåˆ— æä¾›ç¨‹åºä¸å¯å€’å¸¦ã€‚ æ— çŠ¶æ€è‡ªåŠ¨æ‰©å±•å¤„ç† é»˜è®¤æƒ…å†µä¸‹ï¼ŒOrleansæµçš„ç›®æ ‡æ˜¯æ”¯æŒå¤§é‡ç›¸å¯¹è¾ƒå°çš„æµï¼Œæ¯ä¸ªæµç”±ä¸€ä¸ªæˆ–å¤šä¸ªæœ‰çŠ¶æ€Grainå¤„ç†ã€‚æ€»çš„æ¥è¯´ï¼Œæ‰€æœ‰æµçš„å¤„ç†åœ¨å¤§é‡è§„åˆ™çš„(æœ‰çŠ¶æ€çš„)grainsä¹‹é—´è¢«åˆ‡åˆ†ã€‚åº”ç”¨ç¨‹åºä»£ç é€šè¿‡åˆ†é…æµIDå’ŒGrainIDä»¥åŠæ˜¾å¼è®¢é˜…æ¥æ§åˆ¶è¿™ç§åˆ†ç‰‡ã€‚ ç›®æ ‡æ˜¯åˆ†ç‰‡çŠ¶æ€å¤„ç† . ç„¶è€Œï¼Œè¿˜æœ‰ä¸€ä¸ªæœ‰è¶£çš„åœºæ™¯ è‡ªåŠ¨æ‰©å±•æ— çŠ¶æ€å¤„ç† . åœ¨è¿™ä¸ªåœºæ™¯ä¸­ï¼Œåº”ç”¨ç¨‹åºæœ‰å°‘é‡çš„æµ(ç”šè‡³ä¸€ä¸ªå¤§çš„æµ)ï¼Œç›®æ ‡æ˜¯æ— çŠ¶æ€å¤„ç†ã€‚ä¾‹å¦‚ï¼Œäº‹ä»¶çš„å…¨å±€æµï¼Œå…¶ä¸­çš„å¤„ç†æ¶‰åŠå¯¹æ¯ä¸ªäº‹ä»¶è¿›è¡Œè§£ç ï¼Œå¹¶å¯èƒ½å°†å…¶è½¬å‘åˆ°å…¶ä»–æµä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„æœ‰çŠ¶æ€å¤„ç†ã€‚åœ¨Orleansï¼Œå¯ä»¥é€šè¿‡ æ— çŠ¶æ€ Worker Grainsã€‚ æ— çŠ¶æ€è‡ªåŠ¨æ‰©å±•å¤„ç†çš„å½“å‰çŠ¶æ€ï¼š è¿™è¿˜æ²¡æœ‰å®æ–½ã€‚ä»è®¢é˜…æµçš„å°è¯• æ— çŠ¶æ€ Worker grainså°†å¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚ æˆ‘ä»¬æ­£åœ¨è€ƒè™‘æ”¯æŒè¿™ä¸€é€‰æ‹© . Grainså’ŒOrleanså®¢æˆ· OrleansStreams åœ¨Grainså’ŒOrleansçš„å®¢æˆ·ä¸­éƒ½æ˜¯ä¸€è‡´çš„ . ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯ä»¥åœ¨grainå†…éƒ¨å’ŒOrleanså®¢æˆ·ç«¯ä¸­ä½¿ç”¨å®Œå…¨ç›¸åŒçš„apiæ¥ç”Ÿæˆå’Œæ¶ˆè´¹äº‹ä»¶ã€‚è¿™å¤§å¤§ç®€åŒ–äº†åº”ç”¨ç¨‹åºé€»è¾‘ï¼Œä½¿å¾—ç‰¹æ®Šçš„å®¢æˆ·ç«¯api(å¦‚Grain observer)å˜å¾—å¤šä½™ã€‚ å…¨é¢ç®¡ç†å’Œå¯é çš„æµåª’ä½“é…’å§ ä¸ºäº†è·Ÿè¸ªæµè®¢é˜…ï¼ŒOrleansä½¿ç”¨ä¸€ä¸ªåä¸º æµåª’ä½“é…’å§ ä½œä¸ºæµæ¶ˆè´¹è€…å’Œæµç”Ÿäº§è€…çš„äº¤æ±‡ç‚¹ã€‚Pub-Subè·Ÿè¸ªæ‰€æœ‰æµè®¢é˜…ï¼ŒæŒä¹…åŒ–å®ƒä»¬ï¼Œå¹¶å°†æµæ¶ˆè´¹è€…ä¸æµç”Ÿäº§è€…åŒ¹é…ã€‚ åº”ç”¨ç¨‹åºå¯ä»¥é€‰æ‹©å‘å¸ƒè®¢é˜…æ•°æ®çš„å­˜å‚¨ä½ç½®å’Œå­˜å‚¨æ–¹å¼ã€‚Pub-Subç»„ä»¶æœ¬èº«è¢«å®ç°ä¸ºgrains(ç§°ä¸º å…¬å…±åœ°ä¸‹å®¤ )ï¼Œå®ƒä½¿ç”¨Orleanså£°æ˜æ€§æŒä¹…åŒ–ã€‚ å…¬å…±åœ°ä¸‹å®¤ ä½¿ç”¨åä¸ºçš„å­˜å‚¨æä¾›ç¨‹åº PubSubStoreé…’åº— . ä¸ä»»ä½•Grainä¸€æ ·ï¼Œæ‚¨å¯ä»¥ä¸ºå­˜å‚¨æä¾›ç¨‹åºæŒ‡å®šå®ç°ã€‚å¯¹äºæµå¼å‘å¸ƒè®¢é˜…ï¼Œæ‚¨å¯ä»¥æ›´æ”¹ PubSubStoreé…’åº— åœ¨silosæ„å»ºæ—¶ï¼Œä½¿ç”¨æ€æ´›ä¸»æœºç”Ÿæˆå™¨ï¼š ä¸‹é¢å°†Pub-Subé…ç½®ä¸ºå°†å…¶çŠ¶æ€å­˜å‚¨åœ¨Azureè¡¨ä¸­ã€‚ hostBuilder.AddAzureTableGrainStorage(\"PubSubStore\", options=>{ options.ConnectionString = \"Secret\"; }); è¿™æ ·ï¼Œå‘å¸ƒè®¢é˜…æ•°æ®å°†æŒä¹…åœ°å­˜å‚¨åœ¨Azureè¡¨ä¸­ã€‚å¯¹äºåˆå§‹å¼€å‘ï¼Œæ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨å†…å­˜å­˜å‚¨ã€‚é™¤äº†Pub-Subä¹‹å¤–ï¼ŒOrleansæµåª’ä½“è¿è¡Œæ—¶è¿˜ä»ç”Ÿäº§è€…å‘æ¶ˆè´¹è€…ä¼ é€’äº‹ä»¶ï¼Œç®¡ç†åˆ†é…ç»™æ´»åŠ¨ä½¿ç”¨æµçš„æ‰€æœ‰è¿è¡Œæ—¶èµ„æºï¼Œå¹¶é€æ˜åœ°ä»æœªä½¿ç”¨çš„æµä¸­åƒåœ¾æ”¶é›†è¿è¡Œæ—¶èµ„æºã€‚ é…ç½® ä¸ºäº†ä½¿ç”¨æµï¼Œæ‚¨éœ€è¦é€šè¿‡æ€æ´›ä¸»æœºæˆ–ç¾¤é›†å®¢æˆ·ç«¯æ„å»ºå™¨å¯ç”¨æµæä¾›ç¨‹åºã€‚æ‚¨å¯ä»¥é˜…è¯»æœ‰å…³æµæä¾›ç¨‹åºçš„æ›´å¤šä¿¡æ¯ åœ¨è¿™é‡Œ . ç¤ºä¾‹æµæä¾›ç¨‹åºè®¾ç½®ï¼š hostBuilder.AddSimpleMessageStreamProvider(\"SMSProvider\") .AddAzureQueueStreams<AzureQueueDataAdapterV2>(\"AzureQueueProvider\", optionsBuilder => optionsBuilder.Configure( options=>{ options.ConnectionString = \"Secret\"; })) .AddAzureTableGrainStorage(\"PubSubStore\", options=>{ options.ConnectionString = \"Secret\"; }); ä¸‹ä¸€ä¸ª Orleansæ²³æµä¾›åº”å•†"
  },
  "Documentation/streaming/stream_providers.html": {
    "href": "Documentation/streaming/stream_providers.html",
    "title": "Orleans Stream Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æµæä¾›è€… Streamså¯ä»¥æœ‰ä¸åŒçš„å½¢çŠ¶å’Œå½¢å¼ã€‚ä¸€äº›æµå¯èƒ½é€šè¿‡ç›´æ¥TCPé“¾æ¥ä¼ é€’äº‹ä»¶ï¼Œè€Œå¦ä¸€äº›æµåˆ™é€šè¿‡æŒä¹…é˜Ÿåˆ—ä¼ é€’äº‹ä»¶ã€‚ä¸åŒçš„æµç±»å‹å¯èƒ½ä½¿ç”¨ä¸åŒçš„æ‰¹å¤„ç†ç­–ç•¥ï¼Œä¸åŒçš„ç¼“å­˜ç®—æ³•æˆ–ä¸åŒçš„åå‹ç¨‹åºã€‚ä¸ºé¿å…å°†æµåº”ç”¨ç¨‹åºé™åˆ¶ä¸ºä»…è¿™äº›è¡Œä¸ºé€‰æ‹©çš„ä¸€éƒ¨åˆ†ï¼Œ æµæä¾›è€… æ˜¯Orleans Streaming Runtimeçš„å¯æ‰©å±•æ€§ç‚¹ï¼Œå…è®¸ç”¨æˆ·å®ç°ä»»ä½•ç±»å‹çš„æµã€‚è¿™ä¸ªæ‰©å±•ç‚¹åœ¨ç²¾ç¥ä¸Šç±»ä¼¼äº Orleanså­˜å‚¨æä¾›å•† ã€‚Orleansç›®å‰ä¸è®¸å¤šæµæä¾›ç¨‹åºä¸€èµ·æä¾›ï¼ŒåŒ…æ‹¬ï¼š ç®€å•æ¶ˆæ¯æµæä¾›è€… å’Œ Azureé˜Ÿåˆ—æµæä¾›ç¨‹åº ã€‚ ç®€å•æ¶ˆæ¯æµæä¾›è€… ç®€å•æ¶ˆæ¯æµæä¾›ç¨‹åºï¼Œä¹Ÿç§°ä¸ºSMSæä¾›ç¨‹åºï¼Œé€šè¿‡åˆ©ç”¨å¸¸è§„çš„OrleansGrainsæ¶ˆæ¯ä¼ é€’é€šè¿‡TCPä¼ é€’äº‹ä»¶ã€‚ç”±äºSMSä¸­çš„äº‹ä»¶æ˜¯é€šè¿‡ä¸å¯é çš„TCPé“¾æ¥ä¼ é€’çš„ï¼Œå› æ­¤SMSå¯ä»¥ ä¸ ç¡®ä¿å¯é çš„äº‹ä»¶ä¼ é€’ï¼Œå¹¶ä¸”ä¸ä¼šè‡ªåŠ¨é‡æ–°å‘é€SMSæµå¤±è´¥çš„æ¶ˆæ¯ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œç”Ÿäº§è€…çš„è°ƒç”¨ stream.OnNextAsync è¿”å›ä¸€ä¸ª Task ä»£è¡¨æµä½¿ç”¨è€…çš„å¤„ç†çŠ¶æ€ï¼Œå®ƒå‘Šè¯‰ç”Ÿäº§è€…ä½¿ç”¨è€…æ˜¯å¦æˆåŠŸæ¥æ”¶å¹¶å¤„ç†äº†äº‹ä»¶ã€‚å¦‚æœæ­¤ä»»åŠ¡å¤±è´¥ï¼Œåˆ™ç”Ÿäº§è€…å¯ä»¥å†³å®šå†æ¬¡å‘é€åŒä¸€äº‹ä»¶ï¼Œä»è€Œåœ¨åº”ç”¨ç¨‹åºçº§åˆ«ä¸Šå®ç°å¯é æ€§ã€‚å°½ç®¡æµæ¶ˆæ¯ä¼ é€’æ˜¯å°½åŠ›è€Œä¸ºçš„ï¼Œä½†SMSæµæœ¬èº«æ˜¯å¯é çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒPub-Subæ‰§è¡Œçš„è®¢æˆ·åˆ°ç”Ÿäº§è€…ç»‘å®šæ˜¯å®Œå…¨å¯é çš„ã€‚ Azureé˜Ÿåˆ—(AQ)æµæä¾›ç¨‹åº Azureé˜Ÿåˆ—(AQ)æµæä¾›ç¨‹åºé€šè¿‡Azureé˜Ÿåˆ—ä¼ é€’äº‹ä»¶ã€‚åœ¨ç”Ÿäº§è€…ç«¯ï¼ŒAQæµæä¾›ç¨‹åºå°†äº‹ä»¶ç›´æ¥æ’é˜Ÿåˆ°Azureé˜Ÿåˆ—ä¸­ã€‚åœ¨æ¶ˆè´¹è€…æ–¹é¢ï¼ŒAQ Stream Providerç®¡ç†ä¸€ç»„ æ‹‰å‰‚ ä»ä¸€ç»„Azureé˜Ÿåˆ—ä¸­æå–äº‹ä»¶ï¼Œå¹¶å°†äº‹ä»¶ä¼ é€’ç»™ä½¿ç”¨äº‹ä»¶çš„åº”ç”¨ç¨‹åºä»£ç ã€‚å¯ä»¥å°†æ‹‰åŠ¨ä»£ç†è§†ä¸ºä¸€ç§åˆ†å¸ƒå¼â€œå¾®æœåŠ¡â€ï¼Œå³ä¸€ç§åˆ†åŒºçš„ï¼Œé«˜åº¦å¯ç”¨çš„å¼¹æ€§åˆ†å¸ƒå¼ç»„ä»¶ã€‚ç‰µå¼•å‰‚åœ¨æ‰¿è½½åº”ç”¨ç¨‹åºGrainçš„ç›¸åŒsilosä¸­è¿è¡Œã€‚å› æ­¤ï¼Œæ— éœ€è¿è¡Œå•ç‹¬çš„Azureå·¥ä½œè§’è‰²æ¥ä»é˜Ÿåˆ—ä¸­æ‹‰å‡ºã€‚æ‹‰åŠ¨ä»£ç†ç¨‹åºï¼Œå®ƒä»¬çš„ç®¡ç†ï¼ŒèƒŒå‹ï¼Œå¹³è¡¡å®ƒä»¬ä¹‹é—´çš„é˜Ÿåˆ—ä»¥åŠå°†é˜Ÿåˆ—ä»æ•…éšœä»£ç†ç¨‹åºåˆ‡æ¢åˆ°å¦ä¸€ä¸ªä»£ç†ç¨‹åºçš„å­˜åœ¨ç”±Orleans Streaming Runtimeå®Œå…¨ç®¡ç†ï¼Œå¹¶ä¸”å¯¹äºä½¿ç”¨æµçš„åº”ç”¨ç¨‹åºä»£ç æ˜¯é€æ˜çš„ã€‚ é˜Ÿåˆ—é€‚é…å™¨ é€šè¿‡æŒä¹…é˜Ÿåˆ—ä¼ é€’äº‹ä»¶çš„ä¸åŒæµæä¾›ç¨‹åºè¡¨ç°å‡ºç›¸ä¼¼çš„è¡Œä¸ºï¼Œå¹¶å—åˆ°ç›¸ä¼¼çš„å®ç°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æä¾›äº†é€šç”¨çš„å¯æ‰©å±• PersistentStreamProvider å…è®¸å¼€å‘äººå‘˜æ’å…¥ä¸åŒç±»å‹çš„é˜Ÿåˆ—ï¼Œè€Œæ— éœ€ä»å¤´å¼€å§‹ç¼–å†™å…¨æ–°çš„æµæä¾›ç¨‹åºã€‚ PersistentStreamProvider ä½¿ç”¨ä¸€ä¸ª IQueueAdapter ç»„ä»¶ï¼Œå®ƒæŠ½è±¡ç‰¹å®šçš„é˜Ÿåˆ—å®ç°ç»†èŠ‚ï¼Œå¹¶æä¾›ä½¿äº‹ä»¶å…¥é˜Ÿå’Œå‡ºé˜Ÿçš„æ–¹æ³•ã€‚å…¶ä½™çš„å…¨éƒ¨ç”±å†…éƒ¨é€»è¾‘å¤„ç† PersistentStreamProvider ã€‚ä¸Šé¢æåˆ°çš„Azureé˜Ÿåˆ—æä¾›ç¨‹åºä¹Ÿä»¥è¿™ç§æ–¹å¼å®ç°ï¼šå®ƒæ˜¯ PersistentStreamProvider ä½¿ç”¨ä¸€ä¸ª AzureQueueAdapter ã€‚ ä¸‹ä¸€ä¸ª Orleansæµå®æ–½ç»†èŠ‚"
  },
  "Documentation/streaming/index.html": {
    "href": "Documentation/streaming/index.html",
    "title": "Orleans Streams | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "OrleansStreams Orleans v.1.0.0å¢åŠ äº†å¯¹ç¼–ç¨‹æ¨¡å‹çš„æµæ‰©å±•çš„æ”¯æŒã€‚æµæ‰©å±•æä¾›äº†ä¸€ç»„æŠ½è±¡å’ŒAPIï¼Œä½¿å¯¹æµçš„æ€è€ƒå’Œä½¿ç”¨å˜å¾—æ›´ç®€å•ï¼Œæ›´å¯é ã€‚æµæ‰©å±•å…è®¸å¼€å‘äººå‘˜ç¼–å†™ä»¥ç»“æ„åŒ–æ–¹å¼å¯¹ä¸€ç³»åˆ—äº‹ä»¶è¿›è¡Œæ“ä½œçš„å“åº”å¼åº”ç”¨ç¨‹åºã€‚æµæä¾›ç¨‹åºçš„å¯æ‰©å±•æ€§æ¨¡å‹ä½¿ç¼–ç¨‹æ¨¡å‹å¯ä¸å¤šç§ç°æœ‰æ’é˜ŸæŠ€æœ¯å…¼å®¹å¹¶å¯ç§»æ¤ï¼Œä¾‹å¦‚ æ´»åŠ¨ä¸­å¿ƒ ï¼Œ æœåŠ¡æ€»çº¿ ï¼Œ Azureé˜Ÿåˆ— å’Œ é˜¿å¸•å¥‡Â·å¡å¤«å¡ ã€‚æ— éœ€ç¼–å†™ç‰¹æ®Šä»£ç æˆ–è¿è¡Œä¸“ç”¨è¿›ç¨‹æ¥ä¸æ­¤ç±»é˜Ÿåˆ—è¿›è¡Œäº¤äº’ã€‚ æˆ‘ä¸ºä»€ä¹ˆè¦åœ¨ä¹ï¼Ÿ å¦‚æœæ‚¨å·²ç»çŸ¥é“æ‰€æœ‰ æµå¤„ç† å¹¶ä¸”ç†Ÿæ‚‰è¯¸å¦‚ æ´»åŠ¨ä¸­å¿ƒ ï¼Œ å¡å¤«å¡ ï¼Œ Azureæµåˆ†æ ï¼Œ é˜¿å¸•å¥‡é£æš´ ï¼Œ Apache Sparkæµ å’Œ .NETä¸­çš„ååº”æ€§æ‰©å±•(Rx) ï¼Œæ‚¨å¯èƒ½ä¼šé—®ä¸ºä»€ä¹ˆè¦å…³å¿ƒã€‚ ä¸ºä»€ä¹ˆæˆ‘ä»¬è¿˜éœ€è¦å¦ä¸€ä¸ªæµå¤„ç†ç³»ç»Ÿï¼Œä»¥åŠActorä¸æµä¹‹é—´çš„å…³ç³»ï¼Ÿ â€œä¸ºä»€ä¹ˆOrleansStreamsï¼Ÿâ€ æ˜¯è¦å›ç­”è¿™ä¸ªé—®é¢˜ã€‚ ç¨‹å¼è®¾è®¡æ¨¡å‹ Orleans Streamsç¼–ç¨‹æ¨¡å‹èƒŒåæœ‰è®¸å¤šåŸåˆ™ã€‚ OrleansStreamsæ˜¯ è™šæ‹Ÿ ã€‚å³ï¼Œæµå§‹ç»ˆå­˜åœ¨ã€‚å®ƒä¸æ˜¯æ˜¾å¼åˆ›å»ºæˆ–é”€æ¯çš„ï¼Œå®ƒæ°¸è¿œä¸ä¼šå¤±è´¥ã€‚ æµæ˜¯ ç”±...ç¡®å®š æµIDï¼Œä»… é€»è¾‘åç§° ç”±GUIDå’Œå­—ç¬¦ä¸²ç»„æˆã€‚ OrleansStreamså…è®¸ åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šå°†æ•°æ®ç”Ÿæˆä¸å…¶å¤„ç†è„±é’© ã€‚è¿™æ„å‘³ç€æµç”Ÿäº§è€…å’Œæµä½¿ç”¨è€…å¯èƒ½ä½äºä¸åŒçš„æœåŠ¡å™¨ä¸Šï¼Œå¤„äºä¸åŒçš„æ—¶é—´ï¼Œå¹¶ä¸”å°†æ‰¿å—æ•…éšœã€‚ OrleansStreamsæ˜¯ è½»å·§è€ŒåŠ¨æ€ ã€‚Orleans Streaming Runtimeæ—¨åœ¨å¤„ç†å¤§é‡é«˜é€Ÿç‡æ¥æ¥å»å»çš„æµã€‚ Orleansæµ ç»‘å®šæ˜¯åŠ¨æ€çš„ ã€‚Orleans Streaming Runtimeæ—¨åœ¨å¤„ç†Grainsä»¥é«˜é€Ÿç‡è¿æ¥åˆ°æµæˆ–ä»æµä¸­æ–­å¼€çš„æƒ…å†µã€‚ Orleansæµåª’ä½“è¿è¡Œæ—¶ é€æ˜åœ°ç®¡ç†æµæ¶ˆè€—çš„ç”Ÿå‘½å‘¨æœŸ ã€‚åº”ç”¨ç¨‹åºè®¢é˜…æµä¹‹åï¼Œä»é‚£æ—¶èµ·ï¼Œå³ä½¿å­˜åœ¨æ•…éšœï¼Œå®ƒä¹Ÿå°†æ¥æ”¶æµçš„äº‹ä»¶ã€‚ OrleansStreams è·¨Grainså’ŒOrleanså®¢æˆ·ç»Ÿä¸€å·¥ä½œ ã€‚ ç¼–ç¨‹API åº”ç”¨ç¨‹åºé€šè¿‡ä¸ä¼—æ‰€å‘¨çŸ¥çš„APIéå¸¸ç›¸ä¼¼çš„APIä¸æµè¿›è¡Œäº¤äº’ .NETä¸­çš„ååº”æ€§æ‰©å±•(Rx) ï¼Œ é€šè¿‡ä½¿ç”¨ Orleans.Streams.IAsyncStream <T> å®ç°\\ Orleans.Streams.IAsyncObserver <T> å’Œ Orleans.Streams.IAsyncObservable <T> æ¥å£ã€‚ åœ¨ä¸‹é¢çš„å…¸å‹ç¤ºä¾‹ä¸­ï¼Œè®¾å¤‡ç”Ÿæˆä¸€äº›æ•°æ®ï¼Œè¿™äº›æ•°æ®ä½œä¸ºHTTPè¯·æ±‚å‘é€åˆ°äº‘ä¸­è¿è¡Œçš„æœåŠ¡ã€‚åœ¨å‰ç«¯æœåŠ¡å™¨ä¸­è¿è¡Œçš„Orleanså®¢æˆ·ç«¯æ”¶åˆ°æ­¤HTTPè°ƒç”¨ï¼Œå¹¶å°†æ•°æ®å‘å¸ƒåˆ°åŒ¹é…çš„è®¾å¤‡æµä¸­ï¼š public async Task OnHttpCall(DeviceEvent deviceEvent) { // Post data directly into device's stream. IStreamProvider streamProvider = GrainClient.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<DeviceEventData> deviceStream = streamProvider.GetStream<DeviceEventData>(deviceEvent.DeviceId); await deviceStream.OnNextAsync(deviceEvent.Data); } åœ¨ä¸‹é¢çš„å¦ä¸€ä¸ªç¤ºä¾‹ä¸­ï¼ŒèŠå¤©ç”¨æˆ·(å®ç°ä¸ºOrleans Grain)åŠ å…¥èŠå¤©å®¤ï¼Œè·å–è¯¥æˆ¿é—´ä¸­æ‰€æœ‰å…¶ä»–ç”¨æˆ·ç”Ÿæˆçš„èŠå¤©æ¶ˆæ¯æµçš„å¥æŸ„å¹¶è¿›è¡Œè®¢é˜…ã€‚è¯·æ³¨æ„ï¼ŒèŠå¤©ç”¨æˆ·ä¸éœ€è¦äº†è§£èŠå¤©å®¤çš„Grainæœ¬èº«(æˆ‘ä»¬çš„ç³»ç»Ÿä¸­å¯èƒ½æ²¡æœ‰è¿™ç§Grain)æˆ–è¯¥ç»„ä¸­äº§ç”Ÿæ¶ˆæ¯çš„å…¶ä»–ç”¨æˆ·ã€‚ä¸ç”¨è¯´ï¼Œè¦ç”ŸæˆèŠå¤©æµï¼Œç”¨æˆ·æ— éœ€çŸ¥é“å½“å‰è®¢é˜…äº†è°ã€‚è¿™è¯´æ˜äº†å¦‚ä½•å°†èŠå¤©ç”¨æˆ·åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šå®Œå…¨åˆ†ç¦»ã€‚ public class ChatUser: Grain { public async Task JoinChat(string chatGroupName) { IStreamProvider streamProvider = base.GetStreamProvider(\"myStreamProvider\"); IAsyncStream<string> chatStream = streamProvider.GetStream<string>(chatGroupName); await chatStream.SubscribeAsync((string chatEvent) => Console.Out.Write(chatEvent)); } } å¿«é€Ÿå…¥é—¨æ ·æœ¬ çš„ å¿«é€Ÿå…¥é—¨æ ·æœ¬ æ˜¯å¯¹åœ¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨æµçš„æ€»ä½“å·¥ä½œæµç¨‹çš„å¿«é€Ÿæ¦‚è¿°ã€‚é˜…è¯»åï¼Œæ‚¨åº”è¯¥é˜…è¯» æµç¼–ç¨‹API å¯¹æ¦‚å¿µæœ‰æ›´æ·±å…¥çš„äº†è§£ã€‚ æµç¼–ç¨‹API ä¸€ä¸ª æµç¼–ç¨‹API æä¾›äº†æœ‰å…³ç¼–ç¨‹APIçš„è¯¦ç»†è¯´æ˜ã€‚ æµæä¾›è€… æµå¯ä»¥é€šè¿‡å„ç§å½¢çŠ¶å’Œå½¢å¼çš„ç‰©ç†é€šé“å‡ºç°ï¼Œå¹¶ä¸”å¯ä»¥å…·æœ‰ä¸åŒçš„è¯­ä¹‰ã€‚Orleans Streamingæ—¨åœ¨é€šè¿‡ä»¥ä¸‹æ¦‚å¿µæ”¯æŒè¿™ç§å¤šæ ·æ€§ æµæä¾›è€… ï¼Œè¿™æ˜¯ç³»ç»Ÿä¸­çš„å¯æ‰©å±•ç‚¹ã€‚Orleansç›®å‰æœ‰ä¸¤ä¸ªæµæä¾›ç¨‹åºçš„å®ç°ï¼šåŸºäºTCP ç®€å•æ¶ˆæ¯æµæä¾›è€… å’ŒåŸºäºAzureé˜Ÿåˆ— Azureé˜Ÿåˆ—æµæä¾›ç¨‹åº ã€‚æœ‰å…³Steam Providersçš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·è®¿é—®ï¼š æµæä¾›è€… ã€‚ æµè¯­ä¹‰ æµè®¢é˜…è¯­ä¹‰ ï¼šOrleans Streamsä¿è¯Stream Subscriptionæ“ä½œçš„é¡ºåºä¸€è‡´æ€§ã€‚å…·ä½“æ¥è¯´ï¼Œå½“æ¶ˆè´¹è€…è®¢é˜…æµæ—¶ï¼Œä¸€æ—¦ Task å¦‚æœä»£è¡¨è®¢é˜…æ“ä½œå·²æˆåŠŸè§£å†³ï¼Œåˆ™ä½¿ç”¨è€…å°†çœ‹åˆ°è®¢é˜…åç”Ÿæˆçš„æ‰€æœ‰äº‹ä»¶ã€‚æ­¤å¤–ï¼Œå¯å€’å¸¦æµå…è®¸é€šè¿‡ä½¿ç”¨ä»¥ä¸‹å†…å®¹ä»è¿‡å»çš„ä»»æ„æ—¶é—´ç‚¹è¿›è¡Œè®¢é˜… StreamSequenceToken (å¯ä»¥æ‰¾åˆ°æ›´å¤šè¯¦ç»†ä¿¡æ¯ è¿™é‡Œ )ã€‚ ä¸ªäººæµäº‹ä»¶äº¤ä»˜ä¿è¯ ï¼šå•ä¸ªäº‹ä»¶ä¼ é€’çš„ä¿è¯å–å†³äºå•ä¸ªæµæä¾›è€…ã€‚ä¸€äº›æä¾›ä»…å°½æœ€å¤§å¯èƒ½çš„ä¸€æ¬¡ä¼ é€(ä¾‹å¦‚ç®€å•æ¶ˆæ¯æµ(SMS))ï¼Œè€Œå…¶ä»–ä¸€äº›æä¾›è‡³å°‘ä¸€æ¬¡çš„ä¼ é€(ä¾‹å¦‚Azureé˜Ÿåˆ—æµ)ã€‚ç”šè‡³å¯ä»¥æ„å»ºä¸€ä¸ªå°†ä¿è¯ä¸€æ¬¡äº¤ä»˜çš„æµæä¾›ç¨‹åº(æˆ‘ä»¬è¿˜æ²¡æœ‰è¿™æ ·çš„æä¾›ç¨‹åºï¼Œä½†æ˜¯å¯ä»¥æ„å»ºä¸€ä¸ª)ã€‚ æ´»åŠ¨äº¤ä»˜å• ï¼šäº‹ä»¶é¡ºåºè¿˜å–å†³äºç‰¹å®šçš„æµæä¾›ç¨‹åºã€‚åœ¨SMSæµä¸­ï¼Œç”Ÿäº§è€…é€šè¿‡æ§åˆ¶å…¶å‘å¸ƒæ–¹å¼æ¥æ˜¾å¼æ§åˆ¶æ¶ˆè´¹è€…çœ‹åˆ°çš„äº‹ä»¶çš„é¡ºåºã€‚Azureé˜Ÿåˆ—æµä¸ä¿è¯FIFOé¡ºåºï¼Œå› ä¸ºåŸºç¡€Azureé˜Ÿåˆ—åœ¨æ•…éšœæƒ…å†µä¸‹ä¸ä¿è¯é¡ºåºã€‚åº”ç”¨ç¨‹åºè¿˜å¯ä»¥é€šè¿‡ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ§åˆ¶è‡ªå·±çš„æµäº¤ä»˜é¡ºåº StreamSequenceToken ã€‚ æµå®æ–½ çš„ Orleansæµå®æ–½ æä¾›äº†å†…éƒ¨å®ç°çš„é«˜çº§æ¦‚è¿°ã€‚ ä»£ç æ ·æœ¬ å¯ä»¥æ‰¾åˆ°æœ‰å…³å¦‚ä½•åœ¨Grainsä¸­ä½¿ç”¨æµå¼APIçš„æ›´å¤šç¤ºä¾‹ã€‚ è¿™é‡Œ ã€‚æˆ‘ä»¬è®¡åˆ’åœ¨å°†æ¥åˆ›å»ºæ›´å¤šæ ·æœ¬ã€‚ æ›´å¤šææ–™ å…³äºæµçš„Orleansè™šæ‹Ÿèšä¼š è™šæ‹Ÿèšä¼šçš„Orleansæµåª’ä½“æ¼”ç¤º"
  },
  "Documentation/streaming/streams_why.html": {
    "href": "Documentation/streaming/streams_why.html",
    "title": "Why Orleans Streams? | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä¸ºä»€ä¹ˆæ˜¯OrleansStreamsï¼Ÿ å·²ç»æœ‰å¾ˆå¤šæŠ€æœ¯å¯ä»¥è®©ä½ æ„å»ºæµå¤„ç†ç³»ç»Ÿã€‚è¿™äº›ç³»ç»ŸåŒ…æ‹¬ æŒä¹…å­˜å‚¨æµæ•°æ® (ä¾‹å¦‚ã€‚ï¼Œ æ´»åŠ¨ä¸­å¿ƒ å’Œ å¡å¤«å¡ )ä»¥åŠè¦è¡¨è¾¾çš„ç³»ç»Ÿ è®¡ç®—æ“ä½œ è¿‡æµæ•°æ®(ä¾‹å¦‚ã€‚ï¼Œ Azureæµåˆ†æ , é˜¿å¸•å¥‡é£æš´ ï¼Œå’Œ Apache Sparkæµåª’ä½“ ). è¿™äº›éƒ½æ˜¯å¾ˆå¥½çš„ç³»ç»Ÿï¼Œå…è®¸æ‚¨æ„å»ºé«˜æ•ˆçš„æ•°æ®æµå¤„ç†ç®¡é“ã€‚ ç°æœ‰ç³»ç»Ÿçš„å±€é™æ€§ ä½†æ˜¯ï¼Œè¿™äº›ç³»ç»Ÿä¸é€‚åˆ ç»†Grainè‡ªç”±æ ¼å¼æµä¸Šè®¡ç®—æ•°æ® . ä¸Šé¢æåˆ°çš„æµè®¡ç®—ç³»ç»Ÿéƒ½å…è®¸æ‚¨æŒ‡å®š ä»¥ç›¸åŒæ–¹å¼åº”ç”¨äºæ‰€æœ‰æµé¡¹ç›®çš„æ“ä½œçš„ç»Ÿä¸€æ•°æ®æµå›¾ . å½“æ•°æ®æ˜¯ç»Ÿä¸€çš„ï¼Œå¹¶ä¸”æ‚¨å¸Œæœ›å¯¹è¿™äº›æ•°æ®è¡¨ç¤ºç›¸åŒçš„è½¬æ¢ã€è¿‡æ»¤æˆ–èšåˆæ“ä½œæ—¶ï¼Œè¿™æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„æ¨¡å‹ã€‚ä½†æ˜¯è¿˜æœ‰ä¸€äº›ç”¨ä¾‹éœ€è¦åœ¨ä¸åŒçš„æ•°æ®é¡¹ä¸Šè¡¨è¾¾æ ¹æœ¬ä¸åŒçš„æ“ä½œã€‚åœ¨å…¶ä¸­ä¸€äº›åº”ç”¨ç¨‹åºä¸­ï¼Œä½œä¸ºå¤„ç†çš„ä¸€éƒ¨åˆ†ï¼Œæ‚¨æœ‰æ—¶éœ€è¦è¿›è¡Œå¤–éƒ¨è°ƒç”¨ï¼Œä¾‹å¦‚è°ƒç”¨ä»»æ„restapiã€‚ç»Ÿä¸€æ•°æ®æµå¤„ç†å¼•æ“è¦ä¹ˆä¸æ”¯æŒè¿™äº›åœºæ™¯ï¼Œè¦ä¹ˆä»¥æœ‰é™å’Œå—é™çš„æ–¹å¼æ”¯æŒå®ƒä»¬ï¼Œè¦ä¹ˆæ•ˆç‡ä½ä¸‹ã€‚è¿™æ˜¯å› ä¸ºå®ƒä»¬å¤©ç”Ÿå°±é’ˆå¯¹ å¤§é‡ç±»ä¼¼çš„ç‰©å“ï¼Œé€šå¸¸åœ¨è¡¨ç°åŠ›ã€åŠ å·¥æ–¹é¢å—åˆ°é™åˆ¶ . OrleansStreamsé’ˆå¯¹çš„æ˜¯å…¶ä»–åœºæ™¯ã€‚ åŠ¨æœº è¿™ä¸€åˆ‡éƒ½æ˜¯ä»Orleansç”¨æˆ·è¯·æ±‚æ”¯æŒä»grainæ–¹æ³•è°ƒç”¨è¿”å›é¡¹ç›®åºåˆ—å¼€å§‹çš„ã€‚ä½ å¯ä»¥æƒ³è±¡ï¼Œè¿™åªæ˜¯å†°å±±ä¸€è§’ã€‚ä»–ä»¬å®é™…ä¸Šéœ€è¦çš„è¿œä¸æ­¢è¿™äº›ã€‚ Orleans Streamsçš„ä¸€ä¸ªå…¸å‹åœºæ™¯æ˜¯å½“æ‚¨æœ‰æ¯ä¸ªç”¨æˆ·çš„æµå¹¶ä¸”æ‚¨å¸Œæœ›æ‰§è¡Œ æ¯ä¸ªç”¨æˆ·çš„ä¸åŒå¤„ç† ï¼Œåœ¨å•ä¸ªç”¨æˆ·çš„ä¸Šä¸‹æ–‡ä¸­ã€‚æˆ‘ä»¬å¯èƒ½æœ‰æ•°ç™¾ä¸‡ç”¨æˆ·ï¼Œä½†ä»–ä»¬ä¸­çš„ä¸€äº›äººå¯¹å¤©æ°”æ„Ÿå…´è¶£ï¼Œå¯ä»¥è®¢é˜…ç‰¹å®šåœ°ç‚¹çš„å¤©æ°”é¢„æŠ¥ï¼Œè€Œæœ‰äº›äººåˆ™å¯¹ä½“è‚²èµ›äº‹æ„Ÿå…´è¶£ï¼›è¿˜æœ‰äººåœ¨è·Ÿè¸ªæŸä¸€èˆªç­çš„çŠ¶æ€ã€‚å¤„ç†è¿™äº›äº‹ä»¶éœ€è¦ä¸åŒçš„é€»è¾‘ï¼Œä½†æ‚¨ä¸å¸Œæœ›è¿è¡Œæµå¤„ç†çš„ä¸¤ä¸ªç‹¬ç«‹å®ä¾‹ã€‚ä¸€äº›ç”¨æˆ·åªå¯¹ç‰¹å®šçš„è‚¡ç¥¨æ„Ÿå…´è¶£ï¼Œè€Œä¸”åªæœ‰åœ¨åº”ç”¨æŸä¸ªå¤–éƒ¨æ¡ä»¶æ—¶æ‰æ„Ÿå…´è¶£ï¼Œè¿™ç§æƒ…å†µå¯èƒ½ä¸ä¸€å®šæ˜¯æµæ•°æ®çš„ä¸€éƒ¨åˆ†(å› æ­¤éœ€è¦åœ¨è¿è¡Œæ—¶ä½œä¸ºå¤„ç†çš„ä¸€éƒ¨åˆ†è¿›è¡ŒåŠ¨æ€æ£€æŸ¥)ã€‚ ç”¨æˆ·ä¸€ç›´åœ¨æ”¹å˜ä»–ä»¬çš„å…´è¶£ï¼Œå› æ­¤ä»–ä»¬å¯¹ç‰¹å®šäº‹ä»¶æµçš„è®¢é˜…æ˜¯åŠ¨æ€çš„ï¼Œå› æ­¤ æµåª’ä½“çš„æ‹“æ‰‘ç»“æ„åŠ¨æ€è€Œå¿«é€Ÿåœ°å˜åŒ– . é™¤æ­¤ä¹‹å¤–ï¼Œ æ¯ä¸ªç”¨æˆ·çš„å¤„ç†é€»è¾‘ä¹Ÿä¼šæ ¹æ®ç”¨æˆ·çŠ¶æ€å’Œå¤–éƒ¨äº‹ä»¶åŠ¨æ€åœ°æ¼”åŒ–å’Œæ›´æ”¹ . å¤–éƒ¨äº‹ä»¶å¯ä»¥ä¿®æ”¹ç‰¹å®šç”¨æˆ·çš„å¤„ç†é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªæ¸¸æˆä½œå¼Šæ£€æµ‹ç³»ç»Ÿä¸­ï¼Œå½“å‘ç°ä¸€ç§æ–°çš„ä½œå¼Šæ–¹å¼æ—¶ï¼Œéœ€è¦ç”¨æ–°è§„åˆ™æ›´æ–°å¤„ç†é€»è¾‘æ¥æ£€æµ‹è¿™ç§æ–°çš„è¿è§„è¡Œä¸ºã€‚è¿™å½“ç„¶éœ€è¦åš ä¸ä¼šä¸­æ–­æ­£åœ¨è¿›è¡Œçš„å¤„ç†ç®¡é“ . æ‰¹é‡æ•°æ®æµå¤„ç†å¼•æ“å¹¶ä¸æ˜¯ä¸ºäº†æ”¯æŒè¿™æ ·çš„åœºæ™¯è€Œæ„å»ºçš„ã€‚ å‡ ä¹ä¸ç”¨è¯´ï¼Œè¿™æ ·çš„ç³»ç»Ÿå¿…é¡»è¿è¡Œåœ¨å¤šå°ç½‘ç»œè¿æ¥çš„æœºå™¨ä¸Šï¼Œè€Œä¸æ˜¯åœ¨ä¸€ä¸ªèŠ‚ç‚¹ä¸Šã€‚å› æ­¤ï¼Œå¤„ç†é€»è¾‘å¿…é¡»ä»¥å¯ä¼¸ç¼©å’Œå¼¹æ€§çš„æ–¹å¼åˆ†å¸ƒåœ¨æœåŠ¡å™¨é›†ç¾¤ä¸Šã€‚ æ–°è¦æ±‚ æˆ‘ä»¬ç¡®å®šäº†æµå¤„ç†ç³»ç»Ÿçš„4ä¸ªåŸºæœ¬éœ€æ±‚ï¼Œè¿™å°†ä½¿å®ƒèƒ½å¤Ÿé’ˆå¯¹ä¸Šè¿°åœºæ™¯ã€‚ çµæ´»çš„æµå¤„ç†é€»è¾‘ æ”¯æŒé«˜åº¦åŠ¨æ€çš„æ‹“æ‰‘ ç»†GrainæµGrain åˆ†é… çµæ´»çš„æµå¤„ç†é€»è¾‘ æˆ‘ä»¬å¸Œæœ›ç³»ç»Ÿæ”¯æŒä¸åŒçš„æ–¹å¼æ¥è¡¨è¾¾æµå¤„ç†é€»è¾‘ã€‚æˆ‘ä»¬ä¸Šé¢æåˆ°çš„ç°æœ‰ç³»ç»Ÿè¦æ±‚å¼€å‘äººå‘˜ç¼–å†™ä¸€ä¸ªå£°æ˜æ€§çš„æ•°æ®æµè®¡ç®—å›¾ï¼Œé€šå¸¸æ˜¯éµå¾ªå‡½æ•°å¼ç¼–ç¨‹é£æ ¼ã€‚è¿™é™åˆ¶äº†å¤„ç†é€»è¾‘çš„è¡¨è¾¾èƒ½åŠ›å’Œçµæ´»æ€§ã€‚Orleansæµä¸å¤„ç†é€»è¾‘çš„è¡¨è¾¾æ–¹å¼æ— å…³ã€‚å®ƒå¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªæ•°æ®æµ(ä¾‹å¦‚ï¼Œä½¿ç”¨ NETä¸­çš„æ— åŠŸæ‰©å±•(Rx) )ï¼›ä½œä¸ºä¸€ä¸ªå‡½æ•°ç¨‹åºï¼›ä½œä¸ºä¸€ä¸ªå£°æ˜æ€§æŸ¥è¯¢ï¼›æˆ–è€…åœ¨ä¸€èˆ¬çš„å‘½ä»¤é€»è¾‘ä¸­ã€‚é€»è¾‘å¯ä»¥æ˜¯æœ‰çŠ¶æ€çš„æˆ–æ— çŠ¶æ€çš„ï¼Œå¯èƒ½æœ‰å‰¯ä½œç”¨ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰å‰¯ä½œç”¨ï¼Œå¹¶ä¸”å¯ä»¥è§¦å‘å¤–éƒ¨æ“ä½œã€‚æ‰€æœ‰çš„æƒåŠ›éƒ½å±äºå¼€å‘è€…ã€‚ æ”¯æŒåŠ¨æ€æ‹“æ‰‘ æˆ‘ä»¬å¸Œæœ›ç³»ç»Ÿèƒ½å¤Ÿæ”¯æŒåŠ¨æ€æ¼”åŒ–çš„æ‹“æ‰‘ç»“æ„ã€‚æˆ‘ä»¬ä¸Šé¢æåˆ°çš„ç°æœ‰ç³»ç»Ÿé€šå¸¸ä»…é™äºé™æ€æ‹“æ‰‘ï¼Œè¿™äº›æ‹“æ‰‘åœ¨éƒ¨ç½²æ—¶æ˜¯å›ºå®šçš„ï¼Œå¹¶ä¸”ä¸èƒ½åœ¨è¿è¡Œæ—¶æ¼”åŒ–ã€‚åœ¨ä¸‹é¢çš„æ•°æ®æµè¡¨è¾¾å¼ç¤ºä¾‹ä¸­ï¼Œåœ¨éœ€è¦æ›´æ”¹ä¹‹å‰ï¼Œä¸€åˆ‡éƒ½å¾ˆç®€å•ã€‚ æµ.GroupBy(x=>x.key)ã€‚æå–(x=>x.field)ã€‚é€‰æ‹©(x=>x+2)ã€‚å¹³å‡çª—å£(xï¼Œ5ç§’)ã€‚å…¶ä¸­(x=>x>0.8)* åœ¨ä¸­æ›´æ”¹é˜ˆå€¼æ¡ä»¶ åœ¨å“ªé‡Œï¼Ÿ è¿‡æ»¤å™¨ï¼Œæ·»åŠ é¢å¤–çš„ é€‰æ‹© è¯­å¥æˆ–åœ¨æ•°æ®æµå›¾ä¸­æ·»åŠ å¦ä¸€ä¸ªåˆ†æ”¯å¹¶ç”Ÿæˆæ–°çš„è¾“å‡ºæµã€‚åœ¨ç°æœ‰ç³»ç»Ÿä¸­ï¼Œå¦‚æœä¸æ‹†é™¤æ•´ä¸ªæ‹“æ‰‘ç»“æ„å¹¶ä»å¤´å¼€å§‹é‡æ–°å¯åŠ¨æ•°æ®æµï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ã€‚å®é™…ä¸Šï¼Œè¿™äº›ç³»ç»Ÿå°†æ£€æŸ¥ç°æœ‰çš„è®¡ç®—ï¼Œå¹¶å°†èƒ½å¤Ÿä»æœ€æ–°çš„æ£€æŸ¥ç‚¹é‡æ–°å¯åŠ¨ã€‚å°½ç®¡å¦‚æ­¤ï¼Œè¿™æ ·çš„é‡æ–°å¯åŠ¨å¯¹äºä¸€ä¸ªå®æ—¶äº§ç”Ÿç»“æœçš„åœ¨çº¿æœåŠ¡æ¥è¯´æ˜¯ç ´åæ€§çš„å’Œæ˜‚è´µçš„ã€‚å½“æˆ‘ä»¬åœ¨è®¨è®ºå¤§é‡è¿™æ ·çš„è¡¨è¾¾å¼æ—¶ï¼Œè¿™ç§é‡æ–°å¯åŠ¨å˜å¾—ç‰¹åˆ«ä¸åˆ‡å®é™…ï¼Œè¿™äº›è¡¨è¾¾å¼ä½¿ç”¨ç›¸ä¼¼ä½†ä¸åŒçš„(æ¯ä¸ªç”¨æˆ·ã€æ¯ä¸ªè®¾å¤‡ç­‰)å‚æ•°æ‰§è¡Œï¼Œå¹¶ä¸”è¿™äº›å‚æ•°ä¸æ–­å˜åŒ–ã€‚ æˆ‘ä»¬å¸Œæœ›ç³»ç»Ÿå…è®¸åœ¨è¿è¡Œæ—¶é€šè¿‡å‘è®¡ç®—å›¾ä¸­æ·»åŠ æ–°çš„é“¾æ¥æˆ–èŠ‚ç‚¹ï¼Œæˆ–é€šè¿‡æ›´æ”¹è®¡ç®—èŠ‚ç‚¹å†…çš„å¤„ç†é€»è¾‘æ¥è¿›åŒ–æµå¤„ç†å›¾ã€‚ ç»†GrainæµGrain åœ¨ç°æœ‰ç³»ç»Ÿä¸­ï¼Œæœ€å°çš„æŠ½è±¡å•å…ƒé€šå¸¸æ˜¯æ•´ä¸ªæµ(æ‹“æ‰‘)ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çš„è®¸å¤šç›®æ ‡åœºæ™¯è¦æ±‚æ‹“æ‰‘ä¸­çš„å•ä¸ªèŠ‚ç‚¹/é“¾è·¯æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€»è¾‘å®ä½“ã€‚è¿™æ ·æ¯ä¸ªå®ä½“éƒ½å¯ä»¥ç‹¬ç«‹ç®¡ç†ã€‚ä¾‹å¦‚ï¼Œåœ¨åŒ…å«å¤šä¸ªé“¾è·¯çš„å¤§æµæ‹“æ‰‘ä¸­ï¼Œä¸åŒçš„é“¾è·¯å¯ä»¥å…·æœ‰ä¸åŒçš„ç‰¹æ€§ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ä¸åŒçš„ç‰©ç†ä¼ è¾“ä¸Šå®ç°ã€‚ä¸€äº›é“¾æ¥å¯ä»¥é€šè¿‡TCPå¥—æ¥å­—ï¼Œè€Œå…¶ä»–é“¾æ¥å¯ä»¥é€šè¿‡å¯é é˜Ÿåˆ—ã€‚ä¸åŒçš„é“¾æ¥å¯ä»¥æœ‰ä¸åŒçš„äº¤ä»˜ä¿è¯ã€‚ä¸åŒçš„èŠ‚ç‚¹å¯ä»¥æœ‰ä¸åŒçš„æ£€æŸ¥ç‚¹ç­–ç•¥ï¼Œå®ƒä»¬çš„å¤„ç†é€»è¾‘å¯ä»¥ç”¨ä¸åŒçš„æ¨¡å‹ç”šè‡³ä¸åŒçš„è¯­è¨€æ¥è¡¨è¾¾ã€‚è¿™ç§çµæ´»æ€§åœ¨ç°æœ‰ç³»ç»Ÿä¸­é€šå¸¸æ˜¯ä¸å¯èƒ½çš„ã€‚ æŠ½è±¡å•å…ƒå’Œçµæ´»æ€§çš„è®ºæ®ç±»ä¼¼äºSoA(é¢å‘æœåŠ¡çš„ä½“ç³»ç»“æ„)ä¸å‚ä¸è€…çš„æ¯”è¾ƒã€‚Actorç³»ç»Ÿå…è®¸æ›´å¤§çš„çµæ´»æ€§ï¼Œå› ä¸ºæ¯ä¸ªActoræœ¬è´¨ä¸Šéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹ç®¡ç†çš„â€œå¾®å‹æœåŠ¡â€ã€‚ç±»ä¼¼åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›æµç³»ç»Ÿå…è®¸è¿™ç§ç»†Grainçš„æ§åˆ¶ã€‚ åˆ†é… å½“ç„¶ï¼Œæˆ‘ä»¬çš„ç³»ç»Ÿåº”è¯¥å…·æœ‰ â€œè‰¯å¥½çš„åˆ†å¸ƒå¼ç³»ç»Ÿâ€ . å…¶ä¸­åŒ…æ‹¬ï¼š å¯æ‰©å±•æ€§ -æ”¯æŒå¤§é‡æµå’Œè®¡ç®—å…ƒç´ ã€‚ å¼¹æ€§ -å…è®¸æ·»åŠ /åˆ é™¤èµ„æºä»¥æ ¹æ®è´Ÿè½½å¢é•¿/æ”¶ç¼©ã€‚ å¯é æ€§ -å¯¹å¤±è´¥æœ‰å¼¹æ€§ æ•ˆç‡ -æœ‰æ•ˆåˆ©ç”¨åº•å±‚èµ„æº å“åº”æ€§ -å¯ç”¨è¿‘å®æ—¶åœºæ™¯ã€‚ è¿™äº›éƒ½æ˜¯æˆ‘ä»¬åœ¨è€ƒè™‘å»ºé€ çš„è¦æ±‚ Orleansæµåª’ä½“ . æ¾„æ¸… ï¼šOrleanså½“å‰ä¸æ”¯æŒåƒä¸Šé¢çš„ç¤ºä¾‹é‚£æ ·ç›´æ¥ç¼–å†™å£°æ˜æ€§æ•°æ®æµè¡¨è¾¾å¼ã€‚å¦‚å‰æ‰€è¿°ï¼Œå½“å‰çš„Orleansæµåª’ä½“apiæ˜¯æ›´ä½çº§çš„æ„å»ºå— åœ¨è¿™é‡Œ . æä¾›å£°æ˜æ€§çš„æ•°æ®æµè¡¨è¾¾å¼æ˜¯æˆ‘ä»¬æœªæ¥çš„ç›®æ ‡ã€‚ ä¸‹ä¸€ä¸ª Orleansæµç¼–ç¨‹API"
  },
  "Documentation/resources/Migration/MigrationAzure2.0.html": {
    "href": "Documentation/resources/Migration/MigrationAzure2.0.html",
    "title": "Migration from Orleans 1.5 to 2.0 when using Azure | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä½¿ç”¨Azureä»Orleans 1.5è¿ç§»åˆ°2.0 åœ¨Orleans2.0ä¸­ï¼Œsiloså’Œå®¢æˆ·ç«¯çš„é…ç½®å·²æ›´æ”¹ã€‚åœ¨Orleans1.5ä¸­ï¼Œæˆ‘ä»¬æ›¾ç»æœ‰ä¸€ä¸ªç”¨äºå¤„ç†æ‰€æœ‰é…ç½®é¡¹çš„æ•´ä½“å¯¹è±¡ï¼Œè€Œä¸”æä¾›ç¨‹åºä¹Ÿå·²æ·»åŠ åˆ°è¯¥é…ç½®å¯¹è±¡ä¸­ã€‚åœ¨Orleans2.0ä¸­ï¼Œé…ç½®è¿‡ç¨‹å›´ç»• SiloHostBuilder ï¼Œç±»ä¼¼äºåœ¨ASP.NET Coreä¸­ä½¿ç”¨ WebHostBuilder ã€‚ åœ¨Orleans1.5ä¸­ï¼ŒAzureçš„é…ç½®å¦‚ä¸‹æ‰€ç¤ºï¼š var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); çš„ AzureSilo ç±»å…¬å¼€äº†ä¸€ä¸ªåä¸ºDefaultConfiguration()çš„é™æ€æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ç”¨äºåŠ è½½é…ç½®XMLæ–‡ä»¶ã€‚ä¸å»ºè®®ä½¿ç”¨è¿™ç§é…ç½®silosçš„æ–¹å¼ï¼Œä½†ä»é€šè¿‡ æ—§ç‰ˆæ”¯æŒåŒ… ã€‚ åœ¨Orleans2.0ä¸­ï¼Œé…ç½®å®Œå…¨æ˜¯ç¼–ç¨‹çš„ã€‚æ–°çš„é…ç½®APIå¦‚ä¸‹æ‰€ç¤ºï¼š //Load the different settings from the services configuration var proxyPort = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints[\"OrleansProxyEndpoint\"].IPEndpoint.Port; var siloEndpoint = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints[\"OrleansSiloEndpoint\"].IPEndpoint; var connectionString = RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\"); var deploymentId = RoleEnvironment.DeploymentId; var builder = new SiloHostBuilder() //Set service ID and cluster ID .Configure<ClusterOptions>(options => { options.ClusterId = deploymentId; options.ServiceIs = \"my-app\"; }) // Set silo name .Configure<SiloOptions>(options => options.SiloName = this.Name) //Then, we can configure the different endpoints .ConfigureEndpoints(siloEndpoint.Address, siloEndpoint.Port, proxyPort) //Then, we set the connection string for the storage .UseAzureStorageClustering(options => options.ConnectionString = connectionString) //If reminders are needed, add the service, the connection string is required .UseAzureTableReminderService(connectionString) //If Queues are needed, add the service, set the name and the Adapter, the one shown here //is the one provided with Orleans, but it can be a custom one .AddAzureQueueStreams<AzureQueueDataAdapterV2>(\"StreamProvider\", configurator => configurator.Configure(configure => { configure.ConnectionString = connectionString; })) //If Grain Storage is needed, add the service and set the name .AddAzureTableGrainStorage(\"AzureTableStore\"); AzureSiloåˆ°ISiloHost åœ¨Orleans1.5ï¼Œ AzureSilo ç±»æ˜¯åœ¨Azure Workerè§’è‰²ä¸­æ‰˜ç®¡silosçš„æ¨èæ–¹æ³•ã€‚ä»ç„¶å¯ä»¥é€šè¿‡ Microsoft.Orleans.Hosting.AzureCloudServices NuGetåŒ… ã€‚ public class WorkerRole : RoleEntryPoint { AzureSilo silo; public override bool OnStart() { // Do other silo initialization â€“ for example: Azure diagnostics, etc return base.OnStart(); } public override void OnStop() { silo.Stop(); base.OnStop(); } public override void Run() { var config = AzureSilo.DefaultConfiguration(); config.AddMemoryStorageProvider(); config.AddAzureTableStorageProvider(\"AzureStore\", RoleEnvironment.GetConfigurationSettingValue(\"DataConnectionString\")); // Configure storage providers silo = new AzureSilo(); bool ok = silo.Start(config); silo.Run(); // Call will block until silo is shutdown } } Orleans2.0æä¾›äº†æ›´çµæ´»çš„æ¨¡å—åŒ–APIï¼Œç”¨äºé€šè¿‡ä»¥ä¸‹æ–¹å¼é…ç½®å’Œæ‰˜ç®¡silos SiloHostBuilder å’Œ ISiloHost ã€‚ public class WorkerRole : RoleEntryPoint { private ISiloHost host; private ISiloHostBuilder builder; private readonly CancellationTokenSource cancellationTokenSource = new CancellationTokenSource(); private readonly ManualResetEvent runCompleteEvent = new ManualResetEvent(false); public override void Run() { try { this.RunAsync(this.cancellationTokenSource.Token).Wait(); runCompleteEvent.WaitOne(); } finally { this.runCompleteEvent.Set(); } } public override bool OnStart() { //builder is the SiloHostBuilder from the first section // Build silo host, so that any errors will restart the role instance this.host = this.builder.Build(); return base.OnStart(); } public override void OnStop() { this.cancellationTokenSource.Cancel(); this.runCompleteEvent.WaitOne(); this.host.StopAsync().Wait(); base.OnStop(); } private Task RunAsync(CancellationToken cancellationToken) { return this.host.StartAsync(cancellationToken); } }"
  },
  "Documentation/resources/Migration/Codegen.html": {
    "href": "Documentation/resources/Migration/Codegen.html",
    "title": "Code Generation in Orleans 2.0 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleans2.0ä¸­çš„ä»£ç ç”Ÿæˆ åœ¨Orleans 2.0ä¸­ï¼Œä»£ç ç”Ÿæˆå¾—åˆ°äº†æ”¹è¿›ï¼Œä»è€Œç¼©çŸ­äº†å¯åŠ¨æ—¶é—´å¹¶æä¾›äº†æ›´å…·ç¡®å®šæ€§å’Œå¯è°ƒè¯•æ€§çš„ä½“éªŒã€‚ä¸æ—©æœŸç‰ˆæœ¬ä¸€æ ·ï¼ŒOrleansæä¾›ç”Ÿæˆæ—¶å’Œè¿è¡Œæ—¶ä»£ç ç”Ÿæˆã€‚ åœ¨æ„å»ºæœŸé—´ -è¿™æ˜¯æ¨èçš„é€‰é¡¹ï¼Œä»…æ”¯æŒCï¼ƒé¡¹ç›®ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œä»£ç ç”Ÿæˆå°†åœ¨æ¯æ¬¡ç¼–è¯‘é¡¹ç›®æ—¶è¿è¡Œã€‚å°†ä¸€ä¸ªæ„å»ºä»»åŠ¡æ³¨å…¥åˆ°é¡¹ç›®çš„æ„å»ºç®¡é“ä¸­ï¼Œå¹¶åœ¨é¡¹ç›®çš„ä¸­é—´è¾“å‡ºç›®å½•ä¸­ç”Ÿæˆä»£ç ã€‚è¦æ¿€æ´»æ­¤æ¨¡å¼ï¼Œè¯·æ·»åŠ å…¶ä¸­ä¸€ä¸ªè½¯ä»¶åŒ… Microsoft.Orleans.CodeGenerator.MSBuild è¦ä¹ˆ Microsoft.Orleans.OrleansCodeGenerator.Build æ‰€æœ‰åŒ…å«Grainsï¼ŒGrainæ¥å£ï¼Œåºåˆ—åŒ–å™¨æˆ–éœ€è¦åºåˆ—åŒ–å™¨çš„ç±»å‹çš„é¡¹ç›®ã€‚åŒ…å’Œå…¶ä»–ä»£ç ç”Ÿæˆä¿¡æ¯ä¹‹é—´çš„å·®å¼‚å¯ä»¥åœ¨ç›¸åº”çš„æ–‡ä»¶ä¸­æ‰¾åˆ° ä»£ç ç”Ÿæˆ éƒ¨åˆ†ã€‚é€šè¿‡æŒ‡å®šä»¥ä¸‹å€¼å¯ä»¥åœ¨æ„å»ºæ—¶å‘å‡ºå…¶ä»–è¯Šæ–­ï¼š OrleansCodeGenLogLevel åœ¨ç›®æ ‡é¡¹ç›®çš„ csproj æ–‡ä»¶ã€‚ä¾‹å¦‚ï¼Œ <OrleansCodeGenLogLevel>è·Ÿè¸ª</ OrleansCodeGenLogLevel> ã€‚ é…ç½®æœŸé—´ -è¿™æ˜¯Fï¼ƒï¼ŒVisual Basicå’Œå…¶ä»–éCï¼ƒé¡¹ç›®å”¯ä¸€å—æ”¯æŒçš„é€‰é¡¹ã€‚æ­¤æ¨¡å¼åœ¨é…ç½®é˜¶æ®µç”Ÿæˆä»£ç ã€‚è¦è®¿é—®å®ƒï¼Œè¯·å‚é˜…é…ç½®æ–‡æ¡£ã€‚ ä¸¤ç§æ¨¡å¼éƒ½ç”Ÿæˆç›¸åŒçš„ä»£ç ï¼Œä½†æ˜¯è¿è¡Œæ—¶ä»£ç ç”Ÿæˆåªèƒ½ä¸ºå…¬å…±å¯è®¿é—®ç±»å‹ç”Ÿæˆä»£ç ã€‚"
  },
  "Documentation/resources/Migration/Migration1.5.html": {
    "href": "Documentation/resources/Migration/Migration1.5.html",
    "title": "Migration from Orleans 1.5 to 2.0 | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä»Orleansè¿ç§»åˆ°0.5 Orleansçš„å¤§éƒ¨åˆ†APIåœ¨2.0ä¸­ä¿æŒä¸å˜ï¼Œæˆ–è€…è¿™äº›APIçš„å®ç°ç•™åœ¨é—ç•™ç±»ä¸­ä»¥å®ç°å‘åå…¼å®¹æ€§ã€‚åŒæ—¶ï¼Œæ–°å¼•å…¥çš„apiæä¾›äº†ä¸€äº›æ–°çš„åŠŸèƒ½æˆ–æ›´å¥½çš„æ–¹æ³•æ¥å®Œæˆè¿™äº›ä»»åŠ¡ã€‚å½“æ¶‰åŠåˆ°.NETSDKå·¥å…·å’ŒVisualStudioæ”¯æŒæ—¶ï¼Œè¿˜æœ‰æ›´ç»†å¾®çš„åŒºåˆ«ï¼Œè¿™æœ‰åŠ©äºæˆ‘ä»¬æ„è¯†åˆ°è¿™ä¸€ç‚¹ã€‚æœ¬æ–‡æ¡£ä¸ºå°†åº”ç”¨ç¨‹åºä»£ç ä»è¿ç§»åˆ°Orleans 2.0æä¾›äº†æŒ‡å¯¼ã€‚ Visual Studioå’Œå·¥å…·è¦æ±‚ Orleans2.0.0å»ºç«‹åœ¨.NETæ ‡å‡†2.0ä¹‹ä¸Šã€‚å› æ­¤ï¼Œæ‚¨éœ€è¦å‡çº§å¼€å‘å·¥å…·ï¼Œä»¥ç¡®ä¿æ‚¨è·å¾—æ„‰å¿«çš„å¼€å‘ä½“éªŒã€‚æˆ‘ä»¬å»ºè®®ä½¿ç”¨Visual Studio 2017æˆ–æ›´é«˜ç‰ˆæœ¬æ¥å¼€å‘Orleans 2.0.0åº”ç”¨ç¨‹åºã€‚æ ¹æ®æˆ‘ä»¬çš„ç»éªŒï¼Œ15.5.2åŠæ›´é«˜ç‰ˆæœ¬çš„æ•ˆæœæœ€å¥½ã€‚NET Standard 2.0.0ä¸.NET 4.6.1åŠæ›´é«˜ç‰ˆæœ¬ã€.NET Core 2.0å’Œå…¶ä»–æ¡†æ¶åˆ—è¡¨å…¼å®¹ã€‚Orleans2.0.0ç»§æ‰¿äº†è¿™ç§å…¼å®¹æ€§ã€‚æœ‰å…³ä¸å…¶ä»–.NETæ ‡å‡†çš„å…¼å®¹æ€§ä¿¡æ¯ï¼Œè¯·å‚é˜….NET .NETæ ‡å‡†æ–‡æ¡£ ï¼šå¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨Orleanså¼€å‘.NET Coreæˆ–.NETåº”ç”¨ç¨‹åºï¼Œåˆ™éœ€è¦æŒ‰ç…§æŸäº›æ­¥éª¤æ¥è®¾ç½®ç¯å¢ƒï¼Œä¾‹å¦‚å®‰è£….NET Core SDKã€‚æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒ æ–‡æ¡£ . é…ç½®ä»£ç çš„å¯ç”¨é€‰é¡¹ ç¾¤ä¼—æˆ–éƒ¨é˜Ÿçš„é›†åˆ é…ç½®å’Œå¯åŠ¨silos(ä½¿ç”¨æ–°çš„SiloBuilder APIå’Œæ—§çš„ClusterConfigurationå¯¹è±¡) Orleans 2.0ä¸­æœ‰è®¸å¤šæ–°çš„é€‰é¡¹ç±»ï¼Œå®ƒä»¬ä¸ºé…ç½®silosæä¾›äº†ä¸€ç§æ–°çš„æ–¹æ³•ã€‚ä¸ºäº†ä¾¿äºè¿ç§»åˆ°æ–°çš„APIï¼Œæœ‰ä¸€ä¸ªå¯é€‰çš„å‘åå…¼å®¹åŒ…ï¼Œ Microsoft.Orleans.Runtime.é—äº§ ï¼Œå®ƒæä¾›äº†ä»æ—§çš„1.xé…ç½®APIåˆ°æ–°çš„é…ç½®APIçš„æ¡¥ã€‚ å¦‚æœä½ åŠ ä¸Š Microsoft.Orleans.Runtime.é—äº§ åŒ…ï¼Œsilosä»ç„¶å¯ä»¥é€šè¿‡ä¼ ç»Ÿçš„ ç¾¤é›†é…ç½® å¯¹è±¡ï¼Œç„¶åå¯ä»¥ä¼ é€’ç»™ SiloHostBuilder å»ºé€ å’Œå¯åŠ¨silosã€‚ æ‚¨ä»ç„¶éœ€è¦é€šè¿‡ é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ è°ƒç”¨ã€‚ ä»¥ä¸‹æ˜¯å¦‚ä½•ä»¥ä¼ ç»Ÿæ–¹å¼é…ç½®æœ¬åœ°silosçš„ç¤ºä¾‹ï¼š public class Program { public static async Task Main(string[] args) { try { var host = await StartSilo(); Console.WriteLine(\"Press Enter to terminate...\"); Console.ReadLine(); await host.StopAsync(); return 0; } catch (Exception ex) { Console.WriteLine(ex); return 1; } } private static async Task<ISiloHost> StartSilo() { // define the cluster configuration (temporarily required in the beta version, // will not be required by the final release) var config = ClusterConfiguration.LocalhostPrimarySilo(); // add providers to the legacy configuration object. config.AddMemoryStorageProvider(); var builder = new SiloHostBuilder() .UseConfiguration(config) // Add assemblies to scan for grains and serializers. // For more info read the Application Parts section .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(HelloGrain).Assembly) .WithReferences()) // Configure logging with any logging framework that supports Microsoft.Extensions.Logging. // In this particular case it logs using the Microsoft.Extensions.Logging.Console package. .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; } } é…ç½®å’Œè¿æ¥å®¢æˆ·ç«¯(ä½¿ç”¨æ–°çš„ClientBuilder APIå’Œæ—§çš„ClientConfigurationå¯¹è±¡) orleans2.0ä¸­æœ‰è®¸å¤šæ–°çš„é€‰é¡¹ç±»ï¼Œå®ƒä»¬ä¸ºé…ç½®å®¢æˆ·ç«¯æä¾›äº†ä¸€ç§æ–°çš„æ–¹æ³•ã€‚ä¸ºäº†ä¾¿äºè¿ç§»åˆ°æ–°çš„APIï¼Œæœ‰ä¸€ä¸ªå¯é€‰çš„å‘åå…¼å®¹åŒ…ï¼Œ Microsoft.Orleans.Core.é—äº§ ï¼Œå®ƒæä¾›äº†ä»æ—§çš„1.xé…ç½®APIåˆ°æ–°çš„é…ç½®APIçš„æ¡¥ã€‚ å¦‚æœä½ æ·»åŠ äº† Microsoft.Orleans.Core.é—äº§ åŒ…ï¼Œå®¢æˆ·ç«¯ä»ç„¶å¯ä»¥é€šè¿‡æ—§ç‰ˆæœ¬ä»¥ç¼–ç¨‹æ–¹å¼é…ç½® å®¢æˆ·ç«¯é…ç½® å¯¹è±¡ï¼Œç„¶åå¯ä»¥ä¼ é€’ç»™ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ æ¥æ„å»ºå’Œè¿æ¥å®¢æˆ·ç«¯ã€‚ æ‚¨ä»ç„¶éœ€è¦é€šè¿‡ é…ç½®åº”ç”¨ç¨‹åºéƒ¨ä»¶ è°ƒç”¨ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œè¯´æ˜å®¢æˆ·ç«¯å¦‚ä½•ä½¿ç”¨ä¼ ç»Ÿé…ç½®è¿æ¥åˆ°æœ¬åœ°silosï¼š // define the client configuration (temporarily required in the beta version, // will not be required by the final release) var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder() .UseConfiguration(config) // Add assemblies to scan for grains interfaces and serializers. // For more info read the Application Parts section .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IHello).Assembly)) .ConfigureLogging(logging => logging.AddConsole()) var client = builder.Build(); await client.Connect(); ç™»å½•ä¸­ Orleans 2.0ä½¿ç”¨ä¸ASP.NETæ ¸å¿ƒ2.0ã€‚æ‚¨å¯ä»¥åœ¨ä¸­æ‰¾åˆ°å¤§å¤šæ•°Orleansæ—¥å¿—è®°å½•åŠŸèƒ½çš„æ›¿ä»£å“ASP.NETå²©èŠ¯æµ‹äº•ã€‚Orleansç‰¹å®šçš„æ—¥å¿—è®°å½•åŠŸèƒ½ï¼Œä¾‹å¦‚ ILogConsumer å’Œæ¶ˆæ¯è†¨èƒ€ï¼Œä»ç„¶ä¿æŒåœ¨ Microsoft.Orleans.Logging.é—äº§ åŒ…ï¼Œè¿™æ ·ä½ ä»ç„¶å¯ä»¥é€‰æ‹©ä½¿ç”¨å®ƒä»¬ã€‚ä½†æ˜¯å¦‚ä½•åœ¨2.0ä¸­ä½¿ç”¨Orleansé…ç½®æ—¥å¿—è®°å½•å‘ç”Ÿäº†å˜åŒ–ã€‚è®©æˆ‘æ¥ç»™ä½ ä»‹ç»ä¸€ä¸‹è¿ç§»çš„è¿‡ç¨‹ã€‚ åœ¨1.5ä¸­ï¼Œæ—¥å¿—é…ç½®æ˜¯é€šè¿‡ å®¢æˆ·ç«¯é…ç½® å’Œ èŠ‚ç‚¹é…ç½® . æ‚¨å¯ä»¥é…ç½® é»˜è®¤è·Ÿè¸ªçº§åˆ« , è·Ÿè¸ªæ–‡ä»¶å , è·Ÿè¸ªæ¨¡å¼ , TraceLevelOverrides , è·Ÿè¸ªæ§åˆ¶å° , æ‰¹é‡æ¶ˆæ¯é™åˆ¶ , æœ¨ææ¶ˆè´¹è€… ç­‰ç­‰ã€‚åœ¨2.0ä¸­ï¼Œæ—¥å¿—è®°å½•é…ç½®ä¸ASP.NETcore2.0æ—¥å¿—è®°å½•ï¼Œè¿™æ„å‘³ç€å¤§éƒ¨åˆ†é…ç½®éƒ½æ˜¯é€šè¿‡ Microsoft.Extensions.Logging.ILoggingBuilder . é…ç½® é»˜è®¤è·Ÿè¸ªçº§åˆ« å’Œ TraceLevelOverrides ï¼Œä½ éœ€è¦ç”³è¯· æ—¥å¿—è¿‡æ»¤ åˆ° ILoggingBuilder . ä¾‹å¦‚ï¼Œè¦åœ¨orleansè¿è¡Œæ—¶ä¸­å°†è·Ÿè¸ªçº§åˆ«è®¾ç½®ä¸ºâ€œDebugâ€ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ç¤ºä¾‹ï¼Œ siloBuilder.AddLogging(builder=>builder.AddFilter(\"Orleans\", LogLevel.Debug)); æ‚¨å¯ä»¥ç”¨åŒæ ·çš„æ–¹æ³•ä¸ºåº”ç”¨ç¨‹åºä»£ç é…ç½®æ—¥å¿—çº§åˆ«ã€‚å¦‚æœè¦å°†é»˜è®¤çš„æœ€å°è·Ÿè¸ªçº§åˆ«è®¾ç½®ä¸ºè°ƒè¯•ï¼Œè¯·ä½¿ç”¨ä¸‹é¢çš„ç¤ºä¾‹ siloBuilder.AddLogging(builder=>builder.SetMinimumLevel(LogLevel.Debug); æœ‰å…³æ—¥å¿—ç­›é€‰çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging ; å°†TraceToConsoleé…ç½®ä¸º æ˜¯çš„ ï¼Œéœ€è¦å‚è€ƒ Microsoft.Extensions.Logging.æ§åˆ¶å° æ‰“åŒ…åä½¿ç”¨ æ·»åŠ æ§åˆ¶å°() æ‰©å±•æ–¹æ³• ILoggingBuilder . åŒæ ·çš„ è·Ÿè¸ªæ–‡ä»¶å å’Œ è·Ÿè¸ªæ¨¡å¼ ï¼Œå¦‚æœè¦å°†æ¶ˆæ¯è®°å½•åˆ°æ–‡ä»¶ä¸­ï¼Œåˆ™éœ€è¦ä½¿ç”¨ AddFile(â€œæ–‡ä»¶åâ€) æ–¹æ³• ILoggingBuilder . å¦‚æœæ‚¨ä»ç„¶æƒ³ä½¿ç”¨æ¶ˆæ¯å¡«å……ç‰¹æ€§ï¼Œæ‚¨éœ€è¦é€šè¿‡ ILoggingBuilder ä¹Ÿã€‚æ¶ˆæ¯å¡«å……åŠŸèƒ½å­˜åœ¨äº Microsoft.Orleans.Logging.é—äº§ åŒ…è£¹ã€‚æ‰€ä»¥æ‚¨éœ€è¦é¦–å…ˆæ·»åŠ å¯¹è¯¥åŒ…çš„ä¾èµ–æ€§ã€‚ç„¶åé€šè¿‡ ILoggingBuilder . ä¸‹é¢æ˜¯ä¸€ä¸ªå¦‚ä½•é…ç½®å®ƒçš„ç¤ºä¾‹ ISiloHostBuilder siloBuiler.AddLogging(builder => builder.AddMessageBulkingLoggerProvider(new FileLoggerProvider(\"mylog.log\"))); æ­¤æ–¹æ³•å°†å¯¹ FileLoggerProvider ï¼Œä½¿ç”¨é»˜è®¤çš„å¡«å……é…ç½®ã€‚ ç”±äºæˆ‘ä»¬å°†åœ¨å°†æ¥æœ€ç»ˆå¼ƒç”¨å¹¶åˆ é™¤LogConsumerç‰¹æ€§æ”¯æŒï¼Œæˆ‘ä»¬å¼ºçƒˆå»ºè®®æ‚¨å°½å¿«è¿ç§»æ‰è¿™ä¸ªç‰¹æ€§ã€‚æœ‰ä¸¤ç§æ–¹æ³•ä½ å¯ä»¥é‡‡å–è¿ç§»ã€‚ä¸€ä¸ªé€‰æ‹©æ˜¯ä¿æŒä½ è‡ªå·±çš„ iLoggeræä¾›ç¨‹åº ï¼Œè¿™å°±åˆ›é€ äº† çªƒå¬å™¨ è°ç™»å½•åˆ°æ‰€æœ‰ç°æœ‰çš„æ—¥å¿—ä½¿ç”¨è€…ã€‚è¿™å’Œæˆ‘ä»¬æ­£åœ¨åšçš„éå¸¸ç›¸ä¼¼ Microsoft.Orleans.Logging.é—äº§ åŒ…è£¹ã€‚ä½ å¯ä»¥çœ‹çœ‹ LegacyOrleanSloggeræä¾›ç¨‹åº ä»ä¸­å€Ÿç”¨é€»è¾‘ã€‚å¦ä¸€ä¸ªé€‰æ‹©æ˜¯æ›¿æ¢ ILogConsumer ç°æœ‰çš„ iLoggeræä¾›ç¨‹åº åœ¨nugetä¸Šï¼Œå®ƒæä¾›ç›¸åŒæˆ–ç›¸ä¼¼çš„åŠŸèƒ½ï¼Œæˆ–è€…å®ç°æ‚¨è‡ªå·±çš„åŠŸèƒ½ iLoggeræä¾›ç¨‹åº ç¬¦åˆæ‚¨ç‰¹å®šçš„æ—¥å¿—è®°å½•è¦æ±‚ã€‚å¹¶é…ç½®å®ƒä»¬ iLoggeræä¾›ç¨‹åº ä¸ ILoggingBuilder . ä½†å¦‚æœæ‚¨ä¸èƒ½åœ¨çŸ­æœŸå†…è¿ç§»éæ—¥å¿—ä½¿ç”¨è€…ï¼Œæ‚¨ä»ç„¶å¯ä»¥ä½¿ç”¨å®ƒã€‚æ”¯æŒ ILogConsumer ç”Ÿæ´»åœ¨ Microsoft.Orleans.Logging.é—äº§ åŒ…è£¹ã€‚æ‰€ä»¥æ‚¨éœ€è¦é¦–å…ˆæ·»åŠ å¯¹è¯¥åŒ…çš„ä¾èµ–ï¼Œç„¶åé€šè¿‡æ‰©å±•æ–¹æ³•é…ç½®æ—¥å¿—ä½¿ç”¨è€… æ·»åŠ LegacyOrleansLogging åœ¨ ILoggingBuilder . æœ‰æœ¬åœ°äºº æ·»åŠ æ—¥å¿—è®°å½• æ–¹æ³• IServiceCollection æä¾›å•ä½ASP.NETä¾›æ‚¨é…ç½® ILoggingBuilder . æˆ‘ä»¬è¿˜å°†è¯¥æ–¹æ³•åŒ…è£…åœ¨ ISiloHostBuilder å’Œ IClientBuilder . æ‰€ä»¥ä½ å¯ä»¥è°ƒç”¨ æ·»åŠ æ—¥å¿—è®°å½• æ–¹æ³•æ¥é…ç½®silo builderå’Œclient builder ILoggingBuilder . ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š var severityOverrides = new OrleansLoggerSeverityOverrides(); severityOverrides.LoggerSeverityOverrides.Add(typeof(MyType).FullName, Severity.Warning); siloBuilder.AddLogging(builder => builder.AddLegacyOrleansLogging(new List<ILogConsumer>() { new LegacyFileLogConsumer($\"{this.GetType().Name}.log\") }, severityOverrides)); å¦‚æœæ‚¨æŠ•èµ„äºçš„è‡ªå®šä¹‰å®ç°ï¼Œåˆ™å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½ ILogConsumer æ— æ³•å°†å®ƒä»¬è½¬æ¢ä¸º iLoggeræä¾›ç¨‹åº çŸ­æœŸå†…ã€‚ Logger GetLogger(å­—ç¬¦ä¸²loggerName) æ–¹æ³• Grains åŸºç±»å’Œ IProviderRuntime ï¼Œå’Œ è®°å½•å™¨æ—¥å¿—{getï¼›} åœ¨2.0ä¸­ï¼ŒIStorageProviderä¸Šçš„æ–¹æ³•ä»ä½œä¸ºä¸æ¨èä½¿ç”¨çš„åŠŸèƒ½è¿›è¡Œç»´æŠ¤ã€‚æ‚¨ä»ç„¶å¯ä»¥åœ¨è¿ç§»Orleansé—ç•™æ—¥å¿—çš„è¿‡ç¨‹ä¸­ä½¿ç”¨å®ƒã€‚ä½†æˆ‘ä»¬å»ºè®®ä½ å°½å¿«ç¦»å¼€å®ƒä»¬ã€‚ æä¾›ç¨‹åºé…ç½® åœ¨Orleans 2.0ä¸­ï¼ŒåŒ…å«çš„æä¾›è€…çš„é…ç½®å·²ç»æ ‡å‡†åŒ–ï¼Œå¯ä»¥ä» ä¿±ä¹éƒ¨é€‰é¡¹ ä¸ºsilosæˆ–å®¢æˆ·ç«¯é…ç½®ã€‚ æœåŠ¡IDæ˜¯é›†ç¾¤æ‰€ä»£è¡¨çš„æœåŠ¡æˆ–åº”ç”¨ç¨‹åºçš„ç¨³å®šæ ‡è¯†ç¬¦ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œåœ¨å®æ–½æœåŠ¡çš„ç¾¤é›†çš„éƒ¨ç½²å’Œå‡çº§ä¹‹é—´ï¼ŒæœåŠ¡IDä¸ä¼šæ”¹å˜ã€‚ ä¸æœåŠ¡IDä¸åŒï¼Œé›†ç¾¤IDåªåœ¨ç«–äº•é›†ç¾¤çš„ç”Ÿå‘½å‘¨æœŸä¸­ä¿æŒä¸å˜ã€‚å¦‚æœä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„é›†ç¾¤è¢«å…³é—­ï¼Œå¹¶ä¸”éƒ¨ç½²äº†åŒä¸€æœåŠ¡çš„æ–°é›†ç¾¤ï¼Œé‚£ä¹ˆæ–°é›†ç¾¤å°†æ‹¥æœ‰ä¸€ä¸ªæ–°çš„ã€å”¯ä¸€çš„é›†ç¾¤IDï¼Œä½†æ˜¯å°†ç»´æŠ¤æ—§é›†ç¾¤çš„æœåŠ¡IDã€‚ æœåŠ¡IDé€šå¸¸ç”¨ä½œå¯†é’¥çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºæŒä¹…åŒ–éœ€è¦åœ¨æ•´ä¸ªæœåŠ¡ç”Ÿå‘½å‘¨æœŸä¸­ä¿æŒè¿ç»­æ€§çš„æ•°æ®ã€‚ä¾‹å¦‚GrainçŠ¶æ€ã€æé†’å’ŒæŒä¹…æµçš„é˜Ÿåˆ—ã€‚å¦ä¸€æ–¹é¢ï¼Œé›†ç¾¤æˆå‘˜å…³ç³»è¡¨ä¸­çš„æ•°æ®åªåœ¨å…¶é›†ç¾¤çš„èŒƒå›´å†…æœ‰æ„ä¹‰ï¼Œå› æ­¤é€šå¸¸æ˜¯ä»é›†ç¾¤IDä¸­é”®å…¥çš„ã€‚ åœ¨2.0ä¹‹å‰ï¼ŒOrleansæä¾›è€…çš„è¡Œä¸ºæœ‰æ—¶ä¸ä½¿ç”¨æœåŠ¡IDå’Œé›†ç¾¤ID(ä»¥å‰ä¹Ÿç§°ä¸ºéƒ¨ç½²ID)ä¸ä¸€è‡´ã€‚ç”±äºè¿™ç§ç»Ÿä¸€æ€§ä»¥åŠæä¾›è€…é…ç½®APIçš„æ•´ä½“å˜åŒ–ï¼Œä¸€äº›æä¾›è€…å†™å…¥å­˜å‚¨å™¨çš„æ•°æ®å¯èƒ½ä¼šæ”¹å˜ä½ç½®æˆ–å¯†é’¥ã€‚å¯¹æ­¤æ›´æ”¹æ•æ„Ÿçš„æä¾›ç¨‹åºç¤ºä¾‹æ˜¯Azureé˜Ÿåˆ—æµæä¾›ç¨‹åºã€‚ å¦‚æœæ‚¨æ­£åœ¨å°†ç°æœ‰æœåŠ¡ä»1.xè¿ç§»åˆ°2.0ï¼Œå¹¶ä¸”éœ€è¦ä¿æŒä¸æ‚¨åœ¨æœåŠ¡ä¸­ä½¿ç”¨çš„æä¾›ç¨‹åºæŒä¹…åŒ–çš„æ•°æ®çš„ä½ç½®æˆ–é”®ç›¸å…³çš„å‘åå…¼å®¹æ€§ï¼Œè¯·éªŒè¯æ•°æ®æ˜¯å¦ä½äºæ‚¨çš„æœåŠ¡æˆ–æä¾›å•†é¢„æœŸçš„ä½ç½®ã€‚å¦‚æœæ‚¨çš„æœåŠ¡ç¢°å·§ä¾èµ–äº1.xæä¾›ç¨‹åºå¯¹æœåŠ¡IDå’ŒCluster IDçš„é”™è¯¯ä½¿ç”¨ï¼Œåˆ™å¯ä»¥é‡å†™ ä¿±ä¹éƒ¨é€‰é¡¹ é€šè¿‡è°ƒç”¨ ISiloHostBuilder.AddProviderClusterOptions() æˆ– IClientBuilder.AddProviderClusterOptions() å¹¶å¼ºåˆ¶å®ƒä»å­˜å‚¨å™¨ä¸­çš„1.xä½ç½®è¯»/å†™æ•°æ®"
  },
  "Documentation/resources/Contributing.html": {
    "href": "Documentation/resources/Contributing.html",
    "title": "Contributing to Orleans | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¯¹Orleansçš„è´¡çŒ® ä¸ºé‚£äº›æƒ³ä¸ºOrleansåšå‡ºè´¡çŒ®çš„å¼€å‘è€…æä¾›ä¸€äº›æ³¨é‡Šå’ŒæŒ‡å¯¼ã€‚ å¯¹æœ¬é¡¹ç›®çš„è´¡çŒ® è¿™é‡Œæœ‰ä¸€äº›å»ºè®®ï¼Œä»»ä½•äººå¯»æ‰¾è¿·ä½ ç‰¹æ€§å’Œå·¥ä½œé¡¹ç›®ï¼Œå°†å¯¹Orleansä½œå‡ºç§¯æçš„è´¡çŒ®ã€‚ è¿™äº›åªæ˜¯ä¸€äº›æƒ³æ³•ï¼Œæ‰€ä»¥å¦‚æœä½ æƒ³åˆ°å…¶ä»–æœ‰ç”¨çš„æ–¹æ³•ï¼Œé‚£ä¹ˆå°±æŠŠ è®¨è®ºçº¿ç´¢ åœ¨GitHubä¸Šè®¨è®ºè¿™ä¸ªæè®®ï¼Œå¹¶ä»˜è¯¸è¡ŒåŠ¨ï¼ OrleansGitHubå­˜å‚¨åº“ æ‹‰è¯·æ±‚æ€»æ˜¯å—æ¬¢è¿çš„ï¼ å®ä¹ ç”Ÿå’Œå­¦ç”Ÿé¡¹ç›® å¯¹å¯èƒ½çš„å®ä¹ ç”Ÿ/å­¦ç”Ÿé¡¹ç›®çš„ä¸€äº›å»ºè®®ã€‚ æ–‡ä»¶ç¼–åˆ¶æŒ‡å— ç”¨äºç¼–å†™æ­¤ç½‘ç«™æ–‡æ¡£çš„æ ·å¼æŒ‡å—ã€‚ ä»£ç è´¡çŒ® è¿™ä¸ªé¡¹ç›®å’Œå¦ä¸€ä¸ªé¡¹ç›®ä½¿ç”¨ç›¸åŒçš„è´¡çŒ®è¿‡ç¨‹ DotNeté¡¹ç›® åœ¨GitHubä¸Šã€‚ DotNeté¡¹ç›®è´¡çŒ®æŒ‡å— ä¸ºGitHubä¸Šçš„DotNeté¡¹ç›®æä¾›å¸®åŠ©çš„æŒ‡å—å’Œå·¥ä½œæµã€‚ äº’è”ç½‘CLA GitHubä¸ŠDotNeté¡¹ç›®çš„è´¡çŒ®è®¸å¯åè®®ã€‚ .NETæ¡†æ¶è®¾è®¡æŒ‡å— ä¸€äº›åŸºæœ¬çš„APIè®¾è®¡è§„åˆ™ã€ç¼–ç æ ‡å‡†å’Œ.NETFramework APIçš„æ ·å¼æŒ‡å—ã€‚ ç¼–ç æ ‡å‡†å’Œæƒ¯ä¾‹ å¯¹äºç¼–ç é£æ ¼çš„æˆ˜äº‰ï¼Œæˆ‘ä»¬å°½é‡ä¸è¦è¿‡äºæ‹˜æ³¥äºå¼ºè¿«ç—‡ï¼Œä½†åœ¨å‘ç”Ÿäº‰è®®æ—¶ï¼Œæˆ‘ä»¬ç¡®å®ä¼šå›åˆ°GitHubä¸Šå…¶ä»–DotNet OSSé¡¹ç›®ä½¿ç”¨çš„ä¸¤æœ¬â€œ.NETç¼–ç æ ‡å‡†â€ä¹¦ç±ä¸­çš„æ ¸å¿ƒåŸåˆ™ï¼š ç¼–ç é£æ ¼æŒ‡å— .NETæ¡†æ¶è®¾è®¡æŒ‡å— è¿˜æœ‰å¾ˆå¤šå…¶ä»–æœ‰ç”¨çš„æ–‡æ¡£ .NETæ ¸å¿ƒæ¸…é™¤å™¨ å’Œ .NETæ ¸å¿ƒæ¡†æ¶ å€¼å¾—ä¸€è¯»çš„æ–‡æ¡£ç«™ç‚¹ï¼Œå°½ç®¡å¤§å¤šæ•°æœ‰ç»éªŒçš„Cå¼€å‘äººå‘˜å¯èƒ½å·²ç»é€šè¿‡æ¸—é€è·å¾—äº†è®¸å¤šè¿™æ ·çš„æœ€ä½³å®è·µï¼Œç‰¹åˆ«æ˜¯åœ¨æ€§èƒ½å’Œå†…å­˜ç®¡ç†æ–¹é¢ã€‚ æºä»£ç ç»„ç»‡ Orleanså¹¶æ²¡æœ‰ä¸¥æ ¼éµå¾ªâ€œæ¯ä¸ªæ–‡ä»¶ä¸€ä¸ªç±»â€çš„è§„åˆ™ï¼Œä½†æ˜¯æˆ‘ä»¬å°è¯•ä½¿ç”¨å®é™…çš„åˆ¤æ–­æ¥æœ€å¤§é™åº¦åœ°æ”¹å˜å›¢é˜Ÿä¸­å¼€å‘äººå‘˜çš„â€œä»£ç ç†è§£èƒ½åŠ›â€ã€‚å¦‚æœè®¸å¤šå°çš„ishç±»å…±äº«ä¸€ä¸ªâ€œå…¬å…±ä¸»é¢˜â€å’Œ/æˆ–æ€»æ˜¯ä¸€èµ·å¤„ç†ï¼Œé‚£ä¹ˆåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå°†å®ƒä»¬æ”¾åœ¨ä¸€ä¸ªæºä»£ç æ–‡ä»¶ä¸­æ˜¯å¯ä»¥çš„ã€‚ä¾‹å¦‚ï¼Œä¸åŒçš„â€œLogConsumerâ€ç±»æœ€åˆæ”¾åœ¨å•ä¸ªæºæ–‡ä»¶ä¸­ï¼Œå› ä¸ºå®ƒä»¬è¡¨ç¤ºä»£ç ç†è§£çš„å•ä¸ªå•å…ƒã€‚ ä½œä¸ºæ¨è®ºï¼Œå¦‚æœç±»ä½äºä¸ç±»åŒåçš„æ–‡ä»¶ä¸­ï¼Œé‚£ä¹ˆæŸ¥æ‰¾è¯¥ç±»çš„æºä»£ç å°±å®¹æ˜“å¾—å¤š[ç±»ä¼¼äºJavaæ–‡ä»¶å‘½åè§„åˆ™]å› æ­¤ï¼Œåœ¨ä»£ç æŸ¥æ‰¾èƒ½åŠ›å’Œæœ€å°åŒ–/é™åˆ¶è§£å†³æ–¹æ¡ˆä¸­çš„é¡¹ç›®æ•°é‡å’Œé¡¹ç›®ä¸­çš„æ–‡ä»¶æ•°é‡ä¹‹é—´å­˜åœ¨ç€ä¸€ç§å¼ åŠ›å’Œä»·å€¼åˆ¤æ–­[å¯¹äºå¤§å‹é¡¹ç›®ï¼Œè¿™ä¸¤è€…éƒ½ç›´æ¥å½±å“åˆ°visualstudioçš„â€œå¼€æ”¾â€å’Œâ€œæ„å»ºâ€æ—¶é—´\"]. åœ¨VSå’ŒReSharperä¸­çš„ä»£ç æœç´¢å·¥å…·ç»å¯¹æœ‰å¸®åŠ©ã€‚ ä¾èµ–å…³ç³»å’Œé¡¹ç›®é—´å¼•ç”¨ æˆ‘ä»¬éå¸¸ä¸¥æ ¼çš„ä¸€ä¸ªä¸»é¢˜æ˜¯å…³äºç»„ä»¶å’Œå­ç³»ç»Ÿä¹‹é—´çš„ä¾èµ–å¼•ç”¨ã€‚ ç»„ä»¶/é¡¹ç›®å‚è€ƒ è§£å†³æ–¹æ¡ˆä¸­é¡¹ç›®ä¹‹é—´çš„å¼•ç”¨å¿…é¡»å§‹ç»ˆä½¿ç”¨â€œ é¡¹ç›®å‚è€ƒæ–‡çŒ® â€œè€Œä¸æ˜¯â€ DLLå¼•ç”¨ â€œä»¥ç¡®ä¿æ„å»ºå·¥å…·çŸ¥é“ç»„ä»¶æ„å»ºå…³ç³»ã€‚ èµ–ç‰¹ : <ProjectReference Include=\"..\\Orleans\\Orleans.csproj\"> <Project>{BC1BD60C-E7D8-4452-A21C-290AEC8E2E74}</Project> <Name>Orleans</Name> </ProjectReference> é”™äº† : <Reference Include=\"Orleans\" > <HintPath>..\\Orleans\\bin\\Debug\\Orleans.dll</HintPath> </Reference> ä¸ºäº†å¸®åŠ©ç¡®ä¿é¡¹ç›®é—´å¼•ç”¨ä¿æŒå¹²å‡€ï¼Œç„¶ååœ¨æ„å»ºæœåŠ¡å™¨ä¸Š[å’Œæœ¬åœ°çš„ ç”Ÿæˆ.cmd è„šæœ¬]æˆ‘ä»¬æ•…æ„ä½¿ç”¨å¹¶æ’è¾“å…¥ .\\src å’Œè¾“å‡º .\\äºŒè¿›åˆ¶æ–‡ä»¶ ç›®å½•è€Œä¸æ˜¯æ›´æ­£å¸¸çš„å°±åœ°æ„å»ºç›®å½•ç»“æ„(ä¾‹å¦‚ã€‚ [é¡¹ç›®]\\bin\\å‘å¸ƒ )ç”±æœ¬åœ°å¼€å‘è®¡ç®—æœºä¸Šçš„VSä½¿ç”¨ã€‚ ç»Ÿä¸€ç»„ä»¶ç‰ˆæœ¬ æˆ‘ä»¬åœ¨æ•´ä¸ªOrleansä»£ç åº“ä¸­ä½¿ç”¨ç›¸åŒçš„å¤–éƒ¨ç»„ä»¶ç»Ÿä¸€ç‰ˆæœ¬ï¼Œå› æ­¤ä¸éœ€è¦æ·»åŠ  ç»‘å®šé‡å®šå‘ ä¸­çš„æ¡ç›® åº”ç”¨ç¨‹åºé…ç½® æ–‡ä»¶å¤¹ã€‚ è€Œä¸”ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå‡ ä¹æ²¡æœ‰å¿…è¦ ç§æœ‰=çœŸ å…ƒç´ ï¼Œä½†é‡å†™ä¸Windows/VSâ€œsystemâ€ç»„ä»¶çš„å†²çªé™¤å¤–ã€‚ä¸€äº›åŒ…ç®¡ç†å·¥å…·åœ¨è¿›è¡Œç‰ˆæœ¬æ›´æ”¹æ—¶æœ‰æ—¶ä¼šæ„Ÿåˆ°å›°æƒ‘ï¼Œæœ‰æ—¶ä¼šè®¤ä¸ºæˆ‘ä»¬åœ¨ä¸€ä¸ªè§£å†³æ–¹æ¡ˆä¸­ä½¿ç”¨åŒä¸€ç¨‹åºé›†çš„å¤šä¸ªç‰ˆæœ¬ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬ä»æ¥æ²¡æœ‰è¿™æ ·åšè¿‡ã€‚ æˆ‘ä»¬æ¸´æœ›æœ‰ä¸€å¤©.NETåŒ…ç®¡ç†å·¥å…·å¯ä»¥è¿›è¡Œäº‹åŠ¡æ€§ç‰ˆæœ¬æ›´æ”¹ï¼åœ¨æ­¤ä¹‹å‰ï¼Œå¶å°”éœ€è¦é€šè¿‡æ‰‹åŠ¨ç¼–è¾‘.csprojæ–‡ä»¶(å®ƒä»¬åªæ˜¯XMLæ–‡æœ¬æ–‡ä»¶)æ¥â€œä¿®å¤â€æŸäº›.NETåŒ…ç®¡ç†å·¥å…·çš„é”™è¯¯æ“ä½œï¼Œå¹¶/æˆ–ä½¿ç”¨â€œDiscard Edited Lineâ€å‡½æ•°ï¼Œè¿™äº›å‡½æ•°æ˜¯å¤§å¤šæ•°ä¼˜ç§€çš„Gitå·¥å…·ï¼Œå¦‚ é˜¿ç‰¹æ‹‰æ–¯èµ„æºæ ‘ æä¾›ã€‚ ä½¿ç”¨â€œsortâ€å¼•ç”¨å’Œç»Ÿä¸€çš„ç»„ä»¶ç‰ˆæœ¬å¯ä»¥é¿å…åœ¨Orleansè¿è¡Œæ—¶ç»„ä»¶å’Œ/æˆ–å¤–éƒ¨ç»„ä»¶ä¹‹é—´åˆ›å»ºè„†å¼±çš„é“¾æ¥ï¼Œå¹¶ä¸”åœ¨è¿‡å»å‡ å¹´ä¸­è¢«è¯æ˜åœ¨é‡è¦éƒ¨ç½²é‡Œç¨‹ç¢‘æœŸé—´ä¸ºOrleanså›¢é˜Ÿé™ä½å‹åŠ›æ°´å¹³éå¸¸æœ‰æ•ˆã€‚:)"
  },
  "Documentation/resources/orleans_thinking_big_and_small.html": {
    "href": "Documentation/resources/orleans_thinking_big_and_small.html",
    "title": "Orleans - Thinking Big and Small | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "TL; DRï¼šæ‚¨ä¸éœ€è¦æ•°ç™¾å°æœåŠ¡å™¨å³å¯ä»Orleansä¸­å—ç›Šã€‚ä¸€æŠŠå°±è¶³å¤Ÿäº†ã€‚ æ­£å¦‚æˆ‘ä»¬åˆšåˆšå®£å¸ƒOrleansè®¡åˆ’çš„å…¬å¼€é¢„è§ˆ( ç°åœ¨å¯ç”¨ï¼šâ€œOrleansâ€é¡¹ç›®çš„é¢„è§ˆâ€“å¤§è§„æ¨¡çš„äº‘æœåŠ¡ )ï¼Œ// build /ä¸Šçš„ä¸€äº›æœ€åˆçš„é—®é¢˜å’Œè®¨è®ºéƒ½å›´ç»•ç€Orleansç¼–ç¨‹æ¨¡å‹é€‚åˆå“ªç§ç±»å‹çš„æœåŠ¡ã€‚æˆ‘å¬åˆ°æœ‰äººè¯´Orleansé€‚ç”¨äºè¶…å¤§è§„æ¨¡ç³»ç»Ÿã€‚å°½ç®¡ä»æŠ€æœ¯ä¸Šè®²æ˜¯æ­£ç¡®çš„ï¼Œä½†ä»–ä»¬å¯¹æˆ‘æ¥è¯´å¹¶ä¸å®Œæ•´ï¼Œå¹¶è¿«ä½¿æˆ‘å†™è¿™ç¯‡æ–‡ç« ã€‚ é€‚ç”¨èŒƒå›´ Orleansé€‚ç”¨æ€§çš„ä¸€ä¸ªæç«¯æ˜¯å•æœºåº”ç”¨ã€‚æœ‰äº›äººå°†è§’è‰²éš”ç¦»å’Œå®‰å…¨å¹¶å‘è§†ä¸ºè¶³å¤Ÿå¤§çš„å¥½å¤„ï¼Œå› æ­¤å€¼å¾—ä»¥ä¼ é€’æ¶ˆæ¯ä¸ºä»£ä»·ã€‚è¿™ä¸æ˜¯æˆ‘ä»¬åœ¨æ„å»ºOrleansæ—¶è¿›è¡Œä¼˜åŒ–çš„ç”¨ä¾‹ï¼Œè€Œæ˜¯ä¸€ç§åˆæ³•çš„ä½¿ç”¨æ¨¡å¼ï¼Œåªæ˜¯åœ¨äº‘ç¯å¢ƒä¸­ä¸æ˜¯å¾ˆæœ‰è¶£ã€‚ åœ¨å¦ä¸€ç«¯ï¼Œæˆ‘ä»¬å‘ç°äº†è·¨è¶Šæ•°åƒå°æœåŠ¡å™¨çš„å¤§è§„æ¨¡éƒ¨ç½²ã€‚æˆ‘ä»¬åœ¨æ•°ç™¾å°æœåŠ¡å™¨çš„éƒ¨ç½²ä¸Šå¯¹Orleansè¿›è¡Œäº†æµ‹è¯•ï¼Œæˆ‘ç›¸ä¿¡å®ƒå¯ä»¥åœ¨æ•°åƒå°æœåŠ¡å™¨ä¸Šæ­£å¸¸è¿è¡Œï¼Œå³ä½¿éœ€è¦è¿›è¡Œä¸€äº›é…ç½®è°ƒæ•´ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ä½†æ˜¯ï¼Œæˆ‘ä¸ªäººå¯¹å¤šå°‘ä¸ªäº§å“å®é™…ä¸Šéœ€è¦è·¨æ•°åƒä¸ªæœåŠ¡å™¨çš„å•ä¸ªäº‘æœåŠ¡æŒæ€€ç–‘æ€åº¦ï¼Œè€Œä¸æ˜¯è¿è¡Œå¤šä¸ªç›¸äº’å…³è”çš„æœåŠ¡ï¼Œè€Œæ¯ä¸ªæœåŠ¡å®ä¾‹éƒ½éƒ¨ç½²åœ¨æ•°åä¸ªæˆ–æ•°ç™¾ä¸ªæœåŠ¡å™¨ä¸Šï¼Œå› æ­¤æˆ‘ä¸ªäººå¯¹æ­¤æŒæ€€ç–‘æ€åº¦ã€‚ åˆ†å¸ƒå¼ç³»ç»Ÿâ€“åŒæ ·çš„é—®é¢˜ï¼Œæ— è®ºå¤§å° å½“ç³»ç»Ÿä»ä¸€å°æœåŠ¡å™¨ç§»åŠ¨åˆ°å¤šå°æœåŠ¡å™¨æ—¶ï¼Œå¼€å‘äººå‘˜å°†é¢ä¸´å‡ ä¹ç›¸åŒçš„æŒ‘æˆ˜ï¼Œè€Œä¸è®ºå…¶è§„æ¨¡æ˜¯3-5ã€30-50è¿˜æ˜¯300-500æœåŠ¡å™¨ç³»ç»Ÿã€‚ä»–ä»¬ç°åœ¨å¿…é¡»å¤„ç†è®¡ç®—çš„åˆ†å¸ƒï¼Œå®ƒä»¬ä¹‹é—´çš„åè°ƒï¼Œå¯ä¼¸ç¼©æ€§ï¼Œå®¹é”™å’Œé‡æ–°é…ç½®ï¼Œè¯Šæ–­ç­‰ã€‚ç°åœ¨ï¼Œä»–ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿï¼Œè¿™ä»æ¥éƒ½ä¸å®¹æ˜“ã€‚å»ºç«‹æœ‰çŠ¶æ€çš„åˆ†å¸ƒå¼ç³»ç»Ÿæ›´åŠ å›°éš¾ã€‚ Orleansæ—¨åœ¨é€šè¿‡æä¾›ä¸€ç»„æ˜“äºä½¿ç”¨çš„æŠ½è±¡æ¥å¸®åŠ©æ„å»ºæ­¤ç±»ç³»ç»Ÿï¼Œè¿™äº›æŠ½è±¡å¯å¤§å¤§ç®€åŒ–å¼€å‘äººå‘˜çš„ç”Ÿæ´»å¹¶å¸®åŠ©ä»–ä»¬é¿å…å¸¸è§çš„åˆ†å¸ƒå¼ç³»ç»Ÿé™·é˜±ã€‚åˆ†å¸ƒå¼è¿è¡Œæ—¶æ—¨åœ¨æ‰§è¡Œå¤§å¤šæ•°ç¹é‡çš„å·¥ä½œã€‚åœ¨æ„å»ºä¸åŒè§„æ¨¡çš„æœåŠ¡æ—¶ï¼Œå¼€å‘äººå‘˜åŒæ ·å¯ä»¥ä»Orleansçš„è¿™äº›åŠŸèƒ½ä¸­å—ç›Šï¼Œå› ä¸ºOrleansè§£å†³çš„é—®é¢˜å®é™…ä¸Šæ˜¯ç›¸åŒçš„ã€‚Grainçš„æŠ½è±¡ç®€åŒ–äº†æœ‰å…³ç³»ç»Ÿçš„æ¨ç†ï¼ŒåŒæ—¶é¼“åŠ±å¯¹çŠ¶æ€è¿›è¡Œç»†Grainçš„åˆ’åˆ†ä»¥å®ç°å¯ä¼¸ç¼©æ€§ã€‚è™šæ‹Ÿè§’è‰²åŠŸèƒ½æœ‰åŠ©äºèµ„æºç®¡ç†å’Œå®¹é”™ã€‚è‡ªåŠ¨ä¼ æ’­å¼‚å¸¸ä¼šæœ€å¤§ç¨‹åº¦åœ°å‡å°‘é”™è¯¯å¤„ç†ä»£ç ï¼Œè€Œä¸ä¼šä¸¢å¤±æ•…éšœã€‚åˆ†å¸ƒå¼è¿è¡Œæ—¶è´Ÿè´£æœåŠ¡å™¨æ•…éšœï¼Œæ¶ˆæ¯ä¼ é€’ï¼Œè·¯ç”±ï¼Œå•çº¿ç¨‹æ‰§è¡Œå’Œå…¶ä»–ç³»ç»Ÿçº§åˆ«çš„ä¿è¯ã€‚æ‚¨ä¸éœ€è¦æ•°ç™¾å°æœåŠ¡å™¨å³å¯å¼€å§‹æé«˜å¼€å‘äººå‘˜çš„å·¥ä½œæ•ˆç‡ã€‚ å¼¹æ€§ å¾ˆéš¾ä¸ºå°†æ¥çš„ç³»ç»Ÿé¢„æµ‹è´Ÿè½½ï¼Œè€Œä¸”é€šå¸¸æ ¹æœ¬ä¸å¯èƒ½ã€‚æ¯ä¸ªåˆåˆ›ä¼ä¸šéƒ½æ¢¦æƒ³æœ‰ä¸€å¤©ä¼šè¢«æ–©é¦–ï¼Œè¿™å¯¹ä¼ä¸šæ¥è¯´æ˜¯ç¦æ°”ï¼Œä¹Ÿæ˜¯å¯¹ç³»ç»Ÿçš„è¯…å’’ã€‚æˆ–è€…æ‚¨çš„CMOå¯èƒ½éå¸¸å–œæ¬¢æ‚¨çš„BIæ•°æ®ï¼Œä»¥è‡³äºå¥¹çªç„¶æƒ³å°†å…¶å­˜å‚¨åœ¨5ç§’å†…è€Œä¸æ˜¯30åˆ†é’Ÿå†…ã€‚ä¸ºå¯èƒ½æ°¸è¿œä¸ä¼šå®ç°çš„é«˜è´Ÿè½½è€Œå»ºé€ æ˜¯æ˜‚è´µçš„ã€‚Orleansæ¨¡å‹é€šè¿‡é¼“åŠ±ä»¥å¯æ‰©å±•çš„æ–¹å¼è®¾è®¡ç³»ç»Ÿæ¥å¸®åŠ©è§£å†³å¼¹æ€§é—®é¢˜ï¼Œè¿™æ ·æ‚¨å°±å¯ä»¥ä»å°è§„æ¨¡éƒ¨ç½²å¼€å§‹ï¼Œå¹¶åœ¨ä¸æ›´æ”¹åº”ç”¨ç¨‹åºä»£ç çš„æƒ…å†µä¸‹ä»å°è§„æ¨¡éƒ¨ç½²æˆ–æ‰©å¤§è§„æ¨¡(å¦‚æœéœ€è¦)ã€‚ åº•çº¿ ä»å•æœåŠ¡å™¨è®¾ç½®è½¬ç§»åˆ°åˆ†å¸ƒå¼ç³»ç»Ÿ(æ— è®ºæ˜¯2å°æˆ–3å°æœåŠ¡å™¨è¿˜æ˜¯æ•°åƒå°æœåŠ¡å™¨)ï¼Œæ‚¨åº”è¯¥éƒ½èƒ½ä»Orleansä¸­å—ç›Šã€‚å¦‚æœæ‚¨è®¤ä¸ºå¯èƒ½éœ€è¦ä¸€å¤©çš„æ—¶é—´æ¨ªå‘æ‰©å±•æˆ–å®¹é”™ï¼Œæ‚¨ç”šè‡³å¯ä»¥å¼€å§‹ä¸Orleansä¸€èµ·æ„å»ºå•æœåŠ¡å™¨è§£å†³æ–¹æ¡ˆã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯æ‚¨çš„ä»£ç æ— éœ€æ›´æ”¹ã€‚åªéœ€æ·»åŠ æ›´å¤šæœåŠ¡å™¨ï¼Œæ‚¨çš„grainå°±ä¼šéå¸ƒä»–ä»¬ã€‚ -è°¢å°”ç›–Â·æ‹œç§‘å¤«(Sergey Bykov)"
  },
  "Documentation/resources/student_projects.html": {
    "href": "Documentation/resources/student_projects.html",
    "title": "Student Projects | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å­¦ç”Ÿé¡¹ç›® æˆ‘ä»¬ä¸ºå­¦ç”Ÿæ¨èä¸¤ç§ç±»å‹çš„é¡¹ç›®ï¼š ç¬¬ä¸€ç§ç±»å‹åŒ…æ‹¬æ¢ç´¢æ€§çš„ï¼Œå¼€æ”¾å¼çš„ï¼Œ ç ”ç©¶æ€§é¡¹ç›® ç›®æ ‡æ˜¯åœ¨Orleanså»ºç«‹æ–°çš„èƒ½åŠ›ã€‚è¿™äº›é¡¹ç›®çš„èŒƒå›´é€šå¸¸å¾ˆå¹¿ï¼Œé€‚åˆç¡•å£«ã€åšå£«æˆ–é«˜çº§æœ¬ç§‘ç”Ÿæœ€åä¸€å¹´çš„å­¦ä¹ ã€‚è¿™äº›é¡¹ç›®çš„æœ€ç»ˆç›®æ ‡æ˜¯ä¸ºOrleansæä¾›åˆ›æ„å’Œè®¾è®¡ã€‚æˆ‘ä»¬ä¸ä¸€å®šæœŸæœ›åœ¨è¿™äº›é¡¹ç›®ä¸­ç”Ÿæˆçš„ä»£ç ç›´æ¥è´¡çŒ®åˆ°è¿™ä¸ªå­˜å‚¨åº“ä¸­ï¼Œä½†æ˜¯è¿™å°†æ˜¯å¾ˆå¥½çš„ã€‚ ç¬¬äºŒç§ç±»å‹åŒ…æ‹¬ å­¦ç”Ÿæ•™è‚²ç†å¿µ . è¿™äº›éƒ½æ˜¯å¯ä»¥åœ¨Orleansä¹‹ä¸Šæ„å»ºçš„æœ‰è¶£åº”ç”¨ç¨‹åºçš„æƒ³æ³•ï¼Œæˆ–è€…æ˜¯ä¸ºOrleanså¼€å‘çš„ä¸€äº›æ–°åŠŸèƒ½ã€‚è¿™äº›é¡¹ç›®é€‚åˆåœ¨é«˜çº§æœ¬ç§‘æˆ–ç ”ç©¶ç”Ÿè¯¾ç¨‹ä¸­æˆè¯¾ï¼Œå­¦ç”Ÿä»¬å­¦ä¹ äº‘è®¡ç®—å’Œç°ä»£åˆ†å¸ƒå¼æŠ€æœ¯ï¼Œå¹¶å¸Œæœ›è·å¾—æ„å»ºäº‘åº”ç”¨ç¨‹åºçš„å®é™…åŠ¨æ‰‹ç»éªŒã€‚æˆ‘ä»¬ä¸å¸Œæœ›åœ¨è¿™äº›é¡¹ç›®ä¸­ç”Ÿæˆçš„ä»£ç ç›´æ¥è´¡çŒ®ç»™è¿™ä¸ªå­˜å‚¨åº“ã€‚ ç ”ç©¶é¡¹ç›®ï¼š è‡ªåŠ¨ç¼©æ”¾ã€‚ åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œå­¦ç”Ÿå¯ä»¥ä»æ¢ç´¢ç°æœ‰çš„è‡ªåŠ¨ä¼¸ç¼©æœºåˆ¶å¼€å§‹ï¼Œä»¥æ§åˆ¶windowsazureä¸­çš„èµ„æºåˆ†é…( è‡ªåŠ¨è°ƒæ•´åº”ç”¨ç¨‹åºå— ). ä¸‹ä¸€æ­¥åŒ…æ‹¬æ¢ç´¢ç”±Orleansæ”¶é›†çš„å„ç§ç»Ÿè®¡æ•°æ®å’Œèµ„æºæ¶ˆè€—æŒ‡æ ‡ï¼Œå¹¶å°†å®ƒä»¬ç”¨ä½œAzureè‡ªåŠ¨ç¼©æ”¾çš„è¾“å…¥ã€‚è¯¥é¡¹ç›®çš„é«˜çº§é˜¶æ®µå¯èƒ½æ¶‰åŠæ”¹å–„Orleanså†…éƒ¨å¯¹å¼¹æ€§å˜åŒ–ä½œå‡ºååº”çš„æœºåˆ¶ï¼Œä¾‹å¦‚é€šè¿‡å®æ–½å®æ—¶æ¼”å‘˜è¿ç§»æ¥å‡å°‘åˆ©ç”¨æ–°èµ„æºæ‰€éœ€çš„æ—¶é—´ã€‚ ä¸ºåŸºäºOrleansçš„äº‘æœåŠ¡è‡ªåŠ¨ç”Ÿæˆå‰ç«¯ . è¿™ä¸ªé¡¹ç›®å°†Orleans actoræ¨¡å‹æ— ç¼åœ°æ‰©å±•åˆ°HTTPä¸–ç•Œä¸­ã€‚é¡¹ç›®çš„å‡çº§éƒ¨åˆ†åŒ…æ‹¬æ ¹æ®å‚ä¸è€…çš„.NETæ¥å£å’Œå…ƒæ•°æ®åŠ¨æ€ç”ŸæˆHTTPç«¯ç‚¹ã€‚ä¸»è¦éƒ¨åˆ†åŒ…æ‹¬è‡ªåŠ¨ç”Ÿæˆå‰ç«¯ä»¥æ”¯æŒwebå¥—æ¥å­—å’ŒåŒå‘æ•°æ®æµï¼Œè¿™éœ€è¦å¤æ‚çš„ä»£ç ç”Ÿæˆå’Œä¼˜åŒ–ä»¥è·å¾—é«˜æ€§èƒ½ã€‚å®ƒè¿˜éœ€è¦æ³¨æ„å®¹é”™ï¼Œåœ¨æœåŠ¡å™¨é‡æ–°å¯åŠ¨ã€å®¢æˆ·ç«¯é‡æ–°è¿æ¥å’Œè¿ç§»è¿‡ç¨‹ä¸­ä¿æŒæµå¼ä¼šè¯çš„é«˜å¯ç”¨æ€§ï¼Œè¿™æ˜¯ä¸€ä¸ªé‡å¤§çš„ç ”ç©¶æŒ‘æˆ˜ã€‚ å®ä½“æ¡†æ¶çš„å­˜å‚¨æä¾›ç¨‹åº . è¿™ä¸ªé¡¹ç›®åŒ…æ‹¬ä½¿Orleanså¯¹è±¡èƒ½å¤Ÿå°†å®ƒä»¬çš„çŠ¶æ€å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ï¼Œå¹¶éšåå¯¹å…¶è¿›è¡ŒæŸ¥è¯¢ã€‚è¿™å¯èƒ½åŒ…æ‹¬ä½¿ç”¨EntityFramework(EF)åœ¨SQLAzureæ•°æ®åº“ä¸Šæ·»åŠ å¯¹Orleanså¯¹è±¡æŒä¹…åŒ–çš„æ”¯æŒï¼ŒEFæ˜¯Microsofté’ˆå¯¹.NETçš„å¼€æºå¯¹è±¡å…³ç³»æ˜ å°„å™¨ï¼Œå¹¶é€šè¿‡LINQæŸ¥è¯¢å…¬å¼€è¿™äº›æ•°æ®ã€‚å¯ä»¥ä½¿ç”¨æ ‡å‡†æ•°æ®åº“åŸºå‡†å’Œ/æˆ–å®šåˆ¶çš„Orleansåº”ç”¨ç¨‹åºæ¥è¯„ä¼°å’Œè°ƒæ•´å®ç°ã€‚ åˆ†å¸ƒå¼ç³»ç»ŸåŸºå‡†æµ‹è¯• . å®šä¹‰ä¸€ä¸ªé€‚ç”¨äºåƒOrleansè¿™æ ·çš„åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºå‡†æµ‹è¯•åˆ—è¡¨ã€‚åŸºå‡†åº”ç”¨ç¨‹åºåœ¨ç²¾ç¥ä¸Šå¯èƒ½ç±»ä¼¼äº TPCæ•°æ®åº“åŸºå‡† æˆ– UCBâ€œå¹³è¡ŒçŸ®æ˜Ÿâ€ å®æ–½ åœ¨è¿™é‡Œ å¯ä»¥ç”¨æ¥æè¿°åˆ†å¸ƒå¼æ¡†æ¶çš„æ€§èƒ½å’Œå¯ä¼¸ç¼©æ€§ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸ºOrleanså¼€å‘ä¸€ä¸ªæ–°çš„åŸºå‡†ï¼Œä»¥æ¯”è¾ƒå­˜å‚¨ä¾›åº”å•†çš„æ€§èƒ½ã€‚ æµä¸Šçš„å£°æ˜æ€§æ•°æ®æµè¯­è¨€ . å®šä¹‰å¹¶æ„å»º ä¸‰å‰æˆŸé£æš´ å°±åƒOrleansStreamsä¸Šçš„é™ˆè¿°æ€§è¯­è¨€ã€‚å¼€å‘ä¸€ä¸ªä¼˜åŒ–ç¨‹åºæ¥é…ç½®æµå¤„ç†ä»¥æœ€å°åŒ–æ€»ä½“æˆæœ¬ã€‚ å®¢æˆ·ç«¯è®¾å¤‡çš„ç¼–ç¨‹æ¨¡å‹ . å°†Orleansæ‰©å±•åˆ°å®¢æˆ·ç«¯è®¾å¤‡ï¼Œå¦‚ä¼ æ„Ÿå™¨ã€è°ƒç”¨ã€å¹³æ¿ç”µè„‘å’Œå°å¼æœºã€‚å¯ç”¨Grainé€»è¾‘åœ¨å®¢æˆ·ç«¯ä¸Šæ‰§è¡Œã€‚æ½œåœ¨åœ°æ”¯æŒå±‚åˆ†å‰²ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒåŠ¨æ€åœ°å†³å®šå“ªäº›éƒ¨åˆ†çš„ä»£ç åœ¨è®¾å¤‡ä¸Šæ‰§è¡Œï¼Œå“ªäº›éƒ¨åˆ†è¢«å¸è½½åˆ°äº‘ä¸Šã€‚ å¯¹grain/actorç±»ã€äºŒçº§ç´¢å¼•çš„æŸ¥è¯¢ . å»ºç«‹ä¸€ä¸ªåˆ†å¸ƒå¼çš„ã€å¯æ‰©å±•çš„ã€å¯é çš„GrainsæŒ‡æ•°ã€‚è¿™åŒ…æ‹¬æ­£å¼å®šä¹‰æŸ¥è¯¢æ¨¡å‹å’Œå®ç°åˆ†å¸ƒå¼ç´¢å¼•ã€‚ç´¢å¼•æœ¬èº«å¯ä»¥å®ç°ä¸ºOrleansGrainså’Œ/æˆ–å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ã€‚ å¤§è§„æ¨¡æ¨¡æ‹Ÿ . Orleansé€‚åˆå¤§è§„æ¨¡çš„æ¨¡æ‹Ÿå»ºç­‘ã€‚æ¢ç´¢Orleansåœ¨ä¸åŒæ¨¡æ‹Ÿä¸­çš„åº”ç”¨ï¼Œä¾‹å¦‚ï¼Œè›‹ç™½è´¨ç›¸äº’ä½œç”¨ã€ç½‘ç»œæ¨¡æ‹Ÿã€æ¨¡æ‹Ÿé€€ç«ç­‰ã€‚ è¯¾ç¨‹é¡¹ç›®ï¼š ç‰©è”ç½‘åº”ç”¨ . ä¾‹å¦‚ï¼Œè¯¥åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ä¼ æ„Ÿå™¨/è®¾å¤‡å‘äº‘ç«¯æŠ¥å‘Šå…¶çŠ¶æ€ï¼Œåœ¨äº‘ä¸­ï¼Œæ¯ä¸ªè®¾å¤‡éƒ½ç”±Orleansçš„å‚ä¸è€…è¡¨ç¤ºã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡webæµè§ˆå™¨è¿æ¥åˆ°ä»£è¡¨å…¶è®¾å¤‡çš„actorï¼Œå¹¶æ£€æŸ¥å…¶çŠ¶æ€æˆ–æ§åˆ¶å®ƒã€‚è¿™ä¸ªé¡¹ç›®éœ€è¦æŒæ¡è®¸å¤šç°ä»£äº‘æŠ€æœ¯ï¼ŒåŒ…æ‹¬ Windows Azure ï¼ŒOrleansï¼Œ ç½‘ç»œAPI æˆ–è€…ASP.NET, ä¿¡å·å‘˜ ç”¨äºå°†å‘½ä»¤ä»äº‘ç«¯ä¼ è¾“å›è®¾å¤‡ï¼Œå¹¶ç¼–å†™ä¼ æ„Ÿå™¨/è®¾å¤‡/æ‰‹æœºåº”ç”¨ç¨‹åºã€‚ åŸºäºOrleansçš„äº‘ä¸­ç±»ä¼¼Twitterçš„å¤§å‹å¯ä¼¸ç¼©èŠå¤©æœåŠ¡ . æ¯ä¸ªç”¨æˆ·éƒ½å¯ä»¥ç”±ä¸€ä¸ªOrleansæ¼”å‘˜ä»£è¡¨ï¼Œè¯¥æ¼”å‘˜åŒ…å«å…¶è¿½éšè€…åˆ—è¡¨ã€‚ åŸºäºOrleansçš„Faceboookç±»ç¤¾äº¤åº”ç”¨ . æ¯ä¸ªç”¨æˆ·å¯ä»¥ç”±ä¸€ä¸ªOrleansæ¼”å‘˜ä»£è¡¨ï¼Œå…¶ä¸­åŒ…æ‹¬ä¸€ä¸ªæœ‹å‹åˆ—è¡¨å’Œæœ‹å‹å¯ä»¥åœ¨ä¸Šé¢å†™å­—çš„å¢™ã€‚ ç®€å•å­˜å‚¨æä¾›ç¨‹åº . ä¸ºå­˜å‚¨ç³»ç»Ÿ(å¦‚é”®å€¼å­˜å‚¨æˆ–æ•°æ®åº“ç³»ç»Ÿ)æ·»åŠ å­˜å‚¨æä¾›ç¨‹åºã€‚ä¸€ä¸ªç®€å•çš„äººå¯ä»¥ç”¨ Orleansåºåˆ—åŒ–ç¨‹åº ï¼Œå¦‚ç°æœ‰çš„ Azureè¡¨å­˜å‚¨æä¾›ç¨‹åº . æ›´å¤æ‚çš„æ–¹æ³•æ˜¯å°†Orleansç±»çš„çŠ¶æ€å˜é‡æ˜ å°„åˆ°å­˜å‚¨ç³»ç»Ÿçš„ç»†Grainç»“æ„ã€‚å¤æ‚çš„æ˜¯ä¸Šé¢æåˆ°çš„å®ä½“æ¡†æ¶å­˜å‚¨æä¾›ç¨‹åº ç ”ç©¶é¡¹ç›® . æ¯”è¾ƒä¸åŒç±»å‹å’Œå¤§å°çš„å‚ä¸è€…çŠ¶æ€çš„ä¸åŒå­˜å‚¨æä¾›ç¨‹åºçš„æ€§èƒ½ã€‚ ä¸å…¶ä»–åˆ†å¸ƒå¼åº”ç”¨æ¡†æ¶çš„æ¯”è¾ƒ . ä»¥ä¸ºå¦ä¸€ä¸ªåº”ç”¨ç¨‹åºæ¡†æ¶ç¼–å†™çš„ç¤ºä¾‹åº”ç”¨ç¨‹åºä¸ºä¾‹ï¼Œä¾‹å¦‚ è°·æ­Œåº”ç”¨å¼•æ“ æˆ– é˜¿å…‹å¡ æŠŠå®ƒç¿»è¯‘æˆOrleansã€‚é€šè¿‡æ¯”è¾ƒåº”ç”¨ç¨‹åºï¼Œæ€»ç»“æ¯ä¸ªæ¡†æ¶çš„ç›¸å¯¹ä¼˜åŠ¿å’ŒåŠ£åŠ¿ã€‚ å·²å®Œæˆçš„ç ”ç©¶é¡¹ç›®ï¼š ä¸‹é¢æ˜¯ä¸€äº›ä»¥å‰æˆåŠŸçš„ç ”ç©¶é¡¹ç›®çš„ä¾‹å­ã€‚ åˆ†å¸ƒå¼æ—¥å¿—åˆ†æã€å…³è”ä¸è°ƒè¯• . å¤§å‹åˆ†å¸ƒå¼ç³»ç»Ÿçš„è°ƒè¯•æ˜¯ä¸€é¡¹å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡ï¼Œå› ä¸ºåœ¨ä¸åŒè¿›ç¨‹å’Œä¸åŒæœºå™¨ä¸Šè¿è¡Œçš„åˆ†å¸ƒå¼ç»„ä»¶ä¹‹é—´å­˜åœ¨ç€å¤§é‡çš„æ•°æ®å’Œå¤æ‚çš„åŠ¨æ€äº¤äº’ã€‚æœ¬é¡¹ç›®çš„ç›®æ ‡æ˜¯åˆ†æç°æœ‰æŠ€æœ¯ï¼Œæå‡ºè§£å†³æ–¹æ¡ˆï¼Œç„¶åå®ç°åŸå‹å·¥å…·ï¼Œç”¨äºæ”¶é›†ã€å…³è”å’Œåˆ†æå¤šæœºå™¨åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºè¿è¡Œæ—¶ç¯å¢ƒä¸­çš„åº”ç”¨ç¨‹åºé”™è¯¯æ—¥å¿—æ–‡ä»¶æ•°æ®ã€‚è¿™åŒ…æ‹¬ä»å¤šä¸ªè§’åº¦æ¢ç´¢é—®é¢˜ç©ºé—´ï¼ŒåŒ…æ‹¬ï¼š a. Approaches to efficient logging, collection and analysis of failure information from various log-capture mechanisms in a distributed Orleans runtime environment. b. Possible applications of machine learning to find log patterns that signal serious production issues, and then detecting these patterns in near real time as a production monitoring utility. c. Ways to help individual developers perform real-time debugging of run-time issues with their applications. This project was performed successfully and result in a published paper [PAD: Performance Anomaly Detection in Multi-Server Distributed Systems](http://research.microsoft.com/apps/pubs/?id=217109) and a proof of concept implementation of a distributed log analysis tool. Horton-åˆ†å¸ƒå¼å›¾å½¢æ•°æ®åº“ . Hortonæ˜¯ä¸€ä¸ªç ”ç©¶é¡¹ç›®ï¼Œç›®æ ‡æ˜¯å»ºç«‹ä¸€ä¸ªå­˜å‚¨ã€ç®¡ç†å’ŒæŸ¥è¯¢å¤§è§„æ¨¡åˆ†å¸ƒå¼å›¾å½¢çš„ç³»ç»Ÿã€‚å®ƒå®Œå…¨æ˜¯ä½œä¸ºä¸€ä¸ªOrleansåº”ç”¨ç¨‹åºå®ç°çš„ã€‚è¯¥é¡¹ç›®çš„ç»“æœæ˜¯ å‡ºç‰ˆç‰© ä»¥åŠä¸€äº›éå¸¸æˆåŠŸçš„å­¦ç”Ÿé¡¹ç›®ã€‚"
  },
  "Documentation/resources/links.html": {
    "href": "Documentation/resources/links.html",
    "title": "Links | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é“¾æ¥ ç”±Orleansé˜Ÿ Orleanså»ºç­‘ï¼šåŸç†ä¸æ–¹æ³•I ç¬¬142é›†ï¼šMicrosoftç ”ç©¶é¡¹ç›®Orleansç®€åŒ–äº†å¯ä¼¸ç¼©äº‘æœåŠ¡çš„å¼€å‘ Orleansï¼šå¤§å¤§å°å°çš„æ€è€ƒ ç°åœ¨å¯ç”¨ï¼šâ€œOrleansâ€é¡¹ç›®çš„é¢„è§ˆâ€“å¤§è§„æ¨¡çš„äº‘æœåŠ¡ Orleansï¼šåˆ†å¸ƒå¼è™šæ‹Ÿè§’è‰²çš„å¯ç¼–ç¨‹æ€§å’Œå¯ä¼¸ç¼©æ€§ è¢«åˆ«äºº ä»‹ç»Orleans Microsoft Orleans v2.0-é¢å‘åˆå­¦è€…å’Œä¸“å®¶çš„ç»¼åˆæŒ‡å—(PowerPoint) Orleansè®¡åˆ’åˆæ¢ å†çœ‹Orleansè®¡åˆ’ Orleansè®¡åˆ’ï¼šç®€ä»‹ Orleansè®¡åˆ’ç®€ä»‹ Orleansç®€ä»‹ Orleansä¸“æ¡ˆï¼šä¸åŒäºErlangï¼Œä¸“ä¸ºä¼—å¤šå¼€å‘äººå‘˜è®¾è®¡ æ‚¨å¯èƒ½è¦ä½¿ç”¨Microsoft Orleansé¡¹ç›®çš„ä¸¤ä¸ªåŸå›  Hatay Tunaå’ŒChristian Martinez-Orleansçš„åº”ç”¨æ¼”å‘˜æ¨¡å‹ ä¸Orleansæ¼”å‘˜ç¼–ç¨‹ï¼šæœ‰ä»€ä¹ˆä¸åŒï¼Ÿ Orleansâ€“ä¸º#azureæ„å»ºçš„â€œäº‘åŸç”Ÿâ€è¿è¡Œæ—¶ Orleansè®¡åˆ’-æ¼”å‘˜æ¨¡å‹æ¡†æ¶ é€šè¿‡Erlangè‰²çœ¼é•œäº†è§£Microsoft Orleans åœ¨ä¼ä¸šåº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ä»£å·â€œ Orleansâ€ é™¤äº†ä»‹ç» Grainsï¼ŒGrainså’Œæ›´å¤šGrains åœ¨ç‰©è”ç½‘ä¸–ç•Œä¸­ç»†Grainçš„OrleansGrains å¯ç›‘æ§çš„Grains æ±‡æ€»ç»“æœåœ¨Orleans ä½¿ç”¨Orleansåˆ›å»ºRESTfulæœåŠ¡ ä¸Orleansä¸€èµ·è§£å†³åˆ†å‘ï¼Œé«˜ååé‡å’Œä½å»¶è¿Ÿé—®é¢˜â€“ä¸“ä¸º#Azureæ„å»ºçš„â€œäº‘åŸç”Ÿâ€è¿è¡Œæ—¶ åœ¨#ProjectOrleansä¸­ä»…å¶å°”ä¿å­˜ä¸€æ¬¡çŠ¶æ€ ä½¿ç”¨Orleansæ„å»ºå¯æ‰©å±•çš„äº‘åº”ç”¨ç¨‹åº ç‰©è”ç½‘ä¸–ç•Œä¸­çš„Orleans Orleansé¢„è§ˆå’Œå…‰ç¯4 åœ¨Haloä¸­ä½¿ç”¨â€œOrleansâ€é¡¹ç›® Orleansä¸è·³å‡ºæ€ç»´ John Azariahå’ŒMahesh Krishnan-ä¸å˜æ€§ï¼ŒçŠ¶æ€å’Œè§„æ¨¡-Azureä¸­çš„åŠŸèƒ½ï¼Œåˆ†å¸ƒå¼åº”ç”¨ç¨‹åº æœ€åç¼–è¾‘ï¼š2018å¹´6æœˆ5æ—¥"
  },
  "Documentation/resources/orleans_architecture_principles_and_approach_I.html": {
    "href": "Documentation/resources/orleans_architecture_principles_and_approach_I.html",
    "title": "Orleans Architecture - Principles and Approach I | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ—¢ç„¶Orleans(æœ€ç»ˆ)å¯ä»¥ä½œä¸ºå¼€æºä½¿ç”¨ï¼Œé‚£ä¹ˆäº†è§£ä¿ƒæˆOrleansèƒŒåçš„è®¾è®¡å†³ç­–çš„ç›®æ ‡å’ŒåŸåˆ™å¾ˆé‡è¦ï¼Œè¿™æ ·æ–°çš„å˜åŒ–è¦ä¹ˆé€‚åˆè¯¥æ¡†æ¶ï¼Œè¦ä¹ˆæ˜ç¡®åœ°å¹¶æœ‰æ„åœ°ä¿®æ”¹é‚£äº›ç›®æ ‡å’ŒåŸåˆ™ã€‚ åœ¨æˆ‘åŠ å…¥Orleansé¡¹ç›®æ—¶ï¼Œæˆ‘ä»¬åŒæ„ç›®æ ‡æ˜¯å»ºç«‹ä¸€ä¸ªæ¡†æ¶ï¼Œä½¿ä¸»æµå¼€å‘äººå‘˜å¯ä»¥è½»æ¾æ„å»ºå¯æ‰©å±•çš„åˆ†å¸ƒå¼(äº‘)åº”ç”¨ç¨‹åºã€‚è¦å¯¹æ­¤è¿›è¡Œç»†åˆ†ï¼š ç›®æ ‡è¯»è€…ä¸åº”æ’é™¤å°šæœªå®Œæˆåˆ†å¸ƒå¼ç³»ç»Ÿå¼€å‘çš„ç¨‹åºå‘˜ ã€‚æˆ‘ä»¬å¸Œæœ›ä½¿æ‰€æœ‰å¼€å‘äººå‘˜ï¼Œæ— è®ºæ˜¯äº‘ä¸“å®¶è¿˜æ˜¯äº‘åˆå­¦è€…ï¼Œéƒ½å¯ä»¥ä¸“æ³¨äºä»–ä»¬çš„åº”ç”¨ç¨‹åºé€»è¾‘å’ŒåŠŸèƒ½(å³çœŸæ­£æä¾›ä¸šåŠ¡ä»·å€¼çš„å†…å®¹)ï¼Œè€Œä¸æ˜¯é€šç”¨çš„åˆ†å¸ƒå¼ç³»ç»Ÿé—®é¢˜ã€‚ ç›®çš„æ˜¯è®©ä»–ä»¬è½»æ¾æ„å»ºäº‘åº”ç”¨ç¨‹åº ã€‚è½»æ¾åœ°æ„å‘³ç€ï¼Œä»–ä»¬ä¸å¿…æ¯”ç»å¯¹éœ€è¦å¤šè€ƒè™‘åˆ†é…ã€‚è½»æ¾åœ°ä¹Ÿæ„å‘³ç€Orleansåº”è¯¥å°½å¯èƒ½å‘å¼€å‘äººå‘˜å±•ç¤ºç†Ÿæ‚‰çš„å¤–è§‚ï¼›åœ¨.NETä¸Šä¸‹æ–‡ä¸­ï¼Œè¿™æ„å‘³ç€Cï¼ƒå¯¹è±¡å’Œæ¥å£ã€‚ è¿™äº›åº”ç”¨ç¨‹åºåº”è¯¥æ˜¯*â€œé»˜è®¤æƒ…å†µä¸‹å¯æ‰©å±•â€ *ã€‚ç”±äºæˆ‘ä»¬çš„ç›®æ ‡ç”¨æˆ·ä¸ä¸€å®šæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸“å®¶ï¼Œå› æ­¤æˆ‘ä»¬å¸Œæœ›ä¸ºä»–ä»¬æä¾›ä¸€ä¸ªæ¡†æ¶ï¼Œä½¿ä»–ä»¬æ— éœ€æ˜ç¡®è€ƒè™‘å³å¯æ„å»ºå¯æ‰©å±•çš„åº”ç”¨ç¨‹åºã€‚è¿™æ„å‘³ç€è¯¥æ¡†æ¶å¿…é¡»ä¸ºå®ƒä»¬åšå‡ºå¾ˆå¤šå†³å®šï¼Œä»¥ç¡®ä¿å¯æ¥å—çš„å¯æ‰©å±•æ€§ç¨‹åº¦ï¼Œå³ä½¿è¿™æ„å‘³ç€å¯æ‰©å±•æ€§å¹¶éå¯¹æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½æ˜¯æœ€ä½³çš„ã€‚ æˆ‘ä»¬é€šè¿‡ä¸€ç³»åˆ—æ¶æ„åŸåˆ™å¯¹è¿™ä¸€ç›®æ ‡è¿›è¡Œäº†è¡¥å……ï¼š æˆ‘ä»¬ä¸“æ³¨äº80ï¼…çš„æ¡ˆä¾‹ ã€‚å½“ç„¶ï¼Œæœ‰äº›åº”ç”¨ç¨‹åºä¸é€‚åˆOrleansä½¿ç”¨ï¼›æ²¡å…³ç³»ã€‚æœ‰ä¸€äº›Orleansé€‚åˆçš„åº”ç”¨ç¨‹åºï¼Œä½†æ˜¯é€šè¿‡Orleansä¸å…è®¸çš„å¤§é‡æ‰‹åŠ¨è°ƒæ•´ï¼Œæ‚¨å¯ä»¥åœ¨å…¶ä¸­è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ä¹Ÿå¯ä»¥Orleansçš„80ï¼…å¯ä»¥å¾ˆå¥½åœ°æ‹Ÿåˆå¹¶åœ¨è®¸å¤šæœ‰è¶£çš„åº”ç”¨ç¨‹åºä¸Šè¡¨ç°å‡ºè‰²ï¼Œæˆ‘ä»¬å®æ„¿80ï¼…ä¸Šåšå¾—å¾ˆå¥½ï¼Œä¹Ÿä¸æ„¿99ï¼…ä¸Šåšå¾—ä¸å¥½ã€‚ å¯æ‰©å±•æ€§è‡³å…³é‡è¦ ã€‚å¦‚æœå¯ä»¥æ›´å¥½åœ°è¿›è¡Œæ‰©å±•ï¼Œæˆ‘ä»¬å°†æƒè¡¡åŸå§‹æ€§èƒ½ã€‚ å¯ç”¨æ€§è‡³å…³é‡è¦ ã€‚äº‘åº”ç”¨ç¨‹åºåº”è¯¥åƒå®ç”¨ç¨‹åºï¼šéšæ—¶éšåœ°éƒ½å¯ä»¥ä½¿ç”¨ã€‚ æ£€æµ‹å¹¶ä¿®å¤é—®é¢˜ ï¼Œä¸è¦ä»¥ä¸ºæ‚¨å¯ä»¥100ï¼…é˜»æ­¢å®ƒä»¬ã€‚åœ¨äº‘è§„æ¨¡ä¸Šï¼Œåäº‹ç»å¸¸å‘ç”Ÿï¼Œç”šè‡³ä¸å¯èƒ½å‘ç”Ÿçš„åäº‹ä¹Ÿå¾ˆå°‘å‘ç”Ÿã€‚è¿™å¯¼è‡´äº†æˆ‘ä»¬é€šå¸¸è¢«ç§°ä¸ºâ€œé¢å‘æ¢å¤çš„è®¡ç®—â€ï¼Œè€Œä¸æ˜¯è¯•å›¾åšåˆ°å®¹é”™ã€‚æˆ‘ä»¬çš„ç»éªŒè¡¨æ˜ï¼Œå®¹é”™èƒ½åŠ›å¾ˆå¼±ï¼Œè€Œä¸”å¸¸å¸¸æ˜¯è™šå¹»çš„ã€‚å³ä½¿æ˜¯ç»è¿‡æ•°å­¦éªŒè¯çš„åè®®ä¹Ÿæ— æ³•é˜²æ­¢å†…å­˜æˆ–ç£ç›˜æ§åˆ¶å™¨ä¸­çš„éšæœºä½ç¿»è½¬åœ¨æŠ¥å‘ŠæˆåŠŸæ—¶å¤±è´¥ï¼Œè¿™æ˜¯æˆ‘åœ¨èŒä¸šç”Ÿæ¶¯ä¸­å·²ç»çœ‹åˆ°çš„çœŸå®ç¤ºä¾‹ã€‚ ä»¥ä¸Šå¯¼è‡´æˆ‘ä»¬é‡‡å–äº†æŸäº›åšæ³•ï¼š APIä¼˜å…ˆè®¾è®¡ ï¼šå¦‚æœæˆ‘ä»¬ä¸çŸ¥é“å¦‚ä½•å‘å¼€å‘äººå‘˜å…¬å¼€åŠŸèƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸ä¼šæ„å»ºå®ƒã€‚å½“ç„¶ï¼Œæœ€å¥½çš„æ–¹æ³•æ˜¯ä½¿åŠŸèƒ½å®Œå…¨ä¸æ¥è§¦å¼€å‘äººå‘˜ã€‚ è½»æ¾åšæ­£ç¡®çš„äº‹ ï¼šè¦ä½¿äº‹æƒ…å°½å¯èƒ½ç®€å•(ä½†ä¸è¦ç®€å•)ï¼Œå¦‚æœèºä¸åˆ€æ˜¯æ­£ç¡®çš„å·¥å…·ï¼Œè¯·ä¸è¦ç”¨é”¤å­ç ¸ã€‚æ­£å¦‚æˆ‘ä»¬çš„æ—©æœŸé‡‡ç”¨è€…ä¹‹ä¸€æ‰€è¯´çš„é‚£æ ·ï¼Œæˆ‘ä»¬è¯•å›¾å¸®åŠ©å®¢æˆ·â€œè½å…¥æˆåŠŸä¹‹å‘â€ã€‚å¦‚æœæœ‰ä¸€ä¸ªæ ‡å‡†æ¨¡å¼å¯ä»¥å¾ˆå¥½åœ°é€‚åˆ80ï¼…çš„åº”ç”¨ç¨‹åºï¼Œé‚£ä¹ˆä¸å¿…æ‹…å¿ƒå¯ç”¨æ‰€æœ‰å¯èƒ½çš„æ›¿ä»£æ–¹æ³•ã€‚Orleanså¯¹å¼‚æ­¥çš„æ‹¥æŠ¤å°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ã€‚ ä½¿å¼€å‘äººå‘˜è½»æ¾æ‰©å±•æ¡†æ¶è€Œä¸ç ´åæ¡†æ¶ ã€‚è‡ªå®šä¹‰åºåˆ—åŒ–å’ŒæŒä¹…åŒ–æä¾›ç¨‹åºå°±æ˜¯å…¶ä¸­çš„å‡ ä¸ªç¤ºä¾‹ã€‚æŸç§è‡ªå®šä¹‰ä»»åŠ¡è®¡åˆ’æ‰©å±•å°†æ˜¯åç¤ºä¾‹ã€‚ éµå¾ªæœ€å°‘æƒŠå–œçš„åŸåˆ™ ï¼šå°½å¯èƒ½ä½¿äº‹ç‰©ç†Ÿæ‚‰ï¼Œä½†ä¸€åˆ‡éƒ½åº”æŒ‰ç…§å¤–è§‚è¿›è¡Œã€‚ ä¸‹ä¸€ç¯‡æ–‡ç« å°†å¼€å§‹å°†è¿™äº›åŸç†åº”ç”¨äºå½“å‰çš„Orleansè®¾è®¡ï¼Œå¹¶é€æ­¥æ¢ç©¶æˆ‘ä»¬åšå‡ºçš„æŸäº›ç‰¹å®šå†³ç­–çš„åŠ¨æœºã€‚ è°¢è°¢é˜…è¯»ï¼ è‰¾ä¼¦Â·ç›–å‹’ è‰¾ä¼¦Â·ç›–å‹’ï¼Œ http://research.microsoft.com/en-us/people/ageller/ ï¼Œåœ¨Microsoft Researchä»äº‹é‡å­è®¡ç®—ã€‚ä»2008å¹´åˆ°2012å¹´ï¼Œä»–æ˜¯Orleansçš„ä¸»è¦æ¶æ„å¸ˆä¹‹ä¸€ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œä»2004å¹´åˆ°2008å¹´ï¼Œä»–æ˜¯Amazon Web Servicesçš„å¹³å°æ¶æ„å¸ˆï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œä»–åœ¨ç”µä¿¡å’Œé‡‘èæœåŠ¡é¢†åŸŸæ„å»ºäº†å„ç§å¤§å‹ç”Ÿäº§åˆ†å¸ƒå¼ç³»ç»Ÿã€‚"
  },
  "Documentation/resources/documentation_guidelines.html": {
    "href": "Documentation/resources/documentation_guidelines.html",
    "title": "Documentation Guidelines | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ–‡ä»¶ç¼–åˆ¶æŒ‡å— Orleansæ–‡æ¡£æ˜¯å†…ç½®çš„ é™ä»· . æˆ‘ä»¬ä½¿ç”¨ä¸€äº›ç®€å•çš„çº¦å®šæ¥ç¡®ä¿æ•´ä¸ªæ–‡æ¡£é›†ä¸­çš„æ ·å¼ä¸€è‡´ã€‚ è¿™äº›æ ‡å‡†æ­£åœ¨å¼•å…¥ã€‚å¦‚æœæ‚¨å¯¹è¿™äº›æŒ‡å¯¼åŸåˆ™æœ‰å¼‚è®®ï¼Œè¯·æå‡ºé—®é¢˜æˆ–è¯·æ±‚ã€‚å¦‚æœå‘ç°æ–‡æ¡£ä¸ç¬¦åˆæŒ‡å¯¼åŸåˆ™ï¼Œè¯·è¿›è¡Œä¿®å¤å¹¶æäº¤è¯·æ±‚ã€‚å¦å¤–ï¼Œå¦‚æœä½ ä½¿ç”¨çš„æ˜¯Windows10ï¼Œä½ å¯ä»¥å»å•†åº—æ‰¾åˆ°å…è´¹çš„é™ä»·ç¼–è¾‘å™¨ï¼Œæ¯”å¦‚ è¿™ ç»“æ„ è¯­è¨€ æ–‡ä»¶å°†éµå¾ªç¾å›½è‹±è¯­æ‹¼å†™ã€‚æ¡Œé¢å·¥å…·ï¼Œå¦‚ http://markdownpad.com å’Œ Visual Studioä»£ç  æœ‰æ‹¼å†™æ£€æŸ¥åŠŸèƒ½ã€‚ æ®µè½ç»“æ„ æ¯å¥è¯éƒ½åº”è¯¥å†™åœ¨ä¸€è¡Œï¼Œæ¯è¡Œåªèƒ½å†™ä¸€å¥è¯ã€‚è¿™ä½¿å¾—åˆå¹¶æ›´æ”¹æ›´å®¹æ˜“ï¼Œå¹¶æœ‰åŠ©äºè¯†åˆ«å†—é•¿çš„è¯­è¨€ã€‚Markdownä¸­çš„æ®µè½åªæ˜¯ä¸€è¡Œæˆ–å¤šè¡Œè¿ç»­æ–‡æœ¬ï¼Œåè·Ÿä¸€è¡Œæˆ–å¤šè¡Œç©ºç™½è¡Œã€‚ æ ‡é¢˜ æ ‡é¢˜åº”è¯¥ç”¨æ¥ç»„ç»‡æ–‡ä»¶ã€‚é¿å…ä½¿ç”¨å…¶ä»–å¼ºè°ƒåŠŸèƒ½ï¼Œå¦‚ALLCAPSï¼Œ æ–œä½“å­— æˆ– å¤§èƒ†çš„ ç¡®å®šä¸€ä¸ªæ–°çš„è¯é¢˜ã€‚ä½¿ç”¨æ ‡å¤´ä¸ä»…æ›´åŠ ä¸€è‡´ï¼Œè€Œä¸”å…è®¸é“¾æ¥åˆ°æ ‡å¤´ã€‚ é¡µè„š åœ¨é¡µé¢çš„æœ«å°¾ï¼Œé“¾æ¥åˆ°æ–‡æ¡£ä¸­çš„ä¸‹ä¸€ä¸ªé€»è¾‘é¡µé¢å¾ˆæœ‰å¸®åŠ©ã€‚å¦‚æœè¯¥é¡µæ˜¯å­èŠ‚ä¸­çš„æœ€åä¸€é¡µï¼Œåˆ™é“¾æ¥å›ç´¢å¼•é¡µæ˜¯æœ‰ç”¨çš„ã€‚ é£æ ¼ ä»£ç æ ¼å¼ ç¤ºä¾‹ä»£ç å—çš„æ ¼å¼åº”ä¸ºåé¢ç´§è·Ÿç€è¯­è¨€çš„ä¸‰ä¸ªåå‹¾å·æ ¼å¼ã€‚ [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> { ... } å°†å‘ˆç°ä¸º [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> ... { ... } å†…è”ä»£ç åº”è¯¥ç”¨ä¸€ä¸ªåå‹¾å·æ ‡è®°(`). å…¶ä¸­åŒ…æ‹¬ä»¥ä¸‹å‚è€ƒï¼š é”®å…¥åç§°ï¼Œä¾‹å¦‚ã€‚ Task<T> å˜é‡åï¼Œä¾‹å¦‚ã€‚ æ¸¸æˆ åç§°ç©ºé—´ï¼Œä¾‹å¦‚ã€‚ Orleansã€‚å­˜å‚¨ã€‚AzureTablesStorage å¦‚æœæ˜¾ç¤ºè¾“å‡ºçš„æ–‡æœ¬(ä¾‹å¦‚æ–‡æœ¬æ–‡ä»¶å†…å®¹æˆ–æ§åˆ¶å°è¾“å‡º)ï¼Œåˆ™å¯ä»¥ä½¿ç”¨åä¸‰å‹¾å·è€Œä¸æŒ‡å®šè¯­è¨€ï¼Œä¹Ÿå¯ä»¥ç¼©è¿›å†…å®¹ã€‚ä¾‹å¦‚ï¼š 1 said: Welcome to my team! 0 said: Thanks! 1 said: Thanks! 0 said: Thanks! æ–‡ä»¶åå’Œè·¯å¾„ å¼•ç”¨æ–‡ä»¶åã€ç›®å½•/æ–‡ä»¶å¤¹æˆ–URIæ—¶ï¼Œè¯·ä½¿ç”¨æ ‡å‡†æ–œä½“æ¥æ ¼å¼åŒ–ã€‚è¿™å¯ä»¥é€šè¿‡åœ¨å­—ç¬¦ä¸²å‘¨å›´åŠ ä¸Šä¸€ä¸ªæ˜Ÿå·æ¥å®Œæˆ( * )æˆ–è€…ä¸€ä¸ªä¸‹åˆ’çº¿( _ ) ç¤ºä¾‹ï¼š å¥¥å°”å‹’ansRuntimeInterfaces.dll Cï¼š \\äºŒè¿›åˆ¶æ–‡ä»¶ ../src/Grains.cs æ¡Œå­ æ ‡è®°æ”¯æ’‘ è¡¨æ ¼æ•°æ® . å¯ä»¥ä½¿ç”¨è¡¨æ¥æ„é€ æ•°æ®ï¼Œä»¥ä¾¿è¯»è€…å¯ä»¥è½»æ¾åœ°ä½¿ç”¨è¿™äº›æ•°æ®ã€‚ åç¼€ å•ä½ å¥³å£« æ¯«ç§’ s ç§’ ç±³ åˆ†é’Ÿ é“¾æ¥ å¼•ç”¨å¦ä¸€ä¸ªæ¦‚å¿µæ—¶ï¼Œè¯·æä¾›æŒ‡å‘è¯¥æ¦‚å¿µçš„é“¾æ¥ã€‚é¡µé¢ä¸­çš„æ­£å‘å’Œåå‘å¼•ç”¨å¯ä»¥é€šè¿‡é¡µçœ‰è¿›è¡Œé“¾æ¥ã€‚eã€ g.é“¾æ¥å› ç»“æ„ æŒ‡å‘å…¶ä»–æ–‡æ¡£çš„é“¾æ¥æ—¢å¯ä»¥é“¾æ¥åˆ°é¡µé¢ï¼Œä¹Ÿå¯ä»¥é“¾æ¥åˆ°é¡µé¢ä¸­çš„å­èŠ‚/é¡µçœ‰ã€‚å¤–éƒ¨é“¾æ¥åº”ä½œä¸ºå®Œæ•´é“¾æ¥å…¬å¼€ã€‚ä¾‹å¦‚ https://github.com/dotnet/roslyn è´¡çŒ® Orleansæ–‡æ¡£ä½œä¸ºé™ä»·æ–‡ä»¶ç®¡ç†åœ¨æ‰˜ç®¡åœ¨ä¸Šçš„Gitå­˜å‚¨åº“ä¸­ gh pagesåˆ†éƒ¨çš„GitHub . è§ GitHubé¡µé¢ æœ‰å…³å¦‚ä½•ä½¿ç”¨ ghé¡µé¢ â€œé¡¹ç›®ç°åœºâ€æ–‡ä»¶çš„åˆ†æ”¯çº¦å®šã€‚"
  },
  "Documentation/resources/frequently_asked_questions.html": {
    "href": "Documentation/resources/frequently_asked_questions.html",
    "title": "Frequently Asked Questions | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¸¸è§é—®é¢˜è§£ç­” å¯åˆ©ç”¨æ€§ æˆ‘å¯ä»¥åœ¨æˆ‘çš„é¡¹ç›®ä¸­å…è´¹ä½¿ç”¨Orleanså—ï¼Ÿ å½“ç„¶ã€‚æºä»£ç å·²ç»åœ¨ éº»çœç†å·¥å­¦é™¢æ‰§ç…§ . NuGetåŒ…å‘å¸ƒäº nuget.orgç½‘ç«™ . Orleansçš„ç”Ÿäº§å‡†å¤‡å¥½äº†å—ï¼Ÿæˆ‘å¬è¯´è¿™æ˜¯ä¸€ä¸ªç ”ç©¶é¡¹ç›®ã€‚ å®é™…ä¸Šï¼ŒOrleansæœ€åˆæ˜¯ä½œä¸ºå¾®è½¯ç ”ç©¶é™¢çš„ä¸€ä¸ªç ”ç©¶é¡¹ç›®å¼€å§‹çš„ã€‚å®ƒåæ¥æˆé•¿ä¸ºä¸€ç§äº§å“ï¼Œè‡ª2011å¹´èµ·åœ¨å¾®è½¯å†…éƒ¨æŠ•å…¥ç”Ÿäº§ï¼Œå¹¶åœ¨2015å¹´å…¬å¼€å‘å¸ƒåè¢«å…¶ä»–ä½¿ç”¨ã€‚Orleanså·²ç»åšå¥½äº†ç”Ÿäº§å‡†å¤‡ï¼Œä¸ºè®¸å¤šé«˜å¯ç”¨æ€§ç³»ç»Ÿå’Œäº‘æœåŠ¡æä¾›äº†åŠ¨åŠ›ã€‚ å¾®è½¯æ”¯æŒOrleanså—ï¼Ÿ Orleansçš„æºä»£ç å·²ç»åœ¨éº»çœç†å·¥å­¦é™¢æˆæƒä¸‹å‘å¸ƒ GitHub . å¾®è½¯ç»§ç»­åœ¨OrleansæŠ•èµ„ï¼Œå¹¶æ¥å—ç¤¾åŒºå¯¹ä»£ç åº“çš„è´¡çŒ®ã€‚ å®šä½ Orleansæ˜¯æœåŠ¡å™¨äº§å“å—ï¼Ÿæˆ‘å¦‚ä½•ç®¡ç†Orleansï¼Ÿ Orleansæ˜¯ä¸€ä¸ªæ¡†æ¶ï¼Œä¸€ç»„åº“ï¼Œå¯ä»¥å¸®åŠ©æ‚¨æ„å»ºåº”ç”¨ç¨‹åºã€‚åŸºäºOrleansçš„åº”ç”¨ç¨‹åºå¯ä»¥åœ¨å„ç§æ‰˜ç®¡ç¯å¢ƒä¸­è¿è¡Œï¼Œåœ¨äº‘ç«¯æˆ–æœ¬åœ°é›†ç¾¤ä¸­ï¼Œç”šè‡³åœ¨ä¸€å°æœºå™¨ä¸Šã€‚åº”ç”¨ç¨‹åºå¼€å‘äººå‘˜è´Ÿè´£åœ¨å…¶ç›®æ ‡å®¿ä¸»ç¯å¢ƒä¸­æ„å»ºã€éƒ¨ç½²å’Œè¿è¡ŒåŸºäºOrleansçš„åº”ç”¨ç¨‹åºã€‚ æˆ‘åœ¨å“ªé‡Œå¯ä»¥è·‘Orleansï¼Ÿ Orleanså¯ä»¥åœ¨ä»»ä½•.NETåº”ç”¨ç¨‹åºå¯ä»¥è¿è¡Œçš„ç¯å¢ƒä¸­è¿è¡Œã€‚åœ¨Orleans 2.0ä¹‹å‰ï¼Œå®ƒéœ€è¦å®Œæ•´çš„.NETæ¡†æ¶ã€‚ä»2.0å¼€å§‹ï¼ŒOrleanséµå¾ª.NETæ ‡å‡†2.0ï¼Œå› æ­¤å¯ä»¥åœ¨æ”¯æŒ.NETCoreçš„Windowså’ŒéWindowsç¯å¢ƒä¸­è¿è¡Œ.NETCoreã€‚ Orleansæ˜¯ä¸ºè”šè“è€Œå»ºçš„å—ï¼Ÿ ä¸ï¼Œæˆ‘ä»¬ç›¸ä¿¡ä½ åº”è¯¥å¯ä»¥åœ¨ä»»ä½•ä½ éœ€è¦çš„åœ°æ–¹ï¼Œä»¥ä½ éœ€è¦çš„æ–¹å¼ç®¡ç†Orleansã€‚Orleanséå¸¸çµæ´»ï¼Œå¹¶ä¸”æœ‰è®¸å¤šå¯é€‰çš„æä¾›å•†å¸®åŠ©åœ¨äº‘ç¯å¢ƒä¸­æ‰˜ç®¡å®ƒï¼Œæ¯”å¦‚Azureã€AWSæˆ–GCPï¼Œæˆ–è€…æœ¬åœ°é›†ç¾¤ï¼Œå¯ä»¥é€‰æ‹©æ”¯æŒOrleansé›†ç¾¤åè®®çš„æŠ€æœ¯ã€‚ Orleanså’Œå…¶ä»–actorè¯­è¨€å’Œæ¡†æ¶(æ¯”å¦‚Erlangæˆ–Akka)æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ è™½ç„¶åŸºäºActoræ¨¡å‹çš„ç›¸åŒåŸºæœ¬åŸåˆ™ï¼Œä½†Orleanså‘å‰è¿ˆè¿›äº†ä¸€æ­¥ï¼Œå¼•å…¥äº†è™šæ‹Ÿå‚ä¸è€…çš„æ¦‚å¿µï¼Œè¯¥æ¦‚å¿µæå¤§åœ°ç®€åŒ–äº†å¼€å‘äººå‘˜çš„ä½“éªŒï¼Œå¹¶ä¸”æ›´é€‚åˆäºäº‘æœåŠ¡å’Œé«˜è§„æ¨¡ç³»ç»Ÿã€‚ è®¾è®¡ åœ¨æˆ‘çš„åº”ç”¨ç¨‹åºä¸­ï¼ŒGrainsåº”è¯¥æœ‰å¤šå¤§æˆ–å¤šå°ï¼Ÿ grainséš”ç¦»æ¨¡å‹ä½¿å®ƒä»¬èƒ½å¤Ÿå¾ˆå¥½åœ°è¡¨ç¤ºç‹¬ç«‹çš„çŠ¶æ€å’Œè®¡ç®—ä¸Šä¸‹æ–‡ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œgrainsè‡ªç„¶åœ°æ˜ å°„åˆ°ç”¨æˆ·ã€ä¼šè¯ã€å¸æˆ·ç­‰åº”ç”¨ç¨‹åºå®ä½“ã€‚è¿™äº›å®ä½“é€šå¸¸å½¼æ­¤éš”ç¦»ï¼Œå¯ä»¥ç‹¬ç«‹è®¿é—®å’Œæ›´æ–°ï¼Œå¹¶å…¬å¼€ä¸€ç»„å®šä¹‰è‰¯å¥½çš„å—æ”¯æŒæ“ä½œã€‚è¿™ä¸ç›´è§‚çš„â€œä¸€ä¸ªå®ä½“-ä¸€ä¸ªçº¹ç†â€æ¨¡å‹å¾ˆå¥½åœ°é…åˆä½¿ç”¨ã€‚ å¦‚æœä¸€ä¸ªåº”ç”¨ç¨‹åºå®ä½“å°è£…äº†å¤ªå¤šçš„çŠ¶æ€ï¼Œé‚£ä¹ˆå®ƒå¯èƒ½å¤ªå¤§ï¼Œæ— æ³•ç”¨å•ä¸ªgrainsæœ‰æ•ˆåœ°è¡¨ç¤ºï¼Œå› æ­¤å¿…é¡»å¤„ç†å¯¹å®ƒçš„é«˜é€Ÿç‡è¯·æ±‚ã€‚å°½ç®¡ä¸€ä¸ªå•ç‹¬çš„grainé€šå¸¸æ¯ç§’å¯ä»¥å¤„ç†å‡ åƒä¸ªçç¢çš„è°ƒç”¨ï¼Œä½†ç»éªŒæ³•åˆ™æ˜¯è¦è­¦æƒ•å•ä¸ªgrainæ¯ç§’æ¥æ”¶æ•°ç™¾ä¸ªè¯·æ±‚ã€‚è¿™å¯èƒ½æ˜¯Grainså¤ªå¤§çš„è¿¹è±¡ï¼Œå°†å…¶åˆ†è§£æˆä¸€ç»„æ›´å°çš„grainså¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªæ›´ç¨³å®šå’Œå¹³è¡¡çš„ç³»ç»Ÿã€‚ ä¸€ä¸ªåº”ç”¨ç¨‹åºå®ä½“å¯èƒ½å¤ªå°è€Œä¸èƒ½æˆä¸ºä¸€ä¸ªGrainï¼Œå¦‚æœè¿™ä¼šå¯¼è‡´å…¶ä»–Grainä¸ä¹‹æŒç»­äº¤äº’ï¼Œå¹¶å› æ­¤å¯¼è‡´å¤ªå¤šçš„æ¶ˆæ¯ä¼ é€’å¼€é”€ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè®©é‚£äº›ç›¸äº’ä½œç”¨å¯†åˆ‡çš„å®ä½“æˆä¸ºå•ä¸ªgrainsçš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥ç›´æ¥ç›¸äº’è°ƒç”¨äº†ã€‚ å¦‚ä½•é¿å…grainçƒ­ç‚¹ï¼Ÿ Grainsçš„ååé‡å—å•ä¸ªçº¿ç¨‹çš„é™åˆ¶ï¼Œè¯¥çº¿ç¨‹çš„æ¿€æ´»å¯ä»¥åœ¨è¯¥çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚å› æ­¤ï¼Œå»ºè®®é¿å…ä¸€ä¸ªå•ç‹¬çš„Grainæ¥æ”¶åˆ°ä¸ç›¸ç§°çš„è¯·æ±‚ä»½é¢æˆ–å‚ä¸å¤„ç†å¯¹å…¶ä»–Grainçš„è¯·æ±‚çš„è®¾è®¡ã€‚æœ‰å¤šç§æ¨¡å¼å¯ä»¥å¸®åŠ©é˜²æ­¢å•ä¸ªgrainsè¿‡è½½ï¼Œå³ä½¿åœ¨é€»è¾‘ä¸Šå®ƒæ˜¯é€šä¿¡çš„ä¸­å¿ƒç‚¹ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªgrainæ˜¯ç”±å¤§é‡grainå®šæœŸæŠ¥å‘Šçš„ä¸€äº›è®¡æ•°å™¨æˆ–ç»Ÿè®¡ä¿¡æ¯çš„èšåˆå™¨ï¼Œä¸€ç§è¡Œä¹‹æœ‰æ•ˆçš„æ–¹æ³•æ˜¯æ·»åŠ æ§åˆ¶æ•°é‡çš„ä¸­é—´èšåˆå™¨Grainï¼Œå¹¶å°†æ¯ä¸ªæŠ¥å‘ŠGrain(ä½¿ç”¨é”®ä¸Šçš„æ¨¡æˆ–æ•£åˆ—)åˆ†é…ç»™ä¸­é—´èšåˆå™¨ï¼Œä»¥ä¾¿è´Ÿè½½æˆ–å¤šæˆ–å°‘åœ°å‡åŒ€åˆ†å¸ƒåœ¨æ‰€æœ‰ä¸­é—´èšé›†grainsä¸Šï¼Œè¿™äº›ä¸­é—´èšé›†grainså®šæœŸå‘ä¸­å¤®èšé›†grainsæŠ¥å‘Šéƒ¨åˆ†èšé›†ç‰©ã€‚ å¦‚ä½• æˆ‘æ€æ ·æ‰èƒ½æ’•ä¸‹ä¸€ç²’Grainsï¼Ÿ ä¸€èˆ¬æ¥è¯´ï¼Œä¸éœ€è¦åº”ç”¨ç¨‹åºé€»è¾‘æ¥å¼ºåˆ¶å–æ¶ˆæ¿€æ´»grainï¼Œå› ä¸ºOrleansè¿è¡Œæ—¶ä¼šè‡ªåŠ¨æ£€æµ‹å¹¶åœç”¨grainçš„ç©ºé—²æ¿€æ´»ä»¥å›æ”¶ç³»ç»Ÿèµ„æºã€‚è®©Orleansè¿™æ ·åšæ›´æœ‰æ•ˆï¼Œå› ä¸ºå®ƒæ‰¹å¤„ç†åœç”¨æ“ä½œï¼Œè€Œä¸æ˜¯é€ä¸ªæ‰§è¡Œå®ƒä»¬ã€‚åœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œå½“æ‚¨è®¤ä¸ºç¡®å®éœ€è¦åŠ å¿«grainsçš„å¤±æ´»ï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨ base.DeactivateOnIdle() æ–¹æ³•ã€‚ æˆ‘èƒ½å‘Šè¯‰Orleansåœ¨å“ªé‡Œæ¿€æ´»Grainså—ï¼Ÿ ä½¿ç”¨é™åˆ¶æ€§çš„å¸ƒå±€ç­–ç•¥æ˜¯å¯ä»¥åšåˆ°çš„ï¼Œä½†æˆ‘ä»¬é€šå¸¸è®¤ä¸ºè¿™æ˜¯ä¸€ç§éå¸¸å…ˆè¿›çš„æ¨¡å¼ï¼Œéœ€è¦ä»”ç»†è€ƒè™‘ã€‚é€šè¿‡æŒ‰ç…§é—®é¢˜çš„å»ºè®®æ¥åšï¼Œåº”ç”¨ç¨‹åºå°†æ‰¿æ‹…èµ„æºç®¡ç†çš„è´Ÿæ‹…ï¼Œè€Œä¸ä¸€å®šè¦æœ‰è¶³å¤Ÿçš„å…³äºç³»ç»Ÿå…¨å±€çŠ¶æ€çš„ä¿¡æ¯æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚åœ¨silosé‡å¯çš„æƒ…å†µä¸‹ï¼Œè¿™ç§æƒ…å†µå°¤å…¶é€‚å¾—å…¶åï¼Œåœ¨äº‘ç¯å¢ƒä¸­ï¼Œæ“ä½œç³»ç»Ÿè¡¥ä¸å¯èƒ½ä¼šå®šæœŸå‘ç”Ÿè¿™ç§æƒ…å†µã€‚å› æ­¤ï¼Œç‰¹å®šä½ç½®å¯èƒ½ä¼šå¯¹åº”ç”¨ç¨‹åºçš„å¯ä¼¸ç¼©æ€§ä»¥åŠå¯¹ç³»ç»Ÿæ•…éšœçš„æ¢å¤èƒ½åŠ›äº§ç”Ÿè´Ÿé¢å½±å“ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºåº”ç”¨ç¨‹åºç¡®å®çŸ¥é“åº”è¯¥åœ¨ä½•å¤„æ¿€æ´»ç‰¹å®šgrainsçš„ç½•è§æƒ…å†µï¼Œä¾‹å¦‚ï¼Œå¦‚æœå®ƒçŸ¥é“grainæŒä¹…çŠ¶æ€çš„ä½ç½®ï¼Œé‚£ä¹ˆåœ¨1.5.0ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†è‡ªå®šä¹‰å­˜å‚¨ç­–ç•¥å’Œæ§åˆ¶å™¨ã€‚ å¦‚ä½•å¯¹grainsè¿›è¡Œç‰ˆæœ¬è®¾ç½®æˆ–æ·»åŠ æ–°çš„grainç±»å’Œæ¥å£ï¼Ÿ æ‚¨å¯ä»¥å‘æ­£åœ¨è¿è¡Œçš„é›†ç¾¤ä¸­æ·»åŠ å…·æœ‰æ–°Grainç±»æˆ–ç°æœ‰Grainç±»çš„æ–°ç‰ˆæœ¬çš„silosã€‚ æˆ‘èƒ½ä»å…¬å…±äº’è”ç½‘è¿æ¥åˆ°Orleansçš„å‘å°„äº•å—ï¼Ÿ Orleansè¢«è®¾è®¡ä¸ºä½œä¸ºæœåŠ¡çš„åç«¯éƒ¨åˆ†è¿›è¡Œæ‰˜ç®¡ï¼Œæ‚¨éœ€è¦åˆ›å»ºä¸€ä¸ªå¤–éƒ¨å®¢æˆ·ç«¯å°†è¿æ¥åˆ°çš„å‰ç«¯å±‚ã€‚å®ƒå¯ä»¥æ˜¯åŸºäºHTTPçš„webapié¡¹ç›®ã€socketæœåŠ¡å™¨ã€signalæœåŠ¡å™¨æˆ–å…¶ä»–ä»»ä½•é€‚åˆåº”ç”¨ç¨‹åºéœ€è¦çš„æœåŠ¡å™¨ã€‚å¦‚æœæ‚¨å°†ç«–äº•çš„TCPç«¯ç‚¹æš´éœ²ç»™å®ƒï¼Œæ‚¨å¯ä»¥ä»Internetè¿æ¥åˆ°Orleansï¼Œä½†æ˜¯ä»å®‰å…¨æ€§çš„è§’åº¦æ¥çœ‹ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¥½çš„å®è·µã€‚ å¦‚æœåœ¨æˆ‘çš„Grainsè°ƒç”¨è¿”å›å¯¹æˆ‘çš„è°ƒç”¨çš„å“åº”ä¹‹å‰å‘ç”Ÿæ•…éšœï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ å¦‚æœåœ¨grainè°ƒç”¨è¿‡ç¨‹ä¸­å‘ç”Ÿsilosæ•…éšœï¼Œæ‚¨å°†æ”¶åˆ°ä¸€ä¸ªå¼‚å¸¸ï¼Œæ‚¨å¯ä»¥åœ¨ä»£ç ä¸­æ•è·å¹¶é‡è¯•ï¼Œæˆ–è€…æ ¹æ®åº”ç”¨ç¨‹åºé€»è¾‘æ‰§è¡Œå…¶ä»–æ“ä½œæ¥å¤„ç†é”™è¯¯ã€‚åœ¨silosä¸­å¤±è´¥çš„Grainså°†åœ¨ä¸‹æ¬¡è°ƒç”¨æ—¶è‡ªåŠ¨é‡æ–°å®ä¾‹åŒ–ã€‚Orleansè¿è¡Œæ—¶å¹¶ä¸æ€¥äºä»ä¸€ä¸ªå¤±è´¥çš„silosä¸­é‡æ–°åˆ›å»ºGrainsï¼Œå› ä¸ºå®ƒä»¬ä¸­çš„è®¸å¤šå¯èƒ½ä¸æ˜¯ç«‹å³éœ€è¦çš„ï¼Œæˆ–è€…æ ¹æœ¬å°±ä¸éœ€è¦ã€‚ç›¸åï¼Œè¿è¡Œæ—¶ä¼šå•ç‹¬åœ°é‡æ–°åˆ›å»ºè¿™äº›Grainï¼Œå¹¶ä¸”åªæœ‰åœ¨é’ˆå¯¹ç‰¹å®šGrainçš„æ–°è¯·æ±‚åˆ°è¾¾æ—¶ã€‚å¯¹äºæ¯ä¸€ç²’Grainsï¼Œå®ƒä»ä¸€ä¸ªå¯ç”¨çš„silosä¸­æŒ‘é€‰ä¸€ä¸ªä½œä¸ºæ–°çš„å¯„ä¸»ã€‚ è¿™ç§æ–¹æ³•çš„å¥½å¤„æ˜¯ï¼Œå›æ”¶è¿‡ç¨‹åªå¯¹å®é™…ä½¿ç”¨çš„Grainsæ‰§è¡Œï¼Œè€Œä¸”å®ƒä¼šåŠæ—¶åˆ†å¸ƒåœ¨æ‰€æœ‰å¯ç”¨çš„silosä¸­ï¼Œè¿™æé«˜äº†ç³»ç»Ÿçš„å“åº”èƒ½åŠ›å’Œå›æ”¶é€Ÿåº¦ã€‚è¿˜è¦æ³¨æ„ï¼Œåœ¨siloså‘ç”Ÿæ•…éšœå’ŒOrleansé›†ç¾¤æ£€æµ‹åˆ°æ•…éšœä¹‹é—´å­˜åœ¨å»¶è¿Ÿã€‚å»¶è¿Ÿæ˜¯æ£€æµ‹é€Ÿåº¦å’Œè¯¯æŠ¥æ¦‚ç‡ä¹‹é—´çš„å¯é…ç½®æŠ˜è¡·ã€‚åœ¨æ­¤è¿‡æ¸¡æœŸé—´ï¼Œå¯¹Grainsçš„æ‰€æœ‰è°ƒç”¨éƒ½å°†å¤±è´¥ï¼Œä½†åœ¨æ£€æµ‹åˆ°æ•…éšœåï¼Œå°†åœ¨å¦ä¸€ä¸ªsilosä¸Šåˆ›å»ºä¸€ä¸ªæ–°çš„Grainsè°ƒç”¨ï¼Œå› æ­¤å®ƒæœ€ç»ˆå°†å¯ç”¨ã€‚ å¦‚æœGrainsè°ƒç”¨æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ ç”±äºOrleansä½¿ç”¨ä¸€ä¸ªåä½œçš„å¤šä»»åŠ¡æ¨¡å‹ï¼Œå®ƒä¸ä¼šè‡ªåŠ¨æŠ¢å grainçš„æ‰§è¡Œï¼Œä½†æ˜¯Orleansä¼šä¸ºé•¿æ—¶é—´æ‰§è¡Œçš„grainè°ƒç”¨ç”Ÿæˆè­¦å‘Šï¼Œä»¥ä¾¿æ‚¨å¯ä»¥æ£€æµ‹åˆ°å®ƒä»¬ã€‚ä¸æŠ¢å å¼å¤šä»»åŠ¡ç›¸æ¯”ï¼Œåä½œå¤šä»»åŠ¡å…·æœ‰æ›´å¥½çš„ååé‡ã€‚è¯·è®°ä½ï¼Œgrainè°ƒç”¨ä¸åº”åŒæ­¥æ‰§è¡Œä»»ä½•é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼Œå¦‚IOæ“ä½œï¼Œä¹Ÿä¸åº”é˜»å¡å…¶ä»–è¦å®Œæˆçš„ä»»åŠ¡ã€‚æ‰€æœ‰ç­‰å¾…éƒ½åº”è¯¥ä½¿ç”¨å¼‚æ­¥æ–¹å¼å®Œæˆawaitæˆ–å…¶ä»–å¼‚æ­¥å…³é”®å­—ç­‰å¾…æœºåˆ¶ã€‚Grainsåº”è¯¥å°½å¿«è¿”å›ï¼Œè®©å…¶ä»–Grainsæ‰§è¡Œä»¥è·å¾—æœ€å¤§ååé‡ã€‚"
  },
  "Documentation/resources/index.html": {
    "href": "Documentation/resources/index.html",
    "title": "Resources | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "èµ„æºèµ„æº è´¡çŒ® å¯¹äºè¦ä¸ºOrleansåšè´¡çŒ®çš„å¼€å‘äººå‘˜çš„ä¸€äº›è¯´æ˜å’Œå‡†åˆ™ã€‚ æ–‡ä»¶æŒ‡å— Orleansæ–‡æ¡£å†…ç½®åœ¨Markdownä¸­ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸€äº›ç®€å•çš„çº¦å®šæ¥ç¡®ä¿æ•´ä¸ªæ–‡æ¡£çš„é£æ ¼ç»Ÿä¸€ã€‚ é“¾æ¥ é“¾æ¥åˆ°Orleanså›¢é˜Ÿæˆå‘˜å’Œå…¶ä»–äººçš„æ–‡ç« ã€‚ ç®€æŠ¥ æœ‰å…³ä¸»é¢˜çš„PowerPointæ¼”ç¤ºæ–‡ç¨¿çš„é›†åˆï¼Œè¿™äº›ä¸»é¢˜åŒ…æ‹¬â€œOrleansæœ€ä½³å®è·µâ€ï¼Œâ€œå¹³è¡¡æŠ€æœ¯â€å’Œâ€œæµâ€ã€‚"
  },
  "1.5/Documentation/Event-Sourcing/Overview.html": {
    "href": "1.5/Documentation/Event-Sourcing/Overview.html",
    "title": "Event Sourcing | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Event Sourcing Event sourcing provides a flexible way to manage and persist grain state. An event-sourced grain has many potential advantages over a standard grain. For one, it can be used with many different storage provider configurations, and supports geo-replication across multiple clusters. Moreover, it cleanly separates the grain class from definitions of the grain state (represented by a grain state object) and grain updates (represented by event objects). The documentation is structured as follows: JournaledGrain Basics explains how to define an event-sourced grains by deriving from JournaledGrain , how to access the current state, and how to raise events that update the state. Replicated Instances explains how the event-sourcing mechanism handles replicated grain instances and ensures consistency. It discusses the possibility of racing events and conflicts, and how to address them. Immediate/Delayed Confirmation explains how delayed confirmation of events, and reentrancy, can improve availability and throughput. Notifications explains how to subscribe to notifications, allowing grains to react to new events. Configuration explains how to configure projects, clusters, and log-consistency providers. Built-In Log-Consistency Providers explains how the three currently included log-consistency providers work. Diagnostics explains how to monitor for connection errors, and get simple statistics. The behavior documented above is reasonably stable, as far as the JournaledGrain API is concerned. However, we expect to extend or change the list of log consistency providers soon, to more easily allow developers to plug in standard event storage systems."
  },
  "1.5/Documentation/Event-Sourcing/MultiVersion.html": {
    "href": "1.5/Documentation/Event-Sourcing/MultiVersion.html",
    "title": "Immediate vs. Delayed Confirmation | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Immediate Confirmation For many applications, we want to ensure that events are confirmed immediately, so that the persisted version does not lag behind the current version in memory, and we do not risk losing the latest state if the grain should fail. We can guarantee this by following these rules: Confirm all RaiseEvent calls using ConfirmEvents before the grain method returns. Make sure tasks returned by RaiseConditionalEvent complete before the grain method returns. Avoid [Reentrant] or [AlwaysInterleave] attributes, so only one grain call can be processed at a time. If we follow these rules, it means that after an event is raised, no other grain code can execute until the event has been written to storage. Therefore, it is impossible to observe inconsistencies between the version in memory and the version in storage. While this is often exactly what we want, it also has some potential disadvantages. Potential Disadvantages if the connection to a remote cluster or to storage is temporarily interrupted , then the grain becomes unavailable: effectively, the grain cannot execute any code while it is stuck waiting to confirm the events, which can take an indefinite amount of time (the log-consistency protocol keeps retrying until storage connectivity is restored). when handling a lot of of updates to a single grain instance , confirming them one at a time can become very inefficient, i.e. have poor throughput. Delayed Confirmation To improve availability and throughput in the situations mentioned above, grains can choose to do one or both of the following: allow grain methods to raise events without waiting for confirmation. allow reentrancy, so the grain can keep processing new calls even if previous calls get stuck waiting for confirmation. This means it is possible for grain code to execute while some events are still in the process of being confirmed. The JournaledGrain API has some specific provisions to give developers precise control over how to deal with unconfirmed events that are currently \"in flight\". The following property can be examined to find out what events are currently unconfirmed: IEnumerable<EventType> UnconfirmedEvents { get; } Also, since the state returned by the State property does not include the effect of unconfirmed events, there is an alternative property StateType TentativeState { get; } which returns a \"tentative\" state, obtained from \"State\" by applying all the unconfirmed events. The tentative state is essentially a \"best guess\" at what will likely become the next confirmed state, after all unconfirmed events are confirmed. However, there is no guarantee that it actually will, because the grain may fail, or because the events may race against other events and lose, causing them to be canceled (if they are conditional) or appear at a later position in the sequence than anticipated (if they are unconditional). Concurrency Guarantees Note that Orleans turn-based scheduling (cooperative concurrency) guarantees always apply, even when using reentrancy or delayed confirmation. This means that even though several methods may be in progress, only one can be actively executing --- all others are stuck at an await, so there are never any true races caused by parallel threads. In particular, note that: The properties State , TentativeState , Version , and UnconfirmedEvents can change during the execution of a method. But such changes can only happen while stuck at an await. These guarantees assume that the user code stays within the recommended practice with respect to tasks and async/await (in particular, does not use thread pool tasks, or only uses them for code that does not call grain functionality and that are properly awaited)."
  },
  "1.5/Documentation/Event-Sourcing/Subscribe.html": {
    "href": "1.5/Documentation/Event-Sourcing/Subscribe.html",
    "title": "Notifications | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Notifications It is often convenient to have the ability to react to state changes. All callbacks are subject to Orleans' turn-based guarantees; see also the section on Concurrency Guarantees . Tracking Confirmed State To be notified of any changes to the confirmed state, JournaledGrain subclasses can override this method: protected override void OnStateChanged() { // read state and/or event log and take appropriate action } OnStateChanged is called whenever the confirmed state is updated, i.e. the version number increases. This can happen when A newer version of the state was loaded from storage. An event that was raised by this instance has been successfully written to storage. A notification message was received from some other instance. Note that since all grains initially have version zero, until the initial load from storage completes, this means that OnStateChanged is called whenever the initial load completes with a version larger than zero. Tracking Tentative State To be notified of any changes to the tentative state, JournaledGrain subclasses can override this method: protected override void OnTentativeStateChanged() { // read state and/or events and take appropriate action } OnTentativeStateChanged is called whenever the tentative state changes, i.e. if the combined sequence (ConfirmedEvents + UnconfirmedEvents) changes. In particular, a callback to OnTentativeStateChanged() always happens during RaiseEvent ."
  },
  "1.5/Documentation/Event-Sourcing/Diagnostics.html": {
    "href": "1.5/Documentation/Event-Sourcing/Diagnostics.html",
    "title": "JournaledGrain Diagnostics | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . JournaledGrain Diagnostics Monitoring Connection Errors By design, log consistency providers are resilient under connection errors (including both connections to storage, and connections between clusters). But just tolerating errors is not enough, as applications usually need to monitor any such issues, and bring them to the attention of an operator if they are serious. JournaledGrain subclasses can override the following methods to receive notifiations when there are connection errors observed, and when those errors are resolved: protected override void OnConnectionIssue(ConnectionIssue issue) { /// handle the observed error described by issue } protected override void OnConnectionIssueResolved(ConnectionIssue issue) { /// handle the resolution of a previously reported issue } ConnectionIssue is an abstract class, with several common fields describing the issue, including how many times it has been observed since the last time connection was successful. The actual type of connection issue is defined by subclasses. Connection issues are categorized into types, such as PrimaryOperationFailed or NotificationFailed , and sometimes have extra keys (such as RemoteCluster ) that further narrow the category. If the same category of issue happens several times (for example, we keep getting a NotificationFailed that targets the same RemoteCluster ), it is reported each time by OnConnectionIssue . Once this category of issue is resolved (for example, we are finally successful with sending a notification to this RemoteCluster ), then OnConnectionIssueResolved is called once, with the same issue object that was last reported by OnConnectionIssue . Connection issues, and their resolution, for independent categories, are reported independently. Simple Statistics We currently offer a simple support for basic statistics (in the future, we will probably replace this with a more standard telemetry mechanism). Statistics collection can be enabled or disabled for a JournaledGrain by calling void EnableStatsCollection() void DisableStatsCollection() The statistics can be retrieved by calling LogConsistencyStatistics GetStats()"
  },
  "1.5/Documentation/Advanced-Concepts/Application-Bootstrap-within-a-Silo.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Application-Bootstrap-within-a-Silo.html",
    "title": "Application Bootstrapping within a Silo | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Application Bootstrapping within a Silo There are several scenarios where application want to run some \"auto-exec\" functions when a silo comes online. Some examples include, but are not limited to: Starting background timers to perform periodic housekeeping tasks Pre-loading some cache grains with data downloaded from external backing storage. We have now added support for this auto-run functionality through configuring \"bootstrap providers\" for Orleans silos. For example: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <BootstrapProviders> <Provider Type=\"My.App.BootstrapClass1\" Name=\"bootstrap1\" /> <Provider Type=\"My.App.BootstrapClass2\" Name=\"bootstrap2\" /> </BootstrapProviders> </Globals> </OrleansConfiguration> It is also possible to register Bootstrap provider programaticaly, via calling one of the: public void RegisterBootstrapProvider(string providerTypeFullName, string providerName, IDictionary<string, string> properties = null) public void RegisterBootstrapProvider<T>(string providerName, IDictionary<string, string> properties = null) where T : IBootstrapProvider on the Orleans.Runtime.Configuration.GlobalConfiguration class. These bootstrap providers are C# classes that implement the Orleans.Providers.IBootstrapProvider interface. When each silo starts up, the Orleans runtime will instantiate each of the listed app bootstrap classes, and then call their Init method in an appropriate runtime execution context that allows those classes to act as a client and send messages to grains. There should be no blocking calls made inside the Init method. Task Init( string name, IProviderRuntime providerRuntime, IProviderConfiguration config) Any Exceptions that are thrown from an Init method of a bootstrap provider will be reported by the Orleans runtime in the silo log, then the silo startup will be halted. This fail-fast approach is the standard way that Orleans handles silo start-up issues, and is intended to allow any problems with silo configuration and/or bootstrap logic to be easily detected during testing phases rather than being silently ignored and causing unexpected problems later in the silo lifecycle."
  },
  "1.5/Documentation/Advanced-Concepts/Powershell-Client.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Powershell-Client.html",
    "title": "PowerShell Client Module | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . PowerShell Client Module The Orleans PowerShell Client Module is a set of PowerShell Cmdlets that wraps GrainClient in a set of convenient commands making possible to interact with not just ManagementGrain but any IGrain just as a regular Orleans application can by using Powershell scripts. These Cmdlets enable a series of scenarios from start maintenance tasks, tests, monitoring or any other kind of automation by leveraging Powershell scripts. Here is how to use it: Installing the module From Source You can build from source the OrleansPSUtils project and just import it with: PS> Import-Module .\\projectOutputDir\\Orleans.psd1 Althought you can do that, there is a much easier and interesting way for doing that by installing it from PowerShell Gallery . From PowerShell Gallery Powershell modules today are easily shared just as Nuget packages but instead of nuget.org, they are hosted on PowerShell Gallery . To install it on a specific folder just run: PS> Save-Module -Name OrleansPSUtils -Path <path> To install it on your PowerShell modules path ( the recommended way ), just run: PS> Install-Module -Name OrleansPSUtils If you plan to use this module on an Azure Automation , just click on the button bellow: Using the module Regardless of the way you decide to install it, the first thing you need to do in order to actually use it is import the module on the current PowerShell session so the Cmdlets get available by running this: PS> Import-Module OrleansPSUtils Note : In case of building from source, you must import it as suggested on the Install section by using the path to the .psd1 instead of using the module name since it will not be on the $env:PSModulePath PowerShell runtime variable. Again, it is highly recommended that you install from PowerShell Gallery instead. After the module is imported (which means it is loaded on PowerShell session), you will have the following Cmdlets available: Start-GrainClient Stop-GrainClient Get-Grain Start-GrainClient This module is a wrapper around GrainClient.Initialize() and its overloads. Usage : Start-GrainClient The same as call GrainClient.Initialize() which will look for the known Orleans Client configuration file names Start-GrainClient [-ConfigFilePath] <string> [[-Timeout] <timespan>] Will use the provided file path as in GrainClient.Initialize(filePath) Start-GrainClient [-ConfigFile] <FileInfo> [[-Timeout] <timespan>] Use an instance of the System.FileInfo class representing the config file just as GrainClient.Initialize(fileInfo) Start-GrainClient [-Config] <ClientConfiguration> [[-Timeout] <timespan>] Use an instance of a Orleans.Runtime.Configuration.ClientConfiguration like in GrainClient.Initialize(config) Start-GrainClient [-GatewayAddress] <IPEndPoint> [[-OverrideConfig] <bool>] [[-Timeout] <timespan>] Takes a Orleans Cluster Gateway Address Endpoint Note : The Timeout parameter is optional and if it is informed and greater than System.TimeSpan.Zero , it will call Orleans.GrainClient.SetResponseTimeout(Timeout) internally. Stop-GrainClient Takes no parameters and when called, if the GrainClient is initialized will gracefuly uninitialize. Get-Grain Wrapper around GrainClient.GrainFactory.GetGrain<T>() and its overloads. The mandatory parameter is -GrainType and the -XXXKey for the current Grain key types supported by Orleans ( string , Guid , long ) and also the -KeyExtension that can be used on Grains with compound keys. This Cmdlet return a grain reference of the type passed by as parameter on -GrainType . Example: A simple example on calling MyInterfacesNamespace.IMyGrain.SayHeloTo grain method: PS> Import-Module OrleansPSUtils PS> $configFilePath = Resolve-Path(\".\\ClientConfig.xml\").Path PS> Start-GrainClient -ConfigFilePath $configFilePath PS> Add-Type -Path .\\MyGrainInterfaceAssembly.dll PS> $grainInterfaceType = [MyInterfacesNamespace.IMyGrain] PS> $grainId = [System.Guid]::Parse(\"A4CF7B5D-9606-446D-ACE9-C900AC6BA3AD\") PS> $grain = Get-Grain -GrainType $grainInterfaceType -GuidKey $grainId PS> $message = $grain.SayHelloTo(\"Gutemberg\").Result PS> Write-Output $message Hello Gutemberg! PS> Stop-GrainClient We plan to update this page as we introduce more Cmdlets like use Observers, Streams and other Orleans core features more natively on Powershell. We hope that this help people as a starting point for automation. As always, this is a work-in-progress and we love contributions! :) Please note that the intent is not to reimplement the whole client on PowerShell but instead, give IT and DevOps teams a way to interact with the Grains without need to implement a .Net application."
  },
  "1.5/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html": {
    "href": "1.5/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html",
    "title": "Activation Garbage Collection | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Activation Garbage Collection As described in Grains , a grain activation is an in-memory instance of a grain class that gets automatically created by the Orleans runtime on an as-needed basis as a temporary physical embodiment of a grain. Activation Garbage Collection (Activation GC) is the process of removal from memory of unused grain activations. It is conceptually similar to how garbage collection of memory works in .NET. However, Activation GC only takes into consideration how long a particular grain activation has been idle. Memory usage is not used as a factor. How Activation GC Works The general process of Activation GC involves Orleans runtime in a silo periodically scanning for grain activations that have not been used at all for the configured period of time (Collection Age Limit). Once a grain activation has been idle for that long, it gets deactivated. The deactivation process begins by the runtime calling the grainâ€™s OnDeactivateAsync() method, and completes by removing references to the grain activation object from all data structures of the silo, so that the memory is reclaimed by the .NET GC. As a result, with no burden put on the application code, only recently used grain activations stay in memory while activations that aren't used anymore get automatically removed, and system resources used by them get reclaimed by the runtime. What counts as â€œbeing activeâ€ for the purpose of grain activation collection receiving a method call receiving a reminder receiving an event via streaming What does NOT count as â€œbeing activeâ€ for the purpose of grain activation collection performing a call (to another grain or to an Orleans client) timer events arbitrary IO operations or external calls not involving Orleans framework Collection Age Limit This period of time after which an idle grain activation becomes subject to Activation GC is called Collection Age Limit. The default Collection Age Limit is 2 hours, but it can be changed globally or for individual grain classes. Explicit Control of Activation Garbage Collection Delaying Activation GC A grain activation can delay its own Activation GC, by calling this.DelayDeactivation() method: protected void DelayDeactivation(TimeSpan timeSpan) This call will ensure that this activation is not deactivated for at least the specified time duration. It takes priority over Activation Garbage Collection settings specified in the config, but does not cancel them. Therefore, this call provides an additional hook to delay the deactivation beyond what is specified in the Activation Garbage Collection settings . This call can not be used to expedite Activation Garbage Collection. A positive timeSpan value means â€œprevent GC of this activation for that time spanâ€. A negative timeSpan value means â€œcancel the previous setting of the DelayDeactivation call and make this activation behave based on the regular Activation Garbage Collection settingsâ€. Scenarios: 1) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (20 min), it will cause this activation to not be collected for at least 20 min. 2) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (5 min), the activation will be collected after 10 min, if no extra calls were made. 3) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (5 min), and after 7 minutes there is another call on this grain, the activation will be collected after 17 min from time zero, if no extra calls were made. 4) Activation Garbage Collection settings specify age limit of 10 minutes and the grain is making a call to DelayDeactivation (20 min), and after 7 minutes there is another call on this grain, the activation will be collected after 20 min from time zero, if no extra calls were made. Note that DelayDeactivation does not 100% guarantee that the grain activation will not get deactivated before the specified period of time expires. There are certain failure cases that may cause 'premature' deactivation of grains. That means that DelayDeactivation cannot not be used as a means to 'pin' a grain activation in memory forever or to a specific silo . DelayDeactivation is merely an optimization mechanism that can help reduce the aggregate cost of a grain getting deactivated and reactivated over time, if that matters. In most cases there should be no need to use DelayDeactivation at all. Expediting Activation GC A grain activation can also instruct the runtime to deactivate it next time it becomes idle by calling this.DeactivateOnIdle() method: protected void DeactivateOnIdle() A grain activation is considered idle if it is not processing any message at the moment. If you call DeactivateOnIdle while a grain is processing a message, it will get deactivated as soon as processing of the current message is finished. If there are any requests queued for the grain, they will be forwarded to the next activation. DeactivateOnIdle take priority over any Activation Garbage Collection settings specified in the config or DelayDeactivation . Note that this setting only applies to the grain activation from which it has been called and it does not apply to other grain activation of this type. Configuration Programmatic Configuration Default Collection Age Limit (for all grain types) can be set via: void GlobalConfiguration.Application.SetDefaultCollectionAgeLimit(TimeSpan ageLimit) For individual grain types the limit can be set via: void GlobalConfiguration.Application.SetCollectionAgeLimit(Type type, TimeSpan ageLimit) The limit can also be reset for a grain type, so that the default limit would apply to it, via: void GlobalConfiguration.Application.ResetCollectionAgeLimitToDefault(Type type) XML Configuration (deprecated) Any length of time in the configuration XML file may use a suffix that specifies a unit of time: Suffix Unit none millisecond(s) ms millisecond(s) s second(s) m minute(s) hr hour(s) Specifying Default Collection Age Limit The default collection age limit that applies to all grain types can be customized by adding the OrleansConfiguation/Globals/Application/Defaults/Deactivation element to the OrleansConfiguration.xml file. The minimal allowed age limit is 1 minute. The following example specifies that all activations that have been idle for 10 minutes or more should be considered eligible for deactivation. <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Application> <Defaults> <Deactivation AgeLimit=\"10m\"/> </Defaults> </Application> </Globals> </OrleansConfiguration> Specifying per-Type Age Limits Individual grain types may specify a collection age limit that is independent from the global default, using the OrleansConfiguation/Globals/Application/GrainType/Deactivation element. The minimal allowed age limit is 1 minute. In the following example, activations that have been idle for 10 minutes are eligible for collection, except activations that are instantiations of the MyGrainAssembly.DoNotDeactivateMeOften class, which are not considered collectable unless idle for a full 24 hours: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <Application> <Defaults> <Deactivation AgeLimit=\"10m\"/> </Defaults> <GrainType Type=\"MyGrainAssembly.DoNotDeactivateMeOften\"> <Deactivation AgeLimit=\"24hr\"/> </GrainType> </Application> </Globals> </OrleansConfiguration> Any number of GrainType elements may be specified."
  },
  "1.5/Documentation/Core-Features/Grain-Persistence.html": {
    "href": "1.5/Documentation/Core-Features/Grain-Persistence.html",
    "title": "Grain Persistence | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grain Persistence Goals Allow different grain types to use different types of storage providers (e.g., one uses Azure table, and one uses an ADO.NET one) or the same type of storage provider but with different configurations (e.g., both use Azure table, but one uses storage account #1 and one uses storage account #2) Allow configuration of a storage provider instance to be swapped (e.g., Dev-Test-Prod) with just config file changes, and no code changes required. Provide a framework to allow additional storage providers to be written later, either by the Orleans team or others. Provide a minimal set of production-grade storage providers Storage providers have complete control over how they store grain state data in persistent backing store. Corollary: Orleans is not providing a comprehensive ORM storage solution, but allows custom storage providers to support specific ORM requirements as and when required. Grain Persistence API Grain types can be declared in one of two ways: Extend Grain if they do not have any persistent state, or if they will handle all persistent state themselves, or Extend Grain<T> if they have some persistent state that they want the Orleans runtime to handle. Stated another way, by extending Grain<T> a grain type is automatically opted-in to the Orleans system managed persistence framework. For the remainder of this section, we will only be considering Option #2 / Grain<T> because Option #1 grains will continue to run as now without any behavior changes. Grain State Stores Grain classes that inherit from Grain<T> (where T is an application-specific state data type that needs to be persisted) will have their state loaded automatically from a specified storage. Grains will be marked with a [StorageProvider] attribute that specifies a named instance of a storage provider to use for reading / writing the state data for this grain. [StorageProvider(ProviderName=\"store1\")] public class MyGrain<MyGrainState> ... { ... } The Orleans Provider Manager framework provides a mechanism to specify & register different storage providers and storage options in the silo config file. <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"DevStore\" /> <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"store1\" DataConnectionString=\"DefaultEndpointsProtocol=https;AccountName=data1;AccountKey=SOMETHING1\" /> <Provider Type=\"Orleans.Storage.AzureBlobStorage\" Name=\"store2\" DataConnectionString=\"DefaultEndpointsProtocol=https;AccountName=data2;AccountKey=SOMETHING2\" /> </StorageProviders> Configuring Storage Providers AzureTableStorage <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"TableStore\" DataConnectionString=\"UseDevelopmentStorage=true\" /> The following attributes can be added to the <Provider /> element to configure the provider: DataConnectionString=\"...\" (mandatory) - The Azure storage connection string to use TableName=\"OrleansGrainState\" (optional) - The table name to use in table storage, defaults to OrleansGrainState DeleteStateOnClear=\"false\" (optional) - If true, the record will be deleted when grain state is cleared, otherwise an null record will be written, defaults to false UseJsonFormat=\"false\" (optional) - If true, the json serializer will be used, otherwise the Orleans binary serializer will be used, defaults to false UseFullAssemblyNames=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Indents the serialized json, defaults to false Note: state should not exceed 64KB, a limit imposed by Table Storage. AzureBlobStorage <Provider Type=\"Orleans.Storage.AzureTableStorage\" Name=\"BlobStore\" DataConnectionString=\"UseDevelopmentStorage=true\" /> The following attributes can be added to the <Provider /> element to configure the provider: DataConnectionString=\"...\" (mandatory) - The Azure storage connection string to use ContainerName=\"grainstate\" (optional) - The blob storage container to use, defaults to grainstate UseFullAssemblyNames=\"false\" (optional) - Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - Indents the serialized json, defaults to false DynamoDBStorageProvider <Provider Type=\"Orleans.Storage.DynamoDBStorageProvider\" Name=\"DDBStore\" DataConnectionString=\"Service=us-wes-1;AccessKey=MY_ACCESS_KEY;SecretKey=MY_SECRET_KEY;\" /> DataConnectionString=\"...\" (mandatory) - The DynamoDB storage connection string to use. You can set Service , AccessKey , SecretKey , ReadCapacityUnits and WriteCapacityUnits in it. TableName=\"OrleansGrainState\" (optional) - The table name to use in table storage, defaults to OrleansGrainState DeleteStateOnClear=\"false\" (optional) - If true, the record will be deleted when grain state is cleared, otherwise an null record will be written, defaults to false UseJsonFormat=\"false\" (optional) - If true, the json serializer will be used, otherwise the Orleans binary serializer will be used, defaults to false UseFullAssemblyNames=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Serializes types with full assembly names (true) or simple (false), defaults to false IndentJSON=\"false\" (optional) - (if UseJsonFormat=\"true\" ) Indents the serialized json, defaults to false ADO.NET Storage Provider (SQL Storage Provider) The ADO .NET Storage Provider allows you to store grain state in relational databases. Currently following databases are supported: SQL Server MySQL/MariaDB PostgreSQL Oracle First, install the base package: Install-Package Microsoft.Orleans.OrleansSqlUtils Under the folder where the package gets installed alongside your project, you will find different SQL scripts for the supported database vendors. You can also get them from the OrleansSQLUtils repository . Create a database, and then run the appropriate script to create the tables. The next steps are to install a second NuGet package (see table below) specific to the database vendor you want, and to configure the storage provider either programmatically or via XML configuration. Database Script NuGet Package AdoInvariant Remarks SQL Server CreateOrleansTables_SQLServer.sql System.Data.SqlClient System.Data.SqlClient MySQL / MariaDB CreateOrleansTables_MySQL.sql MySql.Data MySql.Data.MySqlClient PostgreSQL CreateOrleansTables_PostgreSQL.sql Npgsql Npgsql Oracle CreateOrleansTables_Oracle.sql ODP.net Oracle.DataAccess.Client No .net Core support The following is an example of how to configure an ADO .NET Storage Provider using XML configuration: <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.AdoNetStorageProvider\" Name=\"OrleansStorage\" AdoInvariant=\"<AdoInvariant>\" DataConnectionString=\"<ConnectionString>\" UseJsonFormat=\"true\" /> </StorageProviders> </Globals> </OrleansConfiguration> In code, you would need something like the following: var properties = new Dictionary<string, string>() { [\"AdoInvariant\"] = \"<AdoInvariant>\", [\"DataConnectionString\"] = \"<ConnectionString>\", [\"UseJsonFormat\"] = \"true\" }; config.Globals.RegisterStorageProvider<AdoNetStorageProvider>(\"OrleansStorage\", properties); Essentially, you only need to set the database-vendor-specific connection string and an AdoInvariant (see table above) that identifies the vendor. You may also choose the format in which the data is saved, which may be either binary (default), JSON, or XML. While binary is the most compact option, it is opaque and you will not be able to read or work with the data. JSON is the recommended option. You can set the following properties: Name Type Description Name String Arbitrary name that persistent grains will use to refer to this storage provider Type String Set to Orleans.Storage.AdoNetStorageProvider AdoInvariant String Identifies the database vendor (see above table for values; default is System.Data.SqlClient ) DataConnectionString String Vendor-specific database connection string (required) UseJsonFormat Boolean Use JSON format (recommended) UseXmlFormat Boolean Use XML format UseBinaryFormat Boolean Use compact binary format (default) The StorageProviders sample provides some code you can use to quickly test the above, and also showcases some custom storage providers. Use the following command in the Package Manager Console to update all Orleans packages to the latest version: Get-Package | where Id -like 'Microsoft.Orleans.*' | foreach { update-package $_.Id } The ADO.NET persistence has functionality to version data and define arbitrary (de)serializers with arbitrary application rules and streaming, but currently there is no method to expose them to application code. More information in ADO.NET Persistence Rationale . MemoryStorage MemoryStorage is a simple storage provider that does not really use a persistent data store underneath. It is convenient to learn to work with Storage Providers quickly, but is not intended to be used in real scenarios. Note: This provider persists state to volatile memory which is erased at silo shut down. Use only for testing. To set up the memory storage provider using XML configuration: <?xml version=\"1.0\" encoding=\"utf-8\"?> <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"OrleansStorage\" NumStorageGrains=\"10\" /> </StorageProviders> </Globals> </OrleansConfiguration> To set it up in code: siloHost.Config.Globals.RegisterStorageProvider<MemoryStorage>(\"OrleansStorage\"); You can set the following properties: Name Type Description Name String Arbitrary name that persistent grains will use to refer to this storage provider Type String Set to Orleans.Storage.MemoryStorage NumStorageGrains Integer The number of grains to use to store the state, defaults to 10 ShardedStorageProvider <Provider Type=\"Orleans.Storage.ShardedStorageProvider\" Name=\"ShardedStorage\"> <Provider /> <Provider /> <Provider /> </Provider> Simple storage provider for writing grain state data shared across a number of other storage providers. A consistent hash function (default is Jenkins Hash) is used to decide which shard (in the order they are defined in the config file) is responsible for storing state data for a specified grain, then the Read / Write / Clear request is bridged over to the appropriate underlying provider for execution. Notes on Storage Providers If there is no [StorageProvider] attribute specified for a Grain<T> grain class, then a provider named Default will be searched for instead. If not found then this is treated as a missing storage provider. If there is only one provider in the silo config file, it will be considered to be the Default provider for this silo. A grain that uses a storage provider which is not present and defined in the silo configuration when the silo loads will fail to load, but the rest of the grains in that silo can still load and run. Any later calls to that grain type will fail with an Orleans.Storage.BadProviderConfigException error specifying that the grain type is not loaded. The storage provider instance to use for a given grain type is determined by the combination of the storage provider name defined in the [StorageProvider] attribute on that grain type, plus the provider type and configuration options for that provider defined in the silo config. Different grain types can use different configured storage providers, even if both are the same type: for example, two different Azure table storage provider instances, connected to different Azure storage accounts (see config file example above). All configuration details for storage providers is defined statically in the silo configuration that is read at silo startup. There are no mechanisms provided at this time to dynamically update or change the list of storage providers used by a silo. However, this is a prioritization / workload constraint rather than a fundamental design constraint. State Storage APIs There are two main parts to the grain state / persistence APIs: Grain-to-Runtime and Runtime-to-Storage-Provider. Grain State Storage API The grain state storage functionality in the Orleans Runtime will provide read and write operations to automatically populate / save the GrainState data object for that grain. Under the covers, these functions will be connected (within the code generated by Orleans client-gen tool) through to the appropriate persistence provider configured for that grain. Grain State Read / Write Functions Grain state will automatically be read when the grain is activated, but grains are responsible for explicitly triggering the write for any changed grain state as and when necessary. See the Failure Modes section below for details of error handling mechanisms. GrainState will be read automatically (using the equivalent of base.ReadStateAsync() ) before the OnActivateAsync() method is called for that activation. GrainState will not be refreshed before any method calls to that grain, unless the grain was activated for this call. During any grain method call, a grain can request the Orleans runtime to write the current grain state data for that activation to the designated storage provider by calling base.WriteStateAsync() . The grain is responsible for explicitly performing write operations when they make significant updates to their state data. Most commonly, the grain method will return the base.WriteStateAsync() Task as the final result Task returned from that grain method, but it is not required to follow this pattern. The runtime will not automatically update stored grain state after any grain methods. During any grain method or timer callback handler in the grain, the grain can request the Orleans runtime to re-read the current grain state data for that activation from the designated storage provider by calling base.ReadStateAsync() . This will completely overwrite any current state data currently stored in the grain state object with the latest values read from persistent store. An opaque provider-specific Etag value ( string ) may be set by a storage provider as part of the grain state metadata populated when state was read. Some providers may choose to leave this as null if they do not use Etag s. Conceptually, the Orleans Runtime will take a deep copy of the grain state data object for its own use during any write operations. Under the covers, the runtime may use optimization rules and heuristics to avoid performing some or all of the deep copy in some circumstances, provided that the expected logical isolation semantics are preserved. Sample Code for Grain State Read / Write Operations Grains must extend the Grain<T> class in order to participate in the Orleans grain state persistence mechanisms. The T in the above definition will be replaced by an application-specific grain state class for this grain; see the example below. The grain class should also be annotated with a [StorageProvider] attribute that tells the runtime which storage provider (instance) to use with grains of this type. public class MyGrainState { public int Field1 { get; set; } public string Field2 { get; set; } } [StorageProvider(ProviderName=\"store1\")] public class MyPersistenceGrain : Grain<MyGrainState>, IMyPersistenceGrain { ... } Grain State Read The initial read of the grain state will occur automatically by the Orleans runtime before the grainâ€™s OnActivateAsync() method is called; no application code is required to make this happen. From that point forward, the grainâ€™s state will be available through the Grain<T>.State property inside the grain class. Grain State Write After making any appropriate changes to the grainâ€™s in-memory state, the grain should call the base.WriteStateAsync() method to write the changes to the persistent store via the defined storage provider for this grain type. This method is asynchronous and returns a Task that will typically be returned by the grain method as its own completion Task. public Task DoWrite(int val) { State.Field1 = val; return base.WriteStateAsync(); } Grain State Refresh If a grain wishes to explicitly re-read the latest state for this grain from backing store, the grain should call the base.ReadStateAsync() method. This will reload the grain state from persistent store, via the defined storage provider for this grain type, and any previous in-memory copy of the grain state will be overwritten and replaced when the ReadStateAsync() Task completes. public async Task<int> DoRead() { await base.ReadStateAsync(); return State.Field1; } Failure Modes for Grain State Persistence Operations Failure Modes for Grain State Read Operations Failures returned by the storage provider during the initial read of state data for that particular grain will result in the activate operation for that grain to be failed; in this case, there will not be any call to that grainâ€™s OnActivateAsync() life cycle callback method. The original request to that grain which caused the activation will be faulted back to the caller the same way as any other failure during grain activation. Failures encountered by the storage provider to read state data for a particular grain will result in the ReadStateAsync() Task to be faulted. The grain can choose to handle or ignore that faulted Task , just like any other Task in Orleans. Any attempt to send a message to a grain which failed to load at silo startup time due to a missing / bad storage provider config will return the permanent error Orleans.BadProviderConfigException . Failure Modes for Grain State Write Operations Failures encountered by the storage provider to write state data for a particular grain will result in the WriteStateAsync() Task to be faulted. Usually, this will mean the grain call will be faulted back to the client caller provided the WriteStateAsync() Task is correctly chained in to the final return Task for this grain method. However, it will be possible for certain advanced scenarios to write grain code to specifically handle such write errors, just like they can handle any other faulted Task . Grains that execute error-handling / recovery code must catch exceptions / faulted WriteStateAsync() Task s and not re-throw to signify that they have successfully handled the write error. Storage Provider Framework There is a service provider API for writing additional persistence providers â€“ IStorageProvider . The Persistence Provider API covers read and write operations for GrainState data. public interface IStorageProvider { Logger Log { get; } Task Init(); Task Close(); Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState); } Storage Provider Semantics Any attempt to perform a write operation when the storage provider detects an Etag constraint violation should cause the write Task to be faulted with transient error Orleans.InconsistentStateException and wrapping the underlying storage exception. public class InconsistentStateException : AggregateException { /// <summary>The Etag value currently held in persistent storage.</summary> public string StoredEtag { get; private set; } /// <summary>The Etag value currently held in memory, and attempting to be updated.</summary> public string CurrentEtag { get; private set; } public InconsistentStateException( string errorMsg, string storedEtag, string currentEtag, Exception storageException ) : base(errorMsg, storageException) { this.StoredEtag = storedEtag; this.CurrentEtag = currentEtag; } public InconsistentStateException(string storedEtag, string currentEtag, Exception storageException) : this(storageException.Message, storedEtag, currentEtag, storageException) { } } Any other failure conditions from a write operation should cause the write Task to be broken with an exception containing the underlying storage exception. Data Mapping Individual storage providers should decide how best to store grain state â€“ blob (various formats / serialized forms) or column-per-field are obvious choices. The basic storage provider for Azure Table encodes state data fields into a single table column using Orleans binary serialization. ADO.NET Persistence Rationale The principles for ADO.NET backed persistence storage are: Keep business critical data safe an accessible while data, the format of data and code evolve. Take advantenge of vendor and storage specific functionality. In practice this means adhering to ADO.NET implementation goals and some added implementation logic in ADO.NET specific storage provider that allow evolving the shape of the data in the storage. In addition to the usual storage provider capabilities, the ADO.NET provider has built-in capability to Change storage data format from one format to another format (e.g. from JSON to binary) when roundtripping state. Shape the type to be saved or read from the storage in arbitrary ways. This helps to evolve the version state. Stream data out of the database. Both 1. and 2. can be applied on arbitrary decision parameters, such as grain ID , grain type , payload data . This happen so that one chooses a format, e.g. Simple Binary Encoding (SBE) and implements IStorageDeserializer and IStorageSerializer . The built-in (de)serializers have been built using this method. The OrleansStorageDefault (De)Serializer can be used as examples on how to implement other formats. When the (de)serializers have been implemented, they need to ba added to the StorageSerializationPicker property in AdoNetStorageProvider . This is an implementation of IStorageSerializationPicker . By default StorageSerializationPicker will be used. And example of changing data storage format or using (de)serializers can be seen at RelationalStorageTests . Currently there is no method to expose this to Orleans application consumption as there is no method to access the framework created AdoNetStorageProvider instance."
  },
  "1.5/Documentation/Core-Features/Observers.html": {
    "href": "1.5/Documentation/Core-Features/Observers.html",
    "title": "Client Observers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . There are situations in which a simple message/response pattern is not enough, and the client needs to receive asynchronous notifications. For example, a user might want to be notified when a new instant message has been published by a friend. Client observers is a mechanism that allows notifying clients asynchronously. An observer is a one-way asynchronous interface that inherits from IGrainObserver , and all its methods must be void. The grain sends a notification to the observer by invoking it like a grain interface method, except that it has no return value, and so the grain need not depend on the result. The Orleans runtime will ensure one-way delivery of the notifications. A grain that publishes such notifications should provide an API to add or remove observers. In addition, it is usually convenient to expose a method that allows an existing subscription to be cancelled. Grain developers may use the Orleans ObserverSubscriptionManager<T> generic class to simplify development of observed grain types. To subscribe to a notification, the client must first create a local C# object that implements the observer interface. It then calls a static method on the observer factory, CreateObjectReference() , to turn the C# object into a grain reference, which can then be passed to the subscription method on the notifying grain. This model can also be used by other grains to receive asynchronous notifications. Unlike in the client subscription case, the subscribing grain simply implements the observer interface as a facet, and passes in a reference to itself (e.g. this.AsReference<IMyGrainObserverInterface> ). Code Example Let's assume that we have a grain that periodicaly sends messages to clients. For simplicity, the message in our example will be a string. We first define the interface on the client that will receive the message. the interface will look like this public interface IChat : IGrainObserver { void ReceiveMessage(string message); } The only special thing is that the interface should inherit from IGrainObserver . Now any client that wants to observe those messages should implement a class which implements IChat . The simplest case would be something like this: public class Chat : IChat { public void ReceiveMessage(string message) { Console.WriteLine(message); } } Now on the server we should have a Grain which sends these chat messages to clients. The Grain also should have a mechanism for clients to subscribe and unsubscribe themselves to receive notifications. For subscription the Grain can use the utility class ObserverSubscriptionManager : class HelloGrain : Grain, IHello { private ObserverSubscriptionManager<IChat> _subsManager; public override async Task OnActivateAsync() { // We created the utility at activation time. _subsManager = new ObserverSubscriptionManager<IChat>(); await base.OnActivateAsync(); } // Clients call this to subscribe. public Task Subscribe(IChat observer) { _subsManager.Subscribe(observer); return TaskDone.Done; } //Also clients use this to unsubscribe themselves to no longer receive the messages. public Task UnSubscribe(IChat observer) { _subsManager.Unsubscribe(observer); return TaskDone.Done; } } To send the message to clients the Notify method of the ObserverSubscriptionManager<IChat> instance can be used. The method takes an Action<T> method or lambda expression (where T is of type IChat here). You can call any method on the interface to send it to clients. In our case we only have one method ReceiveMessage and our sending code on the server would look like this: public Task SendUpdateMessage(string message) { _subsManager.Notify(s => s.ReceiveMessage(message)); return TaskDone.Done; } Now our server has a method to send messages to observer clients, two methods for subscribing/unsubscribing and the client implemented a class to be able to observe the grain messages. The last step is to create an observer reference on the client using our previously implemented Chat class and let it receive the messages after subscribing it. The code would look like this: //First create the grain reference var friend = GrainClient.GrainFactory.GetGrain<IHello>(0); Chat c = new Chat(); //Create a reference for chat usable for subscribing to the observable grain. var obj = await GrainClient.GrainFactory.CreateObjectReference<IChat>(c); //Subscribe the instance to receive messages. await friend.Subscribe(obj); Now whenever our grain on the server calls the SendUpdateMessage method, all subscribed clients will receive the message. In our client code, the Chat instance in variable c will receive the message and output it to the console. Note: Objects passed to CreateObjectReference are held via a WeakReference<T> and will therefore be garbage collected if no other references exist. Users should maintain a reference for each observer which they do not want to be collected. Note: Observers are inherently unreliable since you don't get any response back to know if the message is received and processed or simply failed due to any condition which might arise in a distributed system. Because of that your observers should poll the grain periodically or use any other mechanism to ensure that they received all messages which they should have received. In some situations you can afford to lose some messages and you don't need any additional mechanism but if you need to make sure that all observers are always receiving the messages and are receiving all of them, both periodic resubscriptions and polling the observer grain, can help to ensure eventual processing of all messages."
  },
  "1.5/Documentation/Core-Features/StatelessWorker.html": {
    "href": "1.5/Documentation/Core-Features/StatelessWorker.html",
    "title": "Stateless Worker Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Stateless Worker Grains By default, the Orleans runtime creates no more than one activation of a grain within the cluster. This is the most intuitive expression of the Virtual Actor model with each grain corresponding to an entity with a unique type/identity. However, there are also cases when an application needs to perform functional stateless operations that are not tied to a particular entity in the system. For example, if client sends requests with compressed payloads that need to be decompressed before they could be routed to the target grain for processing, such decompression/routing logic is not tied to a specific entity in the application, and can easily scale out. When the [StatelessWorker] attribute is applied to a grain class, it indicates to the Orleans runtime that grains of that class should be treated as Stateless Worker grains. Stateless Worker grains have the following properties that make their execution very different from that of normal grain classes. The Orleans runtime can and will create multiple activations of a Stateless Worker grain on different silos of the cluster. Requests made to Stateless Worker grains are always executed locally, that is on the same silo where the request originated, either made by a grain running on the silo or received by the silo's client gateway. Hence, calls to Stateless Worker grains from other grains or from client gateways never incur a remote message. The Orleans Runtime automatically creates additional activations of a Stateless Worker grain if the already existing ones are busy. The maximum number of activations of a Stateless Worker grain the runtime creates per silo is limited by default by the number of CPU cores on the machine, unless specified explicitly by the optional maxLocalWorkers argument. Because of 2 and 3, Stateless Worker grain activations are not individually addressable. Two subsequent requests to a Stateless Worker grain may be processed by different activations of it. Stateless Worker grains provide a straightforward way of creating an auto-managed pool of grain activations that automatically scales up and down based on the actual load. The runtime always scans for available Stateless Worker grain activations in the same order. Because of that, it always dispatches a requests to the first idle local activation it can find, and only gets to the last one if all previous activations are busy. If all activations are busy and the activation limit hasn't been reached, it creates one more activation at the end of the list, and dispatches the request to it. That means that when the rate of requests to a Stateless Worker grain increases, and existing activations are all currently busy, the runtime expands the pool of its activations up to the limit. Conversely, when the load drops, and it can be handled by a smaller number of activations of the Stateless Worker grain, the activations at the tail of the list will not be getting requests dispatched to them. They will become idle, and eventually deactivated by the standard activation collection process. Hence, the pool of activations will eventually shrink to match the load. The following example defines a Stateless Worker grain class MyStatelessWorkerGrain with the default maximum activation number limit. [StatelessWorker] public class MyStatelessWorkerGrain : Grain, IMyStatelessWorkerGrain { ... } Making a call to a Stateless Worker grain is the same as to any other grain. The only difference is that in most cases a single grain ID is used, 0 or Guid.Empty . Multiple grain IDs can be used when having multiple Stateless Worker grain pools, one per ID, is desirable. var worker = GrainFactory.GetGrain<IMyStatelessWorkerGrain>(0); await worker.Process(args); This one defines a Stateless Worker grain class with no more than one grain activation per silo. [StatelessWorker(1)] // max 1 activation per silo public class MyLonelyWorkerGrain : ILonelyWorkerGrain { ... } Note that [StatelessWorker] attribute does not change reentrancy of the target grain class. Just like any other grains, Stateless Worker grains are non-reentrant by default. They can be explicitly made reentrant by adding a [Reentrant] attribute to the grain class. State The \"Stateless\" part of \"Stateless Worker\" does not mean that a Stateless Worker cannot have state and is limited only to executing functional operations. Like any other grain, a Stateless Worker grain can load and keep in memory any state it needs. It's just because multiple activations of a Stateless Worker grain can be created on the same and different silos of the cluster, there is no easy mechanism to coordinate state held by different activations. There are several useful patterns that involve Stateless Worker holding state. Scaled out hot cache items For hot cache items that experience high throughput, holding each such item in a Stateless Worker grain makes it a) automatically scale out within a silo and across all silos in the cluster; and b) makes the data always locally available on the silo that received the client request via its client gateway, so that the requests can be answered without an extra network hop to another silo. Reduce style aggregation In some scenarios applications need to calculate certain metrics across all grains of a particular type in the cluster, and report the aggregates periodically. Examples are reporting number of players per game map, average duration of a VoIP call, etc. If each of the many thousands or millions of grains were to report their metrics to a single global aggregator, the aggregator would get immediately overloaded unable to process the flood of reports. The alternative approach is to turn this task into a 2 (or more) step reduce style aggregation. The first layer of aggregation is done by reporting grain sending their metrics to a Stateless Worker pre-aggregation grain. The Orleans runtime will automatically create multiple activations of the Stateless Worker grain with each silo. Since all such calls will be processed locally with no remote calls or serialization of the messages, the cost of such aggregation will be significantly less than in a remote case. Now each of the pre-aggregation Stateless Worker grain activations, independently or in coordination with other local activations, can send their aggregated reports to the global final aggregator (or to another reduction layer if necessary) without overloading it."
  },
  "1.5/Documentation/Core-Features/Timers-and-Reminders.html": {
    "href": "1.5/Documentation/Core-Features/Timers-and-Reminders.html",
    "title": "Timers and Reminders | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Timers and Reminders The Orleans runtime provides two mechanisms, called timers and reminders, that enable the developer to specify periodic behavior for grains. Timers Description Timers are used to create periodic grain behavior that isn't required to span multiple activations (instantiations of the grain). It is essentially identical to the standard . NET System.Threading.Timer class. In addition, it is subject to single threaded execution guarantees within the grain activation that it operates. Each activation may have zero or more timers associated with it. The runtime executes each timer routine within the runtime context of the activation that it is associated with. Usage To start a timer, use the Grain.RegisterTimer method, which returns an IDisposable reference: protected IDisposable RegisterTimer(Func<object, Task> asyncCallback, object state, TimeSpan dueTime, TimeSpan period) asyncCallback is the function to be invoked when the timer ticks. state is an object that will be passed to asyncCallback when the timer ticks. dueTime specifies a quantity of time to wait before issuing the first timer tick. period specifies the period of the timer. Cancel the timer by disposing it. A timer will cease to trigger if the activation is deactivated or when a fault occurs and its silo crashes. Important Considerations When activation collection is enabled, the execution of a timer callback does not change the activation's state from idle to in use. This means that a timer cannot be used to postpone deactivation of otherwise idle activations. The period passed to Grain.RegisterTimer is the amount of time that passes from the moment the Task returned by asyncCallback is resolved to the moment that the next invocation of asyncCallback should occur. This not only makes it impossible for successive calls to asyncCallback to overlap but also makes it so that the length of time asyncCallback takes to complete affects the frequency at which asyncCallback is invoked. This is an important deviation from the semantics of System.Threading.Timer . Each invocation of asyncCallback is delivered to an activation on a separate turn and will never run concurrently with other turns on the same activation. Note however, asyncCallback invocations are not delivered as messages and are thus not subject to message interleaving semantics. This means that invocations of asyncCallback should be considered to behave as if running on a reentrant grain with respect to other messages to that grain. Reminders Description Reminders are similar to timers with a few important differences: Reminders are persistent and will continue to trigger in all situations (including partial or full cluster restarts) unless explicitly cancelled. Reminders are associated with a grain, not any specific activation. If a grain has no activation associated with it and a reminder ticks, one will be created. e.g.: If an activation becomes idle and is deactivated, a reminder associated with the same grain will reactivate the grain when it ticks next. Reminders are delivered by message and are subject to the same interleaving semantics as all other grain methods. Reminders should not be used for high-frequency timers-- their period should be measured in minutes, hours, or days. Configuration Reminders, being persistent, rely upon storage to function. You must specify which storage backing to use before the reminder subsystem will function. The reminder functionality is controlled by the SystemStore element in the server-side configuration. It works with either Azure Table or SQL Server as the store. <SystemStore SystemStoreType=\"AzureTable\" /> OR <SystemStore SystemStoreType=\"SqlServer\" /> If you just want a placeholder implementation of reminders to work with without needing to set up an Azure account or SQL database, then adding this element to the configuration file (under 'Globals') will give you a development-only implementation of the reminder system: <ReminderService ReminderServiceType=\"ReminderTableGrain\"/> Usage A grain that uses reminders must implement the IRemindable.RecieveReminder method. Task IRemindable.ReceiveReminder(string reminderName, TickStatus status) { Console.WriteLine(\"Thanks for reminding me-- I almost forgot!\"); return TaskDone.Done; } To start a reminder, use the Grain.RegisterOrUpdateReminder method, which returns an IOrleansReminder object: protected Task<IOrleansReminder> RegisterOrUpdateReminder(string reminderName, TimeSpan dueTime, TimeSpan period) reminderName is a string that must uniquely identify the reminder within the scope of the contextual grain. dueTime specifies a quantity of time to wait before issuing the first timer tick. period specifies the period of the timer. Since reminders survive the lifetime of any single activation, they must be explicitly cancelled (as opposed to being disposed). You cancel a reminder by calling Grain.UnregisterReminder : protected Task UnregisterReminder(IOrleansReminder reminder) reminder is the handle object returned by Grain.RegisterOrUpdateReminder . Instances of IOrleansReminder aren't guaranteed to be valid beyond the lifespan of an activation. If you wish to identify a reminder in a way that persists, use a string containing the reminder's name. If you only have the reminder's name and need the corresponding instance of IOrleansReminder , call the Grain.GetReminder method: protected Task<IOrleansReminder> GetReminder(string reminderName) Which Should I Use? We recommend that you use timers in the following circumstances: It doesn't matter (or is desirable) that the timer ceases to function if the activation is deactivated or failures occur. If the resolution of the timer is small (e.g. reasonably expressible in seconds or minutes). The timer callback can be started from Grain.OnActivateAsync or when a grain method is invoked. We recommend that you use reminders in the following circumstances: When the periodic behavior needs to survive the activation and any failures. To perform infrequent tasks (e.g. reasonably expressible in minutes, hours, or days). Combining Timers and Reminders You might consider using a combination of reminders and timers to accomplish your goal. For example, if you need a timer with a small resolution that needs to survive across activations, you can use a reminder that runs every five minutes, whose purpose is to wake up a grain that restarts a local timer that may have been lost due to a deactivation."
  },
  "1.5/Documentation/Core-Features/Dependency-Injection.html": {
    "href": "1.5/Documentation/Core-Features/Dependency-Injection.html",
    "title": "Dependency Injection | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . What is Dependency Injection Dependency injection (DI) is a software design pattern that implements inversion of control for resolving dependencies. Orleans is using the abstraction written by the developers of ASP.NET Core . For a detailed explanation about how it works, check out the official documentation . DI in Orleans Dependency Injection is currently supported only on the server side within Orleans. Orleans makes it possible to inject dependencies into application Grains . However Orleans supports every container dependent injection mechanisms, one of the most commonly used method is constructor injection. Theoretically any type can be injected which was previously registered in a IServiceCollection during Silo startup. Note *: As Orleans is evolving, as of the current plans it will be possible to leverage dependency injection in other application classes as well, like StreamProviders . Configuring DI The DI configuration is a global configuration value and must be configured there. Orleans is using a similar approach as ASP.NET Core to configure DI. You must have a Startup class within your application which must contain a ConfigureServices method. It must return an object instance of type: IServiceProvider . Configuration is done by specifying the type of your Startup class via one of the methods described below. Note : Previously DI configuration was specified at the cluster node level, this was changed in the recent release. Configuring from Code It is possible to tell Orleans what Startup type you like to use with code based configuration. There is an extension method named UseStartup on the ClusterConfiguration class which you can use to do that. var configuration = new ClusterConfiguration(); configuration.UseStartupType<MyApplication.Configuration.MyStartup>(); Configuring via XML To register your Startup class with Orleans you add a Startup element to the Defaults section and in the Type attribute you specify the assembly-qualified name for the type. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <tns:OrleansConfiguration xmlns:tns=\"urn:orleans\"> <tns:Defaults> <tns:Startup Type=\"MyApplication.Configuration.Startup,MyApplication\" /> </tns:Defaults> </tns:OrleansConfiguration> Example Here is a complete Startup class example: namespace MyApplication.Configuration { public class MyStartup { public IServiceProvider ConfigureServices(IServiceCollection services) { services.AddSingleton<IInjectedService, InjectedService>(); return services.BuildServiceProvider(); } } } This example shows how a Grain can utilize IInjectedService via constructor injection and also the complete declaration and implementation of the injected service: public interface ISimpleDIGrain : IGrainWithIntegerKey { Task<long> GetTicksFromService(); } public class SimpleDIGrain : Grain, ISimpleDIGrain { private readonly IInjectedService injectedService; public SimpleDIGrain(IInjectedService injectedService) { this.injectedService = injectedService; } public Task<long> GetTicksFromService() { return injectedService.GetTicks(); } } public interface IInjectedService { Task<long> GetTicks(); } public class InjectedService : IInjectedService { public Task<long> GetTicks() { return Task.FromResult(DateTime.UtcNow.Ticks); } } Test Framework Integration DI truly shines when coupled with a testing framework to verify the correctness of the code that build. You can read about the components for testing in Orleans by following our tutorials . You will need to do two things to set up DI with tests. First you will need to implement mocks of your services. This is done in our example using Moq , a popular mocking framework for .NET. Here is an example of mocking a service. public class MockServices { public IServiceProvider ConfigureServices(IServiceCollection services) { var mockInjectedService = new Mock<IInjectedService>(); mockInjectedService.Setup(t => t.GetTicks()).Returns(knownDateTime); services.AddSingleton<IInjectedService>(mockInjectedService.Object); return services.BuildServiceProvider(); } } To include these services in your test silo, you will need to specify MockServices as the silo startup class. Here is an example of doing this. [TestClass] public class IInjectedServiceTests: TestingSiloHost { private static TestingSiloHost host; [TestInitialize] public void Setup() { if (host == null) { host = new TestingSiloHost( new TestingSiloOptions { StartSecondary = false, AdjustConfig = clusterConfig => { clusterConfig.UseStartupType<MockServices>(); } }); } } }"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Grains.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Grains.html",
    "title": "Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Grains Grains are the key primitives of the Orleans programming model. Grains are the building blocks of an Orleans application, they are atomic units of isolation, distribution, and persistence. Grains are objects that represent application entities. Just like in the classic Object Oriented Programming, a grain encapsulates state of an entity and encodes its behavior in the code logic. Grains can hold references to each other and interact by invoking each otherâ€™s methods exposed via interfaces. Orleans aims to greatly simplify building a scalable application and eliminate most of the concurrency challenges By not sharing data between grains instances except via message passing. By providing the single-threaded execution guarantee to each individual grain. A typical grain encapsulates state and behavior of a single entity (e.g. a specific user or a device or a session). Grain Identity An individual grain is a uniquely addressable instance of a grain type (class). Each grain has a unique identity, also referred to as a grain key, within its type. Grain identity within its type can be a long integer, a GUID, a string, or a combination of a long+string or GUID+string. Accessing a Grain A grain class implements one or more grain interfaces, formal code contracts for interacting with grains of that type. To invoke a grain, a caller needs to know the grain interface that the grain class implements that includes the method that the caller wants to call and the unique identity (key) of the target grain. For example, here's how a user profile grain can be called to update user's address if email is used as a user identity. var user = grainFactory.GetGrain<IUserProfile>(userEmail); await user.UpdateAddress(newAddress); A call to GetGrain is an inexpensive local operation of constructing a grain reference with an embedded identity and type of the target grain. Note that there is no need to create or instantiate the target grain. We make a call to it to update user's address as if the user's grain is already instantiated for us. This is one of the biggest advantages of the Orleans programming model - we never need to create, instantiate or delete grains. We can write our code as if all possible grains, for example millions of user profiles, are always in memory waiting for us to call them. Behind the scenes, the Orleans runtime performs all the heavy lifting of managing resources to transparently bring grains to memory when needed. Behind the Scenes - Grain Lifecycle Grains live in execution containers called silos. Silos form a cluster that combines resources of multiple physical or virtual machines. When there is work (request) for a grain, Orleans ensures there is an instance of the grain on one of the Silos in the cluster. If there is no instance of the grain on any silo, the Orleans runtime creates one. This process is called Activation. In case a grain is using Grain Persistence , the runtime automatically reads the state from the backing store upon activation. Once activated on a silo, a grain processes incoming requests (method calls) from other grains or from outside of the cluster (usually from frontend web servers). In the course of processing a request a grain may call other grains or some external services. If a grain stops receiving requests and stays idle, after a configurable period of inactivity Orleans removes the grain from memory (deactivates it) to free up resources for other grains. If and when there's a new request for that grain, Orleans will activate it again, potentially on a different silo, so the caller gets the impression that the grain stayed in memory the whole time. A grain goes through the lifecycle from existing only as its persisted state (if it has any) in storage to being instantiated in memory to being removed from memory. Orleans controls the process of activating and deactivating grains transparently. When coding a grain, a developer assumes all grains are always activated. The sequence of key events in grain lifecycle looks like this. Another grain or a client makes a call to a method of the grain (via a grain reference) The grain gets activated (if it is not already activated somewhere in the cluster) and an instance of the grain class, called a grain activation, is created Constructor of the grain is executed leveraging Dependency Injection if applicable If Declarative Persistence is used, the grain state is read from storage If overridden, OnActivateAsync is called The grain processes incoming requests The grain remains idle for some time Silo runtime decides to deactivate the grain Silo runtime calls OnDeactivateAsync , if overridden Silo runtime removes the grain from memory Upon a graceful shutdown of a silo, all grain activations it holds get deactivated. Any requests waiting to be processed in grains' queues get forwarded to other silos in the cluster, where new activations of deactivated grains get created on an as-needed basis. If a silo shuts down or dies ungracefully, other silos in the cluster detect the failure, and start creating new activations of grains lost on the failed silo, as new requests for those grains arrive. Note that detection of a silo failure takes some time (configurable), and hence the process of reactivating lost grains isn't instantaneous. Grain Execution A grain activation performs work in chunks and finishes each chunk before it moves on to the next. Chunks of work include method invocations in response to requests from other grains or external clients, and closures scheduled on completion of a previous chunk. The basic unit of execution corresponding to a chunk of work is known as a turn. While Orleans may execute many turns belonging to different activations in parallel, each activation will always execute its turns one at a time. This means that there is no need to use locks or other synchronization methods to guard against data races and other multi-threading hazards. Next Next we look at how to implement a grain class. Developing a Grain"
  },
  "1.5/Documentation/Getting-Started-With-Orleans/Running-the-Application.html": {
    "href": "1.5/Documentation/Getting-Started-With-Orleans/Running-the-Application.html",
    "title": "Running the Application | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Orleans Application As was illustrated in the previous topic , a typical Orleans application consists of a cluster of server processes (silos) where grains live, and a set of client processes, usually web servers, that receive external requests, turn them into grain method calls, and return results back. Hence, the first thing one needs to do to run an Orleans application is to start a cluster of silos. For testing purposes, a cluster can consist of a single silo. For a reliable production deployment, we obviously want more than one silos in a cluster for fault tolerance and scale. Once the cluster is running, we can start one or more client processes that connect to the cluster and can send requests to the grains. Clients connect to a special TCP endpoint on silos - gateway. By default, every silo in a cluster has a client gateway enabled. So clients can connect to all silos in parallel for better performance and resilience. Configuring and Starting a Silo A silo is configured programmatically via a ClusterConfiguration object. It can be instantiated and populated directly, load settings from a file, or created with several available helper methods for different deployment environments. For local testing, the easiest way to go is to use ClusterConfiguration.LocalhostPrimarySilo() helper method. The configuration object is then passed to a new instance of SiloHost class, that can be initialized and started after that. You can create an empty console application project targeting .NET Framework 4.6.1 or higher for hosting a silo. Add the Microsoft.Orleans.Server NuGet meta-package to the project. PM> Install-Package Microsoft.Orleans.Server Here is an example of how a local silo can be started: var siloConfig = ClusterConfiguration.LocalhostPrimarySilo(); var silo = new SiloHost(\"Test Silo\", siloConfig); silo.InitializeOrleansSilo(); silo.StartOrleansSilo(); Console.WriteLine(\"Press Enter to close.\"); // wait here Console.ReadLine(); // shut the silo down after we are done. silo.ShutdownOrleansSilo(); Configuring and Connecting a Client Client for connecting to a cluster of silos and sending requests to grains is configured programmatically via a ClientConfiguration object and a ClientBuilder . ClientConfiguration object can be instantiated and populated directly, load settings from a file, or created with several available helper methods for different deployment environments. For local testing, the easiest way to go is to use ClientConfiguration.LocalhostSilo() helper method. The configuration object is then passed to a new instance of ClientBuilder class. ClientBuilder exposes more methods for configuring additional client features. After that Build method of the ClientBuilder object is called to get an implementation of IClusterClient interface. Finally, we call Connect() method on the returned object to connect to the cluster. You can create an empty console application project targeting .NET Framework 4.6.1 or higher for running a client or reuse the console application project you created for hosting a silo. Add the Microsoft.Orleans.Client NuGet meta-package to the project. PM> Install-Package Microsoft.Orleans.Client Here is an example of how a client can connect to a local silo: var config = ClientConfiguration.LocalhostSilo(); var builder = new ClientBuilder().UseConfiguration(config). var client = builder.Build(); await client.Connect(); Production Configurations The configuration examples we used here are for testing silos and clients running on the same machine as localhost . In production, silos and clients usually run on different servers and are configured with one of the reliable cluster configuration options. You can find more about that in the Configuration Guide and in the description of Cluster Management . Next Debugging"
  },
  "1.5/Documentation/Runtime-Implementation-Details/Consul-Deployment.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Consul-Deployment.html",
    "title": "Using Consul as a Membership Provider | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Using Consul as a Membership Provider Introduction to Consul Consul is a distributed, highly available and datacenter-aware service discovery platform which includes simple service registration, health checking, failure detection and key/value storage. It is built on the premise that every node in the datacenter is running a Consul agent which is either acting as a server or client which communicate via a scalable gossip protocol. There is a very detailed overview of Consul including comparisons with similar solutions here . Consul is written in GO and is open source ; compiled downloads are available for Mac OS X, FreeBSD, Linux, Solaris and Windows Why Choose Consul? As an Orleans Membership Provider , Consul is a good choice when you need to deliver an on-premise solution which does not require your potential customers to have existing infrastructure and a co-operative IT provider. Consul is a very lightweight single executable, has no dependencies and as such can easily be built into your own middleware solution. And when Consul is already your solution for discovering, checking and maintaining your microservices, it makes sense to fully integrate with Orleans membership for simplicity and ease of operation. We therefore implemented a membership table in Consul (also known as \"Orleans Custom System Store\"), which fully integrates with Orleans's Cluster Management . Setting up Consul There is very extensive documentation available on Consul.io about setting up a stable Consul cluster and it doesn't make sense to repeat that here; however for your convenience we include this guide so you can very quickly get Orleans running with a standalone Consul agent. 1) Create a folder to install Consul into, e.g. C:\\Consul 2) Create a subfolder: C:\\Consul\\Data (Consul will not create this if it doesn't exist) 3) Download and unzip Consul.exe into C:\\Consul\\ 4) Open a command prompt at C:\\Consul\\ 5) Enter Consul.exe agent -server -bootstrap -data-dir \"C:\\Consul\\Data\" -client=0.0.0.0 agent Instructs Consul to run the agent process that hosts the services. Without this the Consul process will attempt to use RPC to configure a running agent. -server Defines the agent as a server and not a client (A Consul client is an agent that hosts all the services and data, but does not have voting rights to decide, and cannot become, the cluster leader -bootstrap The first (and only the first!) node in a cluster must be bootstrapped so that it assumes the cluster leadership. -data-dir [path] Specifies the path where all Consul data is stored, including the cluster membership table -client=0.0.0.0 Informs Consul which IP to open the service on. There are many other parameters, and the option to use a json configuration file. Please consult the Consul documentation for a full listing of the options. 6) Verify that Consul is running and ready to accept membership requests from Orleans by opening the services endpoint in your browser. Configuration of Orleans Server There is currently a known issue with the \"Custom\" membership provider OrleansConfiguration.xml configuration file that will fail to parse correctly. For this reason you have to provide a placeholder SystemStore in the xml and then configure the provider in code before starting the Silo. OrleansConfiguration.xml <OrleansConfiguration xmlns=\"urn:orleans\"> <Globals> <SystemStore SystemStoreType=\"None\" DataConnectionString=\"http://localhost:8500\" DeploymentId=\"MyOrleansDeployment\" /> </Globals> <Defaults> <Networking Address=\"localhost\" Port=\"22222\" /> <ProxyingGateway Address=\"localhost\" Port=\"30000\" /> </Defaults> </OrleansConfiguration> Code public void Start(ClusterConfiguration config) { _siloHost = new SiloHost(System.Net.Dns.GetHostName(), config); _siloHost.Config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.Custom; _siloHost.Config.Globals.MembershipTableAssembly = \"OrleansConsulUtils\"; _siloHost.Config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.Disabled; _siloHost.InitializeOrleansSilo(); var startedok = _siloHost.StartOrleansSilo(); if (!startedok) throw new SystemException(String.Format(\"Failed to start Orleans silo '{0}' as a {1} node\", _siloHost.Name, _siloHost.Type)); Log.Information(\"Orleans Silo is running.\\n\"); } Alternatively you could configure the silo entirely in code. Client The client configuration is much simpler ClientConfiguration.xml <ClientConfiguration xmlns=\"urn:orleans\"> <SystemStore SystemStoreType=\"Custom\" CustomGatewayProviderAssemblyName=\"OrleansConsulUtils\" DataConnectionString=\"http://192.168.1.26:8500\" DeploymentId=\"MyOrleansDeployment\" /> </ClientConfiguration> Client SDK If you are interested in using Consul for your own service discovery there are Client SDKs for most popular languages. Implementation Detail The Membership Table Provider makes use of Consul's Key/Value store functionality with CAS. When each Silo starts it registers two KV entries, one which contains the Silo details and one which holds the last time the Silo reported it was alive (the latter refers to diagnostics \"I am alive\" entries and not to failure detection hearbeats which are sent directly between the silos and are not written into the table). All writes to the table are performed with CAS to provide concurrency control, as necessitated by Orleans's Cluster Management Protocol . Once the Silo is running you can view these entries in your web browser here , this will display something like: [ \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753\", \"orleans/MyOrleansDeployment/192.168.1.26:11111@191780753/iamalive\" ] You will notice that the keys are prefixed with \"orleans/\" this is hard coded in the provider and is intended to avoid key space collision with other users of Consul. Each of these keys can be read by appending their key name (sans quotes of course) to the Consul KV root . Doing so will present you with the following: [ { \"LockIndex\": 0, \"Key\": \"orleans/MyOrleansDeployment/192.168.1.26:22222@191780753\", \"Flags\": 0, \"Value\": \"[BASE64 UTF8 Encoded String]\", \"CreateIndex\": 10, \"ModifyIndex\": 12 } ] Decoding the string will give you the actual Orleans Membership data: http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress] { \"Hostname\": \"[YOUR_MACHINE_NAME]\", \"ProxyPort\": 22222, \"StartTime\": \"2016-01-29T16:25:54.9538838Z\", \"Status\": 3, \"SuspectingSilos\": [] } http://localhost:8500/v1/KV/orleans/MyOrleansDeployment/[SiloAddress]/IAmAlive \"2016-01-29T16:35:58.9193803Z\" When the Clients connect, they read the KVs for all silos in the cluster in one HTTP GET by using the uri http://192.168.1.26:8500/v1/KV/orleans/MyOrleansDeployment/?recurse . Limitations Orleans Extended Membership Protocol (Table Version & ETag) Consul KV currrently does not currently support atomic updates. Therefore, the Orleans Consul Membership Provider only implements the the Orleans Basic Membership Protocol, as described here and does not support the Extended Membership Protocol. This Extended protocol was introduced as an additional, but not essential, silo connectivity validation and as a foundation to functionality that has not yet been implemented. Providing your infrastructure is correctly configured you will not experience any detrimental effect of the lack of support. Multiple Datacenters The Key Value Pairs in Consul are not currently replicated between Consul datacenters. There is a separate project to address this but it has not yet been proven to support Orleans. When running on Windows When Consul starts on Windows it logs the following message: ==> WARNING: Windows is not recommended as a Consul server. Do not use in production. This is displayed simply due to lack of focus on testing when running in a Windows environment and not because of any actual known issues. Read the discussion here before deciding if Consul is the right choice for you. Potential Future Enhanecements 1) Prove that the Consul KV replication project is able to support an Orleans cluster in a WAN environment between multiple Consul datacenters. 2) Implement the Reminder Table in Consul. 3) Implement the Extended Membership Protocol. The team behind Consul does plan on implementing atomic operations, once this functionality is available it will be possible to remove the limitations in the provider."
  },
  "1.5/Documentation/Runtime-Implementation-Details/Scheduler.html": {
    "href": "1.5/Documentation/Runtime-Implementation-Details/Scheduler.html",
    "title": "Scheduler | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Important You are looking at the 1.5 documentation Orleans 2.0 is a significant overhaul from the 1.x versions. You can find 2.0 documentation here . Scheduler Orleans Scheduler is a component within the Orleans runtime responsible for executing application code and parts of the runtime code to ensure the single threaded execution semantics . It implements a custom TPL Task scheduler. Orleans Task scheduler is a hierarchical 2 level scheduler. At the first level there is the global OrleansTaskScheduler that is responsible for execution of system activities. At the second level every grain activation has its own ActivationTaskScheduler , which provides the single threaded execution semantics. At a high level, the execution path is the following: A request arrives to the correct silo and the destination activation is found. A request is translated into a Task that is queued for execution by that activation, on its ActivationTaskScheduler. Any subsequent Task created as part of the grain method execution is natively enqueued to the same ActivationTaskScheduler, via the standard TaskScheduler mechanism. Every ActivationTaskScheduler has a queue of tasks queued for execution. Orleans Scheduler has a set of worker threads that are collectively used by all the activation schedulers. Those threads periodically scan all the scheduler queues for work to execute. A thread takes a queue (each queue is taken by one thread at a time) and starts executing Tasks in that queue in FIFO order. The combination of one thread at a time taking a queue and the thread executing Tasks sequentially is what provides the single threaded execution semantics. Work Items: Orleans uses a notion of Work Items to designate the entry point into the scheduler. Every new request is enqueued initially as a work item which simply wraps the execution of the first Task for that request. Work items simply provide more contextual information about the scheduling activity (the caller, the name of the activity, logging) and sometimes some extra work that has to be done on behalf of that scheduling activity (post invocation activity in Invoke work item). There are currently the following work item types: Invoke work item â€“ this is the mostly frequently used work item type. It represents execution of an application request. Request/Response work items â€“ executes a system request (request to a SystemTarget) TaskWorkItem â€“ represent a Task queued to the top level OrleansTaskScheduler. Used instead of a direct Task just for convenience of data structures (more details below). WorkItemGroup â€“ group of work items that share the same scheduler. Used to wrap a queue of Tasks for each ActivationTaskScheduler. ClosureWorkItem â€“ a wrapper around a closure (arbitrary lambda) that is queued to the system context. Scheduling Context: Scheduling Context is a tag, just an opaque object that represents scheduling target â€“ activation data, system target or system null context. High level Principles: Tasks are always queued to the correct scheduler 1.1 Tasks are never moved around from one scheduler to another. 1.2 We never create tasks on behalf of other tasks to execute them. 1.3 WorkItems are wrapped within Task (that is, in order to execute a work item, we create a Task whose lambda function will just run the work item lambda). By always going via tasks we ensure that any activity is executed via an appropriate Task scheduler. Tasks are executed on the scheduler where they were queued by using base.TryExecute (and not by RunSynchronously) There is a one to one mapping between ATS, WorkItem Group and Scheduling Context: 3.1 Activation Task Scheduler (ATS) is a custom TPL scheduler. We keep ATS thin and store all the data in WorkItemGroup. ATS points to its WorkItemGroup. 3.2 WorkItem Group is the actual holder (data object) of the activation Tasks. The Tasks are stored in a List - the queue of all tasks for its ATS. WorkItemGroup points back to its ATS. Data Flow and Execution of Tasks and Work items: The entry point is always a work item enqueued into OrleansTaskScheduler. It can be one of the Invoke/Request/Response/Closure WorkItem. Wrapped into a Task and enqueued into the correct ActivationTaskScheduler based on the context via Task.Start. A Task that is queued to its ActivationTaskScheduler is put into the WorkItemGroup queue. When a Task is put into a WorkItemGroup queue, WorkItemGroup makes sure it appears in OrleansTaskScheduler global RunQueue. RunQueue is the global queue of runnable WorkItemGroups, those that have at least one Task queued, and thus ready to be executed. Worker threads scan the RunQueue of OrleansTaskScheduler which hold WorkItemGroups and call WorkItemGroups.Execute WorkItemGroups.Execute scans the queue of its tasks and executes them via ActivationTaskScheduler.RunTask(Task) 6.1 ActivationTaskScheduler.RunTask(Task) calls base.TryExecute. 6.2 Task that were enqueued directly to the scheduler via TPL will just execute 6.3 Tasks that wrap work items will call workItem.Execute which will execute the Closure work item delegate. Low level design â€“ Work Items: Queueing work items to OrleansTaskScheduler is how the whole chain of execution for every request starts in the Orleans runtime. This is our entry point into the Scheduler. Work items are first submitted to OrleansTaskScheduler (since this is the interface presented to the rest of the system). 2.1 Only closure/invoke/resume work items can be submitted this way. 2.2 TaskWorkItem cannot be submitted to OrleansTaskScheduler directly (read more below on handling of TaskWorkItem). Every work item must be wrapped into Task and enqueued to the right scheduler via Task.Start. 3.1 This will make sure the TaskScheduler.Current is set correctly on any Task that is created implicitly during execution of this workItem. 3.2 Wrapping is done by creating a Task via WrapWorkItemAsTask that will execute the work item and enqueuing it to the right scheduler via Task.Start(scheduler). 3.3 Work items for the null context are queued to OrleansTaskScheduler. 3.4 Work items for non-null contexts are queued to ActivationTaskScheduler Low level design â€“ Queueing Tasks: Tasks are queued directly to the right scheduler 1.1 Tasks are queued implicitly by TPL via protected override void QueueTask(Task task) 1.2 A Task that has a non-null context is always enqueued to ActivationTaskScheduler 1.3 A Task that has the null context is always enqueued to OrleansTaskScheduler Queueing Tasks to ActivationTaskScheduler: 2.1 We never wrap a Task in another Task. A Task gets added directly to the WorkItem Group queue Queueing Tasks to OrleansTaskScheduler: 3.1 When a Task is enqueued to the OrleansTaskScheduler, we wrap it into a TaskWorkItem and put it into this schedulerâ€™s queue of work items. 3.2 This is just a matter of data structures, nothing inherent about it: 3.3 OrleansTaskScheduler usually holds work item groups to schedule them, so its RunQueue has a BlockingCollection . 3.4 Since tasks to the null context are also queued to OrleansTaskScheduler, we reuse the same data structure, thus we have to wrap each Task in a TaskWorkItem. 3.5 We should be able to get rid of this wrapping completely by adjusting the RunQueue data structure. This may simplify the code a bit, but in general should not matter. Also, in the future we should move away from the null context anyway, so this issue will be gone anyway Inlining tasks: Since Tasks are always queued to the right scheduler, in theory it should always be safe to inline any Task."
  },
  "Documentation/resources/nuget_packages.html": {
    "href": "Documentation/resources/nuget_packages.html",
    "title": "Orleans NuGet Packages | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "OrleansNuGetè½¯ä»¶åŒ… å…³é”®å¥—é¤ åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦ä½¿ç”¨5ä¸ªå…³é”®çš„NuGetè½¯ä»¶åŒ…ï¼š å¾®è½¯Orleansæ ¸å¿ƒæŠ½è±¡ PM> Install-Package Microsoft.Orleans.Core.Abstractions åŒ…å«Orleans.Core.Abstractions.dllï¼Œè¯¥æ–‡ä»¶å®šä¹‰å¼€å‘åº”ç”¨ç¨‹åºä»£ç (grainsæ¥å£å’Œç±»)æ‰€éœ€çš„Orleanså…¬å…±ç±»å‹ã€‚ä»»ä½•Orleansé¡¹ç›®éƒ½éœ€è¦ç›´æ¥æˆ–é—´æ¥å¼•ç”¨æ­¤è½¯ä»¶åŒ…ã€‚å°†å…¶æ·»åŠ åˆ°å®šä¹‰grainæ¥å£å’Œç±»çš„é¡¹ç›®ä¸­ã€‚ Microsoft Orleansæ„å»ºæ—¶ä»£ç ç”Ÿæˆ Microsoft.Orleans.OrleansCodeGenerator.Build ã€‚ PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator.Build å‡ºç°åœ¨Orleans1.2.0ä¸­ã€‚ä¸ºGrainsæ¥å£å’Œå®æ–½é¡¹ç›®æä¾›æ—¶é—´æ”¯æŒã€‚å°†å…¶æ·»åŠ åˆ°æ‚¨çš„grainæ¥å£å’Œå®ç°é¡¹ç›®ä¸­ï¼Œä»¥å¯ç”¨grainå¼•ç”¨å’Œåºåˆ—åŒ–å™¨çš„ä»£ç ç”Ÿæˆã€‚ Microsoft.Orleans.CodeGenerator.MSBuild ã€‚ PM> Install-Package Microsoft.Orleans.CodeGenerator.MSBuild å‡ºç°åœ¨ Orleans2.1.0 ã€‚æ›¿ä»£ Microsoft.Orleans.OrleansCodeGenerator.Build åŒ…ã€‚åˆ©ç”¨Roslynè¿›è¡Œä»£ç åˆ†æï¼Œä»¥é¿å…åŠ è½½åº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶å¹¶æ”¹å–„å¯¹å¢é‡æ„å»ºçš„æ”¯æŒï¼Œè¿™å°†ç¼©çŸ­æ„å»ºæ—¶é—´ã€‚ Microsoft OrleansæœåŠ¡å™¨åº“ PM> Install-Package Microsoft.Orleans.Server ä¸€ä¸ªæ˜“äºæ„å»ºå’Œå¯åŠ¨silosçš„å…ƒè½¯ä»¶åŒ…ã€‚åŒ…æ‹¬ä»¥ä¸‹è½¯ä»¶åŒ…ï¼š å¾®è½¯Orleansæ ¸å¿ƒæŠ½è±¡ å¾®è½¯Orleansæ ¸å¿ƒ Microsoft.Orleans.OrleansRuntime Microsoft.Orleans.OrleansProviders Microsoft Orleanså®¢æˆ·åº“ PM> Install-Package Microsoft.Orleans.Client ä¸€ä¸ªç”¨äºè½»æ¾æ„å»ºå’Œå¯åŠ¨Orleanså®¢æˆ·(å‰ç«¯)çš„å…ƒè½¯ä»¶åŒ…ã€‚åŒ…æ‹¬ä»¥ä¸‹è½¯ä»¶åŒ…ï¼š å¾®è½¯Orleansæ ¸å¿ƒæŠ½è±¡ å¾®è½¯Orleansæ ¸å¿ƒ Microsoft.Orleans.OrleansProviders å¾®è½¯Orleansæ ¸å¿ƒåº“ PM> Install-Package Microsoft.Orleans.Core åŒ…å«åº”ç”¨ç¨‹åºä»£ç å’ŒOrleanså®¢æˆ·(å‰ç«¯)ä½¿ç”¨çš„å¤§å¤šæ•°Orleanså…¬å…±ç±»å‹çš„å®ç°ã€‚å¼•ç”¨å®ƒä»¥æ„å»ºä½¿ç”¨Orleansç±»å‹ä½†ä¸å¤„ç†æ‰˜ç®¡æˆ–å­¤å²›çš„åº“å’Œå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºã€‚åŒ…å«åœ¨Microsoft.Orleans.Clientå’ŒMicrosoft.Orleans.Serverå…ƒè½¯ä»¶åŒ…ä¸­ï¼Œå¹¶ä¸”å¤§å¤šæ•°å…¶ä»–è½¯ä»¶åŒ…ç›´æ¥æˆ–é—´æ¥åœ°å¯¹å…¶è¿›è¡Œå¼•ç”¨ã€‚ ä»£ç®¡ å¾®è½¯Orleansè¿è¡Œæ—¶ PM> Install-Package Microsoft.Orleans.OrleansRuntime ç”¨äºé…ç½®å’Œå¯åŠ¨silosçš„åº“ã€‚åœ¨æ‚¨çš„silosä¸»æœºé¡¹ç›®ä¸­å¼•ç”¨å®ƒã€‚åŒ…å«åœ¨Microsoft.Orleans.Serverå…ƒè½¯ä»¶åŒ…ä¸­ã€‚ Microsoft Orleansè¿è¡Œæ—¶æŠ½è±¡ PM> Install-Package Microsoft.Orleans.Runtime.Abstractions åŒ…å«Microsoft.Orleans.OrleansRuntimeä¸­å®ç°çš„ç±»å‹çš„æ¥å£å’ŒæŠ½è±¡ã€‚ Microsoft Orleansåœ¨Azureäº‘æœåŠ¡ä¸Šæ‰˜ç®¡ PM> Install-Package Microsoft.Orleans.Hosting.AzureCloudServices åŒ…å«ç”¨äºå°†siloså’ŒOrleanså®¢æˆ·ç«¯æ‰˜ç®¡ä¸ºAzureäº‘æœåŠ¡çš„å¸®åŠ©ç¨‹åºç±»(å·¥ä½œäººå‘˜è§’è‰²å’ŒWebè§’è‰²)ã€‚ Microsoft Orleans Service Fabricæ‰˜ç®¡æ”¯æŒ PM> Install-Package Microsoft.Orleans.Hosting.ServiceFabric åŒ…å«ç”¨äºå°†silosä½œä¸ºæ— çŠ¶æ€Service FabricæœåŠ¡æ‰˜ç®¡çš„å¸®åŠ©ç¨‹åºç±»ã€‚ é›†ç¾¤æä¾›å•† ä»¥ä¸‹è½¯ä»¶åŒ…åŒ…æ‹¬ç”¨äºåœ¨å„ç§å­˜å‚¨æŠ€æœ¯ä¸­æŒä¹…å­˜å‚¨é›†ç¾¤æˆå‘˜æ•°æ®çš„æ’ä»¶ã€‚ Microsoft Orleansç¾¤é›†æä¾›è€…ï¼Œç”¨äºAzureè¡¨å­˜å‚¨ PM> Install-Package Microsoft.Orleans.Clustering.AzureStorage åŒ…æ‹¬ç”¨äºä½¿ç”¨Azureè¡¨å­˜å‚¨ç¾¤é›†æˆå‘˜èµ„æ ¼æ•°æ®çš„æ’ä»¶ã€‚ Microsoft Orleans ADO.NETæä¾›ç¨‹åºçš„ç¾¤é›†æä¾›ç¨‹åº PM> Install-Package Microsoft.Orleans.Clustering.AdoNet åŒ…æ‹¬ç”¨äºä½¿ç”¨ADO.NETåœ¨æ”¯æŒçš„æ•°æ®åº“ä¹‹ä¸€ä¸­å­˜å‚¨é›†ç¾¤æˆå‘˜èµ„æ ¼æ•°æ®çš„æ’ä»¶ã€‚ Microsoft Orleansé¢†äº‹å®ç”¨ç¨‹åº PM> Install-Package Microsoft.Orleans.OrleansConsulUtils åŒ…æ‹¬ç”¨äºä½¿ç”¨Consulå­˜å‚¨é›†ç¾¤æˆå‘˜æ•°æ®çš„æ’ä»¶ã€‚ Microsoft Orleans ZooKeeperå®ç”¨ç¨‹åº PM> Install-Package Microsoft.Orleans.OrleansZooKeeperUtils åŒ…æ‹¬ç”¨äºä½¿ç”¨ZooKeeperå­˜å‚¨é›†ç¾¤æˆå‘˜æ•°æ®çš„æ’ä»¶ã€‚ é€‚ç”¨äºAWS DynamoDBçš„Microsoft Orleansç¾¤é›†æä¾›ç¨‹åº PM> Install-Package Microsoft.Orleans.Clustering.DynamoDB åŒ…æ‹¬ç”¨äºä½¿ç”¨AWS DynamoDBå­˜å‚¨é›†ç¾¤æˆå‘˜æ•°æ®çš„æ’ä»¶ã€‚ æé†’æä¾›è€… ä»¥ä¸‹è½¯ä»¶åŒ…åŒ…æ‹¬ç”¨äºåœ¨å„ç§å­˜å‚¨æŠ€æœ¯ä¸­æŒä¹…ä¿å­˜æé†’çš„æ’ä»¶ã€‚ Microsoft Orleansæé†’Azureè¡¨å­˜å‚¨ PM> Install-Package Microsoft.Orleans.Reminders.AzureStorage åŒ…æ‹¬ç”¨äºä½¿ç”¨Azureè¡¨å­˜å‚¨æé†’çš„æ’ä»¶ã€‚ Microsoft Orleansæé†’ADO.NETæä¾›ç¨‹åº PM> Install-Package Microsoft.Orleans.Reminders.AdoNet åŒ…æ‹¬ç”¨äºä½¿ç”¨ADO.NETåœ¨ä¸€ä¸ªå—æ”¯æŒçš„æ•°æ®åº“ä¹‹ä¸€ä¸­å­˜å‚¨æé†’çš„æ’ä»¶ã€‚ Microsoft Orleansæé†’æä¾›è€…ï¼Œé€‚ç”¨äºAWS DynamoDB PM> Install-Package Microsoft.Orleans.Reminders.DynamoDB åŒ…æ‹¬ç”¨äºä½¿ç”¨AWS DynamoDBå­˜å‚¨æé†’çš„æ’ä»¶ã€‚ grainå‚¨å­˜ä¾›åº”å•† ä»¥ä¸‹è½¯ä»¶åŒ…åŒ…æ‹¬ç”¨äºåœ¨å„ç§å­˜å‚¨æŠ€æœ¯ä¸­ä¿æŒgrainsçŠ¶æ€çš„æ’ä»¶ã€‚ Microsoft Orleans Persistence Azureå­˜å‚¨ PM> Install-Package Microsoft.Orleans.Persistence.AzureStorage åŒ…æ‹¬ç”¨äºä½¿ç”¨Azureè¡¨æˆ–Azure Blobå­˜å‚¨GrainçŠ¶æ€çš„æ’ä»¶ã€‚ Microsoft Orleans Persistence ADO.NETæä¾›ç¨‹åº PM> Install-Package Microsoft.Orleans.Persistence.AdoNet åŒ…æ‹¬ç”¨äºä½¿ç”¨ADO.NETåœ¨æ”¯æŒçš„æ•°æ®åº“ä¹‹ä¸€ä¸­å­˜å‚¨grainsçŠ¶æ€çš„æ’ä»¶ã€‚ MicrosoftOrleansæŒä¹…åŒ–DynamoDB PM> Install-Package Microsoft.Orleans.Persistence.DynamoDB åŒ…æ‹¬ç”¨äºä½¿ç”¨AWS DynamoDBå­˜å‚¨GrainçŠ¶æ€çš„æ’ä»¶ã€‚ æµæä¾›è€… ä»¥ä¸‹è½¯ä»¶åŒ…åŒ…æ‹¬ç”¨äºä¼ é€’æµäº‹ä»¶çš„æ’ä»¶ã€‚ Microsoft Orleans ServiceBuså®ç”¨ç¨‹åº PM> Install-Package Microsoft.Orleans.OrleansServiceBus åŒ…æ‹¬Azureäº‹ä»¶ä¸­å¿ƒçš„æµæä¾›ç¨‹åºã€‚ Microsoft Orleansæµå¼Azureå­˜å‚¨ PM> Install-Package Microsoft.Orleans.Streaming.AzureStorage åŒ…æ‹¬Azureé˜Ÿåˆ—çš„æµæä¾›ç¨‹åºã€‚ Microsoft Orleans Streaming AWS SQS PM> Install-Package Microsoft.Orleans.Streaming.SQS åŒ…æ‹¬AWS SQSæœåŠ¡çš„æµæä¾›ç¨‹åºã€‚ Microsoft Orleans Google Cloud Platformå®ç”¨ç¨‹åº PM> Install-Package Microsoft.Orleans.OrleansGCPUtils åŒ…æ‹¬GCP PubSubæœåŠ¡çš„æµæä¾›ç¨‹åºã€‚ å…¶ä»–å¥—é¤ å¾®è½¯Orleansä»£ç ç”Ÿæˆ PM> Install-Package Microsoft.Orleans.OrleansCodeGenerator åŒ…æ‹¬è¿è¡Œæ—¶ä»£ç ç”Ÿæˆå™¨ã€‚ å¾®è½¯Orleansäº‹ä»¶æ¥æº PM> Install-Package Microsoft.Orleans.EventSourcing åŒ…å«ä¸€ç»„ç”¨äºåˆ›å»ºå…·æœ‰äº‹ä»¶æºçŠ¶æ€çš„Grainsç±»çš„åŸºæœ¬ç±»å‹ã€‚ å¼€å‘ä¸æµ‹è¯• å¾®è½¯Orleansä¾›åº”å•† PM> Install-Package Microsoft.Orleans.OrleansProviders åŒ…å«ä¸€ç»„å°†æ•°æ®ä¿ç•™åœ¨å†…å­˜ä¸­çš„æŒä¹…åŒ–å’Œæµæä¾›ç¨‹åºã€‚ç”¨äºæµ‹è¯•ã€‚é€šå¸¸ï¼Œä¸å»ºè®®å°†å…¶ç”¨äºç”Ÿäº§ï¼Œé™¤éå¯ä»¥æ¥å—æ•°æ®ä¸¢å¤±ä»¥é˜²æ­¢å­¤å²›æ•…éšœã€‚ Microsoft Orleansæµ‹è¯•ä¸»æœºåº“ PM> Install-Package Microsoft.Orleans.TestingHost åŒ…æ‹¬ç”¨äºåœ¨æµ‹è¯•é¡¹ç›®ä¸­æ‰˜ç®¡å­¤å²›å’Œå®¢æˆ·ç«¯çš„åº“ã€‚ åºåˆ—åŒ–å™¨ å¾®è½¯Orleanså€ºåˆ¸åºåˆ—åŒ–å™¨ PM> Install-Package Microsoft.Orleans.Serialization.Bond åŒ…æ‹¬å¯¹ å€ºåˆ¸åºåˆ—åŒ–å™¨ ã€‚ Microsoft Orleans Googleå®ç”¨å·¥å…· PM> Install-Package Microsoft.Orleans.OrleansGoogleUtils åŒ…æ‹¬Googleåè®®ç¼“å†²åŒºåºåˆ—åŒ–ç¨‹åºã€‚ Microsoft Orleans protobuf-netåºåˆ—åŒ–å™¨ PM> Install-Package Microsoft.Orleans.ProtobufNet åŒ…æ‹¬åè®®ç¼“å†²åŒºä¸²è¡Œå™¨çš„protobuf-netç‰ˆæœ¬ã€‚ é¥æµ‹ MicrosoftOrleansé¥æµ‹æ¶ˆè´¹è€…-æ€§èƒ½è®¡æ•°å™¨ PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.Counters Orleans Telemetry APIçš„Windows Performance Counterå®ç°ã€‚ Microsoft Orleans Telemetryä½¿ç”¨è€…-Azureåº”ç”¨ç¨‹åºè§è§£ PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.AI åŒ…æ‹¬ç”¨äºAzure Application Insightsçš„é¥æµ‹ä½¿ç”¨è€…ã€‚ å¾®è½¯Orleansé¥æµ‹æ¶ˆè´¹è€…-NewRelic PM> Install-Package Microsoft.Orleans.OrleansTelemetryConsumers.NewRelic åŒ…æ‹¬NewRelicçš„é¥æµ‹ç”¨æˆ·ã€‚ å·¥å…·ç±» Microsoft Orleansæ€§èƒ½è®¡æ•°å™¨å·¥å…· PM> Install-Package Microsoft.Orleans.CounterControl åŒ…æ‹¬OrleansCounterControl.exeï¼Œè¯¥æ–‡ä»¶ä¸ºOrleansç»Ÿè®¡ä¿¡æ¯å’Œå·²éƒ¨ç½²çš„Grainç±»æ³¨å†ŒWindowsæ€§èƒ½è®¡æ•°å™¨ç±»åˆ«ã€‚éœ€è¦æµ·æ‹”ã€‚å¯ä»¥ä½œä¸ºè§’è‰²å¯åŠ¨ä»»åŠ¡çš„ä¸€éƒ¨åˆ†åœ¨Azureä¸­æ‰§è¡Œã€‚ äº¤æ˜“æ¬¡æ•° Microsoft Orleans Transactionsæ”¯æŒ PM> Install-Package Microsoft.Orleans.Transactions åŒ…æ‹¬å¯¹è·¨Grainsäº¤æ˜“(æµ‹è¯•ç‰ˆ)çš„æ”¯æŒã€‚ Microsoftåœ¨Azureä¸Šè¿›è¡ŒOrleansäº¤æ˜“ PM> Install-Package Microsoft.Orleans.Transactions.AzureStorage åŒ…æ‹¬ç”¨äºåœ¨Azureè¡¨(beta)ä¸­æŒä¹…ä¿å­˜äº‹åŠ¡æ—¥å¿—çš„æ’ä»¶ã€‚"
  },
  "Documentation/grains/grain_versioning/version_selector_strategy.html": {
    "href": "Documentation/grains/grain_versioning/version_selector_strategy.html",
    "title": "ç‰ˆæœ¬é€‰æ‹©å™¨ç­–ç•¥ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ç‰ˆæœ¬é€‰æ‹©å™¨ç­–ç•¥ å½“é›†ç¾¤ä¸­å­˜åœ¨ç›¸åŒgrainsæ¥å£çš„å¤šä¸ªç‰ˆæœ¬ï¼Œå¹¶ä¸”å¿…é¡»åˆ›å»ºæ–°çš„æ¿€æ´»æ—¶ï¼Œ å…¼å®¹ç‰ˆæœ¬ å°†æ ¹æ®ä¸­å®šä¹‰çš„ç­–ç•¥è¿›è¡Œé€‰æ‹© GrainVersioningOptions.DefaultVersionSelectorStrategy ã€‚ å¼€ç®±å³ç”¨çš„Orleansæ”¯æŒä»¥ä¸‹ç­–ç•¥ï¼š æ‰€æœ‰å…¼å®¹ç‰ˆæœ¬(é»˜è®¤) ä½¿ç”¨æ­¤ç­–ç•¥ï¼Œå°†åœ¨æ‰€æœ‰å…¼å®¹ç‰ˆæœ¬ä¸­éšæœºé€‰æ‹©æ–°æ¿€æ´»çš„ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ç»™å®šçš„grainsæ¥å£çš„ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå³V1å’ŒV2ï¼š V2ä¸V1å‘åå…¼å®¹ é›†ç¾¤ä¸­æœ‰2ä¸ªæ”¯æŒV2çš„silosï¼Œæœ‰8ä¸ªæ”¯æŒV1çš„silos è¯¥è¯·æ±‚æ˜¯ä»V1å®¢æˆ·/siloså‘å‡ºçš„ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ–°æ¿€æ´»å°†æœ‰20ï¼…çš„æœºä¼šæˆä¸ºV2ï¼Œè€Œæœ‰80ï¼…çš„æœºä¼šå°†æ˜¯V1ã€‚ æœ€æ–°ç‰ˆæœ¬ ä½¿ç”¨æ­¤ç­–ç•¥ï¼Œæ–°æ¿€æ´»çš„ç‰ˆæœ¬å°†å§‹ç»ˆæ˜¯æœ€æ–°çš„å…¼å®¹ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ç»™å®šçš„grainsæ¥å£çš„ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå³V1å’ŒV2(V2å‘åæˆ–ä¸V1å®Œå…¨å…¼å®¹)ï¼Œåˆ™æ‰€æœ‰æ–°æ¿€æ´»å°†ä¸ºV2ã€‚ æœ€ä½ç‰ˆæœ¬ ä½¿ç”¨æ­¤ç­–ç•¥ï¼Œæ–°æ¿€æ´»çš„ç‰ˆæœ¬å°†å§‹ç»ˆæ˜¯è¯·æ±‚çš„ç‰ˆæœ¬æˆ–æœ€ä½å…¼å®¹ç‰ˆæœ¬ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœç»™å®šçš„Grainæ¥å£æœ‰2ä¸ªç‰ˆæœ¬ï¼Œå³V2ï¼ŒV3ï¼Œåˆ™æ‰€æœ‰ç‰ˆæœ¬éƒ½å®Œå…¨å…¼å®¹ï¼š å¦‚æœè¯·æ±‚æ˜¯ä»V1å®¢æˆ·ç«¯/siloså‘å‡ºçš„ï¼Œåˆ™æ–°çš„æ¿€æ´»å°†æ˜¯V2 å¦‚æœè¯·æ±‚æ˜¯ä»V3å®¢æˆ·ç«¯/siloså‘å‡ºçš„ï¼Œåˆ™æ–°çš„æ¿€æ´»ä¹Ÿå°†æ˜¯V2"
  },
  "Documentation/grains/grain_versioning/grain_versioning.html": {
    "href": "Documentation/grains/grain_versioning/grain_versioning.html",
    "title": "grainsæ¥å£ç‰ˆæœ¬æ§åˆ¶ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "grainsæ¥å£ç‰ˆæœ¬æ§åˆ¶ [!è­¦å‘Š]æœ¬é¡µä»‹ç»å¦‚ä½•ä½¿ç”¨Grainæ¥å£ç‰ˆæœ¬æ§åˆ¶ã€‚GrainçŠ¶æ€çš„ç‰ˆæœ¬æ§åˆ¶è¶…å‡ºèŒƒå›´ã€‚ æ¦‚è¿° åœ¨ç»™å®šçš„é›†ç¾¤ä¸Šï¼Œsiloså¯ä»¥æ”¯æŒä¸åŒç‰ˆæœ¬çš„Grainsç±»å‹ã€‚ åœ¨æœ¬ä¾‹ä¸­ï¼Œå®¢æˆ·ç«¯å’Œsilos{1,2,3}æ˜¯ç”¨grainæ¥å£ç¼–è¯‘çš„ A ç‰ˆæœ¬1ã€‚silos4æ˜¯ç”¨ A ç‰ˆæœ¬2ã€‚ é™åˆ¶ï¼š æ— çŠ¶æ€å·¥ä½œè¿›ç¨‹ æµæ¥å£æ²¡æœ‰ç‰ˆæœ¬æ§åˆ¶ å¯ç”¨ç‰ˆæœ¬æ§åˆ¶ é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸ä¼šå¯¹grainsè¿›è¡Œç‰ˆæœ¬æ§åˆ¶ã€‚æ‚¨å¯ä»¥ä½¿ç”¨grainæ¥å£ä¸Šçš„VersionAttributeæ¥è®¾ç½®grainç‰ˆæœ¬ï¼š [Version(X)] public interface IVersionUpgradeTestGrain : IGrainWithIntegerKey {} åœ¨å“ªé‡Œï¼Ÿ å æ˜¯grainsæ¥å£çš„ç‰ˆæœ¬å·ï¼Œé€šå¸¸å•è°ƒé€’å¢ã€‚ grainsç‰ˆæœ¬å…¼å®¹æ€§å’Œå­˜å‚¨ å½“æ¥è‡ªç‰ˆæœ¬æ§åˆ¶çš„grainçš„è°ƒç”¨åˆ°è¾¾é›†ç¾¤æ—¶ï¼š å¦‚æœä¸å­˜åœ¨æ¿€æ´»ï¼Œå°†åˆ›å»ºå…¼å®¹çš„æ¿€æ´» å¦‚æœæ¿€æ´»å­˜åœ¨ï¼š å¦‚æœå½“å‰çš„ä¸å…¼å®¹ï¼Œå®ƒå°†è¢«åœç”¨å¹¶åˆ›å»ºæ–°çš„å…¼å®¹çš„(è¯·å‚é˜… ç‰ˆæœ¬é€‰æ‹©å™¨ç­–ç•¥ ) å¦‚æœå½“å‰ç‰ˆæœ¬å…¼å®¹(è¯·å‚è§ ç›¸å®¹grains )ï¼Œè®¿é—®å°†æ­£å¸¸å¤„ç†ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼š æ‰€æœ‰ç‰ˆæœ¬åŒ–çš„grainsåªèƒ½å‘åå…¼å®¹(å‚è§ å‘åå…¼å®¹å‡†åˆ™ å’Œ ç›¸å®¹grains ). è¿™æ„å‘³ç€v1grainså¯ä»¥è°ƒç”¨v2grainsï¼Œä½†v2grainsä¸èƒ½è°ƒç”¨v1ã€‚ å½“é›†ç¾¤ä¸­å­˜åœ¨å¤šä¸ªç‰ˆæœ¬æ—¶ï¼Œæ–°çš„æ¿€æ´»å°†éšæœºå­˜å‚¨åœ¨å…¼å®¹çš„silosä¸Šã€‚ æ‚¨å¯ä»¥é€šè¿‡é€‰é¡¹æ›´æ”¹æ­¤é»˜è®¤è¡Œä¸º GrainVersioningé€‰é¡¹ : var silo = new SiloHostBuilder() [...] .Configure<GrainVersioningOptions>(options => { options.DefaultCompatibilityStrategy = nameof(BackwardCompatible); options.DefaultVersionSelectorStrategy = nameof(MinimumVersion); }) [...]"
  },
  "Documentation/grains/event_sourcing/replicated_instances.html": {
    "href": "Documentation/grains/event_sourcing/replicated_instances.html",
    "title": "Replicated Grains | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¤šå‰¯æœ¬ Grains æœ‰æ—¶ï¼ŒåŒä¸€Grainçš„å¤šä¸ªå®ä¾‹å¯èƒ½å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œä¾‹å¦‚åœ¨æ“ä½œå¤šé›†ç¾¤æ—¶ï¼Œä½¿ç”¨ [OneInstancePerCluster] å±æ€§ã€‚journaledgrainæ—¨åœ¨ä»¥æœ€å°çš„å½±å“æ”¯æŒå¤šå‰¯æœ¬å®ä¾‹ã€‚å®ƒä¾èµ–äº æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº è¿è¡Œå¿…è¦çš„åè®®ä»¥ç¡®ä¿æ‰€æœ‰å®ä¾‹åŒæ„ç›¸åŒçš„äº‹ä»¶åºåˆ—ã€‚ç‰¹åˆ«è¦æ³¨æ„ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š ä¸€è‡´çš„ç‰ˆæœ¬ ï¼šGrainsçŠ¶æ€çš„æ‰€æœ‰ç‰ˆæœ¬(ä¸´æ—¶ç‰ˆæœ¬é™¤å¤–)éƒ½åŸºäºç›¸åŒçš„å…¨å±€äº‹ä»¶åºåˆ—ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¦‚æœä¸¤ä¸ªå®ä¾‹çœ‹åˆ°ç›¸åŒçš„ç‰ˆæœ¬å·ï¼Œåˆ™å®ƒä»¬çœ‹åˆ°ç›¸åŒçš„çŠ¶æ€ã€‚ äº‹ä»¶ç«äº‰ ï¼šå¤šä¸ªå®ä¾‹å¯ä»¥åŒæ—¶å¼•å‘äº‹ä»¶ã€‚ä¸€è‡´æ€§æä¾›ç¨‹åºè§£å†³äº†è¿™ä¸ªç«äº‰ï¼Œå¹¶ç¡®ä¿æ¯ä¸ªäººéƒ½åŒæ„ç›¸åŒçš„é¡ºåºã€‚ é€šçŸ¥/ååº”æ€§ ï¼šåœ¨ä¸€ä¸ªGrainså®ä¾‹ä¸Šå¼•å‘äº‹ä»¶åï¼Œä¸€è‡´æ€§æä¾›ç¨‹åºä¸ä»…æ›´æ–°å­˜å‚¨ï¼Œè¿˜é€šçŸ¥æ‰€æœ‰å…¶ä»–Grainså®ä¾‹ã€‚ æœ‰å…³ä¸€è‡´æ€§æ¨¡å‹çš„ä¸€èˆ¬è®¨è®ºï¼Œè¯·å‚è§ æŠ€æœ¯æŠ¥å‘Š ä»¥åŠ GSP è®ºæ–‡ (å…¨å±€åºåˆ—åè®®)ã€‚ æ¡ä»¶äº‹ä»¶ å¦‚æœäº‹ä»¶ç«äº‰æœ‰å†²çªï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç”±äºæŸç§åŸå› ï¼Œä¸åº”è¯¥åŒæ—¶è¿›è¡Œï¼Œé‚£ä¹ˆäº‹ä»¶ç«äº‰å¯èƒ½ä¼šæœ‰é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ä»é“¶è¡Œè´¦æˆ·å–æ¬¾æ—¶ï¼Œæœ‰ä¸¤ä¸ªå®ä¾‹å¯ä»¥ç‹¬ç«‹åœ°ç¡®å®šæœ‰è¶³å¤Ÿçš„èµ„é‡‘ç”¨äºå–æ¬¾ï¼Œå¹¶å‘å‡ºå–æ¬¾äº‹ä»¶ã€‚ä½†è¿™ä¸¤ä¸ªäº‹ä»¶çš„ç»“åˆå¯èƒ½é€æ”¯ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œjournaledgrain apiæ”¯æŒ RaiseConditionalEvent æ–¹æ³•ã€‚ bool success = await RaiseConditionalEvent(new WithdrawalEvent() { ... }); æ¡ä»¶äº‹ä»¶ä»”ç»†æ£€æŸ¥æœ¬åœ°ç‰ˆæœ¬æ˜¯å¦ä¸å­˜å‚¨ä¸­çš„ç‰ˆæœ¬åŒ¹é…ã€‚å¦‚æœæ²¡æœ‰ï¼Œåˆ™æ„å‘³ç€äº‹ä»¶åºåˆ—åŒæ—¶å¢é•¿ï¼Œè¿™æ„å‘³ç€æ­¤äº‹ä»¶å·²å¤±å»ä¸å…¶ä»–äº‹ä»¶çš„ç«äº‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¡ä»¶äº‹ä»¶æ˜¯ ä¸ é™„åŠ åˆ°æ—¥å¿—ä¸­ï¼Œå¹¶ä¸” RaiseConditionalEvent è¿”å›falseã€‚ è¿™ç±»ä¼¼äºåœ¨æ¡ä»¶å­˜å‚¨æ›´æ–°ä¸­ä½¿ç”¨e-tagsï¼Œå¹¶ä¸”åŒæ ·æä¾›äº†ä¸€ç§ç®€å•çš„æœºåˆ¶æ¥é¿å…æäº¤å†²çªäº‹ä»¶ã€‚ å¯¹åŒä¸€ä¸ªGrainåŒæ—¶ä½¿ç”¨æ¡ä»¶å’Œæ— æ¡ä»¶äº‹ä»¶æ˜¯å¯èƒ½å’Œæ˜æ™ºçš„ï¼Œä¾‹å¦‚ DepositEvent ä»¥åŠ WithdrawalEvent ã€‚å­˜æ¬¾ä¸éœ€è¦æœ‰æ¡ä»¶ï¼šå³ä½¿ DepositEvent å¦‚æœç«äº‰å¤±è´¥ï¼Œåˆ™ä¸å¿…å–æ¶ˆï¼Œä½†ä»å¯ä»¥é™„åŠ åˆ°å…¨å±€äº‹ä»¶åºåˆ—ä¸­ã€‚ ç­‰å¾…ä»»åŠ¡è¿”å›è€… RaiseConditionalEvent è¶³ä»¥ç¡®è®¤äº‹ä»¶ï¼Œå³ä¸å¿…åŒæ—¶è°ƒç”¨ ConfirmEvents ã€‚ æ˜¾å¼åŒæ­¥ æœ‰æ—¶ï¼Œæœ€å¥½ç¡®ä¿Grainså®Œå…¨èµ¶ä¸Šæœ€æ–°ç‰ˆæœ¬ã€‚è¿™å¯ä»¥é€šè¿‡è°ƒç”¨ await RefreshNow(); å…¶ä¸­(1)ç¡®è®¤æ‰€æœ‰æœªç¡®è®¤äº‹ä»¶ï¼Œå’Œ(2)ä»å­˜å‚¨ä¸­åŠ è½½æœ€æ–°ç‰ˆæœ¬ã€‚"
  },
  "Documentation/grains/event_sourcing/log_consistency_providers.html": {
    "href": "Documentation/grains/event_sourcing/log_consistency_providers.html",
    "title": "Log-Consistency Providers | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å†…ç½®æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº çš„ Microsoft.Orleans.EventSourcing è¯¥è½¯ä»¶åŒ…åŒ…æ‹¬å‡ ä¸ªæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºï¼Œè¿™äº›æä¾›ç¨‹åºæ¶µç›–äº†é€‚åˆå…¥é—¨çš„åŸºæœ¬æ–¹æ¡ˆï¼Œå¹¶å…·æœ‰ä¸€å®šçš„å¯æ‰©å±•æ€§ã€‚ Orleans.EventSourcing. StateStorage .LogConsistencyProvide è¯¥æä¾›å•†å­˜å‚¨ grainsçŠ¶æ€å¿«ç…§ ï¼Œä½¿ç”¨å¯ä»¥ç‹¬ç«‹é…ç½®çš„æ ‡å‡†å­˜å‚¨æä¾›ç¨‹åºã€‚ ä¿ç•™åœ¨å­˜å‚¨ä¸­çš„æ•°æ®æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒæ—¢åŒ…å«GrainçŠ¶æ€(ç”±ç¬¬ä¸€ä¸ªtypeå‚æ•°æŒ‡å®šä¸º JournaledGrain )å’Œä¸€äº›å…ƒæ•°æ®(ç‰ˆæœ¬å·ï¼Œä»¥åŠç”¨äºé¿å…å­˜å‚¨è®¿é—®å¤±è´¥æ—¶äº‹ä»¶é‡å¤çš„ç‰¹æ®Šæ ‡è®°)ã€‚ ç”±äºæ¯æ¬¡è®¿é—®å­˜å‚¨æ—¶éƒ½ä¼šè¯»å–/å†™å…¥æ•´ä¸ªgrainsçŠ¶æ€ï¼Œå› æ­¤æ­¤æä¾›ç¨‹åºä¸é€‚ç”¨äºgrainsçŠ¶æ€éå¸¸å¤§çš„å¯¹è±¡ã€‚ è¯¥æä¾›è€…ä¸æ”¯æŒ RetrieveConfirmedEvents (æ£€ç´¢å·²ç¡®è®¤äº‹ä»¶)ï¼šå®ƒä¸èƒ½ä»å­˜å‚¨ä¸­æ£€ç´¢äº‹ä»¶ï¼Œå› ä¸ºäº‹ä»¶æ²¡æœ‰æŒä¹…åŒ–ã€‚ Orleans.EventSourcingã€‚ LogStorage .LogConsistencyProvider è¯¥æä¾›å•†å­˜å‚¨ å®Œæ•´çš„äº‹ä»¶åºåˆ—ä½œä¸ºå•ä¸ªå¯¹è±¡ ï¼Œä½¿ç”¨å¯ä»¥ç‹¬ç«‹é…ç½®çš„æ ‡å‡†å­˜å‚¨æä¾›ç¨‹åºã€‚ ä¿ç•™åœ¨å­˜å‚¨ä¸­çš„æ•°æ®æ˜¯ä¸€ä¸ªåŒ…å«ä»¥ä¸‹å†…å®¹çš„å¯¹è±¡ï¼š List <EventType> object ä»¥åŠä¸€äº›å…ƒæ•°æ®(ä¸€ä¸ªç‰¹æ®Šçš„æ ‡è®°ï¼Œç”¨äºåœ¨å­˜å‚¨è®¿é—®å¤±è´¥æ—¶é¿å…äº‹ä»¶é‡å¤)ã€‚ è¯¥æä¾›è€…ç¡®å®æ”¯æŒ RetrieveConfirmedEvents . æ‰€æœ‰äº‹ä»¶å§‹ç»ˆå¯ç”¨å¹¶ä¿å­˜åœ¨å†…å­˜ä¸­ã€‚ ç”±äºæ¯æ¬¡è®¿é—®å­˜å‚¨æ—¶éƒ½ä¼šè¯»å–/å†™å…¥æ•´ä¸ªäº‹ä»¶åºåˆ—ï¼Œå› æ­¤æ­¤æä¾›ç¨‹åºæ˜¯ ä¸é€‚åˆåœ¨ç”Ÿäº§ä¸­ä½¿ç”¨ ï¼Œé™¤éä¿è¯äº‹ä»¶åºåˆ—ä¿æŒå¾ˆçŸ­ã€‚æ­¤æä¾›ç¨‹åºçš„ä¸»è¦ç›®çš„æ˜¯è¯´æ˜äº‹ä»¶æºçš„è¯­ä¹‰ï¼Œä»¥åŠç”¨äºç¤ºä¾‹/æµ‹è¯•ç¯å¢ƒçš„è¯­ä¹‰ã€‚ Orleans.EventSourcing. CustomStorage .LogConsistencyProvider æ­¤æä¾›ç¨‹åºå…è®¸å¼€å‘äººå‘˜æ’å…¥è‡ªå·±çš„å­˜å‚¨æ¥å£ï¼Œç„¶ååœ¨é€‚å½“çš„æ—¶é—´ç”±conistencyåè®®è°ƒç”¨ã€‚è¿™ä¸ªæä¾›ç¨‹åºä¸ä¼šå¯¹å­˜å‚¨çš„å†…å®¹æ˜¯çŠ¶æ€å¿«ç…§è¿˜æ˜¯äº‹ä»¶åšå‡ºç‰¹å®šçš„å‡è®¾â€”ç¨‹åºå‘˜å¯ä»¥æ§åˆ¶è¿™ä¸ªé€‰æ‹©(å¹¶ä¸”å¯ä»¥å­˜å‚¨å…¶ä¸­ä¸€ä¸ªæˆ–ä¸¤ä¸ª)ã€‚ è¦ä½¿ç”¨æ­¤æä¾›ç¨‹åºï¼Œå¿…é¡»ä» JournaledGrain<StateType, EventType> ï¼Œä½†è¿˜å¿…é¡»å®ç°ä»¥ä¸‹æ¥å£ï¼š public interface ICustomStorageInterface<StateType, EventType> { Task<KeyValuePair<int,StateType>> ReadStateFromStorage(); Task<bool> ApplyUpdatesToStorage(IReadOnlyList<EventType> updates, int expectedversion); } ä¸€è‡´æ€§æä¾›ç¨‹åºå¸Œæœ›å®ƒä»¬ä»¥æŸç§æ–¹å¼è¿è¡Œã€‚ç¨‹åºå‘˜åº”è¯¥æ„è¯†åˆ°ï¼š ç¬¬ä¸€ç§æ–¹æ³•ï¼Œ ReadStateFromStorage ï¼Œåº”åŒæ—¶è¿”å›ç‰ˆæœ¬å’ŒçŠ¶æ€readã€‚å¦‚æœå°šæœªå­˜å‚¨ä»»ä½•å†…å®¹ï¼Œåˆ™åº”ä¸ºç‰ˆæœ¬è¿”å›é›¶ï¼Œå¹¶è¿”å›ä¸çš„é»˜è®¤æ„é€ å‡½æ•°ç›¸åŒ¹é…çš„çŠ¶æ€ çŠ¶æ€ç±»å‹ . ApplyUpdatesToStorage å¦‚æœé¢„æœŸç‰ˆæœ¬ä¸å®é™…ç‰ˆæœ¬ä¸åŒ¹é…ï¼Œåˆ™å¿…é¡»è¿”å›false(è¿™ç±»ä¼¼äºe-tagæ£€æŸ¥)ã€‚ å¦‚æœ ApplyUpdatesToStorage å¤±è´¥ï¼Œä½†å‡ºç°å¼‚å¸¸ï¼Œä¸€è‡´æ€§æä¾›ç¨‹åºå°†é‡è¯•ã€‚è¿™æ„å‘³ç€å¦‚æœæŠ›å‡ºè¿™æ ·çš„å¼‚å¸¸ï¼ŒæŸäº›äº‹ä»¶å¯èƒ½ä¼šè¢«å¤åˆ¶ï¼Œä½†äº‹ä»¶å®é™…ä¸Šæ˜¯æŒä¹…åŒ–çš„ã€‚å¼€å‘äººå‘˜è´Ÿè´£ç¡®ä¿è¿™æ˜¯å®‰å…¨çš„ï¼šä¾‹å¦‚ï¼Œè¦ä¹ˆé€šè¿‡ä¸å¼•å‘å¼‚å¸¸æ¥é¿å…è¿™ç§æƒ…å†µï¼Œè¦ä¹ˆç¡®ä¿é‡å¤äº‹ä»¶å¯¹åº”ç”¨ç¨‹åºé€»è¾‘æ— å®³ï¼Œè¦ä¹ˆæ·»åŠ ä¸€äº›é¢å¤–çš„æœºåˆ¶æ¥è¿‡æ»¤é‡å¤é¡¹ã€‚ æ­¤æä¾›ç¨‹åºä¸æ”¯æŒ RetrieveConfirmedEvents . å½“ç„¶ï¼Œç”±äºå¼€å‘äººå‘˜æ— è®ºå¦‚ä½•éƒ½æ§åˆ¶ç€å­˜å‚¨æ¥å£ï¼Œæ‰€ä»¥ä»–ä»¬ä¸éœ€è¦é¦–å…ˆè°ƒç”¨è¿™ä¸ªæ¥å£ï¼Œè€Œæ˜¯å¯ä»¥å®ç°è‡ªå·±çš„äº‹ä»¶æ£€ç´¢ã€‚"
  },
  "Documentation/grains/event_sourcing/event_sourcing_configuration.html": {
    "href": "Documentation/grains/event_sourcing/event_sourcing_configuration.html",
    "title": "Configuration | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é…ç½® é…ç½®é¡¹ç›®å¼•ç”¨ grainsæ¥å£ å’Œä»¥å‰ä¸€æ ·ï¼Œæ¥å£åªä¾èµ–äº å¾®è½¯.orleans.core åŒ…ï¼Œå› ä¸ºgrainæ¥å£ç‹¬ç«‹äºå®ç°ã€‚ Grainså®ç° æ—¥å¿—éœ€è¦ä» è¡Œç¨‹<sï¼Œe> æˆ– æ—¥å¿—è®°å½•<s> ï¼Œå®šä¹‰è§ Microsoft.Orleans.EventSourcing åŒ…è£¹ã€‚ æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº æˆ‘ä»¬ç›®å‰åŒ…æ‹¬ä¸‰ä¸ªæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº(ç”¨äºçŠ¶æ€å­˜å‚¨ã€æ—¥å¿—å­˜å‚¨å’Œè‡ªå®šä¹‰å­˜å‚¨)ã€‚è¿™ä¸‰ä¸ªéƒ½åŒ…å«åœ¨ Microsoft.Orleans.EventSourcing åŒ…è£…ä¹Ÿä¸€æ ·ã€‚å› æ­¤ï¼Œæ‰€æœ‰è¢«è®°å½•çš„Grainséƒ½å·²ç»å¯ä»¥è·å¾—è¿™äº›ã€‚æœ‰å…³è¿™äº›æä¾›ç¨‹åºçš„åŠŸèƒ½å’ŒåŒºåˆ«çš„è¯´æ˜ï¼Œè¯·å‚è§ åŒ…æ‹¬æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº . ç¾¤é›†é…ç½® æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºçš„é…ç½®ä¸ä»»ä½•å…¶ä»–Orleansæä¾›ç¨‹åºä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œè¦åŒ…å«æ‰€æœ‰ä¸‰ä¸ªæä¾›è€…(å½“ç„¶ï¼Œæ‚¨å¯èƒ½ä¸éœ€è¦å…¨éƒ¨ä¸‰ä¸ªæä¾›è€…)ï¼Œè¯·å°†æ­¤æ·»åŠ åˆ° <Globals> é…ç½®æ–‡ä»¶çš„å…ƒç´ ï¼š <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.StateStorage.LogConsistencyProvider\" Name=\"StateStorage\" /> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"LogStorage\" /> <Provider Type=\"Orleans.EventSourcing.CustomStorage.LogConsistencyProvider\" Name=\"CustomStorage\" /> </LogConsistencyProviders> åŒæ ·å¯ä»¥é€šè¿‡ç¼–ç¨‹å®ç°ã€‚ç§»åŠ¨åˆ°2.0.0ç¨³å®šï¼Œå®¢æˆ·ç«¯é…ç½®å’Œé›†ç¾¤é…ç½®ä¸å†å­˜åœ¨ï¼å®ƒç°åœ¨å·²ç»è¢«ä¸€ä¸ªclientbuilderå’Œä¸€ä¸ªsilobuilderæ‰€å–ä»£(æ³¨æ„æ²¡æœ‰é›†ç¾¤æ„å»ºå™¨)ã€‚ builder.AddLogStorageBasedLogConsistencyProvider(\"LogStorage\") Grainsç±»å±æ€§ æ¯ä¸ªè®°å½•çš„Grainsç±»å¿…é¡»æœ‰ æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº å±æ€§æŒ‡å®šæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºã€‚ä¸€äº›æä¾›å•†è¿˜è¦æ±‚ å­˜å‚¨æä¾›ç¨‹åº å±æ€§ã€‚å¦‚ï¼š[å­˜å‚¨æä¾›ç¨‹åº(providername=â€œorleanslocalstorageâ€)][logconsistencyprovider(providername = \"logstorage\")]å…¬å…±ç±»äº‹ä»¶æºdbankAccountGrain:JournaledGrain ï¼ŒIEventSourceBankAccountGrain{} æ‰€ä»¥è¿™é‡Œâ€œorleanslocalstorageâ€è¢«ç”¨æ¥å­˜å‚¨grainçŠ¶æ€ï¼Œå…¶ä¸­â€œlogstorageâ€æ˜¯eventsourcingäº‹ä»¶çš„å†…å­˜å­˜å‚¨æä¾›ç¨‹åºã€‚ LogConsistencyProviderå±æ€§ è¦æŒ‡å®šæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºï¼Œè¯·æ·»åŠ  [æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº(providername=â€¦)] å±æ€§ï¼Œå¹¶æä¾›ç”±ç¾¤é›†é…ç½®é…ç½®é…ç½®çš„æä¾›ç¨‹åºçš„åç§°ã€‚ä¾‹å¦‚ï¼š [LogConsistencyProvider(ProviderName = \"CustomStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain, ICustomStorage { ... } StorageProviderå±æ€§ ä¸€äº›æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº(åŒ…æ‹¬ æ—¥å¿—å­˜å‚¨ å’Œ çŠ¶æ€å­˜å‚¨ )ä½¿ç”¨æ ‡å‡†çš„StorageProviderä¸å­˜å‚¨é€šä¿¡ã€‚æ­¤æä¾›ç¨‹åºä½¿ç”¨å•ç‹¬çš„ å­˜å‚¨æä¾›ç¨‹åº å±æ€§ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š [LogConsistencyProvider(ProviderName = \"LogStorage\")] [StorageProvider(ProviderName = \"AzureBlobStorage\")] public class ChatGrain : JournaledGrain<XDocument, IChatEvent>, IChatGrain { ... } é»˜è®¤æä¾›ç¨‹åº å¯ä»¥çœç•¥ æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº å’Œ/æˆ– å­˜å‚¨æä¾›ç¨‹åº å±æ€§ï¼Œå¦‚æœåœ¨é…ç½®ä¸­æŒ‡å®šäº†é»˜è®¤å€¼ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ç‰¹æ®Šçš„åç§°æ¥å®Œæˆçš„ è¿çº¦ å„è‡ªçš„ä¾›åº”å•†ã€‚ä¾‹å¦‚ï¼š <LogConsistencyProviders> <Provider Type=\"Orleans.EventSourcing.LogStorage.LogConsistencyProvider\" Name=\"Default\" /> </LogConsistencyProviders> <StorageProviders> <Provider Type=\"Orleans.Storage.MemoryStorage\" Name=\"Default\" /> </StorageProviders>"
  },
  "Documentation/grains/event_sourcing/immediate_vs_delayed_confirmation.html": {
    "href": "Documentation/grains/event_sourcing/immediate_vs_delayed_confirmation.html",
    "title": "Immediate vs. Delayed Confirmation | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ç«‹å³ç¡®è®¤ å¯¹äºè®¸å¤šåº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å¸Œæœ›ç¡®ä¿äº‹ä»¶ç«‹å³å¾—åˆ°ç¡®è®¤ï¼Œä»¥ä¾¿æŒä¹…åŒ–çš„ç‰ˆæœ¬ä¸ä¼šè½åäºå†…å­˜ä¸­çš„å½“å‰ç‰ˆæœ¬ï¼Œå¹¶ä¸”æˆ‘ä»¬ä¸ä¼šå†’ä¸¢å¤±æœ€æ–°çŠ¶æ€çš„é£é™©(å¦‚æœgrainå¤±è´¥)ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹è§„åˆ™æ¥ä¿è¯ï¼š åœ¨Grainæ–¹æ³•è¿”å›ä¹‹å‰ï¼Œä½¿ç”¨ ConfirmEvents ç¡®è®¤æ‰€æœ‰ RaiseEvent è°ƒç”¨ã€‚ åœ¨Grainæ–¹æ³•è¿”å›ä¹‹å‰ç¡®ä¿ç”± RaiseConditionalEvent è¿”å›çš„ä»»åŠ¡å·²å®Œæˆã€‚ é¿å… [Reentrant] æˆ– [AlwaysInterleave] å±æ€§ï¼Œå› æ­¤ä¸€æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªgrainè°ƒç”¨ã€‚ å¦‚æœæˆ‘ä»¬éµå¾ªè¿™äº›è§„åˆ™ï¼Œåˆ™æ„å‘³ç€åœ¨å¼•å‘äº‹ä»¶ä¹‹åï¼Œåœ¨å°†äº‹ä»¶å†™å…¥å­˜å‚¨å™¨ä¹‹å‰ï¼Œä¸èƒ½æ‰§è¡Œå…¶ä»–Grainä»£ç ã€‚å› æ­¤ï¼Œä¸å¯èƒ½è§‚å¯Ÿåˆ°å†…å­˜ä¸­çš„ç‰ˆæœ¬å’Œå­˜å‚¨ä¸­çš„ç‰ˆæœ¬ä¹‹é—´çš„ä¸ä¸€è‡´ã€‚è™½ç„¶è¿™é€šå¸¸æ­£æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œä½†å®ƒä¹Ÿæœ‰ä¸€äº›æ½œåœ¨çš„ç¼ºç‚¹ã€‚ æ½œåœ¨åŠ£åŠ¿ å¦‚æœ ä¸è¿œç¨‹ç¾¤é›†æˆ–å­˜å‚¨çš„è¿æ¥æš‚æ—¶ä¸­æ–­ ï¼Œåˆ™grainå˜å¾—ä¸å¯ç”¨ï¼šå®é™…ä¸Šï¼Œgrainåœ¨ç­‰å¾…ç¡®è®¤äº‹ä»¶æ—¶æ— æ³•æ‰§è¡Œä»»ä½•ä»£ç ï¼Œè¿™å¯èƒ½éœ€è¦æ— é™é•¿çš„æ—¶é—´(æ—¥å¿—ä¸€è‡´æ€§åè®®ä¸€ç›´åœ¨é‡è¯•ï¼Œç›´åˆ°æ¢å¤å­˜å‚¨è¿æ¥)ã€‚ å¤„ç†æ—¶ å¯¹å•ä¸ªgrainå®ä¾‹çš„å¤§é‡æ›´æ–° ï¼Œä¸€æ¬¡ç¡®è®¤ä¸€ä¸ªä¼šå˜å¾—éå¸¸ä½æ•ˆï¼Œå³ååé‡å¾ˆä½ã€‚ å»¶è¿Ÿç¡®è®¤ ä¸ºäº†æé«˜ä¸Šè¿°æƒ…å†µä¸‹çš„å¯ç”¨æ€§å’Œååé‡ï¼ŒGrainså¯ä»¥é€‰æ‹©æ‰§è¡Œä»¥ä¸‹ä¸€é¡¹æˆ–ä¸¤é¡¹æ“ä½œï¼š å…è®¸grainæ–¹æ³•åœ¨ä¸ç­‰å¾…ç¡®è®¤çš„æƒ…å†µä¸‹å¼•å‘äº‹ä»¶ã€‚ å…è®¸é‡å…¥ï¼Œè¿™æ ·å³ä½¿ä»¥å‰çš„è°ƒç”¨åœ¨ç­‰å¾…ç¡®è®¤æ—¶è¢«é˜»å¡ï¼Œgrainä¹Ÿå¯ä»¥ç»§ç»­å¤„ç†æ–°çš„è°ƒç”¨ã€‚ è¿™æ„å‘³ç€å½“æŸäº›äº‹ä»¶ä»åœ¨ç¡®è®¤è¿‡ç¨‹ä¸­æ—¶ï¼Œå¯ä»¥æ‰§è¡ŒGrainä»£ç ã€‚è¿™ä¸ª æ—¥å¿—è®°å½• apiæœ‰ä¸€äº›å…·ä½“è§„å®šï¼Œè®©å¼€å‘äººå‘˜èƒ½å¤Ÿç²¾ç¡®æ§åˆ¶å¦‚ä½•å¤„ç†å½“å‰â€œæ­£åœ¨è¿è¡Œâ€çš„æœªç»ç¡®è®¤çš„äº‹ä»¶ã€‚ å¯ä»¥æ£€æŸ¥ä»¥ä¸‹å±æ€§ä»¥äº†è§£å½“å‰æœªç¡®è®¤çš„äº‹ä»¶ï¼š IEnumerable<EventType> UnconfirmedEvents { get; } è€Œä¸”ï¼Œç”±äº State å±æ€§ä¸åŒ…æ‹¬æœªç¡®è®¤äº‹ä»¶çš„å½±å“ï¼Œæœ‰ä¸€ä¸ªå¯é€‰å±æ€§ StateType TentativeState { get; } å®ƒè¿”å›ä¸€ä¸ªâ€œæš‚å®šâ€çŠ¶æ€ï¼Œé€šè¿‡åº”ç”¨æ‰€æœ‰æœªç¡®è®¤çš„äº‹ä»¶ä»â€œçŠ¶æ€â€è·å¾—ã€‚åœ¨æ‰€æœ‰æœªç»è¯å®çš„äº‹ä»¶è¢«è¯å®åï¼Œæš‚æ—¶çŠ¶æ€æœ¬è´¨ä¸Šæ˜¯å¯¹ä¸‹ä¸€ä¸ªç¡®è®¤çŠ¶æ€çš„â€œæœ€ä½³çŒœæµ‹â€ã€‚ç„¶è€Œï¼Œå¹¶ä¸èƒ½ä¿è¯å®ƒçœŸçš„ä¼šå‘ç”Ÿï¼Œå› ä¸ºGrainså¯èƒ½ä¼šå¤±è´¥ï¼Œæˆ–è€…å› ä¸ºäº‹ä»¶å¯èƒ½ä¸å…¶ä»–äº‹ä»¶ç«äº‰è€Œå¤±è´¥ï¼Œå¯¼è‡´å®ƒä»¬è¢«å–æ¶ˆ(å¦‚æœå®ƒä»¬æ˜¯æœ‰æ¡ä»¶çš„)æˆ–è€…å‡ºç°åœ¨åºåˆ—ä¸­æ¯”é¢„æœŸçš„æ›´æ™šçš„ä½ç½®(å¦‚æœå®ƒä»¬æ˜¯æ— æ¡ä»¶çš„)ã€‚ å¹¶å‘ä¿è¯ è¯·æ³¨æ„ï¼Œå³ä½¿åœ¨ä½¿ç”¨Reentrantæ€§æˆ–å»¶è¿Ÿç¡®è®¤çš„æƒ…å†µä¸‹ï¼ŒåŸºäºorleans turnçš„è°ƒåº¦(åä½œå¹¶å‘)ä¿è¯ä¹Ÿå§‹ç»ˆé€‚ç”¨ã€‚è¿™æ„å‘³ç€ï¼Œå³ä½¿æœ‰å‡ ä¸ªæ–¹æ³•åœ¨è¿›è¡Œä¸­ï¼Œä¹Ÿåªæœ‰ä¸€ä¸ªæ–¹æ³•å¯ä»¥ä¸»åŠ¨æ‰§è¡Œâ€”â€”æ‰€æœ‰å…¶ä»–çš„æ–¹æ³•éƒ½å¤„äºç­‰å¾…çŠ¶æ€ï¼Œå› æ­¤ä»æ¥æ²¡æœ‰ä»»ä½•çœŸæ­£çš„ç«äº‰æ˜¯ç”±å¹¶è¡Œçº¿ç¨‹å¼•èµ·çš„ã€‚ å°¤å…¶è¦æ³¨æ„ï¼š State , TentativeState , Version , å’Œ UnconfirmedEvents å±æ€§å¯ä»¥åœ¨æ–¹æ³•æ‰§è¡ŒæœŸé—´æ›´æ”¹ã€‚ ä½†è¿™ç§å˜åŒ–åªèƒ½åœ¨ç­‰å¾…çš„æ—¶å€™å‘ç”Ÿã€‚ è¿™äº›ä¿è¯å‡å®šç”¨æˆ·ä»£ç ä¿æŒåœ¨ æ¨èåšæ³• å…³äºä»»åŠ¡å’Œå¼‚æ­¥/ç­‰å¾…(ç‰¹åˆ«æ˜¯ï¼Œä¸ä½¿ç”¨çº¿ç¨‹æ± ä»»åŠ¡ï¼Œæˆ–è€…åªå°†å®ƒä»¬ç”¨äºä¸è°ƒç”¨grainåŠŸèƒ½ä¸”ç­‰å¾…æ­£ç¡®çš„ä»£ç )ã€‚"
  },
  "Documentation/grains/event_sourcing/notifications.html": {
    "href": "Documentation/grains/event_sourcing/notifications.html",
    "title": "é€šçŸ¥ | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "é€šçŸ¥ æœ‰èƒ½åŠ›å¯¹çŠ¶æ€å˜åŒ–ä½œå‡ºååº”é€šå¸¸æ˜¯å¾ˆæ–¹ä¾¿çš„ã€‚æ‰€æœ‰å›è°ƒéƒ½å—orleansçš„åŸºäºè½®æ¢çš„ä¿è¯çš„çº¦æŸï¼›å¦è¯·å‚è§å…³äºå¹¶å‘ä¿è¯çš„ä¸€èŠ‚ã€‚ è·Ÿè¸ªç¡®è®¤çŠ¶æ€ å¦‚æœç¡®è®¤çŠ¶æ€å‘ç”Ÿä»»ä½•å˜åŒ–ï¼Œ æ—¥å¿—è®°å½• å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•ï¼š protected override void OnStateChanged() { // read state and/or event log and take appropriate action } çŠ¶æ€å·²æ›´æ”¹ æ¯å½“ç¡®è®¤çš„çŠ¶æ€æ›´æ–°(å³ç‰ˆæœ¬å·å¢åŠ )æ—¶è°ƒç”¨ã€‚è¿™å¯èƒ½å‘ç”Ÿåœ¨ å·²ä»å­˜å‚¨ä¸­åŠ è½½çŠ¶æ€çš„æ–°ç‰ˆæœ¬ã€‚ æ­¤å®ä¾‹å¼•å‘çš„äº‹ä»¶å·²æˆåŠŸå†™å…¥å­˜å‚¨ã€‚ ä»å…¶ä»–å®ä¾‹æ¥æ”¶åˆ°é€šçŸ¥æ¶ˆæ¯ã€‚ æ³¨æ„ï¼Œç”±äºæ‰€æœ‰çš„grainsæœ€åˆéƒ½æœ‰ç‰ˆæœ¬0ï¼Œç›´åˆ°å­˜å‚¨çš„åˆå§‹åŠ è½½å®Œæˆï¼Œè¿™æ„å‘³ç€ çŠ¶æ€å·²æ›´æ”¹ åœ¨åˆå§‹åŠ è½½å®Œæˆä¸”ç‰ˆæœ¬å¤§äºé›¶æ—¶è°ƒç”¨ã€‚ è·Ÿè¸ªæš‚å®šçŠ¶æ€ å¦‚æœä¸´æ—¶çŠ¶æ€æœ‰ä»»ä½•å˜åŒ–ï¼Œ æ—¥å¿—è®°å½• å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•ï¼š protected override void OnTentativeStateChanged() { // read state and/or events and take appropriate action } ontentativestatechanged å½“æš‚å®šçŠ¶æ€æ”¹å˜æ—¶è°ƒç”¨ï¼Œå³å¦‚æœç»„åˆåºåˆ—(confirmedEvents+confirmedEvents)æ”¹å˜ã€‚ç‰¹åˆ«æ˜¯ï¼Œå›è°ƒ ontentativestatechanged() æ€»æ˜¯å‘ç”Ÿåœ¨ è‘¡è„å¹² ."
  },
  "Documentation/grains/event_sourcing/index.html": {
    "href": "Documentation/grains/event_sourcing/index.html",
    "title": "Event Sourcing Overview | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ´»åŠ¨æ¥æº äº‹ä»¶æº¯æºæä¾›äº†ä¸€ç§çµæ´»çš„æ–¹å¼æ¥ç®¡ç†å’ŒæŒä¹…åŒ–GrainçŠ¶æ€ã€‚ä¸æ ‡å‡†Grainsç›¸æ¯”ï¼Œäº‹ä»¶æºGrainså…·æœ‰è®¸å¤šæ½œåœ¨ä¼˜åŠ¿ã€‚é¦–å…ˆï¼Œå®ƒå¯ä»¥ä¸è®¸å¤šä¸åŒçš„å­˜å‚¨æä¾›ç¨‹åºé…ç½®ä¸€èµ·ä½¿ç”¨ï¼Œå¹¶æ”¯æŒè·¨å¤šä¸ªç¾¤é›†çš„åœ°ç†å¤åˆ¶ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜å°†grainç±»ä¸grainçŠ¶æ€(ç”±grainçŠ¶æ€å¯¹è±¡è¡¨ç¤º)å’Œgrainæ›´æ–°(ç”±äº‹ä»¶å¯¹è±¡è¡¨ç¤º)çš„å®šä¹‰å®Œå…¨åˆ†ç¦»ã€‚ æ–‡ä»¶ç»“æ„å¦‚ä¸‹ï¼š æ—¥å¿—è®­ç»ƒåŸºç¡€ è§£é‡Šå¦‚ä½•é€šè¿‡ä» æ—¥å¿—è®°å½• ï¼Œå¦‚ä½•è®¿é—®å½“å‰çŠ¶æ€ï¼Œä»¥åŠå¦‚ä½•å¼•å‘æ›´æ–°çŠ¶æ€çš„äº‹ä»¶ã€‚ å¤åˆ¶å®ä¾‹ è§£é‡Šäº‹ä»¶æºæœºåˆ¶å¦‚ä½•å¤„ç†å¤åˆ¶çš„grainå®ä¾‹å¹¶ç¡®ä¿ä¸€è‡´æ€§ã€‚å®ƒè®¨è®ºäº†æ¯”èµ›äº‹ä»¶å’Œå†²çªçš„å¯èƒ½æ€§ï¼Œä»¥åŠå¦‚ä½•è§£å†³å®ƒä»¬ã€‚ ç«‹å³/å»¶è¿Ÿç¡®è®¤ è§£é‡Šå»¶è¿Ÿçš„äº‹ä»¶ç¡®è®¤å’Œé‡æ–°è¿›å…¥å¦‚ä½•æé«˜å¯ç”¨æ€§å’Œååé‡ã€‚ é€šçŸ¥ è§£é‡Šå¦‚ä½•è®¢é˜…é€šçŸ¥ï¼Œå…è®¸Grainså¯¹æ–°äº‹ä»¶ä½œå‡ºååº”ã€‚ äº‹ä»¶æºé…ç½® è¯´æ˜å¦‚ä½•é…ç½®é¡¹ç›®ã€ç¾¤é›†å’Œæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºã€‚ å†…ç½®æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åº è§£é‡Šå½“å‰åŒ…å«çš„ä¸‰ä¸ªæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºçš„å·¥ä½œæ–¹å¼ã€‚ æ—¥å¿—Grainè¯Šæ–­ è§£é‡Šå¦‚ä½•ç›‘è§†è¿æ¥é”™è¯¯ï¼Œå¹¶è·å–ç®€å•çš„ç»Ÿè®¡ä¿¡æ¯ã€‚ å°±journaledgrain apiè€Œè¨€ï¼Œä¸Šé¢è®°å½•çš„è¡Œä¸ºæ˜¯ç›¸å½“ç¨³å®šçš„ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›å¾ˆå¿«æ‰©å±•æˆ–æ›´æ”¹æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºåˆ—è¡¨ï¼Œä»¥ä¾¿æ›´å®¹æ˜“åœ°å…è®¸å¼€å‘äººå‘˜æ’å…¥æ ‡å‡†äº‹ä»¶å­˜å‚¨ç³»ç»Ÿã€‚"
  },
  "Documentation/grains/event_sourcing/journaledgrain_basics.html": {
    "href": "Documentation/grains/event_sourcing/journaledgrain_basics.html",
    "title": "JournaledGrain API | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "æ—¥å¿—è®­ç»ƒåŸºç¡€ æ—¥è®°grainsæ¥æºäº <journaledgrain<statetypeï¼Œäº‹ä»¶ç±»å‹> ï¼Œå…·æœ‰ä»¥ä¸‹ç±»å‹å‚æ•°ï¼š è¿™ä¸ª çŠ¶æ€ç±»å‹ è¡¨ç¤ºGrainsçš„çŠ¶æ€ã€‚å®ƒå¿…é¡»æ˜¯å…·æœ‰å…¬å…±é»˜è®¤æ„é€ å‡½æ•°çš„ç±»ã€‚ äº‹ä»¶ç±»å‹ æ˜¯å¯ä¸ºæ­¤Grainå¼•å‘çš„æ‰€æœ‰äº‹ä»¶çš„é€šç”¨çˆ¶ç±»å‹ï¼Œå¯ä»¥æ˜¯ä»»ä½•ç±»æˆ–æ¥å£ã€‚ æ‰€æœ‰çŠ¶æ€å’Œäº‹ä»¶å¯¹è±¡éƒ½åº”è¯¥æ˜¯å¯åºåˆ—åŒ–çš„(å› ä¸ºæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºå¯èƒ½éœ€è¦æŒä¹…åŒ–å®ƒä»¬ï¼Œå’Œ/æˆ–åœ¨é€šçŸ¥æ¶ˆæ¯ä¸­å‘é€å®ƒä»¬)ã€‚ å¯¹äºäº‹ä»¶æ˜¯pocos(æ™®é€šçš„æ—§cå¯¹è±¡)çš„Grainsï¼Œ æ—¥å¿—è®°å½•<statetype> å¯ç”¨ä½œ journaledgrain<statetypeï¼Œå¯¹è±¡> æ˜¯çš„ã€‚ è§£è¯»grainçŠ¶å†µ è¦è¯»å–å½“å‰grainsçŠ¶æ€å¹¶ç¡®å®šå…¶ç‰ˆæœ¬å·ï¼Œjournaledgrainå…·æœ‰å±æ€§ GrainState State { get; } int Version { get; } ç‰ˆæœ¬å·å§‹ç»ˆç­‰äºå·²ç¡®è®¤äº‹ä»¶çš„æ€»æ•°ï¼ŒçŠ¶æ€æ˜¯å°†æ‰€æœ‰å·²ç¡®è®¤äº‹ä»¶åº”ç”¨äºåˆå§‹çŠ¶æ€çš„ç»“æœã€‚åˆå§‹çŠ¶æ€çš„ç‰ˆæœ¬ä¸º0(å› ä¸ºæ²¡æœ‰åº”ç”¨ä»»ä½•äº‹ä»¶)ï¼Œç”±grainstateç±»çš„é»˜è®¤æ„é€ å‡½æ•°ç¡®å®šã€‚ é‡è¦ï¼š åº”ç”¨ç¨‹åºä¸åº”ç›´æ¥ä¿®æ”¹ State æ˜¯çš„ã€‚è¿™æœ¬ä¹¦ä»…ä¾›é˜…è¯»ã€‚ç›¸åï¼Œå½“åº”ç”¨ç¨‹åºæƒ³è¦ä¿®æ”¹çŠ¶æ€æ—¶ï¼Œå®ƒå¿…é¡»é€šè¿‡å¼•å‘äº‹ä»¶é—´æ¥åœ°è¿›è¡Œä¿®æ”¹ã€‚ å¼•å‘äº‹ä»¶ é€šè¿‡è°ƒç”¨ è‘¡è„å¹² åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªä»£è¡¨èŠå¤©çš„Grainså¯ä»¥å¼•å‘ åé—ç—‡ è¦æŒ‡ç¤ºç”¨æˆ·æäº¤äº†å¸–å­ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š RaiseEvent(new PostedEvent() { Guid = guid, User = user, Text = text, Timestamp = DateTime.UtcNow }); è¯·æ³¨æ„ è‘¡è„å¹² å¯åŠ¨å¯¹å­˜å‚¨çš„å†™å…¥è®¿é—®ï¼Œä½†ä¸ç­‰å¾…å†™å…¥å®Œæˆã€‚å¯¹äºè®¸å¤šåº”ç”¨ç¨‹åºï¼Œå¿…é¡»ç­‰åˆ°æˆ‘ä»¬ç¡®è®¤äº‹ä»¶å·²è¢«æŒä¹…åŒ–ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ€»æ˜¯ç­‰å¾… è¯å®äºº ä»¥ä¸‹å†…å®¹ï¼š RaiseEvent(new DepositTransaction() { DepositAmount = amount, Description = description }); await ConfirmEvents(); è¯·æ³¨æ„ï¼Œå³ä½¿æ‚¨æ²¡æœ‰æ˜¾å¼è°ƒç”¨ è¯å®äºº ï¼Œäº‹ä»¶æœ€ç»ˆå°†å¾—åˆ°ç¡®è®¤-å®ƒåœ¨åå°è‡ªåŠ¨å‘ç”Ÿã€‚ çŠ¶æ€è½¬æ¢æ–¹æ³• è¿è¡Œæ—¶æ›´æ–°GrainsçŠ¶æ€ è‡ªåŠ¨ æ¯å½“äº‹ä»¶å‘ç”Ÿæ—¶ã€‚åº”ç”¨ç¨‹åºä¸éœ€è¦åœ¨å¼•å‘äº‹ä»¶åæ˜¾å¼æ›´æ–°çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œåº”ç”¨ç¨‹åºä»ç„¶å¿…é¡»æä¾›æŒ‡å®š æ€æ · æ›´æ–°çŠ¶æ€ä»¥å“åº”äº‹ä»¶ã€‚è¿™å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¥å®ç°ã€‚ (ä¸€) grainstateç±»å¯ä»¥å®ç°ä¸€ä¸ªæˆ–å¤šä¸ª åº”ç”¨ æ–¹æ³•è®º çŠ¶æ€ç±»å‹ æ˜¯çš„ã€‚é€šå¸¸ï¼Œä¼šåˆ›å»ºå¤šä¸ªé‡è½½ï¼Œå¹¶ä¸ºäº‹ä»¶çš„è¿è¡Œæ—¶ç±»å‹é€‰æ‹©æœ€æ¥è¿‘çš„åŒ¹é…ï¼š class GrainState { Apply(E1 @event) { // code that updates the state } Apply(E2 @event) { // code that updates the state } } (äºŒ) grainså¯ä»¥è¦†ç›–transitionStateå‡½æ•°ï¼š protected override void TransitionState(State state, EventType @event) { // code that updates the state } å‡è®¾è½¬æ¢æ–¹æ³•é™¤äº†ä¿®æ”¹çŠ¶æ€å¯¹è±¡ä¹‹å¤–æ²¡æœ‰ä»»ä½•å‰¯ä½œç”¨ï¼Œå¹¶ä¸”åº”è¯¥æ˜¯ç¡®å®šæ€§çš„(å¦åˆ™ï¼Œæ•ˆæœæ˜¯ä¸å¯é¢„æµ‹çš„)ã€‚å¦‚æœè½¬æ¢ä»£ç æŠ›å‡ºå¼‚å¸¸ï¼Œåˆ™ä¼šæ•è·è¯¥å¼‚å¸¸å¹¶å°†å…¶åŒ…å«åœ¨æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºå‘å‡ºçš„Orleansæ—¥å¿—ä¸­çš„è­¦å‘Šä¸­ã€‚ ç¡®åˆ‡åœ°è¯´ï¼Œè¿è¡Œæ—¶è°ƒç”¨è½¬æ¢æ–¹æ³•å–å†³äºæ‰€é€‰çš„æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºåŠå…¶é…ç½®ã€‚å¯¹äºåº”ç”¨ç¨‹åºæ¥è¯´ï¼Œæœ€å¥½ä¸è¦ä¾èµ–äºç‰¹å®šçš„æ—¶é—´ï¼Œé™¤éæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºç‰¹åˆ«ä¿è¯ã€‚ ä¸€äº›æä¾›è€…ï¼Œå¦‚ æ—¥å¿—å­˜å‚¨ æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºï¼Œæ¯æ¬¡åŠ è½½Grainæ—¶é‡æ’­äº‹ä»¶åºåˆ—ã€‚å› æ­¤ï¼Œåªè¦äº‹ä»¶å¯¹è±¡ä»ç„¶å¯ä»¥ä»å­˜å‚¨ä¸­æ­£ç¡®ååºåˆ—åŒ–ï¼Œå°±æœ‰å¯èƒ½ä»æ ¹æœ¬ä¸Šä¿®æ”¹grainstateç±»å’Œè½¬æ¢æ–¹æ³•ã€‚ä½†å¯¹äºå…¶ä»–æä¾›å•†ï¼Œå¦‚ çŠ¶æ€å­˜å‚¨ æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºï¼Œä»… Grainç°å²© å¯¹è±¡æ˜¯æŒä¹…åŒ–çš„ï¼Œå› æ­¤å¼€å‘äººå‘˜å¿…é¡»ç¡®ä¿ä»å­˜å‚¨ä¸­è¯»å–æ—¶å¯ä»¥æ­£ç¡®ååºåˆ—åŒ–å®ƒã€‚ å¼•å‘å¤šä¸ªäº‹ä»¶ åœ¨è°ƒç”¨confirmeEventsä¹‹å‰ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨raiseEventï¼š RaiseEvent(e1); RaiseEvent(e2); await ConfirmEvents(); ä½†æ˜¯ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ä¸¤æ¬¡è¿ç»­çš„å­˜å‚¨è®¿é—®ï¼Œå¹¶ä¸”åªåœ¨å†™å…¥ç¬¬ä¸€ä¸ªäº‹ä»¶ä¹‹åï¼ŒGrainså¯èƒ½ä¼šå¤±è´¥ã€‚å› æ­¤ï¼Œé€šå¸¸æœ€å¥½ä½¿ç”¨ RaiseEvents(IEnumerable<EventType> events) è¿™ä¿è¯äº†ç»™å®šçš„äº‹ä»¶åºåˆ—ä»¥åŸå­æ–¹å¼å†™å…¥å­˜å‚¨å™¨ã€‚è¯·æ³¨æ„ï¼Œç”±äºç‰ˆæœ¬å·å§‹ç»ˆä¸äº‹ä»¶åºåˆ—çš„é•¿åº¦åŒ¹é…ï¼Œå› æ­¤å¼•å‘å¤šä¸ªäº‹ä»¶ä¼šä½¿ç‰ˆæœ¬å·æ¯æ¬¡å¢åŠ ä¸€ä¸ªä»¥ä¸Šã€‚ æ£€ç´¢äº‹ä»¶åºåˆ— ä¸‹é¢çš„æ–¹æ³• æ—¥å¿—è®°å½• ç±»å…è®¸åº”ç”¨ç¨‹åºæ£€ç´¢æ‰€æœ‰å·²ç¡®è®¤äº‹ä»¶åºåˆ—çš„æŒ‡å®šæ®µï¼š Task<IReadOnlyList<EventType>> RetrieveConfirmedEvents(int fromVersion, int toVersion) ä½†æ˜¯ï¼Œå¹¶éæ‰€æœ‰æ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºéƒ½æ”¯æŒå®ƒã€‚å¦‚æœä¸æ”¯æŒï¼Œæˆ–è€…åºåˆ—çš„æŒ‡å®šæ®µä¸å†å¯ç”¨ï¼Œåˆ™ å†’å· è¢«æ‰”äº†ã€‚ è¦æ£€ç´¢æœ€æ–°ç¡®è®¤ç‰ˆæœ¬ä¹‹å‰çš„æ‰€æœ‰äº‹ä»¶ï¼Œå¯ä»¥è°ƒç”¨ await RetrieveConfirmedEvents(0, Version); åªèƒ½æ£€ç´¢å·²ç¡®è®¤çš„äº‹ä»¶ï¼šå¦‚æœ Toversion å¤§äºå±æ€§çš„å½“å‰å€¼ ç‰ˆæœ¬ æ˜¯çš„ã€‚ å› ä¸ºç¡®è®¤çš„äº‹ä»¶æ°¸è¿œä¸ä¼šæ”¹å˜ï¼Œæ‰€ä»¥å³ä½¿åœ¨å­˜åœ¨å¤šä¸ªå®ä¾‹æˆ–å»¶è¿Ÿç¡®è®¤çš„æƒ…å†µä¸‹ï¼Œä¹Ÿä¸å¿…æ‹…å¿ƒæ¯”èµ›ã€‚ä½†æ˜¯ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ‰å¯èƒ½ ç‰ˆæœ¬ å½“awaitæ¯”å½“æ—¶æ¢å¤ æ£€ç´¢ç¡®è®¤äº‹ä»¶ è¢«è°ƒç”¨ï¼Œå› æ­¤å»ºè®®å°†å…¶å€¼ä¿å­˜åœ¨å˜é‡ä¸­ã€‚å¦è¯·å‚é˜…å…³äºå¹¶å‘ä¿è¯çš„éƒ¨åˆ†ã€‚"
  },
  "Documentation/grains/event_sourcing/journaledgrain_diagnostics.html": {
    "href": "Documentation/grains/event_sourcing/journaledgrain_diagnostics.html",
    "title": "JournaledGrain Diagnostics | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "JournaledGrainè¯Šæ–­ ç›‘è§†è¿æ¥é”™è¯¯ é€šè¿‡è®¾è®¡ï¼Œæ—¥å¿—ä¸€è‡´æ€§æä¾›ç¨‹åºåœ¨å‡ºç°è¿æ¥é”™è¯¯(åŒ…æ‹¬ä¸å­˜å‚¨çš„è¿æ¥ä»¥åŠç¾¤é›†ä¹‹é—´çš„è¿æ¥)æ—¶å…·æœ‰å¼¹æ€§ã€‚ä½†æ˜¯ä»…ä»…å®¹å¿é”™è¯¯æ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºé€šå¸¸éœ€è¦ç›‘è§†ä»»ä½•æ­¤ç±»é—®é¢˜ï¼Œå¹¶åœ¨ä¸¥é‡æ—¶æè¯·æ“ä½œå‘˜æ³¨æ„ã€‚ å½“è§‚å¯Ÿåˆ°è¿æ¥é”™è¯¯å¹¶è§£å†³äº†è¿™äº›é”™è¯¯æ—¶ï¼ŒJournaledGrainå­ç±»å¯ä»¥é‡å†™ä»¥ä¸‹æ–¹æ³•æ¥æ¥æ”¶é€šçŸ¥ï¼š protected override void OnConnectionIssue(ConnectionIssue issue) { /// handle the observed error described by issue } protected override void OnConnectionIssueResolved(ConnectionIssue issue) { /// handle the resolution of a previously reported issue } ConnectionIssue æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œæœ‰å‡ ä¸ªå…¬å…±å­—æ®µæè¿°è¯¥é—®é¢˜ï¼ŒåŒ…æ‹¬è‡ªä¸Šæ¬¡æˆåŠŸè¿æ¥ä»¥æ¥å·²è§‚å¯Ÿåˆ°æ­¤é—®é¢˜çš„æ¬¡æ•°ã€‚è¿æ¥é—®é¢˜çš„å®é™…ç±»å‹ç”±å­ç±»å®šä¹‰ã€‚è¿æ¥é—®é¢˜åˆ†ä¸ºä»¥ä¸‹å‡ ç§ç±»å‹ï¼š PrimaryOperationFailed è¦ä¹ˆ NotificationFailed ï¼Œæœ‰æ—¶è¿˜æœ‰å¤šä½™çš„é”®(ä¾‹å¦‚ RemoteCluster )ï¼Œè¿›ä¸€æ­¥ç¼©å°äº†ç±»åˆ«ã€‚ å¦‚æœåŒä¸€ç±»åˆ«çš„é—®é¢˜å¤šæ¬¡å‘ç”Ÿ(ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸æ–­æ”¶åˆ°ä»¥ç›¸åŒçš„ RemoteCluster ä¸ºç›®æ ‡çš„ NotificationFailed )ï¼Œæ¯æ¬¡ç”± OnConnectionIssue ã€‚è§£å†³æ­¤ç±»é—®é¢˜å(ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç»ˆäºå¯ä»¥æˆåŠŸå‘æ­¤å‘é€é€šçŸ¥ RemoteCluster )ï¼Œ ç„¶å OnConnectionIssueResolved è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œä¸ é—®é¢˜ ä¸Šæ¬¡æŠ¥å‘Šçš„å¯¹è±¡ OnConnectionIssue ã€‚ç‹¬ç«‹ç±»åˆ«çš„è¿æ¥é—®é¢˜åŠå…¶è§£å†³æ–¹æ¡ˆå°†ç‹¬ç«‹æŠ¥å‘Šã€‚ ç®€å•ç»Ÿè®¡ ç›®å‰ï¼Œæˆ‘ä»¬ä¸ºåŸºæœ¬ç»Ÿè®¡ä¿¡æ¯æä¾›äº†ç®€å•çš„æ”¯æŒ(å°†æ¥ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šç”¨æ›´æ ‡å‡†çš„é¥æµ‹æœºåˆ¶æ¥ä»£æ›¿å®ƒ)ã€‚é€šè¿‡è°ƒç”¨å¯ä»¥ä¸ºJournaledGrainå¯ç”¨æˆ–ç¦ç”¨ç»Ÿè®¡ä¿¡æ¯æ”¶é›† void EnableStatsCollection() void DisableStatsCollection() å¯ä»¥é€šè¿‡è°ƒç”¨è·å–ç»Ÿè®¡ä¿¡æ¯ LogConsistencyStatistics GetStats()"
  },
  "Documentation/grains/cancellation_tokens.html": {
    "href": "Documentation/grains/cancellation_tokens.html",
    "title": "Grain cancellation tokens | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Grainså–æ¶ˆä»¤ç‰Œ orleansè¿è¡Œæ—¶æä¾›äº†ä¸€ç§ç§°ä¸ºgrain cancellation tokençš„æœºåˆ¶ï¼Œä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿå–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„grainæ“ä½œã€‚ è¯´æ˜ GrainCancellationToken æ˜¯æ ‡å‡†çš„åŒ…è£… .NET System.Threading.CancellationToken ï¼Œå®ƒå¯ç”¨çº¿ç¨‹ã€çº¿ç¨‹æ± å·¥ä½œé¡¹æˆ–ä»»åŠ¡å¯¹è±¡ä¹‹é—´çš„åä½œå–æ¶ˆï¼Œå¹¶ä¸”å¯ä»¥ä½œä¸ºgrainæ–¹æ³•å‚æ•°ä¼ é€’ã€‚ ä¸€ä¸ª GrainCancellationTokenSource æ˜¯é€šè¿‡å…¶tokenå±æ€§æä¾›å–æ¶ˆä»¤ç‰Œå¹¶é€šè¿‡è°ƒç”¨ å–æ¶ˆ æ–¹æ³•ã€‚ ç”¨æ³• å®ä¾‹åŒ–CancellationTokenSourceå¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç®¡ç†å¹¶å‘å„ä¸ªå–æ¶ˆä»¤ç‰Œå‘é€å–æ¶ˆé€šçŸ¥ã€‚ var tcs = new GrainCancellationTokenSource(); å°†GrainCancellationTokenSource.Tokenå±æ€§è¿”å›çš„ä»¤ç‰Œä¼ é€’ç»™ä¾¦å¬å–æ¶ˆçš„æ¯ä¸ªGrainæ–¹æ³•ã€‚ var waitTask = grain.LongIoWork(tcs.Token, TimeSpan.FromSeconds(10)); å¯å–æ¶ˆçš„Grainsæ“ä½œéœ€è¦å¤„ç†åº•å±‚ GrainCancellationToken å±æ€§çš„ CancellationToken å°±åƒåœ¨å…¶ä»–.NETä»£ç ä¸­ä¸€æ ·ã€‚ public async Task LongIoWork(GrainCancellationToken tc, TimeSpan delay) { while(!tc.CancellationToken.IsCancellationRequested) { await IoOperation(tc.CancellationToken); } } è°ƒç”¨ç»™ GrainCancellationTokenSource.Cancel æ–¹æ³•å¯åŠ¨å–æ¶ˆã€‚ await tcs.Cancel(); å½“ä½¿ç”¨å®Œ GrainCancellationTokenSource å¯¹è±¡è°ƒç”¨ Dispose æ–¹æ³•ã€‚ tcs.Dispose(); é‡è¦æ³¨æ„äº‹é¡¹ï¼š è¿™ä¸ª GrainCancellationTokenSource.Cancel æ–¹æ³•è¿”å› Task ï¼Œå¹¶ä¸”ä¸ºäº†ç¡®ä¿å–æ¶ˆï¼Œå¿…é¡»åœ¨çŸ­æš‚é€šä¿¡å¤±è´¥çš„æƒ…å†µä¸‹é‡è¯•å–æ¶ˆè°ƒç”¨ã€‚ åœ¨åŸºç¡€ä¸­æ³¨å†Œçš„å›è°ƒ System.Threading.CancellationToken åœ¨æ³¨å†Œå®ƒä»¬çš„grain æ¿€æ´»ä¸­å—å•çº¿ç¨‹æ‰§è¡Œä¿è¯çš„çº¦æŸã€‚ æ¯ä¸ª GrainCancellationToken å¯ä»¥é€šè¿‡å¤šä¸ªæ–¹æ³•è°ƒç”¨ä¼ é€’ã€‚"
  },
  "Documentation/clusters_and_clients/configuration_guide/index.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/index.html",
    "title": "Orleans Configuration Guide | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "Orleansé…ç½®æŒ‡å— æœ¬é…ç½®æŒ‡å—è§£é‡Šäº†å…³é”®é…ç½®å‚æ•°ä»¥åŠå®ƒä»¬åœ¨å¤§å¤šæ•°å…¸å‹ä½¿ç”¨åœºæ™¯ä¸­çš„ä½¿ç”¨æ–¹å¼ã€‚ orleanså¯ä»¥ç”¨äºå„ç§é€‚åˆä¸åŒä½¿ç”¨åœºæ™¯çš„é…ç½®ï¼Œä¾‹å¦‚ç”¨äºå¼€å‘å’Œæµ‹è¯•çš„æœ¬åœ°å•èŠ‚ç‚¹éƒ¨ç½²ã€æœåŠ¡å™¨ç¾¤é›†ã€å¤šå®ä¾‹azureå·¥ä½œè€…è§’è‰²ç­‰ã€‚ æœ¬æŒ‡å—æä¾›äº†åœ¨ç›®æ ‡åœºæ™¯ä¸­è¿è¡ŒOrleansæ‰€éœ€çš„å…³é”®é…ç½®å‚æ•°çš„è¯´æ˜ã€‚è¿˜æœ‰ä¸€äº›å…¶ä»–çš„é…ç½®å‚æ•°ï¼Œä¸»è¦æœ‰åŠ©äºå¾®è°ƒOrleansä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ é€šè¿‡ silohostbuilderè½¯ä»¶ å’Œ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ ä»¥åŠä¸€äº›è¡¥å……æœŸæƒç±»åˆ«ã€‚Orleansçš„é€‰é¡¹ç±»éµå¾ª ASP.NETé€‰é¡¹ æ¨¡å¼ï¼Œå¯é€šè¿‡æ–‡ä»¶ã€ç¯å¢ƒå˜é‡ç­‰åŠ è½½ã€‚è¯·å‚é˜… é€‰é¡¹æ¨¡å¼æ–‡æ¡£ æ›´å¤šä¿¡æ¯ã€‚ å¦‚æœè¦ä¸ºæœ¬åœ°å¼€å‘é…ç½®siloså’Œå®¢æˆ·ç«¯ï¼Œè¯·æŸ¥çœ‹ æœ¬åœ°å¼€å‘é…ç½® é¡µï¼š1èŒ¶ æœåŠ¡å™¨é…ç½® å’Œ å®¢æˆ·ç«¯é…ç½® å¯¼æ¸¸ç›–éƒ¨åˆ†é…ç½®è°·ä»“å’Œé¡¾å®¢ï¼Œå„è‡ªã€‚ ç¬¬äºŒèŠ‚ å…¸å‹é…ç½® æä¾›ä¸€ä¸ªå°‘é‡å…±åŒé…ç½®çš„æ¦‚è¦ã€‚ ä¸€ä»½å¯é…ç½®çš„é‡è¦æ ¸å¿ƒé€‰é¡¹æ¸…å•å¯åœ¨ä¸Šé¢æ‰¾åˆ°ã€‚ æœ¬èŠ‚ é¡µï¼š1 é‡è¦çš„ ç¡®ä¿ä½ é¢„å…ˆé…ç½®å‡€åƒåœ¾é‚®ä»¶æ”¶è— é…ç½®ç½‘æ”¶è— é¡µï¼š1"
  },
  "Documentation/clusters_and_clients/configuration_guide/startup_tasks.html": {
    "href": "Documentation/clusters_and_clients/configuration_guide/startup_tasks.html",
    "title": "Startup Tasks | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "å¯åŠ¨ä»»åŠ¡ åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒæŸäº›ä»»åŠ¡éœ€è¦åœ¨siloså¯ç”¨æ—¶è‡ªåŠ¨æ‰§è¡Œã€‚ å¯åŠ¨ä»»åŠ¡ æä¾›æ­¤åŠŸèƒ½ã€‚ ä¸€äº›ç”¨ä¾‹åŒ…æ‹¬ä½†ä¸é™äºï¼š å¯åŠ¨åå°è®¡æ—¶å™¨ä»¥æ‰§è¡Œå®šæœŸå†…åŠ¡å¤„ç†ä»»åŠ¡ ä½¿ç”¨ä»å¤–éƒ¨å¤‡ä»½å­˜å‚¨ä¸‹è½½çš„æ•°æ®é¢„åŠ è½½ä¸€äº›ç¼“å­˜grains å¯åŠ¨æœŸé—´ä»å¯åŠ¨ä»»åŠ¡å¼•å‘çš„ä»»ä½•å¼‚å¸¸éƒ½å°†åœ¨silosæ—¥å¿—ä¸­æŠ¥å‘Šï¼Œå¹¶å°†åœæ­¢silosã€‚ è¿™ç§å¿«é€Ÿæ•…éšœæ–¹æ³•æ˜¯Orleanså¤„ç†siloså¯åŠ¨é—®é¢˜çš„æ ‡å‡†æ–¹æ³•ï¼Œå…¶ç›®çš„æ˜¯å…è®¸åœ¨æµ‹è¯•é˜¶æ®µè½»æ¾æ£€æµ‹silosé…ç½®å’Œ/æˆ–å¼•å¯¼é€»è¾‘çš„ä»»ä½•é—®é¢˜ï¼Œè€Œä¸æ˜¯åœ¨silosç”Ÿå‘½å‘¨æœŸçš„åæœŸè¢«å¿½ç•¥å¹¶å¯¼è‡´æ„å¤–é—®é¢˜ã€‚ é…ç½®å¯åŠ¨ä»»åŠ¡ å¯åŠ¨ä»»åŠ¡å¯ä»¥ä½¿ç”¨ IsiloHostBuilder é€šè¿‡æ³¨å†Œè¦åœ¨å¯åŠ¨æœŸé—´è°ƒç”¨çš„å§”æ‰˜ï¼Œæˆ–é€šè¿‡æ³¨å†Œ ä¼Šæ–¯å¡”æ™®å¡”æ–¯å…‹ æ˜¯çš„ã€‚ ç¤ºä¾‹ï¼šæ³¨å†Œå§”æ‰˜ siloHostBuilder.AddStartupTask( async (IServiceProvider services, CancellationToken cancellation) => { // Use the service provider to get the grain factory. var grainFactory = services.GetRequiredService<IGrainFactory>(); // Get a reference to a grain and call a method on it. var grain = grainFactory.GetGrain<IMyGrain>(0); await grain.Initialize(); }); ç¤ºä¾‹ï¼šæ³¨å†Œ ä¼Šæ–¯å¡”æ™®å¡”æ–¯å…‹ å®æ–½ é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»å®šä¹‰ ä¼Šæ–¯å¡”æ™®å¡”æ–¯å…‹ ä»¥ä¸‹å†…å®¹ï¼š public class CallGrainStartupTask : IStartupTask { private readonly IGrainFactory grainFactory; public CallGrainStartupTask(IGrainFactory grainFactory) { this.grainFactory = grainFactory; } public async Task Execute(CancellationToken cancellationToken) { var grain = this.grainFactory.GetGrain<IMyGrain>(0); await grain.Initialize(); } } ç„¶åå¿…é¡»åœ¨ IsiloHostBuilder ä»¥ä¸‹å†…å®¹ï¼š siloHostBuilder.AddStartupTask<CallGrainStartupTask>();"
  },
  "Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html": {
    "href": "Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html",
    "title": "Silo Error Code Monitoring | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "silosé”™è¯¯ä»£ç ç›‘è§† ç¾¤ç»„ æ—¥å¿—ç±»å‹ æ—¥å¿—ä»£ç å€¼ é—¨æ§› è¯´æ˜ azureé—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 100800è‡³100899 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š è¯»å–æˆ–å†™å…¥azureè¡¨å­˜å‚¨çš„æš‚æ—¶æ€§é—®é¢˜å°†è®°å½•ä¸ºè­¦å‘Šã€‚å°†è‡ªåŠ¨é‡è¯•ä¸´æ—¶è¯»å–é”™è¯¯ã€‚æœ€åä¸€æ¡é”™è¯¯æ—¥å¿—æ¶ˆæ¯æ„å‘³ç€è¿æ¥åˆ°azureè¡¨å­˜å‚¨å­˜åœ¨å®é™…é—®é¢˜ã€‚ æˆå‘˜è¿æ¥é—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 100600-100699 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š è­¦å‘Šæ—¥å¿—æ˜¯ç½‘ç»œè¿æ¥é—®é¢˜å’Œ/æˆ–silosé‡å¯/è¿ç§»çš„æ—©æœŸæŒ‡ç¤ºã€‚pingè¶…æ—¶å’Œsiloæ­»æŠ•ç¥¨å°†æ˜¾ç¤ºä¸ºè­¦å‘Šæ¶ˆæ¯ã€‚silo detesting it was voted deadå°†æ˜¾ç¤ºä¸ºé”™è¯¯æ¶ˆæ¯ã€‚ Grainsè®¿é—®è¶…æ—¶ è­¦å‘Š 100157ä¸ª çŸ­æ—¶é—´å†…è®°å½•å¤šä¸ªè­¦å‘Š Grainsè°ƒç”¨è¶…æ—¶é—®é¢˜é€šå¸¸ç”±ä¸´æ—¶ç½‘ç»œè¿æ¥é—®é¢˜æˆ–silosé‡æ–°å¯åŠ¨/é‡æ–°å¯åŠ¨é—®é¢˜å¼•èµ·ã€‚ç³»ç»Ÿåº”åœ¨çŸ­æ—¶é—´åæ¢å¤(å–å†³äºæ´»åŠ¨é…ç½®è®¾ç½®)ï¼Œæ­¤æ—¶åº”æ¸…é™¤è¶…æ—¶ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä»…ç›‘è§†æ‰¹é‡æ—¥å¿—ä»£ç 600157è¿™äº›è­¦å‘Šçš„ç§ç±»å°±åº”è¯¥è¶³å¤Ÿäº†ã€‚ silosé‡å¯/è¿ç§» è­¦å‘Š 100601æˆ–100602 ä»»ä½•è­¦å‘Š å½“silosæ£€æµ‹åˆ°å®ƒåœ¨åŒä¸€å°è®¡ç®—æœº{100602)ä¸Šé‡æ–°å¯åŠ¨æˆ–è¿ç§»åˆ°ä¸åŒçš„è®¡ç®—æœº(100601)æ—¶æ‰“å°è­¦å‘Š ç½‘ç»œå¥—æ¥å­—é—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 101000è‡³101999ã€100307100015ã€100016 ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š æ’åº§æ–­å¼€è®°å½•ä¸ºè­¦å‘Šæ¶ˆæ¯ã€‚æ‰“å¼€å¥—æ¥å­—æˆ–åœ¨æ¶ˆæ¯ä¼ è¾“æœŸé—´å‡ºç°çš„é—®é¢˜è®°å½•ä¸ºé”™è¯¯ã€‚ grainé—®é¢˜ è­¦å‘Šæˆ–é”™è¯¯ 101534ä¸ª ä»»ä½•é”™è¯¯æˆ–è­¦å‘Š æ£€æµ‹éé‡å…¥grainsçš„â€œå¡ä½â€è¯·æ±‚ã€‚æ¯æ¬¡è¯·æ±‚æ‰§è¡Œæ—¶é—´è¶…è¿‡5å€è¯·æ±‚è¶…æ—¶æ—¶ï¼Œéƒ½ä¼šæŠ¥å‘Šé”™è¯¯ä»£ç ã€‚"
  },
  "Documentation/clusters_and_clients/index.html": {
    "href": "Documentation/clusters_and_clients/index.html",
    "title": "What is a grain client | Microsoft Orleans ä¸­æ–‡æ–‡æ¡£",
    "keywords": "ä»€ä¹ˆæ˜¯Grainså®¢æˆ·ï¼Ÿ æœ¯è¯­â€œå®¢æˆ·ç«¯â€æˆ–æœ‰æ—¶â€œGrainså®¢æˆ·ç«¯â€ç”¨äºä¸Grainsäº¤äº’çš„åº”ç”¨ç¨‹åºä»£ç ï¼Œä½†å®ƒæœ¬èº«ä¸æ˜¯Grainsé€»è¾‘çš„ä¸€éƒ¨åˆ†ã€‚å®¢æˆ·ç«¯ä»£ç åœ¨OrleansæœåŠ¡å™¨é›†ç¾¤(ç§°ä¸ºsilos)ä¹‹å¤–è¿è¡Œï¼Œè¿™äº›æœåŠ¡å™¨é›†ç¾¤æ‰¿è½½Grainsã€‚å› æ­¤ï¼Œå®¢æˆ·ç«¯å……å½“åˆ°é›†ç¾¤å’Œåº”ç”¨ç¨‹åºæ‰€æœ‰Grainçš„è¿æ¥å™¨æˆ–ç®¡é“ã€‚ é€šå¸¸ï¼Œåœ¨å‰ç«¯webæœåŠ¡å™¨ä¸Šä½¿ç”¨å®¢æˆ·ç«¯è¿æ¥åˆ°ä½œä¸ºä¸­é—´å±‚çš„orleansé›†ç¾¤ï¼Œå…¶ä¸­grainsæ‰§è¡Œä¸šåŠ¡é€»è¾‘ã€‚åœ¨å…¸å‹è®¾ç½®ä¸­ï¼Œå‰ç«¯WebæœåŠ¡å™¨ï¼š æ¥æ”¶Webè¯·æ±‚ æ‰§è¡Œå¿…è¦çš„èº«ä»½éªŒè¯å’ŒæˆæƒéªŒè¯ å†³å®šåº”å¤„ç†è¯·æ±‚çš„Grains ä½¿ç”¨Grainå®¢æˆ·ç«¯å¯¹Grainè¿›è¡Œä¸€ä¸ªæˆ–å¤šä¸ªæ–¹æ³•è°ƒç”¨ å¤„ç†grainè°ƒç”¨å’Œä»»ä½•è¿”å›å€¼çš„æˆåŠŸå®Œæˆæˆ–å¤±è´¥ å‘é€å¯¹Webè¯·æ±‚çš„å“åº” Grainså®¢æˆ·ç«¯åˆå§‹åŒ– åœ¨ä½¿ç”¨grainå®¢æˆ·ç«¯è°ƒç”¨orleansé›†ç¾¤ä¸­æ‰˜ç®¡çš„grainä¹‹å‰ï¼Œéœ€è¦å¯¹å…¶è¿›è¡Œé…ç½®ã€åˆå§‹åŒ–å¹¶è¿æ¥åˆ°é›†ç¾¤ã€‚ é…ç½®é€šè¿‡ å®¢æˆ·ç«¯ç”Ÿæˆå™¨ ä»¥åŠè®¸å¤šè¡¥å……é€‰é¡¹ç±»ï¼Œå…¶ä¸­åŒ…å«ç”¨äºä»¥ç¼–ç¨‹æ–¹å¼é…ç½®å®¢æˆ·ç«¯çš„é…ç½®å±æ€§å±‚æ¬¡ç»“æ„ã€‚ æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨ å®¢æˆ·ç«¯é…ç½®æŒ‡å— æ˜¯çš„ã€‚ å®¢æˆ·ç«¯é…ç½®ç¤ºä¾‹ï¼š var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); æœ€åï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨ Connect() æ–¹æ³•ï¼Œä½¿å…¶è¿æ¥åˆ°Orleansç¾¤é›†ã€‚å®ƒæ˜¯ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•ï¼Œè¿”å› Task æ˜¯çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç­‰å¾…å®ƒçš„å®Œæˆawaitæˆ– .ç­‰ç­‰() æ˜¯çš„ã€‚ await client.Connect(); è°ƒç”¨ç»™Grains ä»å®¢æˆ·é‚£é‡Œè°ƒç”¨ç»™grainå’Œ åœ¨grainä»£ç ä¸­è¿›è¡Œè¿™æ ·çš„è°ƒç”¨ æ˜¯çš„ã€‚ç›¸åŒçš„ getgrain<t>(key) æ–¹æ³•ï¼Œå…¶ä¸­ T æ˜¯ç›®æ ‡grainsæ¥å£ï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹éƒ½ä½¿ç”¨ è·å–Grainså¼•ç”¨ æ˜¯çš„ã€‚ç»†å¾®çš„åŒºåˆ«åœ¨äºæˆ‘ä»¬è°ƒç”¨çš„å·¥å‚å¯¹è±¡ è·å–grains æ˜¯çš„ã€‚åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡è¿æ¥çš„å®¢æˆ·ç«¯å¯¹è±¡æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); Task t = player.JoinGame(game) await t; å¯¹grainæ–¹æ³•çš„è°ƒç”¨è¿”å› Task æˆ–è€… Task<t> æ ¹æ® grainsæ¥å£è§„åˆ™ æ˜¯çš„ã€‚å®¢æˆ·å¯ä»¥ä½¿ç”¨awaitå…³é”®å­—å¼‚æ­¥ç­‰å¾…è¿”å›çš„ Task æ²¡æœ‰é˜»å¡çº¿ç¨‹ï¼Œæˆ–è€…åœ¨æŸäº›æƒ…å†µä¸‹ ç­‰å¾…() æ–¹æ³•æ¥é˜»æ­¢å½“å‰æ‰§è¡Œçº¿ç¨‹ã€‚ ä»å®¢æˆ·ç«¯ä»£ç å’Œä»å¦ä¸€ä¸ªGrainå†…éƒ¨è°ƒç”¨grainsçš„ä¸»è¦åŒºåˆ«åœ¨äºgrainsçš„å•çº¿ç¨‹æ‰§è¡Œæ¨¡å‹ã€‚Grainsè¢«orleansè¿è¡Œæ—¶é™åˆ¶ä¸ºå•çº¿ç¨‹ï¼Œè€Œå®¢æˆ·ç«¯å¯èƒ½æ˜¯å¤šçº¿ç¨‹çš„ã€‚Orleansæ²¡æœ‰åœ¨å®¢æˆ·ç«¯æä¾›ä»»ä½•è¿™æ ·çš„ä¿è¯ï¼Œå› æ­¤å®¢æˆ·ç«¯éœ€è¦ä½¿ç”¨é€‚åˆå…¶ç¯å¢ƒçš„ä»»ä½•åŒæ­¥æ„é€ æ¥ç®¡ç†è‡ªå·±çš„å¹¶å‘æ€§â€”é”ã€äº‹ä»¶ï¼Œ Task ç­‰ç­‰ã€‚ æ¥æ”¶é€šçŸ¥ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç®€å•çš„è¯·æ±‚-å“åº”æ¨¡å¼æ˜¯ä¸å¤Ÿçš„ï¼Œå®¢æˆ·ç«¯éœ€è¦æ¥æ”¶å¼‚æ­¥é€šçŸ¥ã€‚ä¾‹å¦‚ï¼Œå½“æŸä¸ªç”¨æˆ·å‘å¸ƒäº†å¥¹æ­£åœ¨è·Ÿè¸ªçš„æ–°æ¶ˆæ¯æ—¶ï¼Œè¯¥ç”¨æˆ·å¯èƒ½å¸Œæœ›æ”¶åˆ°é€šçŸ¥ã€‚ è§‚å¯Ÿè€… æ˜¯ä¸€ç§è¿™æ ·çš„æœºåˆ¶ï¼Œå®ƒå…è®¸å°†å®¢æˆ·ç«¯å¯¹è±¡å…¬å¼€ä¸ºç±»ä¼¼äºgrainsçš„ç›®æ ‡ï¼Œä»¥ä¾›grainsè°ƒç”¨ã€‚å¯¹è§‚å¯Ÿè€…çš„è®¿é—®å¹¶æ²¡æœ‰æä¾›ä»»ä½•æˆåŠŸæˆ–å¤±è´¥çš„è¿¹è±¡ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä½œä¸ºå•å‘å°½åŠ›ä¿¡æ¯å‘é€çš„ã€‚å› æ­¤ï¼Œåº”ç”¨ç¨‹åºä»£ç æœ‰è´£ä»»åœ¨å¿…è¦æ—¶åœ¨è§‚å¯Ÿè€…ä¹‹ä¸Šæ„å»ºæ›´é«˜çº§åˆ«çš„å¯é æ€§æœºåˆ¶ã€‚ å¦ä¸€ç§å¯ç”¨äºå‘å®¢æˆ·ç«¯ä¼ é€’å¼‚æ­¥æ¶ˆæ¯çš„æœºåˆ¶æ˜¯ Streams æ˜¯çš„ã€‚æµæš´éœ²äº†å•ä¸ªæ¶ˆæ¯ä¼ é€’æˆåŠŸæˆ–å¤±è´¥çš„è¿¹è±¡ï¼Œå› æ­¤èƒ½å¤Ÿä¸å®¢æˆ·ç«¯è¿›è¡Œå¯é çš„é€šä¿¡ã€‚ ä¾‹å­ è¿™æ˜¯ä¸Šé¢ç»™å‡ºçš„ä¸€ä¸ªå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºçš„æ‰©å±•ç‰ˆæœ¬ï¼Œè¯¥å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºè¿æ¥åˆ°Orleansï¼ŒæŸ¥æ‰¾ç©å®¶å¸æˆ·ï¼Œå‘è§‚å¯Ÿå®¶è®¢é˜…ç©å®¶å‚ä¸çš„æ¸¸æˆä¼šè¯çš„æ›´æ–°ï¼Œå¹¶æ‰“å°å‡ºé€šçŸ¥ï¼Œç›´åˆ°ç¨‹åºæ‰‹åŠ¨ç»ˆæ­¢ã€‚ namespace PlayerWatcher { class Program { /// <summary> /// Simulates a companion application that connects to the game /// that a particular player is currently part of, and subscribes /// to receive live notifications about its progress. /// </summary> static void Main(string[] args) { RunWatcher().Wait(); // Block main thread so that the process doesn't exit. // Updates arrive on thread pool threads. Console.ReadLine(); } static async Task RunWatcher() { try { var client = new ClientBuilder() // Clustering information .Configure<ClusterOptions>(options => { options.ClusterId = \"my-first-cluster\"; options.ServiceId = \"MyOrleansService\"; }) // Clustering provider .UseAzureStorageClustering(options => options.ConnectionString = connectionString) // Application parts: just reference one of the grain interfaces that we use .ConfigureApplicationParts(parts => parts.AddApplicationPart(typeof(IValueGrain).Assembly)) .Build(); // Hardcoded player ID Guid playerId = new Guid(\"{2349992C-860A-4EDA-9590-000000000006}\"); IPlayerGrain player = client.GetGrain<IPlayerGrain>(playerId); IGameGrain game = null; while (game == null) { Console.WriteLine(\"Getting current game for player {0}...\", playerId); try { game = await player.GetCurrentGame(); if (game == null) // Wait until the player joins a game { await Task.Delay(5000); } } catch (Exception exc) { Console.WriteLine(\"Exception: \", exc.GetBaseException()); } } Console.WriteLine(\"Subscribing to updates for game {0}...\", game.GetPrimaryKey()); // Subscribe for updates var watcher = new GameObserver(); await game.SubscribeForGameUpdates( await client.CreateObjectReference<IGameObserver>(watcher)); Console.WriteLine(\"Subscribed successfully. Press <Enter> to stop.\"); } catch (Exception exc) { Console.WriteLine(\"Unexpected Error: {0}\", exc.GetBaseException()); } } } /// <summary> /// Observer class that implements the observer interface. Need to pass a grain reference to an instance of this class to subscribe for updates. /// </summary> class GameObserver : IGameObserver { // Receive updates public void UpdateGameScore(string score) { Console.WriteLine(\"New game score: {0}\", score); } } } }"
  }
}